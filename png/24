aclocal.m4:# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
aclocal.m4:# $ac_aux_dir to '$srcdir/foo'.  In other projects, it is set to
aclocal.m4:# tool from the auxiliary directory.  The problem is that $srcdir (and
aclocal.m4:# therefore $ac_aux_dir as well) can be either absolute or relative,
aclocal.m4:# it makes $ac_aux_dir quite unusable in subdirectories: in the top
aclocal.m4:# $ac_aux_dir/missing
aclocal.m4:#    fails when called from a subdirectory if $ac_aux_dir is relative
aclocal.m4:# $top_srcdir/$ac_aux_dir/missing
aclocal.m4:#    fails if $ac_aux_dir is absolute,
aclocal.m4:#          a relative $ac_aux_dir
aclocal.m4:# The reason of the latter failure is that $top_srcdir and $ac_aux_dir
aclocal.m4:# are both prefixed by $srcdir.  In an in-source build this is usually
aclocal.m4:# So we could use something similar to $top_srcdir/$ac_aux_dir/missing,
aclocal.m4:# iff we strip the leading $srcdir from $ac_aux_dir.  That would be:
aclocal.m4:#   am_aux_dir='\$(top_srcdir)/'`expr "$ac_aux_dir" : "$srcdir//*\(.*\)"`
aclocal.m4:#   MISSING="\${SHELL} $am_aux_dir/missing"
aclocal.m4:# configure, and could therefore not use this "fixed" $ac_aux_dir.
aclocal.m4:# Another solution, used here, is to always expand $ac_aux_dir to an
aclocal.m4:# expand $ac_aux_dir to an absolute path
aclocal.m4:am_aux_dir=`cd $ac_aux_dir && pwd`
aclocal.m4:# dependency, and given that the user is not expected to run this macro,
aclocal.m4:      # only be used when explicitly requested.
aclocal.m4:      if test "x$enable_dependency_tracking" = xyes; then
aclocal.m4:  test "x$enable_dependency_tracking" != xno \
aclocal.m4:  [do not reject slow dependency extractors])
aclocal.m4:if test "x$enable_dependency_tracking" != xno; then
aclocal.m4:  am_depcomp="$ac_aux_dir/depcomp"
aclocal.m4:AM_CONDITIONAL([AMDEP], [test "x$enable_dependency_tracking" != xno])
aclocal.m4:  *\'*) eval set x "$CONFIG_FILES" ;;
aclocal.m4:  *)   set x $CONFIG_FILES ;;
aclocal.m4:    # Extract the definition of DEPDIR, am__include, and am__quote
aclocal.m4:    # expansion.
aclocal.m4:      # Make sure the directory exists.
aclocal.m4:     [test x"$AMDEP_TRUE" != x"" || _AM_OUTPUT_DEPENDENCY_COMMANDS],
aclocal.m4:     [AMDEP_TRUE="$AMDEP_TRUE" ac_aux_dir="$ac_aux_dir"])
aclocal.m4:# the next Automake release, Autoconf can make the AC_INIT
aclocal.m4:dnl Autoconf wants to disallow AM_ names.  We explicitly allow
aclocal.m4:# For better backward compatibility.  To be removed once Automake 1.9.x
aclocal.m4:	      [_AM_IF_OPTION([tar-pax], [_AM_PROG_TAR([pax])],
aclocal.m4:# by default if the 'rm' program in use doesn't match our expectations; the
aclocal.m4:  if test x"$ACCEPT_INFERIOR_RM_PROGRAM" = x"yes"; then
aclocal.m4:'rm' anyway, export the environment variable ACCEPT_INFERIOR_RM_PROGRAM
aclocal.m4:dnl Hook into '_AC_COMPILER_EXEEXT' early to learn its expansion.  Do not
aclocal.m4:[# Compute $1's index in $config_headers.
aclocal.m4:      _am_stamp_count=`expr $_am_stamp_count + 1` ;;
aclocal.m4:if test x"${install_sh}" != xset; then
aclocal.m4:  case $am_aux_dir in
aclocal.m4:    install_sh="\${SHELL} '$am_aux_dir/install-sh'" ;;
aclocal.m4:    install_sh="\${SHELL} $am_aux_dir/install-sh"
aclocal.m4:        m4_warn([syntax], [unexpected argument to AM@&t@_MAINTAINER_MODE: $1])])
aclocal.m4:# Fake the existence of programs that GNU maintainers use.  -*- Autoconf -*-
aclocal.m4:if test x"${MISSING+set}" != xset; then
aclocal.m4:  case $am_aux_dir in
aclocal.m4:    MISSING="\${SHELL} \"$am_aux_dir/missing\"" ;;
aclocal.m4:    MISSING="\${SHELL} $am_aux_dir/missing" ;;
aclocal.m4:# Use eval to expand $SHELL
aclocal.m4:# Execute IF-SET if OPTION is set, IF-NOT-SET otherwise.
aclocal.m4:  # compilers refuse to overwrite an existing .o file with -o,
aclocal.m4:    if AM_RUN_LOG([$CC -c conftest.$ac_ext -o conftest2.$ac_objext]) \
aclocal.m4:         && test -f conftest2.$ac_objext; then
aclocal.m4:   # A longer-term fix would be to have automake use am__CC in this case,
aclocal.m4:   CC="$am_aux_dir/compile $CC"
aclocal.m4:# Run COMMAND, save the exit status in ac_status, and log it.
aclocal.m4:   (exit $ac_status); }])
aclocal.m4:dnl A few 'make' implementations (e.g., NonStop OS and NextStep)
aclocal.m4:dnl do not support nested variable expansions.
aclocal.m4:# FORMAT should be one of 'v7', 'ustar', or 'pax'.
aclocal.m4:# Substitute a variable $(am__untar) that extract such
aclocal.m4:_am_tools='gnutar m4_if([$1], [ustar], [plaintar]) pax cpio none'
aclocal.m4:  [am__tar='$${TAR-tar} chof - "$$tardir"' am__untar='$${TAR-tar} xf -'],
aclocal.m4:     [# The POSIX 1988 'ustar' format is defined with fixed-size fields.
aclocal.m4:      # the 'pax' utility can hang on bigger UID/GID (see automake bug#8343
aclocal.m4:      am_max_uid=2097151 # 2^21 - 1
aclocal.m4:      am_max_gid=$am_max_uid
aclocal.m4:      # below are definitely unexpected, so allow the users to see them
aclocal.m4:      if test $am_uid -le $am_max_uid; then
aclocal.m4:      if test $am_gid -le $am_max_gid; then
aclocal.m4:  [pax],
aclocal.m4:      am__tar="$_am_tar --format=m4_if([$1], [pax], [posix], [$1]) -chf - "'"$$tardir"'
aclocal.m4:      am__tar_="$_am_tar --format=m4_if([$1], [pax], [posix], [$1]) -chf - "'"$tardir"'
aclocal.m4:      am__untar="$_am_tar -xf -"
aclocal.m4:      am__untar='tar xf -'
aclocal.m4:    pax)
aclocal.m4:      am__tar='pax -L -x $1 -w "$$tardir"'
aclocal.m4:      am__tar_='pax -L -x $1 -w "$tardir"'
aclocal.m4:      am__untar='pax -r'
ANNOUNCE:Source files with LF line endings (for Unix/Linux) and with a
ANNOUNCE:   libpng-1.6.16.tar.xz (LZMA-compressed, recommended)
ANNOUNCE:   libpng-1.6.16-README.txt
ANNOUNCE:   libpng-1.6.16-LICENSE.txt
ANNOUNCE:    (Bug report by Alex Eubanks).
ANNOUNCE:  Fixed an overflow in png_combine_row with very wide interlaced images.
arm/filter_neon.S:#if defined(__linux__) && defined(__ELF__)
arm/filter_neon.S:.section .note.GNU-stack,"",%progbits /* mark stack as non-executable */
arm/filter_neon.S:.macro  func    name, export=0
arm/filter_neon.S:        .text
arm/filter_neon.S:        /* Explicitly specifying alignment here because some versions of
arm/filter_neon.S:    .if \export
arm/filter_neon.S:func    png_read_filter_row_sub4_neon, export=1
arm/filter_neon.S:        bx              lr
arm/filter_neon.S:func    png_read_filter_row_sub3_neon, export=1
arm/filter_neon.S:        vext.8          d5,  d22, d23, #3
arm/filter_neon.S:        vext.8          d6,  d22, d23, #6
arm/filter_neon.S:        vext.8          d7,  d23, d23, #1
arm/filter_neon.S:        bx              lr
arm/filter_neon.S:func    png_read_filter_row_up_neon, export=1
arm/filter_neon.S:        bx              lr
arm/filter_neon.S:func    png_read_filter_row_avg4_neon, export=1
arm/filter_neon.S:        bx              lr
arm/filter_neon.S:func    png_read_filter_row_avg3_neon, export=1
arm/filter_neon.S:        vext.8          d5,  d22, d23, #3
arm/filter_neon.S:        vext.8          d17, d20, d21, #3
arm/filter_neon.S:        vext.8          d6,  d22, d23, #6
arm/filter_neon.S:        vext.8          d18, d20, d21, #6
arm/filter_neon.S:        vext.8          d7,  d23, d23, #1
arm/filter_neon.S:        vext.8          d19, d21, d21, #1
arm/filter_neon.S:.macro  paeth           rx,  ra,  rb,  rc
arm/filter_neon.S:        vmovn.u16       \rx, q12
arm/filter_neon.S:        vbsl            \rx, \ra, d28
arm/filter_neon.S:func    png_read_filter_row_paeth4_neon, export=1
arm/filter_neon.S:        bx              lr
arm/filter_neon.S:func    png_read_filter_row_paeth3_neon, export=1
arm/filter_neon.S:        vext.8          d5,  d22, d23, #3
arm/filter_neon.S:        vext.8          d17, d20, d21, #3
arm/filter_neon.S:        vext.8          d6,  d22, d23, #6
arm/filter_neon.S:        vext.8          d18, d20, d21, #6
arm/filter_neon.S:        vext.8          d7,  d23, d23, #1
arm/filter_neon.S:        vext.8          d19, d21, d21, #1
arm/arm_init.c:/* Below, after checking __linux__, various non-C90 POSIX 1003.1 functions are
arm/arm_init.c: * presence of the required support, therefore run-time detection is extremely
arm/arm_init.c: * has partial support is contrib/arm-neon/linux.c - a generic Linux
arm/arm_init.c:#  ifdef __linux__
arm/arm_init.c:#     define PNG_ARM_NEON_FILE "contrib/arm-neon/linux.c"
arm/arm_init.c:    * or off explicitly.  In this case the check controls what happens.
arm/arm_init.c:         /* Allow the run-time check to execute if it has been enabled -
arm/arm_init.c:   /* IMPORTANT: any new external functions used here must be declared using
arm/arm_init.c:    * 'prefix' option to configure works:
arm/arm_init.c:    *    ./configure --with-libpng-prefix=foobar_
arm/arm_init.c:    * and examining pngprefix.h; it must contain a #define for every external
arm/filter_neon_intrinsics.c:      uint8x16_t qrp, qpp;
arm/filter_neon_intrinsics.c:   uint8x16_t vtmp = vld1q_u8(rp);
arm/filter_neon_intrinsics.c:   uint8x8x2_t *vrpt = png_ptr(uint8x8x2_t, &vtmp);
arm/filter_neon_intrinsics.c:   uint8x8x2_t vrp = *vrpt;
arm/filter_neon_intrinsics.c:   uint8x8x4_t vdest;
arm/filter_neon_intrinsics.c:      uint8x8_t vtmp1, vtmp2;
arm/filter_neon_intrinsics.c:      uint32x2_t *temp_pointer;
arm/filter_neon_intrinsics.c:      vtmp1 = vext_u8(vrp.val[0], vrp.val[1], 3);
arm/filter_neon_intrinsics.c:      vtmp2 = vext_u8(vrp.val[0], vrp.val[1], 6);
arm/filter_neon_intrinsics.c:      vtmp1 = vext_u8(vrp.val[1], vrp.val[1], 1);
arm/filter_neon_intrinsics.c:      vrpt = png_ptr(uint8x8x2_t, &vtmp);
arm/filter_neon_intrinsics.c:      vst1_lane_u32(png_ptr(uint32_t,rp), png_ldr(uint32x2_t,&vdest.val[0]), 0);
arm/filter_neon_intrinsics.c:      vst1_lane_u32(png_ptr(uint32_t,rp), png_ldr(uint32x2_t,&vdest.val[1]), 0);
arm/filter_neon_intrinsics.c:      vst1_lane_u32(png_ptr(uint32_t,rp), png_ldr(uint32x2_t,&vdest.val[2]), 0);
arm/filter_neon_intrinsics.c:      vst1_lane_u32(png_ptr(uint32_t,rp), png_ldr(uint32x2_t,&vdest.val[3]), 0);
arm/filter_neon_intrinsics.c:   uint8x8x4_t vdest;
arm/filter_neon_intrinsics.c:      uint32x2x4_t vtmp = vld4_u32(png_ptr(uint32_t,rp));
arm/filter_neon_intrinsics.c:      uint8x8x4_t *vrpt = png_ptr(uint8x8x4_t,&vtmp);
arm/filter_neon_intrinsics.c:      uint8x8x4_t vrp = *vrpt;
arm/filter_neon_intrinsics.c:      uint32x2x4_t *temp_pointer;
arm/filter_neon_intrinsics.c:      vst4_lane_u32(png_ptr(uint32_t,rp), png_ldr(uint32x2x4_t,&vdest), 0);
arm/filter_neon_intrinsics.c:   uint8x16_t vtmp;
arm/filter_neon_intrinsics.c:   uint8x8x2_t *vrpt;
arm/filter_neon_intrinsics.c:   uint8x8x2_t vrp;
arm/filter_neon_intrinsics.c:   uint8x8x4_t vdest;
arm/filter_neon_intrinsics.c:   vrpt = png_ptr(uint8x8x2_t,&vtmp);
arm/filter_neon_intrinsics.c:      uint8x8_t vtmp1, vtmp2, vtmp3;
arm/filter_neon_intrinsics.c:      uint8x8x2_t *vppt;
arm/filter_neon_intrinsics.c:      uint8x8x2_t vpp;
arm/filter_neon_intrinsics.c:      uint32x2_t *temp_pointer;
arm/filter_neon_intrinsics.c:      vppt = png_ptr(uint8x8x2_t,&vtmp);
arm/filter_neon_intrinsics.c:      vtmp1 = vext_u8(vrp.val[0], vrp.val[1], 3);
arm/filter_neon_intrinsics.c:      vtmp2 = vext_u8(vpp.val[0], vpp.val[1], 3);
arm/filter_neon_intrinsics.c:      vtmp3 = vext_u8(vrp.val[0], vrp.val[1], 6);
arm/filter_neon_intrinsics.c:      vtmp2 = vext_u8(vpp.val[0], vpp.val[1], 6);
arm/filter_neon_intrinsics.c:      vtmp1 = vext_u8(vrp.val[1], vrp.val[1], 1);
arm/filter_neon_intrinsics.c:      vrpt = png_ptr(uint8x8x2_t,&vtmp);
arm/filter_neon_intrinsics.c:      vtmp2 = vext_u8(vpp.val[1], vpp.val[1], 1);
arm/filter_neon_intrinsics.c:      vst1_lane_u32(png_ptr(uint32_t,rp), png_ldr(uint32x2_t,&vdest.val[0]), 0);
arm/filter_neon_intrinsics.c:      vst1_lane_u32(png_ptr(uint32_t,rp), png_ldr(uint32x2_t,&vdest.val[1]), 0);
arm/filter_neon_intrinsics.c:      vst1_lane_u32(png_ptr(uint32_t,rp), png_ldr(uint32x2_t,&vdest.val[2]), 0);
arm/filter_neon_intrinsics.c:      vst1_lane_u32(png_ptr(uint32_t,rp), png_ldr(uint32x2_t,&vdest.val[3]), 0);
arm/filter_neon_intrinsics.c:   uint8x8x4_t vdest;
arm/filter_neon_intrinsics.c:      uint32x2x4_t vtmp;
arm/filter_neon_intrinsics.c:      uint8x8x4_t *vrpt, *vppt;
arm/filter_neon_intrinsics.c:      uint8x8x4_t vrp, vpp;
arm/filter_neon_intrinsics.c:      uint32x2x4_t *temp_pointer;
arm/filter_neon_intrinsics.c:      vrpt = png_ptr(uint8x8x4_t,&vtmp);
arm/filter_neon_intrinsics.c:      vppt = png_ptr(uint8x8x4_t,&vtmp);
arm/filter_neon_intrinsics.c:      vst4_lane_u32(png_ptr(uint32_t,rp), png_ldr(uint32x2x4_t,&vdest), 0);
arm/filter_neon_intrinsics.c:static uint8x8_t
arm/filter_neon_intrinsics.c:paeth(uint8x8_t a, uint8x8_t b, uint8x8_t c)
arm/filter_neon_intrinsics.c:   uint8x8_t d, e;
arm/filter_neon_intrinsics.c:   uint16x8_t p1, pa, pb, pc;
arm/filter_neon_intrinsics.c:   uint8x16_t vtmp;
arm/filter_neon_intrinsics.c:   uint8x8x2_t *vrpt;
arm/filter_neon_intrinsics.c:   uint8x8x2_t vrp;
arm/filter_neon_intrinsics.c:   uint8x8_t vlast = vdup_n_u8(0);
arm/filter_neon_intrinsics.c:   uint8x8x4_t vdest;
arm/filter_neon_intrinsics.c:   vrpt = png_ptr(uint8x8x2_t,&vtmp);
arm/filter_neon_intrinsics.c:      uint8x8x2_t *vppt;
arm/filter_neon_intrinsics.c:      uint8x8x2_t vpp;
arm/filter_neon_intrinsics.c:      uint8x8_t vtmp1, vtmp2, vtmp3;
arm/filter_neon_intrinsics.c:      uint32x2_t *temp_pointer;
arm/filter_neon_intrinsics.c:      vppt = png_ptr(uint8x8x2_t,&vtmp);
arm/filter_neon_intrinsics.c:      vtmp1 = vext_u8(vrp.val[0], vrp.val[1], 3);
arm/filter_neon_intrinsics.c:      vtmp2 = vext_u8(vpp.val[0], vpp.val[1], 3);
arm/filter_neon_intrinsics.c:      vtmp1 = vext_u8(vrp.val[0], vrp.val[1], 6);
arm/filter_neon_intrinsics.c:      vtmp3 = vext_u8(vpp.val[0], vpp.val[1], 6);
arm/filter_neon_intrinsics.c:      vtmp1 = vext_u8(vrp.val[1], vrp.val[1], 1);
arm/filter_neon_intrinsics.c:      vtmp2 = vext_u8(vpp.val[1], vpp.val[1], 1);
arm/filter_neon_intrinsics.c:      vrpt = png_ptr(uint8x8x2_t,&vtmp);
arm/filter_neon_intrinsics.c:      vst1_lane_u32(png_ptr(uint32_t,rp), png_ldr(uint32x2_t,&vdest.val[0]), 0);
arm/filter_neon_intrinsics.c:      vst1_lane_u32(png_ptr(uint32_t,rp), png_ldr(uint32x2_t,&vdest.val[1]), 0);
arm/filter_neon_intrinsics.c:      vst1_lane_u32(png_ptr(uint32_t,rp), png_ldr(uint32x2_t,&vdest.val[2]), 0);
arm/filter_neon_intrinsics.c:      vst1_lane_u32(png_ptr(uint32_t,rp), png_ldr(uint32x2_t,&vdest.val[3]), 0);
arm/filter_neon_intrinsics.c:   uint8x8_t vlast = vdup_n_u8(0);
arm/filter_neon_intrinsics.c:   uint8x8x4_t vdest;
arm/filter_neon_intrinsics.c:      uint32x2x4_t vtmp;
arm/filter_neon_intrinsics.c:      uint8x8x4_t *vrpt, *vppt;
arm/filter_neon_intrinsics.c:      uint8x8x4_t vrp, vpp;
arm/filter_neon_intrinsics.c:      uint32x2x4_t *temp_pointer;
arm/filter_neon_intrinsics.c:      vrpt = png_ptr(uint8x8x4_t,&vtmp);
arm/filter_neon_intrinsics.c:      vppt = png_ptr(uint8x8x4_t,&vtmp);
arm/filter_neon_intrinsics.c:      vst4_lane_u32(png_ptr(uint32_t,rp), png_ldr(uint32x2x4_t,&vdest), 0);
autogen.sh:# The first time this is run on a GIT checkout the only files that exist are
autogen.sh:# For regular ("tarball") distributions all the files should exist.  We do not
autogen.sh:# arguments (a) for use while testing the script and (b) to fix up systems that
autogen.sh:         exec >&2
autogen.sh:            echo "  fixed, set of autotools.  It is known *NOT* to work with"
autogen.sh:            echo "  Remember: autotools is GNU software, you are expected to"
autogen.sh:         exit 1;;
autogen.sh:libpng_autotools_extra="compile"
autogen.sh:   rm -rf $libpng_autotools_extra
autogen.sh:   exit 0
autogen.sh:# The cache directory doesn't matter - it will be regenerated and does not exist
autogen.sh:      # Clean in case configure files exist
autogen.sh:            exec >&2
autogen.sh:            echo "autoreconf was run, but did not produce all the expected"
autogen.sh:            echo "not compatible with that expected by libpng."
autogen.sh:            exit 1
autogen.sh:         exec >&2
autogen.sh:         exit 1
autogen.sh:         exec >&2
autogen.sh:         exit 1
autogen.sh:         exec >&2
autogen.sh:         exit 1
autogen.sh:      exec >&2
autogen.sh:      exit 1;;
Binary file bin/png-fix-itxt matches
bin/libpng16-config:# Modeled after libxml-config.
bin/libpng16-config:prefix="/Users/ananyu/csci3081/Photoshop/libpng-1.6.16"
bin/libpng16-config:exec_prefix="${prefix}"
bin/libpng16-config:libdir="${exec_prefix}/lib"
bin/libpng16-config:includedir="${prefix}/include/libpng16"
bin/libpng16-config:  --prefix        print libpng prefix
bin/libpng16-config:  --help          print this help and exit
bin/libpng16-config:    exit $1
bin/libpng16-config:    --prefix)
bin/libpng16-config:        echo ${prefix}
bin/libpng16-config:        exit 0
bin/libpng16-config:        exit 1
bin/libpng16-config:exit 0
Binary file bin/pngfix matches
CHANGES:  fixed small problems in stub file
CHANGES:  added pnglib.txt
CHANGES:  added example.c
CHANGES:  fixed some bugs in writer
CHANGES:  fixed various bugs
CHANGES:  fixed many reading and writing bugs
CHANGES:  fixed error in libpng.txt and example.c
CHANGES:  changed external functions passing floats to doubles (k&r problems?)
CHANGES:  fixed some bugs (16-bit, 4-bit interlaced, etc.)
CHANGES:  fixed bugs
CHANGES:  fixed medium model bugs
CHANGES:  fixed other bugs introduced in 0.85 and 0.86
CHANGES:  fixed progressive bugs
CHANGES:  Changed warning/error callback functions to fix bug - this means you
CHANGES:    png_set_message_fn() calls, and that the old API no longer exists
CHANGES:  Fixed png_set_background() to allow using an arbitrary RGB color for
CHANGES:  Fixed gamma and background correction for paletted images, so
CHANGES:    external palette (you will need to #define PNG_CORRECT_PALETTE_SUPPORTED
CHANGES:  Fixed bug with Borland 64K memory allocation (Alexander Lehmann)
CHANGES:  Fixed bug in interlace handling (Smarasderagd, I think)
CHANGES:  Added external C++ wrapper statements to png.h (Gilles Dauphin)
CHANGES:  Fixed png_filler() declarations
CHANGES:  Fixed? background color conversions
CHANGES:  Fixed order of error function pointers to match documentation
CHANGES:  Try to fix Linux "setjmp" buffer size problems
CHANGES:  Fixed bug in pngwutil.c allocating "up_row" twice and "avg_row" never
CHANGES:  Fixed bug in PNG file signature compares when start != 0
CHANGES:    packed-pixel bytes (Kevin Bracey)
CHANGES:  Added experimental filter selection weighting (Greg Roelofs)
CHANGES:  Removed old png_set_rgbx() and png_set_xrgb() functions that have been
CHANGES:    used only on those systems that support it (namely PowerPC and 680x0)
CHANGES:  More description of info_struct in libpng.txt and png.h
CHANGES:  More instructions in example.c
CHANGES:  Fixed serious bug with < 8bpp images introduced in 0.95
CHANGES:  Fixed 256-color transparency bug (Greg Roelofs)
CHANGES:  Fixed up documentation (Greg Roelofs, Laszlo Nyul)
CHANGES:  Fixed "error" in pngconf.h for Linux setjmp() behavior
CHANGES:  Fixed DOS medium model support (Tim Wegner)
CHANGES:  Fixed png_check_keyword() for case with error in static string text
CHANGES:  Fixed typecasts of "new_key", etc. (Andreas Dilger)
CHANGES:  Fixed bug in gamma handling of 4-bit grayscale
CHANGES:  Minor corrections in libpng.txt
CHANGES:  Fixed memory leak in pngwrite.c (free info_ptr->text) (Glenn R-P)
CHANGES:    black pixels to background when a background is supplied and
CHANGES:    no pixels are transparent
CHANGES:  Cleaned up some typos in libpng.txt and in code documentation
CHANGES:  Fixed memory leaks in pCAL chunk processing (Glenn R-P and John Bowler)
CHANGES:    in example.c and libpng.txt, added comments to distinguish between
CHANGES:  Free info_ptr->text instead of end_info_ptr->text in pngread.c (John Bowler)
CHANGES:  Fixed a longstanding "packswap" bug in pngtrans.c
CHANGES:  Fixed some inconsistencies in pngconf.h that prevented compiling with
CHANGES:  Fixed some typos and made other minor rearrangement of libpng.txt (Andreas)
CHANGES:    example.c and libpng.txt, and changed file_gamma for sRGB images to .45
CHANGES:  Renamed makefile.elf to makefile.lnx.
CHANGES:  Added UNIX manual pages libpng.3 (incorporating libpng.txt) and  png.5.
CHANGES:  Check for overlength tRNS chunk present when indexed-color PLTE is read.
CHANGES:  Cleaned up spelling errors in libpng.3/libpng.txt
CHANGES:  Add parentheses for easier reading of pngget.c, fixed "||" should be "&&".
CHANGES:  Touched up example.c to make more of it compileable, although the entire
CHANGES:  Fixed a bug in png_do_shift() (Bryan Tsai)
CHANGES:  Added makefile.os2 and pngos2.def (A. Zabolotny) and makefile.s2x (W. Sebok)
CHANGES:  Added pointers to "note on libpng versions" in makefile.lnx and README
CHANGES:  Fixed dimensions of "short_months" array in pngwrite.c
CHANGES:  Fixed three bugs in pngrtran.c to make gamma+background handling consistent
CHANGES:  Changed format of the PNG_LIBPNG_VER integer to xyyzz instead of xyz
CHANGES:    for major, minor, and bugfix releases.  This is 10001. (Adam Costello,
CHANGES:  Minor changes to makefile.s2x
CHANGES:  Changed makefile.s2x to reduce security risk of using a relative pathname
CHANGES:  Fixed some typos in the documentation (Greg).
CHANGES:  Fixed a problem with value of "channels" returned by png_read_update_info()
CHANGES:  Commented out i386istic "align" compiler flags in makefile.lnx.
CHANGES:  Fixed a bug in png_do_strip_filler with XXRRGGBB => RRGGBB transformation.
CHANGES:  Fixed a bug in pngset.c, introduced in version 0.99c, that sets rowbytes
CHANGES:  Corrected some bugs in the experimental weighted filtering heuristics.
CHANGES:  Fixed a png_convert_to_rfc1123() bug that converts day 31 to 0 (Steve Eddins).
CHANGES:  Fixed two bugs (missing definitions of "istop") introduced in libpng-1.0.1a.
CHANGES:  Fixed a bug in pngrtran.c that would set channels=5 under some circumstances.
CHANGES:  Revised paragraph about png_set_expand() in libpng.txt and libpng.3 (Greg)
CHANGES:  Fixed a bug in pngrtran.c (introduced in libpng-1.0.1a) where the masks for
CHANGES:    filler bytes should have been 0xff instead of 0xf.
CHANGES:  Added max_pixel_depth=32 in pngrutil.c when using FILLER with palette images.
CHANGES:  Corrected example.c, use of row_pointers in png_write_image().
CHANGES:  More corrections to example.c, use of row_pointers in png_write_image()
CHANGES:  Fixed error in example.c with png_set_text: num_text is 3, not 2 (Guido V.)
CHANGES:  Revised libpng.txt and libpng.3 description of png_set_read|write_fn(), and
CHANGES:  Fixed two bugs in makefile.bor .
CHANGES:  Replaced and extended code that was removed from png_set_filler() in 1.0.1a.
CHANGES:  Fixed a bug in png_do_filler() that made it fail to write filler bytes in
CHANGES:    the left-most pixel of each row (Kevin Bracey).
CHANGES:  Fixed a bug in pngtest.c that caused pngtest to try to write a tIME chunk
CHANGES:  Fixed a problem in pngrutil.c: gray_to_rgb didn't always work with 16-bit.
CHANGES:  Fixed a problem in png_read_push_finish_row(), which would not skip some
CHANGES:    passes that it should skip, for images that are less than 3 pixels high.
CHANGES:  Fixed a documentation error about default filtering with 8-bit indexed-color.
CHANGES:  Revised comments on png_set_progressive_read_fn() in libpng.txt and example.c
CHANGES:  Added information about debugging in libpng.txt and libpng.3 .
CHANGES:  Changed "ln -sf" to "ln -s -f" in makefile.s2x, makefile.lnx, and
CHANGES:  Changed "check_if_png" function in example.c to return true (nonzero) if PNG.
CHANGES:  Changed libpng.txt to demonstrate png_sig_cmp() instead of png_check_sig()
CHANGES:  Added makefile.hux, for Hewlett Packard HPUX 10.20 and 11.00 (Jim Rice)
CHANGES:  Fixed a bug in the check for valid IHDR bit_depth/color_types in pngrutil.c
CHANGES:  Replaced leading blanks with tab characters in makefile.hux
CHANGES:  Fixed a bug in pngconf.h that omitted <stdio.h> when PNG_DEBUG==0 (K Bracey).
CHANGES:  Fixed bugs in calculation of the length of rowbytes when adding alpha
CHANGES:  Added some aliases for png_set_expand() in pngrtran.c, namely
CHANGES:    png_set_expand_PLTE(), png_set_expand_depth(), and png_set_expand_tRNS()
CHANGES:  Made alternate versions of  png_set_expand() in pngrtran.c, namely
CHANGES:  Relocated start of 'extern "C"' block in png.h so it doesn't include pngconf.h
CHANGES:  Fixed type casting of igamma in pngrutil.c
CHANGES:  Added new png_expand functions to scripts/pngdef.pas and pngos2.def
CHANGES:  Added a demo read_user_transform_fn that examines the row filters in pngtest.c
CHANGES:  Renamed the makefiles with longer but more user friendly extensions.
CHANGES:  Revised documentation, png.h, and example.c to remove reference to
CHANGES:  Increase max_pixel_depth in pngrutil.c if a user transform needs it.
CHANGES:  Added a comment in makefile.linux warning about buggy -O3 in pgcc 2.95.1
CHANGES:  Fixed sign error in pngvcrd.c (Greg Roelofs)
CHANGES:  Surrounded example.c code with #if 0 .. #endif to prevent people from
CHANGES:  Fixed a typo in the png_set_sRGB() function call in example.c (Jan Nijtmans)
CHANGES:  Further optimization and bugfix of pngvcrd.c
CHANGES:    text_ptr structure.  Instead, it makes its own copy.
CHANGES:  Added code in pngwrite.c to free info_ptr->text[i].key to stop a memory leak.
CHANGES:  Fixed some typecasting in contrib/gregbook/*.c
CHANGES:  Removed some extraneous "-I" from contrib/pngminus/makefile.std
CHANGES:  Change PNG_SRGB_INTENT to PNG_sRGB_INTENT in libpng.txt and libpng.3
CHANGES:  Added iCCP, iTXt, and sPLT support; added "lang" member to the png_text
CHANGES:    png_free_iCCP, png_free_pCAL, png_free_sPLT, png_free_text, png_get_iCCP,
CHANGES:  NOTE: Applications that write text chunks MUST define png_text->lang
CHANGES:    before calling png_set_text(). It must be set to NULL if you want to
CHANGES:         png_text[i].lang = NULL;
CHANGES:    PNG_cHNK_SUPPORTED and combined the three types of PNG_text_SUPPORTED
CHANGES:  Fixed "png_free_spallettes" typo in png.h
CHANGES:  Added "translated_key" to png_text structure and png_write_iTXt().
CHANGES:        png_text[i].translated_key = NULL;
CHANGES:    fixed-point functions such as png_set_gAMA_fixed() were added.
CHANGES:  Expanded tabs and removed trailing blanks in source files.
CHANGES:  Various patches to fix bugs in the sCAL and integer cHRM processing,
CHANGES:  Added new type "png_fixed_point" for integers that hold float*100000 values
CHANGES:    Restored the first four members of png_text to the same order as v.1.0.5d.
CHANGES:    Added members "lang_key" and "itxt_length" to png_text struct.  Set
CHANGES:    text_length=0 when "text" contains iTXt data.  Use the "compression"
CHANGES:  Fixed png_read|write_iTXt() to read|write parameters in the right order,
CHANGES:  Reversed the order of trying to write floating-point and fixed-point gAMA.
CHANGES:  Fixed a libpng-1.0.5h bug in pngrutil.c that was issuing erroneous warnings
CHANGES:  Added high-level functions png_read_png(), png_write_png(), png_free_pixels().
CHANGES:  Fixed pngvcrd.c bug by pushing/popping registers in mmxsupport (Bruce Oberg)
CHANGES:  Revised makefile.gcmmx
CHANGES:  Removed superfluous prototype for png_get_itxt from png.h
CHANGES:  Fixed a bug in pngrtran.c that improperly expanded the background color.
CHANGES:  Return *num_text=0 from png_get_text() when appropriate, and fix documentation
CHANGES:    of png_get_text() in libpng.txt/libpng.3.
CHANGES:    new error handler that's planned for the next libpng release, and changed
CHANGES:    example.c, pngtest.c, and contrib programs to use this macro.
CHANGES:  Revised some of the DLL-export macros in pngconf.h (Greg Roelofs)
CHANGES:  Fixed a bug in png_read_png() that caused it to fail to expand some images
CHANGES:    that it should have expanded.
CHANGES:  Fixed some mistakes in the unused and undocumented INCH_CONVERSIONS functions
CHANGES:    that in example.c.  Added "free_me" member to info_ptr and png_ptr
CHANGES:  Updated makefile.linux and makefile.gccmmx to make directories conditionally.
CHANGES:  Fixed "interlace" typo (should be "interlaced") in contrib/gregbook/read2-x.c
CHANGES:  Fixed bug with use of PNG_BEFORE_IHDR bit in png_ptr->mode, introduced when
CHANGES:  Removed spaces in makefile.linux and makefile.gcmmx, introduced in 1.0.5s
CHANGES:    added png_set_rgb_to_gray_fixed() function.
CHANGES:  Updated documentation of png_rgb_to_gray calculations in libpng.3/libpng.txt.
CHANGES:  Minor revisions of makefile.bor, libpng.txt, and gregbook/rpng2-win.c
CHANGES:  Fixed an error in png_rgb_to_gray_fixed()
CHANGES:  Revised example.c, usage of png_destroy_write_struct().
CHANGES:  Added a check for info_ptr->free_me&PNG_FREE_TEXT when freeing text in png.c
CHANGES:  Minor revisions of libpng.txt/libpng.3.
CHANGES:  Check for existing data and free it if the free_me flag is set, in png_set_*()
CHANGES:    and mentioned the purposes of the two macros in libpng.txt/libpng.3.
CHANGES:  Add checks in png_set_text() for NULL members of the input text structure.
CHANGES:  Revised libpng.txt/libpng.3.
CHANGES:  Relocated paragraph about png_set_background() in libpng.3/libpng.txt
CHANGES:  Changed shared library so-number pattern from 2.x.y.z to xy.z (this builds
CHANGES:  Added documentation of user memory functions in libpng.txt/libpng.3
CHANGES:    of the use of png_set_rows() and png_get_rows() in libpng.txt/libpng.3.
CHANGES:  Eliminated the three new members of png_text when PNG_LEGACY_SUPPORTED is
CHANGES:    overrun when old applications fill the info_ptr->text structure directly.
CHANGES:  Added PNGAPI macro, and added it to the definitions of all exported functions.
CHANGES:  Revised pngset.c to avoid a problem with expanding the png_debug macro.
CHANGES:  Deleted some extraneous defines from pngconf.h
CHANGES:  Expanded libpng.3/libpng.txt information about png_data_freer().
CHANGES:  Make png_free_data() ignore its final parameter except when freeing data
CHANGES:    that can have multiple instances (text, sPLT, unknowns).
CHANGES:  Fixed a new bug in png_set_rows().
CHANGES:  Fixed incorrect illustrations of png_destroy_write_struct() in example.c.
CHANGES:  Revised the deliberately erroneous Linux setjmp code in pngconf.h to produce
CHANGES:    in libpng.txt/libpng.3 the need for applications to check this.
CHANGES:  Changed return type of png_get_x|y_offset_*() from png_uint_32 to png_int_32.
CHANGES:  Fixed some bugs in the unused PNG_INCH_CONVERSIONS functions in pngget.c
CHANGES:  Worked around a problem in pngconf.h; AIX's strings.h defines an "index"
CHANGES:    macro that conflicts with libpng's png_color_16.index. (Dimitri
CHANGES:  Added "msvc" directory with MSVC++ project files (Simon-Pierre Cadieux).
CHANGES:  Revised the workaround of AIX string.h "index" bug.
CHANGES:  Added PNG_NO_POINTER_INDEXING macro to use array-indexing instead of pointer
CHANGES:    indexing in pngrutil.c and pngwutil.c to accommodate a buggy compiler.
CHANGES:  Corrected the definition of PNG_TRANSFORM_INVERT_ALPHA  (0x0400 not 0x0200)
CHANGES:  Updated contrib/visupng/cexcept.h to version 1.0.0.
CHANGES:  Fixed bugs in pngwrite.c and pngwutil.c that prevented writing iCCP chunks.
CHANGES:  Fixed "DJBPP" typo in pnggccrd.c introduced in beta18.
CHANGES:  Revised the definition of "trans_values" in libpng.3/libpng.txt
CHANGES:     for indexed-color input files to avoid potential double-freeing trans array
CHANGES:  Updated makefile.hpux to build a shared library.
CHANGES:  Fixed typo in scripts/makefile.hpux
CHANGES:  Fixed seqence-point bug in contrib/pngminus/png2pnm (Martin Zinser)
CHANGES:  Revised pnggccrd.c to get it all working, and updated makefile.gcmmx (Greg).
CHANGES:  Fixed bugs in iCCP support in pngrutil.c and pngwutil.c.
CHANGES:  Added makefile.macosx and makefile.aix to scripts directory.
CHANGES:  Revised libpng.3/libpng.txt.  Changed "filter type" to "filter method".
CHANGES:  Fixed error handling of unknown compression type in png_decompress_chunk().
CHANGES:  Added png_set_invalid, png_permit_mng_features, and png_mmx_supported to
CHANGES:  Fixed bug with progressive reading of narrow interlaced images in pngpread.c
CHANGES:  Fixed "png_mmx_supported" typo in project definition files.
CHANGES:  Removed png_mmx_support() function and disabled PNG_MNG_FEATURES_SUPPORTED
CHANGES:  Added "-nommx" parameter to contrib/gregbook/rpng2-win and rpng2-x demos.
CHANGES:  Added checks for _mmx_supported in the read_filter_row function of pnggccrd.c
CHANGES:  Added prototype for png_mmx_support() near the top of pnggccrd.c
CHANGES:  Revised png_mmx_support() function in pnggccrd.c
CHANGES:  Fixed memory leak in contrib/visupng/PngFile.c
CHANGES:  Fixed bugs in png_combine_row() in pnggccrd.c and pngvcrd.c (C version)
CHANGES:  Revised png_mmx_supported() function in pnggccrd.c to return proper value.
CHANGES:  Fixed bug in progressive reading (pngpread.c) with small images (height < 8).
CHANGES:  Deleted extraneous space (introduced in 1.0.9) from line 42 of makefile.cygwin
CHANGES:  Added some never-to-be-executed code in pnggccrd.c to quiet compiler warnings.
CHANGES:  Revised contrib/gregbook/rpng*-x.c to avoid a memory leak and to exit cleanly
CHANGES:  Updated example.c
CHANGES:  Revised makefile.gcmmx
CHANGES:     value exceeding 2^bit_depth-1
CHANGES:  Fixed contrib/gregbook/rpng-x.c, rpng2-x.c to avoid crash with XFreeGC().
CHANGES:  Revised makefile.netbsd and makefile.macosx, added makefile.darwin.
CHANGES:  Revised example.c to provide more details about using row_callback().
CHANGES:  Added type cast to each NULL appearing in a function call, except for
CHANGES:  Type cast NULLs appearing in function calls except when PNG_NO_TYPECAST_NULL
CHANGES:  Added a pop/push operation to pnggccrd.c, to preserve Eflag (Maxim Sobolev)
CHANGES:  Added a check for prefix_length > data_length in iCCP chunk handler.
CHANGES:  Fixed a bug with reading the length of iCCP profiles (Larry Reeves).
CHANGES:  Revised makefile.linux, makefile.gcmmx, and makefile.sgi to generate
CHANGES:  Added checks for gamma and chromaticity values over 21474.83, which exceed
CHANGES:  Export (with PNGAPI) png_zalloc, png_zfree, and png_handle_as_unknown
CHANGES:  Eliminated incorrect use of width_mmx from pnggccrd.c in pixel_bytes == 8 case
CHANGES:  Added PNG_1_0_X macro which can be used to build a 1.0.x-compatible library.
CHANGES:  Revised makefiles to put png.h and pngconf.h only in $prefix/include/libpngNN
CHANGES:  Add typecasts of PNG_MAX_UINT in pngset_cHRM_fixed() (Matt Holgate).
CHANGES:  Save the ebx register in pnggccrd.c (Sami Farin)
CHANGES:  Revised description of png_set_filter() in libpng.3/libpng.txt.
CHANGES:  Fixed VER -> PNGVER typo in makefile.macosx and added install-static to
CHANGES:  Fixed bug with $prefix, should be $(prefix) in makefile.hpux.
CHANGES:  Fixed bug in reporting number of channels in pngget.c and pngset.c,
CHANGES:  Exported png_zalloc(), png_zfree(), png_default_read(), png_default_write(),
CHANGES:  Once more restored png_zalloc and png_zfree to regular nonexported form.
CHANGES:    to nonexported form, but with PNGAPI, and removed them from module def
CHANGES:  Revised projects/msvc/README.txt
CHANGES:  Fixed bug in 16 makefiles: $(DESTDIR)/$(LIBPATH) to $(DESTDIR)$(LIBPATH)
CHANGES:  Added missing "\" before closing double quote in makefile.gcmmx.
CHANGES:  Plugged various memory leaks; added png_malloc_warn() and png_set_text_2()
CHANGES:  Plugged memory leak of png_ptr->current_text (Matt Holgate).
CHANGES:  Added "test-installed" target to makefile.linux, makefile.gcmmx,
CHANGES:  Detect buffer overflow in pngpread.c when IDAT is corrupted with extra data.
CHANGES:    makefile.beos, makefile.darwin, makefile.dec, makefile.macosx,
CHANGES:    makefile.solaris, makefile.hpux, makefile.hpgcc, and makefile.so9.
CHANGES:  Revised pnggccrd.c to be able to back out version 1.0.x via PNG_1_0_X macro.
CHANGES:    and about "Extra compressed data" in pngrutil.c.
CHANGES:  Prevent png_ptr->pass from exceeding 7 in png_push_finish_row().
CHANGES:  Updated png.c and pnggccrd.c handling of return from png_mmx_support()
CHANGES:  Added missing "$OBJSDLL" line to makefile.gcmmx.
CHANGES:  Revised makefile.macosx, makefile.darwin, makefile.hpgcc, and makefile.hpux,
CHANGES:    and makefile.aix.
CHANGES:  Commented out warning about uninitialized mmx_support in pnggccrd.c.
CHANGES:  Fixed memory overrun bug in png_do_read_filler() with 16-bit datastreams,
CHANGES:  Revised makefile.macosx, makefile.dec, makefile.aix, and makefile.32sunu.
CHANGES:    Version 1.2.6 is going to be a simple bugfix release.
CHANGES:  Fixed potential overrun in pngerror.c by using strncpy instead of memcpy.
CHANGES:    'x' flag under Cygwin (Cosmin).
CHANGES:  Fixed the special memory handler for Borland C under DOS, in pngmem.c
CHANGES:  Replaced 65536 with 65536L, and 0xffff with 0xffffL, to silence warnings
CHANGES:  Enclosed shift op expressions in parentheses, to silence warnings (Cosmin).
CHANGES:  Used proper type png_fixed_point, to avoid problems on 16-bit platforms,
CHANGES:  Fixed definition of isnonalpha(), in pngerror.c and pngrutil.c (Cosmin).
CHANGES:  Fixed handling of unknown chunks that come after IDAT (Cosmin).
CHANGES:  Fixed definition of PNG_LIBPNG_VER_DLLNUM (Simon-Pierre).
CHANGES:  Commented out warning about uninitialized mmx_support in pngvcrd.c (Cosmin).
CHANGES:  Added extra guard around inclusion of Turbo C memory headers, in pngconf.h
CHANGES:  Updated contrib/visupng/cexcept.h to version 2.0.0 (Cosmin).
CHANGES:  Added PNG_SIZE_MAX (maximum value of a png_size_t variable.
CHANGES:  Turn on PNG_NO_ZALLOC_ZERO by default in version 1.2.x
CHANGES:  Fixed buffer overflow vulnerability in png_handle_tRNS()
CHANGES:  Fixed integer arithmetic overflow vulnerability in png_read_png().
CHANGES:  Fixed some harmless bugs in png_handle_sBIT, etc, that would cause
CHANGES:  Fixed some timestamps in the -config version
CHANGES:  Updated makefile.darwin and removed makefile.macosx from scripts directory.
CHANGES:  Fixed wrong cast of returns from png_get_user_width|height_max().
CHANGES:  Revised libpng.txt to remove 1.2.x stuff from the 1.0.x distribution
CHANGES:  Revised makefile.darwin and makefile.solaris.  Removed makefile.macosx.
CHANGES:    png_malloc_default() which is not supposed to be exported.
CHANGES:  Fixed off-by-one error in one of the conversions to PNG_ROWBYTES() in
CHANGES:  Fixed bug in RGB to RGBX transformation introduced in 1.2.6rc1.
CHANGES:  Fixed old bug in RGB to Gray transformation.
CHANGES:  Fixed problem with 64-bit compilers by casting arguments to abs()
CHANGES:  Fixed mistake in pngtest.c introduced in 1.2.6rc2 (declaration of
CHANGES:  Fixed bug with "optimized window size" in the IDAT datastream, that
CHANGES:  Fixed bug with sCAL chunk and big-endian machines (David Munro).
CHANGES:  Fixed bug in png_text_compress() that would fail to complete a large block.
CHANGES:  Fixed bug, introduced in libpng-1.2.7, that overruns a buffer during
CHANGES:  Fixed (again) definition of PNG_LIBPNG_VER_DLLNUM in png.h (Cosmin).
CHANGES:  Fixed new typo in scripts/pngw32.rc
CHANGES:  Revised man page and libpng.txt to make it clear that one should not call
CHANGES:  Fixed an incorrect typecast in pngrutil.c
CHANGES:  Exported png_get_uint_32, png_save_uint_32, png_get_uint_16, png_save_uint_16,
CHANGES:  Fixed scripts/makefile.cygwin (Christian Biesinger, Cosmin).
CHANGES:  Revised checking of chromaticity limits to accommodate extended RGB
CHANGES:    "Unix" tar distributions (Cosmin).
CHANGES:    with the newly exported functions.
CHANGES:  Fixed CRCRLF line endings in contrib/visupng/VisualPng.dsp
CHANGES:  Changed definition of PKGCONFIG from $prefix/lib to $libdir in configure.ac
CHANGES:  Made swap tables in pngtrans.c PNG_CONST (Carlo Bramix).
CHANGES:  Fixed typo (RELEASE) in configuration files.
CHANGES:  Fixed inconsistent #ifdef's around png_sig_bytes() and png_set_sCAL_s()
CHANGES:  Made some makefiles accept "exec_prefix".
CHANGES:  Fixed some "#if defined (..." which should be "#if defined(..."
CHANGES:  Fixed inconsistency in definition of png_default_read_data()
CHANGES:  Revised calculation of "current" and "major" for irix in ltmain.sh
CHANGES:  Added png_set_expand_gray_1_2_4_to_8() and deprecated
CHANGES:    png_set_gray_1_2_4_to_8() which also expands tRNS to alpha.
CHANGES:  Removed extra CR from contrib/visualpng/VisualPng.dsw (Cosmin)
CHANGES:  Fixed out-of-order declaration in pngwrite.c that was introduced in beta9
CHANGES:  Change "exec_prefix=$prefix" to "exec_prefix=$(prefix)" in makefiles.
CHANGES:  Fixed "LN_FS" typo in makefile.sco and makefile.solaris.
CHANGES:  Added a note in libpng.txt that png_set_sig_bytes(8) can be used when
CHANGES:  Fixed bug in example.c (png_set_palette_rgb -> png_set_palette_to_rgb)
CHANGES:  Deleted extraneous square brackets from [config.h] in configure.ac
CHANGES:  Fixed typo in several makefiles (-W1 should be -Wl)
CHANGES:  Detect and fix attempt to write wrong iCCP profile length (CVE-2006-7244)
CHANGES:  Fix potential buffer overflow in sPLT chunk handler.
CHANGES:  Fix Makefile.am to not try to link to noexistent files.
CHANGES:  Check all exported functions for NULL png_ptr.
CHANGES:  Always export MMX asm functions, just stubs if not building pnggccrd.c
CHANGES:  Added scripts/CMakeLists.txt
CHANGES:  Revised scripts/CMakeLists.txt
CHANGES:  Revised scripts/CMakeLists.txt and configure.ac
CHANGES:  Revised scripts/CMakeLists.txt
CHANGES:  Added scripts/makefile.nommx
CHANGES:  Fixed shared library numbering error that was introduced in 1.2.15beta6.
CHANGES:  Fixed handling of rgb_to_gray when png_ptr->color.gray isn't set.
CHANGES:  Fix bugs in makefile.nommx
CHANGES:  Revised scripts/CMakeLists.txt
CHANGES:  Revised scripts/CMakeLists.txt to install both shared and static libraries.
CHANGES:  Mention examples of libpng usage in the libpng*.txt and libpng.3 documents.
CHANGES:    png_set_expand_gray_1_2_4_to_8().
CHANGES:  Only use the valid bits of tRNS value in png_do_expand() (Brian Cartier)
CHANGES:  Fixed png_handle_tRNS() to only use the valid bits of tRNS value.
CHANGES:  Updated makefile.sgcc and makefile.solaris; added makefile.solaris-x86.
CHANGES:  Deleted extraneous square brackets from configure.ac
CHANGES:  Exported png_write_sig (Cosmin).
CHANGES:  Set pHYs = 2835 x 2835 pixels per meter, and added
CHANGES:    sCAL = 0.352778e-3 x 0.352778e-3 meters, in pngtest.png (Cosmin).
CHANGES:  Patched pnggccrd.c to assemble on x86_64 platforms.
CHANGES:  Fixed a typo (png_byte --> png_bytep) in libpng.3 and libpng.txt (Cosmin).
CHANGES:  Renamed png_mem_size_t to png_alloc_size_t, fixed its definition in
CHANGES:  Detect and fix attempt to write wrong iCCP profile length.
CHANGES:  Fix potential buffer overflow in sPLT chunk handler.
CHANGES:  Fix Makefile.am to not try to link to noexistent files.
CHANGES:  Check all exported functions for NULL png_ptr.
CHANGES:  Added scripts/CMakeLists.txt
CHANGES:  Revised scripts/CMakeLists.txt
CHANGES:  Added scripts/makefile.nommx
CHANGES:  Made inline expansion of png_get_*() optional with PNG_USE_READ_MACROS.
CHANGES:  Updated contrib/visupng/cexcept.h to version 2.0.1
CHANGES:  Removed extra crc check at the end of png_handle_cHRM().  Bug introduced
CHANGES:  Added png_get|set_chunk_cache_max() to limit the total number of sPLT,
CHANGES:    text, and unknown chunks that can be stored.
CHANGES:  Fixed off-by-one error introduced in png_push_read_zTXt() function in
CHANGES:  Revised makefile.darwin to fix shared library numbering.
CHANGES:  Change png_set_gray_1_2_4_to_8() to png_set_expand_gray_1_2_4_to_8()
CHANGES:    in example.c (debian bug report)
CHANGES:  Sync with tEXt vulnerability fix in libpng-1.2.33rc02.
CHANGES:    png_check_cHRM_fixed().
CHANGES:  Eliminated png_check_cHRM().  Instead, always use png_check_cHRM_fixed().
CHANGES:  In png_check_cHRM_fixed(), ensure white_y is > 0, and removed redundant
CHANGES:  Fixed string vs pointer-to-string error in png_check_keyword().
CHANGES:  Rearranged test expressions in png_check_cHRM_fixed() to avoid internal
CHANGES:    to ensure that new_key gets initialized and removed extra warning
CHANGES:  Added new exported function png_calloc().
CHANGES:  Fixed bug introduced in libpng-1.4.0beta48 with the memset arguments
CHANGES:  Fixed order of #ifdef directives in the png_debug defines in png.h
CHANGES:  Revised libpng*.txt and png.h documentation about use of png_write_flush()
CHANGES:  Added a section on differences between 1.0.x and 1.2.x to libpng.3/libpng.txt
CHANGES:  Fixed potential memory leak of "new_name" in png_write_iCCP() (Ralph Giles)
CHANGES:  Clarified usage of sig_bit versus sig_bit_p in example.c (Vincent Torri)
CHANGES:  Fixed typo in libpng docs (PNG_FILTER_AVE should be PNG_FILTER_AVG)
CHANGES:  Revised libpng*.txt and libpng.3 to mention calling png_set_IHDR()
CHANGES:  Added an "xcode" project to the projects directory (Alam Arias).
CHANGES:  Removed extraneous declaration from the new call to png_read_gray_to_rgb()
CHANGES:  Fixed up xcode project (Alam Arias)
CHANGES:  Avoid a possible NULL dereference in debug build, in png_set_text_2().
CHANGES:  Replaced *.tar.lzma with *.tar.xz in distribution.  Get the xz codec
CHANGES:    from <http://tukaani.org/xz>.
CHANGES:  Removed an extra png_debug() recently added to png_write_find_filter().
CHANGES:  Fixed incorrect #ifdef in pngset.c regarding unknown chunk support.
CHANGES:  Removed lpXYZ.tar.bz2 (with CRLF), KNOWNBUG, libpng-x.y.z-KNOWNBUG.txt,
CHANGES:  Moved CMakeLists.txt from scripts into the main libpng directory.
CHANGES:  Various bugfixes and improvements to CMakeLists.txt (Philip Lowman)
CHANGES:  Converted all PNG_NO_* tests to PNG_*_SUPPORTED everywhere except pngconf.h
CHANGES:  Fixed typo introduced in beta78 in pngtest.c ("#if def " should be "#ifdef ")
CHANGES:  Expanded TAB characters in pngrtran.c
CHANGES:  Fixed some inconsistent indentation in pngconf.h
CHANGES:  Updated the "xcode" project (Alam Arias).
CHANGES:  Revised libpng*.txt section about differences between 1.2.x and 1.4.0
CHANGES:  More bugfixes and improvements to CMakeLists.txt (Philip Lowman)
CHANGES:  Removed a harmless extra png_set_invert_alpha() from pngwrite.c
CHANGES:  Apply png_user_chunk_cache_max within png_decompress_chunk().
CHANGES:  Merged libpng-1.2.41.txt with libpng-1.4.0.txt where appropriate.
CHANGES:  Removed all remaining WIN32_WCE #ifdefs except those involving the
CHANGES:  Revised libpng*.txt to describe differences from 1.2.40 to 1.4.0 (instead
CHANGES:  Added README.txt to the beos, cbuilder5, netware, and xcode projects warning
CHANGES:  Updated CMakeLists.txt to add "-DPNG_CONFIGURE_LIBPNG" to the definitions.
CHANGES:    so that only PNG_EXPORT functions are exported.
CHANGES:  Removed projects/beos and netware.txt; no one seems to be supporting them.
CHANGES:  Added the "xcode" project to zip distributions,
CHANGES:  Fixed a typo in scripts/pngwin.def introduced in beta97.
CHANGES:  Removed scripts/makefile.nommx and makefile.vcawin32
CHANGES:  Revised CMakeLists.txt to account for new location of libpng-config.in
CHANGES:    accidentally deleted from the zip and 7z distributions when the xcode
CHANGES:  Fixed a typo in projects/visualc6/pngtest.dsp, introduced in beta100.
CHANGES:    scripts/README.txt
CHANGES:  Removed obsolete comments about ASM from projects/visualc71/README_zlib.txt
CHANGES:  Make the 'png_jmpbuf' macro expand to a call that records the correct
CHANGES:    to put png.h and pngconf.h in $prefix/include, like the other scripts,
CHANGES:    instead of in $prefix/include/libpng.  Also revised makefile.sco
CHANGES:    to put them in $prefix/include/libpng15 instead of in
CHANGES:    $prefix/include/libpng/libpng15.
CHANGES:  Renamed libpng-pc.in back to libpng.pc.in and revised CMakeLists.txt
CHANGES:  Fixed some indentation errors.
CHANGES:  Revised libpng*.txt and libpng.3 about 1.2.x->1.4.x differences.
CHANGES:  Updated CMakeLists.txt for consistent indentation and to avoid an
CHANGES:    links as configure, except for libpng.la and libpng14.la.
CHANGES:  Revised scripts/makefile.linux to install a link to libpng14.so.14.1
CHANGES:  Added png_set|get_chunk_malloc_max() functions.
CHANGES:    png_ptr->png_user_chunk_malloc_max.
CHANGES:  Fixed type declaration of png_get_chunk_malloc_max() in pngget.c (Daisuke
CHANGES:  Noted in scripts/makefile.mingw that it expects to be run under MSYS.
CHANGES:  Added exported png_longjmp() function.
CHANGES:  Added -D_ALLSOURCE in configure.ac, makefile.aix, and CMakeLists.txt
CHANGES:  Removed -D_ALLSOURCE from configure.ac, makefile.aix, and CMakeLists.txt.
CHANGES:  Fixed inconsistent indentations and made numerous cosmetic changes.
CHANGES:    expressions (i.e. a trailing ';' must always be added) and correct
CHANGES:  Added back in export symbols that can be present in the Windows build but
CHANGES:    into PNGCAPI (base C form), PNGAPI (exports) and PNGCBAPI (callbacks),
CHANGES:    file (fixes build on Cygwin).
CHANGES:    to EOL (coming from preprocessor macro expansion).  Added a facility
CHANGES:  Make png_text_struct independent of PNG_iTXt_SUPPORTED, so that
CHANGES:  Removed the xcode project because it has not been updated to work
CHANGES:    storing unneeded error/warning text.
CHANGES:    For Windows/x86 platforms only:
CHANGES:      __cdecl throughout (both API functions and callbacks) on Windows/x86
CHANGES:  Relaxed the overly-restrictive permissions of some files.
CHANGES:  Relaxed more overly-restrictive permissions of some files.
CHANGES:  Fixed dependencies of GET_INT_32 - it does not require READ_INT_FUNCTIONS
CHANGES:  Removed the now-redundant check for out-of-bounds new_row from example.c
CHANGES:  Rewrote png_process_IDAT_data to consistently treat extra data as warnings
CHANGES:  Make png_set_sRGB_gAMA_and_cHRM set values using either the fixed or
CHANGES:    set.  The gregbook code is a useful example because, even though it
CHANGES:    Structure Exceptions or C++ exceptions (compiler willing - note that gcc
CHANGES:  Changed "extern PNG_EXPORT" to "PNG_EXPORT" in png.h (Jan Nijtmans)
CHANGES:  Changed "extern" to "PNG_EXTERN" in pngpriv.h (except for the 'extern "C" {')
CHANGES:  Fixed point APIs are now supported throughout (no missing APIs).
CHANGES:  Internal fixed point arithmetic support exists for all internal floating
CHANGES:  Two new APIs exist to get the number of passes without turning on the
CHANGES:  Most floating point APIs now simply call the fixed point APIs after
CHANGES:    converting the values to the fixed point form used in the PNG file.
CHANGES:  Implemented remaining "_fixed" functions.
CHANGES:  VisualC/GCC warning fixes, VisualC build fixes
CHANGES:    warnings are unavoidable.  Fixes include signed/unsigned fixes in
CHANGES:    pngvalid and checks with gcc -Wall -Wextra -Wunused.
CHANGES:  Add .dll.a to the list of extensions to be symlinked by Makefile.am (Yaakov)
CHANGES:  Fixed non-GCC fixed point builds.  In png.c a declaration was misplaced
CHANGES:    in an earlier update.  Fixed to declare the auto variables at the head.
CHANGES:  Use cexcept.h in pngvalid.c.
CHANGES:  Updated CMakeLists.txt to use CMAKE_INSTALL_LIBDIR variable; useful for
CHANGES:  Revised CMakeLists.txt to put the man pages in share/man/man* not man/man*
CHANGES:  Revised CMakeLists.txt to make symlinks instead of copies when installing.
CHANGES:  Changed PNG_LIB_NAME from pngNN to libpngNN in CMakeLists.txt (Philip Lowman)
CHANGES:  Simplified the pngvalid error-handling code now that cexcept.h is in place.
CHANGES:  Added an explicit make step to projects/vstudio for pnglibconf.h
CHANGES:    Also corrected zlib.vcxproj into which Visual Studio had introduced
CHANGES:  Added new private header files to libpng_sources in CMakeLists.txt
CHANGES:  Fixed a number of problems with 64-bit compilation reported by Visual
CHANGES:  Updated CMakeLists.txt (Philip Lowman).
CHANGES:  Fixed problem with symbols creation in Makefile.am which was assuming that
CHANGES:  Check for out-of-range text compression mode in png_set_text().
CHANGES:  Use document name "libpng-manual.txt" instead of "libpng-<version>.txt"
CHANGES:  Fixed atomicity of chunk header serialization (Cosmin)
CHANGES:  Fixed some incorrect "=" macro names in pnglibconf.dfa
CHANGES:  Included documentation of changes in 1.5.0 from 1.4.x in libpng-manual.txt
CHANGES:  Don't display test results (except PASS/FAIL) when running "make test".
CHANGES:    Instead put them in pngtest-log.txt
CHANGES:  Added "--with-zprefix=<string>" to configure.ac
CHANGES:  Fixed interlace image handling and add test cases (John Bowler)
CHANGES:  Fixed the clean rule in Makefile.am to remove pngtest-log.txt
CHANGES:  Fixed bug in background transformation handling in pngrtran.c (it was
CHANGES:  Fixed typo in a comment in CMakeLists.txt (libpng14 => libpng15) (Cosmin)
CHANGES:  Changed the new configure option "zprefix=string" to "zlib-prefix=string"
CHANGES:    internally happens to call it with one, and fixed a failure to handle
CHANGES:    palette mapped images correctly.  This fixes CVE-2690.
CHANGES:  Fixed a bug in handling of interlaced images (bero at arklinux.org).
CHANGES:  Updated CMakeLists.txt (Clifford Yapp)
CHANGES:  Fixed typecasting of some png_debug() statements (Cosmin)
CHANGES:    samples of each pixel, instead of sampling the red channel three times.
CHANGES:  Prefixed variable names index, div, exp, gamma with "png_" to avoid "shadow"
CHANGES:    warnings, and (mistakenly) changed png_exp() to exp().
CHANGES:  Changed variable names png_index, png_div, png_exp, and png_gamma to
CHANGES:    char_index, divisor, exp_b10, and gamma_val, respectively, and
CHANGES:    changed exp() back to png_exp().
CHANGES:  Revised png_fixed() in png.c to avoid compiler warning about reaching the
CHANGES:  Attempted to fix cpp on Solaris with S. Studio 12 cc, fix build
CHANGES:    because they are incompletely tested.  gray_to_rgb was failing to expand
CHANGES:  Fixed incorrect examples of callback prototypes in the manual, that were
CHANGES:  More -Wshadow fixes for older gcc compilers.  Older gcc versions apparently
CHANGES:  Fixed gcc pendantic warnings.
CHANGES:  Fixed png_get_current_row_number() in the interlaced case.
CHANGES:  Implemented expansion to 16 bits.
CHANGES:  Fixed mistake in the descriptions of user read_transform and write_transform
CHANGES:  Fixed the read/write row callback documentation.
CHANGES:    every row with information pertaining to the next row.
CHANGES:  Fixed scripts/makefile.vcwin32
CHANGES:  Fixed a bug (present since libpng-1.0.7) that makes png_handle_sPLT() fail
CHANGES:  Added API functions (png_set_text_compression_level() and four others) to
CHANGES:  Only compile the new zlib re-initializing code when text or iCCP is
CHANGES:  Fixed gcc -ansi -pedantic compile. A strict ANSI system does not have
CHANGES:  Fixed 64-bit builds where png_uint_32 is smaller than png_size_t in
CHANGES:  Fixed bug with stripping the filler or alpha channel when writing, that
CHANGES:    Internal changes only except a new option to avoid compiling the
CHANGES:    A minor change is to stop the strip_16 and expand_16 interfaces from
CHANGES:    been fixed - this failed to initialize the red channel and accidentally
CHANGES:    was introduced in libpng-1.2.20beta01.  This fixes CVE-2011-2691.
CHANGES:  IDAT compression failed if preceded by a compressed text chunk (bug
CHANGES:  Removed the -D_ALL_SOURCE from definitions for AIX in CMakeLists.txt
CHANGES:  Added expand_16 support to the high level interface.
CHANGES:    change from the previous (unreleased) ABI/API to hide the exact value used
CHANGES:  Improved "pngvalid --speed" to exclude more of pngvalid from the time.
CHANGES:  Documented png_set_alpha_mode(), other changes in libpng.3/libpng-manual.txt
CHANGES:  Minor cleanup and some extra checking in pngrutil.c and pngrtran.c. When
CHANGES:    expanding an indexed image, always expand to RGBA if transparency is
CHANGES:  Reversed earlier 1.5.3 change of transformation order; move png_expand_16
CHANGES:  png_set_background() and png_expand_16() did not work together correctly.
CHANGES:    need_expand false and the matching 16 bit color libpng erroneously just
CHANGES:    treats it as an 8-bit color because of where png_do_expand_16 is in the
CHANGES:    transform list.  This simple fix reduces the supplied colour to 8-bits,
CHANGES:  Added tests for expand16, more fixes for palette image tests to pngvalid.
CHANGES:  Fixed uninitialized memory read in png_format_buffer() (Bug report by
CHANGES:  Fixed png_handle_sCAL which is broken in 1.5. This fixes CVE 2011-2692.
CHANGES:    of the stored value cannot overflow the fixed point representation,
CHANGES:  Fixed and clarified LEGACY 16-to-8 scaling code.
CHANGES:  Fixed a problem in png_do_expand_palette() exposed by optimization in
CHANGES:  The palette expand optimization prevented expansion to an intermediate RGBA
CHANGES:    form if tRNS was present but alpha was marked to be stripped; this exposed
CHANGES:    a check for tRNS in png_do_expand_palette() which is inconsistent with the
CHANGES:  Correction to the expand_16 code; removed extra instance of
CHANGES:  Fixed new bug that was causing both strip_16 and scale_16 to be applied.
CHANGES:  Fixed pngvalid, simplified macros, added checking for 0 in sCAL.
CHANGES:  Fixed pngvalid if ACCURATE_SCALE is defined.
CHANGES:  Fixed some typos and made other minor changes in the manual.
CHANGES:    the file extension, so it always compiles with C++ rules.  Made minor
CHANGES:    changes to pngrutil.c to cast results where C++ expects it but C does not.
CHANGES:  Minor editing of libpng.3 and libpng-manual.txt.
CHANGES:  Revised CMakeLists.txt (Clifford Yapp)
CHANGES:  Prevent unexpected API exports from non-libpng DLLs on Windows.  The "_DLL"
CHANGES:    caused the libpng APIs to be marked as DLL exports in static builds under
CHANGES:  Ensure the CMAKE_LIBRARY_OUTPUT_DIRECTORY is set in CMakeLists.txt
CHANGES:  Fixes to rgb_to_gray and cHRM XYZ APIs (John Bowler):
CHANGES:    Some pixels were treated as true grey when they weren't and such pixels
CHANGES:    truncated to the bit depth rather than rounded have been fixed except in
CHANGES:    png_XYZ_from_xy_checked().
CHANGES:  Fixed 64-bit compilation errors (gcc). The errors fixed relate
CHANGES:  Constant changes for 64-bit compatibility (removal of L suffixes). The
CHANGES:  Removed "L" suffixes in pngpriv.h
CHANGES:  Fixed some 64-bit type conversion warnings in pngrtran.c
CHANGES:    pixel depths after the transforms on both read and write.
CHANGES:    string form because this is exposed in the API.
CHANGES:  Fixed a typo in the definition of the new PNG_STRING_FROM_CHUNK(s,c) macro.
CHANGES:  Revised CMakeLists.txt to work with mingw and removed some material from
CHANGES:    CMakeLists.txt that is no longer useful in libpng-1.5.
CHANGES:  Fixed typo in Makefile.in and Makefile.am ("-M Wl" should be "-M -Wl")."
CHANGES:    percentage for 16-bit and 32-bit pixels in the typical case where the
CHANGES:  Fixed bug in png_write_chunk_header() debug print, introduced in 1.5.6beta01.
CHANGES:  Fixed a relatively harmless memory overwrite in compressed text writing
CHANGES:  Fixes for multiple calls to png_read_update_info. These fixes attend to
CHANGES:    twice results in inaccuracies that can't be easily fixed.  There is now
CHANGES:    an exact multiple of 8 bits and the image is not interlaced.
CHANGES:  Fixed compiler warnings with Intel and MSYS compilers. The logical shift
CHANGES:    fix for Microsoft Visual C is required by other compilers, so this
CHANGES:    enables that fix for all compilers when using compile-time constants.
CHANGES:    and any other-filtered rows with 3 or 4 bytes per pixel (Mans Rullgard).
CHANGES:  Fixed bug in pngvalid on early allocation failure; fixed type cast in
CHANGES:  Fix for the preprocessor of the Intel C compiler. The preprocessor
CHANGES:    generation on x86. The changes are only part of the suggested ones;
CHANGES:  Fixed FP division by zero in pngvalid.c; the 'test_pixel' code left
CHANGES:    the sBIT fields in the test pixel as 0, which resulted in a floating
CHANGES:    FP exceptions cause a crash. Added code to pngvalid to turn on FP
CHANGES:    exceptions if the appropriate glibc support is there to ensure this is
CHANGES:  Multiple transform bug fixes plus a work-round for double gamma correction.
CHANGES:    libpng transform code. This check-in also contains fixes to various bugs
CHANGES:  Fixes for C++ compilation using g++ When libpng source is compiled
CHANGES:  Added --noexecstack to assembler file compilation. GCC does not set
CHANGES:    compilers fault 'extern const' data declarations (because the data is
CHANGES:  Since the gcc driver does not recognize the --noexecstack flag, we must
CHANGES:    use the -Wa prefix to have it passed through to the assembler.
CHANGES:  Added MINGW support to CMakeLists.txt
CHANGES:  Backed out 'simplified' API changes. The API seems too complex and there
CHANGES:  Updated CMakeLists.txt to account for the relocation of pngvalid.c
CHANGES:  Minor fixes to pngvalid.c for gcc 4.6.2 compatibility to remove warnings
CHANGES:  Fixed minor memset/sizeof errors in pngvalid.c.
CHANGES:  Added example programs for the new 'simplified' API.
CHANGES:    change. Also fixed some of the projects/* and contrib/* files that needed
CHANGES:    With this change the required ANSI-C header files are assumed to exist: the
CHANGES:    libpng relies on limits.h and stddef.h existing and behaving as defined
CHANGES:  Fixed race conditions in parallel make builds. With higher degrees of
CHANGES:    temporary files for suffix rules to always use $* and ensures that the
CHANGES:    non-suffix rules use unique file names.
CHANGES:  Start-up code size improvements, error handler flexibility. These changes
CHANGES:    way as everything else, except that the allocations handle NULL return
CHANGES:    reductions; however, this is a reduction in code that is always executed
CHANGES:  Enabled png_get_sCAL_fixed() if floating point APIs are enabled. Previously
CHANGES:    it was disabled whenever internal fixed point arithmetic was selected,
CHANGES:    which meant it didn't exist even on systems where FP was available but not
CHANGES:  Removed the reference to the non-exported function png_memcpy() from
CHANGES:    example.c.
CHANGES:  Fixed the Visual C 64-bit build - it requires jmp_buf to be aligned, but
CHANGES:  Fix bug in pngerror.c: some long warnings were being improperly truncated
CHANGES:  Fixed Min/GW uninstall to remove libpng.dll.a
CHANGES:  Conditionalize the install rules for MINGW and CYGWIN in CMakeLists.txt and
CHANGES:    directory extracted from a tar distribution anymore. You must run it in
CHANGES:    pngsuite/README.txt.
CHANGES:  Fixed Image::colormap misalignment in pngstest.c
CHANGES:    option no longer exists.
CHANGES:  Added symbol prefixing that allows all the libpng external symbols
CHANGES:    to be prefixed (suggested by Reuben Hawkins).
CHANGES:  Fixed 'prefix' builds on clean systems. The generation of pngprefix.h
CHANGES:  Updated INSTALL to explain that autogen.sh must be run in a GIT clone,
CHANGES:    not in a libpng directory extracted from a tar distribution.
CHANGES:  Updated list of test images in CMakeLists.txt
CHANGES:  Fix character count in pngstest command in projects/owatcom/pngstest.tgt
CHANGES:    extremely inaccurate for sRGB conversions because it uses an 8-bit
CHANGES:    to 0 (see Poynton).  The net result is that the calculation has a maximum
CHANGES:  Fixed a memory overwrite bug in simplified read of RGB PNG with
CHANGES:    allow all possible RGB transforms to be passed; pngstest cmppixel needs
CHANGES:  Fixed fixed/float API export conditionals. 1) If FIXED_POINT or
CHANGES:    fix is to cause png.h to declare the functions with PNG_INTERNAL_FUNCTION
CHANGES:  Check for invalid palette index while reading paletted PNG.  When one is
CHANGES:  Do not increase num_palette on invalid_index.
CHANGES:  Relocated check for invalid palette index to pngrtran.c, after unpacking
CHANGES:    the sub-8-bit pixels.
CHANGES:  Fixed CVE-2011-3026 buffer overrun bug.  This bug was introduced when
CHANGES:  Removed unused "current_text" members of png_struct and the png_free()
CHANGES:    of png_ptr->current_text from pngread.c
CHANGES:  Fixed transparent pixel and 16-bit rgb tests in pngstest and removed a
CHANGES:    also allows generation of images with extra chunks, although this is
CHANGES:  Added check for invalid palette index while reading.
CHANGES:  Fixed some bugs in ICC profile writing. The code should now accept
CHANGES:  Relocated palette-index checking function from pngrutil.c to pngtrans.c
CHANGES:  Added palette-index checking while writing.
CHANGES:  Fixed build warnings (MSVC, GCC, GCC v3). Cygwin GCC with default options
CHANGES:    declares 'index' as a global, causing a warning if it is used as a local
CHANGES:    by ANSI-C to be ~x+1).  The padding calculation was changed to use a
CHANGES:    is now fixed, all initialization is delayed, and the code checks for
CHANGES:  Fixed PNG_LIBPNG_BUILD_BASE_TYPE definition. 
CHANGES:  If benign errors are disabled use maximum window on ancilliary inflate.
CHANGES:  Issue a png_benign_error() instead of png_warning() about bad palette index.
CHANGES:  Fixed an off-by-one error in the palette index checking function.
CHANGES:  Fixed a compiler warning under Cygwin (Windows-7, 32-bit system)
CHANGES:  Revised example.c to put text strings in a temporary character array
CHANGES:    instead of directly assigning string constants to png_textp members.
CHANGES:    the process exited, apparently!)
CHANGES:  Revised png_set_text_2() to avoid potential memory corruption (fixes
CHANGES:  Enable png_set_check_for_invalid_index() for both read and write.
CHANGES:    fixes the cases that clang warns about either by eliminating the
CHANGES:  Revised CMakeLists.txt to not attempt to make a symlink under mingw.
CHANGES:  Made fixes for new optimization warnings from gcc 4.7.0. The compiler
CHANGES:    the linker mapfile symbol prefix.
CHANGES:  Improved performance of new do_check_palette_indexes() function (only
CHANGES:  Don't check palette indexes if num_palette is 0 (as it can be in MNG files).
CHANGES:    unknown chunks and all known chunks except for IHDR, PLTE, tRNS, IDAT,
CHANGES:  Changed "a+w" to "u+w" in Makefile.in to fix CVE-2012-3386.
CHANGES:  Fixed configurations where floating point is completely disabled.  Because
CHANGES:    of the changes to support symbol prefixing PNG_INTERNAL_FUNCTION declares
CHANGES:    considerable code cleanup, and extra error checking, is possible.  This
CHANGES:  Add some conditions for compiling png_fixed().  This is a small function
CHANGES:    for compressed text chunks).
CHANGES:  Work around gcc 3.x and Microsoft Visual Studio 2010 complaints. Both object
CHANGES:  Unknown handling fixes and clean up. This adds more correct option
CHANGES:    control of the unknown handling, corrects the pre-existing bug where
CHANGES:    explain how the unknown handling works.
CHANGES:  Corrected fix for unknown handling in pngtest. This reinstates the
CHANGES:  Fixed the simplified API example programs to add the *colormap parameter
CHANGES:  Added contrib/examples/* to the *.zip and *.7z distributions.
CHANGES:  Made makepng and pngtest produce identical PNGs, add "--relaxed" option
CHANGES:    to pngtest. The "--relaxed" option turns off the benign errors that are
CHANGES:    where the length has not been extended to a multiple of 4, and pngtest
CHANGES:  Improved ICC profile handling including cHRM chunk generation and fixed
CHANGES:  Changed ICC profile matrix/vector types to not depend on array type rules.
CHANGES:    except for GCC-4.2.1 work with this version.  The change makes the ANSI-C
CHANGES:    elements in the array moot by explicitly applying const to the base
CHANGES:    elements of the png_icc_matrix and png_icc_vector types. The accidental
CHANGES:    builds, fixed build errors and corrected a minor exit code error in
CHANGES:  Fixed build when using #define PNG_NO_READ_GAMMA in png_do_compose() in
CHANGES:  Fixed GUIDs in projects/vstudio. Some were duplicated or missing,
CHANGES:  Fixed an intermittent SEGV in pngstest due to an uninitialized array element.
CHANGES:  Fixed error checking in the simplified write API (Olaf van der Spek)
CHANGES:  Made png_user_version_check() ok to use with libpng version 1.10.x and later.
CHANGES:  Fixed typo in png.c (PNG_SET_CHUNK_MALLOC_MAX should be PNG_CHUNK_MALLOC_MAX)
CHANGES:  Fixed cases of unquoted DESTDIR in Makefile.am
CHANGES:  Fixed Windows build issues, enabled ARM compilation. Various warnings issued
CHANGES:    by earlier versions of GCC fixed for Cygwin and Min/GW (which both use old
CHANGES:    x86. The test programs cannot be run because they are not signed.
CHANGES:  Discontinued distributing libpng-1.x.x.tar.bz2.
CHANGES:  Discontinued distributing libpng-1.7.0-1.6.0-diff.txt and similar.
CHANGES:  Fixed 'make distcheck' on SUN OS - libpng.so was not being removed
CHANGES:  Fixed conceivable but difficult to repro overflow. Also added two test
CHANGES:  png_set_text_2() (CVE-2013-7354).
CHANGES:  Use consistent handling of overflows in text, sPLT and unknown png_set_* APIs
CHANGES:  Added png_get_palette_max() function.
CHANGES:  Fixed the png_get_palette_max API.
CHANGES:  Update manual about png_get_palette_max().
CHANGES:  Fixed missing dependency in --prefix builds The intermediate
CHANGES:    internal 'prefix.h' file can only be generated correctly after
CHANGES:    build pngprefix.h and pnglibconf.h, often the error goes unnoticed
CHANGES:  Enclosed the new png_get_palette_max in #ifdef PNG_GET_PALETTE_MAX_SUPPORTED
CHANGES:  Fix typo in png.h #ifdef
CHANGES:  Made symbol prefixing work with the ARM neon optimizations. Also allow
CHANGES:  Ported libpng 1.5 options.awk/dfn file handling to 1.6, fixed one bug.
CHANGES:  Removed cc -E workround, corrected png_get_palette_max API Tested on
CHANGES:    double quotes unless it is to be macro substituted the fix should
CHANGES:  Fixed a race condition in the creation of the build 'scripts' directory
CHANGES:  Use approved/supported Android method to check for NEON, use Linux/POSIX
CHANGES:    1003.1 API to check /proc/self/auxv avoiding buffer allocation and other
CHANGES:  Fixed ALIGNED_MEMORY support.
CHANGES:    prefixing. This adds an API to set optimization options externally,
CHANGES:    fix makes the simplified API treat all input files the same way and
CHANGES:  Fixed bugs in the pngpixel and makepng test programs.
CHANGES:  Fixed CMakelists.txt to allow building a single variant of the library
CHANGES:  Changed the CREATE_SYMLINK macro to expect the full path to a file as the
CHANGES:  Updated documentation of 1.5.x to 1.6.x changes in iCCP chunk handling.
CHANGES:  Fixed incorrect warning of excess deflate data. End condition - the
CHANGES:  Added contrib/tools/fixitxt.c, to repair the erroneous iTXt chunk length
CHANGES:    was switched 'off' as opposed to being explicitly disabled.
CHANGES:  Expanded manual paragraph about writing private chunks, particularly
CHANGES:  Added an option to force maximum window size for inflating, which was
CHANGES:  Added png-fix-itxt and png-fix-too-far-back to the built programs and
CHANGES:  Detect wrong libpng versions linked to png-fix-too-far-back, which currently
CHANGES:  Fixed gnu issues: g++ needs a static_cast, gcc 4.4.7 has a broken warning
CHANGES:    Fixed whitespace handling
CHANGES:  Attempt to detect configuration issues with png-fix-too-far-back, which
CHANGES:  Added information in the documentation about problems with and fixes for
CHANGES:  Improved png-fix-too-far-back usage message, added --suffix option.
CHANGES:  Added set(CMAKE_CONFIGURATION_TYPES ...) to CMakeLists.txt (Andrew Hundt)
CHANGES:  Deleted set(CMAKE_BUILD_TYPE) block from CMakeLists.txt
CHANGES:    (pngpriv.h) during the compile.  Without this, symbol prefixing is broken
CHANGES:    the optimizations ('check' vs 'api') are exposed in the public header files
CHANGES:    except that the new setting PNG_ARM_NEON_OPT documents how libpng makes the
CHANGES:  Protect symbol prefixing against CC/CPPFLAGS/CFLAGS useage.
CHANGES:    Previous iOS/Xcode fixes for the ARM NEON optimizations moved the test
CHANGES:    prefixing because the definition of the special png_init_filter_functions
CHANGES:    it is not used, so that it will always get prefixed.
CHANGES:  Revised example.c to illustrate use of PNG_DEFAULT_sRGB and PNG_GAMMA_MAC_18
CHANGES:  Renamed contrib/tools/png-fix-too-far-back.c to pngfix.c and revised it
CHANGES:  Fixed undefined behavior in contrib/tools/pngfix.c and added new strip
CHANGES:    option. pngfix relied on undefined behavior and even a simple change from
CHANGES:    implemented and is the default if --max is given.  Option names have
CHANGES:  Unified pngfix.c source with libpng17.
CHANGES:  Fixed inconsistent conditional compilation of png_chunk_unknown_handling()
CHANGES:    fixed the pngminim makefiles to work when $(MAKEFLAGS) contains stuff
CHANGES:  Fixed default behavior of ARM_NEON_API. If the ARM NEON API option was
CHANGES:  Merged pngunknown.c with 1.7 version and back ported 1.7 improvements/fixes
CHANGES:    treatment of z_const from the library code into pngfix.c
CHANGES:    necessary to exclude some earlier clang versions but this seems unlikely.
CHANGES:  Fixed #include in filter_neon_intrinsics.c and ctype macros. The ctype char
CHANGES:  Fixed 'minimal' builds. Various obviously useful minimal configurations
CHANGES:    overly complex dependencies in scripts/pnglibconf.dfa. This change
CHANGES:  Fixed pngvalid 'fail' function declaration on the Intel C Compiler.
CHANGES:  Tidied up pngfix inits and fixed pngtest no-write builds.
CHANGES:    (png_ptr->palette) in png_do_expand_palette(). This is CVE-2013-6954
CHANGES:    they can be made static. Move the intrapixel functions and the
CHANGES:    x86-64 DLL build (Gentoo Linux) this reduces the size of the text
CHANGES:  Removed #error macro from contrib/tools/pngfix.c (Thomas Klausner).
CHANGES:  Fixed a large number of instances where PNGCBAPI was omitted from
CHANGES:  Fixed combination of ~alpha with shift. On read invert alpha, processing
CHANGES:    contrib/arm-neon subdirectory. The __linux__ code has also been changed to
CHANGES:    compile and link on Android by using /proc/cpuinfo, and the old linux code
CHANGES:    is in contrib/arm-neon/linux-auxv.c.  The new code avoids POSIX and Linux
CHANGES:  Check for __has_extension before using it in pngconf.h, to
CHANGES:    This fixes CERT VU#684412 and CVE-2014-0333.
CHANGES:  Moved some documentation from png.h to libpng.3 and libpng-manual.txt
CHANGES:  Minor editing of contrib/arm-neon/README and contrib/examples/*.c
CHANGES:  Fixed typos in the manual and in scripts/pnglibconf.dfa (CFLAGS -> CPPFLAGS
CHANGES:  Don't warn about invalid dimensions exceeding user limits (Cosmin).
CHANGES:  Fixed a typo in pngrutil.c, introduced in libpng-1.5.6, that interferes
CHANGES:    with "blocky" expansion of sub-8-bit interlaced PNG files (Eric Huss).
CHANGES:    row_callback now receives the proper pass number and unexpanded rows, when
CHANGES:  Test ZLIB_VERNUM instead of PNG_ZLIB_VERNUM in contrib/tools/pngfix.c
CHANGES:    declarations (Max Stepin).
CHANGES:  Ensure "__has_attribute()" macro exists before trying to use it with
CHANGES:  Split a long output string in contrib/gregbook/rpng2-x.c.
CHANGES:  Fixed clang no-warning builds: png_digit was defined but never used.
CHANGES:  Fixed an incorrect separator ("/" should be "\") in scripts/makefile.vcwin32
CHANGES:    Also fixed makefile.bc32, makefile.bor, makefile.msc, makefile.intel, and
CHANGES:  Ensure that CMakeLists.txt makes the target "lib" directory before making
CHANGES:  Added opinion that the ECCN (Export Control Classification Number) for
CHANGES:  Eliminated use of "$<" in makefile explicit rules, when copying
CHANGES:  Do not build contrib/tools/pngfix.c when PNG_SETJMP_NOT_SUPPORTED,
CHANGES:  Add "#include <setjmp.h>" to contrib/tools/pngfix.c (John Bowler)
CHANGES:  Use nanosleep() instead of usleep() in contrib/gregbook/rpng2-x.c
CHANGES:  Define usleep() in contrib/gregbook/rpng2-x.c if not already defined
CHANGES:    in unistd.h and nanosleep() is not available; fixes error introduced
CHANGES:  Disable floating point exception handling in pngvalid.c when
CHANGES:    already defined.  Revert floating point exception handling in pngvalid.c
CHANGES:  Fixed incorrect handling of the iTXt compression flag in pngrutil.c
CHANGES:  Removed unused "text_len" parameter from private function png_write_zTXt().
CHANGES:  Only mark text chunks as written after successfully writing them.
CHANGES:  Fixed some typos in comments.
CHANGES:  Updated README file to explain that direct access to the png_struct
CHANGES:  Changed "if (!x)" to "if (x == 0)" and "if (x)" to "if (x != 0)"
CHANGES:  Changed remaining "if (!x)" to "if (x == 0)" and "if (x)" to "if (x != 0)"
CHANGES:    example.c, pngtest.c, and applications in the contrib directory.
CHANGES:  Fixed GCC unsigned int->float warnings. Various versions of GCC
CHANGES:    avoids the issue by explicitly converting to (int) where safe.
CHANGES:  Fixed array size calculations to avoid warnings. At various points
CHANGES:    in the manual, example.c, pngtest.c, and applications in the contrib
CHANGES:    (Bug report by Alex Eubanks).
CHANGES:  Fixed an overflow in png_combine_row with very wide interlaced images.
CMakeLists.txt:# CMakeLists.txt
CMakeLists.txt:# TODO: fix this by building with awk; without this no cmake build can be
CMakeLists.txt:  add_executable(pngtest ${pngtest_sources})
CMakeLists.txt:  add_executable(pngvalid ${pngvalid_sources})
CMakeLists.txt:  add_executable(pngstest ${pngstest_sources})
CMakeLists.txt:    execute_process(COMMAND ${CMAKE_COMMAND} -E make_directory ${CMAKE_CURRENT_BINARY_DIR}/${CMAKE_LIBRARY_OUTPUT_DIRECTORY})
CMakeLists.txt:    execute_process(COMMAND ${CMAKE_COMMAND} -E create_symlink "${LINK_TARGET}" ${CMAKE_LIBRARY_OUTPUT_DIRECTORY}/${DEST_FILE} WORKING_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR})
CMakeLists.txt:    execute_process(COMMAND ${CMAKE_COMMAND} -E create_symlink "${LINK_TARGET}" ${DEST_FILE} WORKING_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR})
CMakeLists.txt:  set(prefix      ${CMAKE_INSTALL_PREFIX})
CMakeLists.txt:  set(exec_prefix ${CMAKE_INSTALL_PREFIX})
CMakeLists.txt:  # MSVC doesn't use a different file extension for shared vs. static
CMakeLists.txt:# If CMake > 2.4.x, we set a variable used below to export
CMakeLists.txt:# targets to an export file.
CMakeLists.txt:# On versions of CMake that support it, create an export file CMake
CMakeLists.txt:# what's with libpng-manual.txt and all the extra files?
CMakeLists.txt:# pexports libpng.dll > libpng.def
CMakeLists.txt:# lib /def:libpng.def /machine:x86
compile:# As a special exception to the GNU General Public License, if you
compile:	      set x "$@" -Fo"$file"
compile:	      set x "$@" -Fe"$file"
compile:	  set x "$@" -I"$file"
compile:	  set x "$@" -I"$file"
compile:	  set x "$@" "$lib"
compile:	  set x "$@" "$lib"
compile:	  set x "$@" "$1"
compile:	*.cc | *.CC | *.cxx | *.CXX | *.[cC]++)
compile:	  set x "$@" -Tp"$file"
compile:	  set x "$@" "$file"
compile:	  set x "$@" "$1"
compile:  exec "$@" $linker_opts
compile:  exit 1
compile:     exit 1;
compile:arguments, and rename the output as expected.
compile:    exit $?
compile:    exit $?
compile:  cl | *[/\\]cl | cl.exe | *[/\\]cl.exe )
compile:	    set x "$@" -o "$2"
compile:	set x "$@" "$1"
compile:	set x "$@" "$1"
compile:  exec "$@"
compile:# Name of file we expect compiler to create.
compile:# that we are using for the .o file.  Also, base the name on the expected
compile:trap "rmdir '$lockdir'; exit 1" 1 2 15
compile:exit $ret
config.guess:# As a special exception to the GNU General Public License, if you
config.guess:# program.  This Exception is an additional permission under section 7
config.guess:  -h, --help         print this help, then exit
config.guess:  -t, --time-stamp   print date of last modification, then exit
config.guess:  -v, --version      print version number, then exit
config.guess:       echo "$timestamp" ; exit ;;
config.guess:       echo "$version" ; exit ;;
config.guess:       echo "$usage"; exit ;;
config.guess:       exit 1 ;;
config.guess:  exit 1
config.guess:trap 'exit 1' 1 2 15
config.guess:trap "exitcode=\$?; (rm -f \$tmpfiles 2>/dev/null; rmdir \$tmp 2>/dev/null) && exit \$exitcode" 0 ;
config.guess:trap "rm -f \$tmpfiles 2>/dev/null; rmdir \$tmp 2>/dev/null; exit 1" 1 2 13 15 ;
config.guess: { echo "$me: cannot create a temporary directory in $TMPDIR" >&2 ; exit 1 ; } ;
config.guess: ,,)    echo "int x;" > $dummy.c ;
config.guess:	if test x"$CC_FOR_BUILD" = x ; then
config.guess:# This is needed to find uname on a Pyramid OSx when run in the BSD universe.
config.guess:	PATH=$PATH:/.attbin ; export PATH
config.guess:Linux|GNU|GNU/*)
config.guess:# Note: order is significant - the case branches are not exclusive.
config.guess:	    arm*|i386|m68k|ns32k|sh3*|sparc|vax)
config.guess:	# suitable tag, in the style of linux-gnu.
config.guess:	exit ;;
config.guess:	exit ;;
config.guess:	exit ;;
config.guess:	exit ;;
config.guess:	exit ;;
config.guess:	exit ;;
config.guess:	exit ;;
config.guess:	# A Xn.n version is an unreleased experimental baselevel.
config.guess:	echo ${UNAME_MACHINE}-dec-osf`echo ${UNAME_RELEASE} | sed -e 's/^[PVTX]//' | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz'`
config.guess:	# Reset EXIT trap before exiting to avoid spurious non-zero exit code.
config.guess:	exitcode=$?
config.guess:	exit $exitcode ;;
config.guess:	# How do we know it's Interix rather than the generic POSIX subsystem?
config.guess:	echo alpha-pc-interix
config.guess:	exit ;;
config.guess:	exit ;;
config.guess:	exit ;;
config.guess:	exit ;;
config.guess:	exit ;;
config.guess:	exit ;;
config.guess:	exit ;;
config.guess:	exit ;;
config.guess:    arm:RISC*:1.[012]*:*|arm:riscix:1.[012]*:*)
config.guess:	echo arm-acorn-riscix${UNAME_RELEASE}
config.guess:	exit ;;
config.guess:	exit ;;
config.guess:	echo hppa1.1-hitachi-hiuxmpp
config.guess:	exit ;;
config.guess:    Pyramid*:OSx*:*:* | MIS*:OSx*:*:* | MIS*:SMP_DC-OSx*:*:*)
config.guess:	exit ;;
config.guess:    NILE*:*:*:dcosx)
config.guess:	exit ;;
config.guess:    DRS?6000:unix:4.0:6*)
config.guess:	echo sparc-icl-nx6
config.guess:	exit ;;
config.guess:	    sparc) echo sparc-icl-nx7; exit ;;
config.guess:    s390x:SunOS:*:*)
config.guess:	exit ;;
config.guess:	exit ;;
config.guess:	exit ;;
config.guess:    i86pc:AuroraUX:5.*:* | i86xen:AuroraUX:5.*:*)
config.guess:	echo i386-pc-auroraux${UNAME_RELEASE}
config.guess:	exit ;;
config.guess:    i86pc:SunOS:5.*:* | i86xen:SunOS:5.*:*)
config.guess:		SUN_ARCH="x86_64"
config.guess:	exit ;;
config.guess:	# SunOS6.  Hard to guess exactly what SunOS6 will be like, but
config.guess:	exit ;;
config.guess:	exit ;;
config.guess:	exit ;;
config.guess:	test "x${UNAME_RELEASE}" = "x" && UNAME_RELEASE=3
config.guess:	exit ;;
config.guess:	echo sparc-auspex-sunos${UNAME_RELEASE}
config.guess:	exit ;;
config.guess:	exit ;;
config.guess:	exit ;;
config.guess:	exit ;;
config.guess:	exit ;;
config.guess:	exit ;;
config.guess:	exit ;;
config.guess:	exit ;;
config.guess:	exit ;;
config.guess:	exit ;;
config.guess:	echo mips-dec-ultrix${UNAME_RELEASE}
config.guess:	exit ;;
config.guess:	echo vax-dec-ultrix${UNAME_RELEASE}
config.guess:	exit ;;
config.guess:	echo clipper-intergraph-clix${UNAME_RELEASE}
config.guess:	exit ;;
config.guess:	  printf ("mips-mips-riscos%ssysv\n", argv[1]); exit (0);
config.guess:	  printf ("mips-mips-riscos%ssvr4\n", argv[1]); exit (0);
config.guess:	  printf ("mips-mips-riscos%sbsd\n", argv[1]); exit (0);
config.guess:	  exit (-1);
config.guess:	    { echo "$SYSTEM_NAME"; exit; }
config.guess:	exit ;;
config.guess:	echo powerpc-motorola-powermax
config.guess:	exit ;;
config.guess:	echo powerpc-harris-powermax
config.guess:	exit ;;
config.guess:	echo powerpc-harris-powermax
config.guess:	exit ;;
config.guess:	echo powerpc-harris-powerunix
config.guess:	exit ;;
config.guess:	echo m88k-harris-cxux7
config.guess:	exit ;;
config.guess:	exit ;;
config.guess:	exit ;;
config.guess:    AViiON:dgux:*:*)
config.guess:	    if [ ${TARGET_BINARY_INTERFACE}x = m88kdguxelfx ] || \
config.guess:	       [ ${TARGET_BINARY_INTERFACE}x = x ]
config.guess:		echo m88k-dg-dgux${UNAME_RELEASE}
config.guess:		echo m88k-dg-dguxbcs${UNAME_RELEASE}
config.guess:	    echo i586-dg-dgux${UNAME_RELEASE}
config.guess:	exit ;;
config.guess:	exit ;;
config.guess:	exit ;;
config.guess:    XD88*:*:*:*) # Tektronix XD88 system running UTekV (SVR3)
config.guess:	echo m88k-tektronix-sysv3
config.guess:	exit ;;
config.guess:    Tek43[0-9][0-9]:UTek:*:*) # Tektronix 4300 system running UTek (BSD)
config.guess:	echo m68k-tektronix-bsd
config.guess:	exit ;;
config.guess:	echo mips-sgi-irix`echo ${UNAME_RELEASE}|sed -e 's/-/_/g'`
config.guess:	exit ;;
config.guess:	echo romp-ibm-aix     # uname -m gives an 8 hex-code CPU id
config.guess:	exit ;;               # Note that: echo "'`uname -s`'" gives 'AIX '
config.guess:	echo i386-ibm-aix
config.guess:	exit ;;
config.guess:	if [ -x /usr/bin/oslevel ] ; then
config.guess:	echo ${UNAME_MACHINE}-ibm-aix${IBM_REV}
config.guess:	exit ;;
config.guess:				exit(1);
config.guess:			puts("powerpc-ibm-aix3.2.5");
config.guess:			exit(0);
config.guess:			echo rs6000-ibm-aix3.2.5
config.guess:		echo rs6000-ibm-aix3.2.4
config.guess:		echo rs6000-ibm-aix3.2
config.guess:	exit ;;
config.guess:	if [ -x /usr/bin/oslevel ] ; then
config.guess:	echo ${IBM_ARCH}-ibm-aix${IBM_REV}
config.guess:	exit ;;
config.guess:	echo rs6000-ibm-aix
config.guess:	exit ;;
config.guess:	exit ;;
config.guess:	exit ;;                             # report: romp-ibm BSD 4.3
config.guess:	echo rs6000-bull-bosx
config.guess:	exit ;;
config.guess:	exit ;;
config.guess:	exit ;;
config.guess:	exit ;;
config.guess:		if [ -x /usr/bin/getconf ]; then
config.guess:		    exit (0);
config.guess:	    # hppa2.0w-hp-hpux* has a 64-bit kernel and a compiler generating
config.guess:	    # 32-bit code.  hppa64-hp-hpux* has the same kernel and a compiler
config.guess:	    # => hppa2.0w-hp-hpux11.23
config.guess:	    # => hppa64-hp-hpux11.23
config.guess:	echo ${HP_ARCH}-hp-hpux${HPUX_REV}
config.guess:	exit ;;
config.guess:	echo ia64-hp-hpux${HPUX_REV}
config.guess:	exit ;;
config.guess:		  case CPU_PA_RISC1_0: puts ("hppa1.0-hitachi-hiuxwe2"); break;
config.guess:		  case CPU_PA_RISC1_1: puts ("hppa1.1-hitachi-hiuxwe2"); break;
config.guess:		  case CPU_PA_RISC2_0: puts ("hppa2.0-hitachi-hiuxwe2"); break;
config.guess:		  default: puts ("hppa-hitachi-hiuxwe2"); break;
config.guess:	    puts ("m68k-hitachi-hiuxwe2");
config.guess:	  else puts ("unknown-hitachi-hiuxwe2");
config.guess:	  exit (0);
config.guess:		{ echo "$SYSTEM_NAME"; exit; }
config.guess:	echo unknown-hitachi-hiuxwe2
config.guess:	exit ;;
config.guess:	exit ;;
config.guess:	exit ;;
config.guess:	echo hppa1.0-hp-mpeix
config.guess:	exit ;;
config.guess:	exit ;;
config.guess:	exit ;;
config.guess:	if [ -x /usr/sbin/sysversion ] ; then
config.guess:	exit ;;
config.guess:	exit ;;
config.guess:    C1*:ConvexOS:*:* | convex:ConvexOS:C1*:*)
config.guess:	echo c1-convex-bsd
config.guess:	exit ;;
config.guess:    C2*:ConvexOS:*:* | convex:ConvexOS:C2*:*)
config.guess:	then echo c32-convex-bsd
config.guess:	else echo c2-convex-bsd
config.guess:	exit ;;
config.guess:    C34*:ConvexOS:*:* | convex:ConvexOS:C34*:*)
config.guess:	echo c34-convex-bsd
config.guess:	exit ;;
config.guess:    C38*:ConvexOS:*:* | convex:ConvexOS:C38*:*)
config.guess:	echo c38-convex-bsd
config.guess:	exit ;;
config.guess:    C4*:ConvexOS:*:* | convex:ConvexOS:C4*:*)
config.guess:	echo c4-convex-bsd
config.guess:	exit ;;
config.guess:	exit ;;
config.guess:	      -e y/ABCDEFGHIJKLMNOPQRSTUVWXYZ/abcdefghijklmnopqrstuvwxyz/ \
config.guess:	exit ;;
config.guess:	exit ;;
config.guess:	exit ;;
config.guess:	exit ;;
config.guess:	exit ;;
config.guess:	FUJITSU_PROC=`uname -m | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz'`
config.guess:	FUJITSU_SYS=`uname -p | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz' | sed -e 's/\///'`
config.guess:	exit ;;
config.guess:	FUJITSU_SYS=`uname -p | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz' | sed -e 's/\///'`
config.guess:	FUJITSU_REL=`echo ${UNAME_RELEASE} | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz' | sed -e 's/ /_/'`
config.guess:	exit ;;
config.guess:	exit ;;
config.guess:	exit ;;
config.guess:	exit ;;
config.guess:		echo x86_64-unknown-freebsd`echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'` ;;
config.guess:	exit ;;
config.guess:	exit ;;
config.guess:	exit ;;
config.guess:	exit ;;
config.guess:	exit ;;
config.guess:	exit ;;
config.guess:	exit ;;
config.guess:    *:Interix*:*)
config.guess:	    x86)
config.guess:		echo i586-pc-interix${UNAME_RELEASE}
config.guess:		exit ;;
config.guess:		echo x86_64-unknown-interix${UNAME_RELEASE}
config.guess:		exit ;;
config.guess:		echo ia64-unknown-interix${UNAME_RELEASE}
config.guess:		exit ;;
config.guess:	exit ;;
config.guess:	echo x86_64-pc-mks
config.guess:	exit ;;
config.guess:	# How do we know it's Interix rather than the generic POSIX subsystem?
config.guess:	echo i586-pc-interix
config.guess:	exit ;;
config.guess:	exit ;;
config.guess:    amd64:CYGWIN*:*:* | x86_64:CYGWIN*:*:*)
config.guess:	echo x86_64-unknown-cygwin
config.guess:	exit ;;
config.guess:	exit ;;
config.guess:	exit ;;
config.guess:	exit ;;
config.guess:	exit ;;
config.guess:    i*86:Minix:*:*)
config.guess:	echo ${UNAME_MACHINE}-pc-minix
config.guess:	exit ;;
config.guess:    aarch64:Linux:*:*)
config.guess:	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
config.guess:	exit ;;
config.guess:    aarch64_be:Linux:*:*)
config.guess:	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
config.guess:	exit ;;
config.guess:    alpha:Linux:*:*)
config.guess:	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
config.guess:	exit ;;
config.guess:    arc:Linux:*:* | arceb:Linux:*:*)
config.guess:	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
config.guess:	exit ;;
config.guess:    arm*:Linux:*:*)
config.guess:	    echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
config.guess:		echo ${UNAME_MACHINE}-unknown-linux-${LIBC}eabi
config.guess:		echo ${UNAME_MACHINE}-unknown-linux-${LIBC}eabihf
config.guess:	exit ;;
config.guess:    avr32*:Linux:*:*)
config.guess:	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
config.guess:	exit ;;
config.guess:    cris:Linux:*:*)
config.guess:	echo ${UNAME_MACHINE}-axis-linux-${LIBC}
config.guess:	exit ;;
config.guess:    crisv32:Linux:*:*)
config.guess:	echo ${UNAME_MACHINE}-axis-linux-${LIBC}
config.guess:	exit ;;
config.guess:    frv:Linux:*:*)
config.guess:	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
config.guess:	exit ;;
config.guess:    hexagon:Linux:*:*)
config.guess:	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
config.guess:	exit ;;
config.guess:    i*86:Linux:*:*)
config.guess:	echo ${UNAME_MACHINE}-pc-linux-${LIBC}
config.guess:	exit ;;
config.guess:    ia64:Linux:*:*)
config.guess:	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
config.guess:	exit ;;
config.guess:    m32r*:Linux:*:*)
config.guess:	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
config.guess:	exit ;;
config.guess:    m68*:Linux:*:*)
config.guess:	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
config.guess:	exit ;;
config.guess:    mips:Linux:*:* | mips64:Linux:*:*)
config.guess:	test x"${CPU}" != x && { echo "${CPU}-unknown-linux-${LIBC}"; exit; }
config.guess:    or1k:Linux:*:*)
config.guess:	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
config.guess:	exit ;;
config.guess:    or32:Linux:*:*)
config.guess:	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
config.guess:	exit ;;
config.guess:    padre:Linux:*:*)
config.guess:	echo sparc-unknown-linux-${LIBC}
config.guess:	exit ;;
config.guess:    parisc64:Linux:*:* | hppa64:Linux:*:*)
config.guess:	echo hppa64-unknown-linux-${LIBC}
config.guess:	exit ;;
config.guess:    parisc:Linux:*:* | hppa:Linux:*:*)
config.guess:	  PA7*) echo hppa1.1-unknown-linux-${LIBC} ;;
config.guess:	  PA8*) echo hppa2.0-unknown-linux-${LIBC} ;;
config.guess:	  *)    echo hppa-unknown-linux-${LIBC} ;;
config.guess:	exit ;;
config.guess:    ppc64:Linux:*:*)
config.guess:	echo powerpc64-unknown-linux-${LIBC}
config.guess:	exit ;;
config.guess:    ppc:Linux:*:*)
config.guess:	echo powerpc-unknown-linux-${LIBC}
config.guess:	exit ;;
config.guess:    ppc64le:Linux:*:*)
config.guess:	echo powerpc64le-unknown-linux-${LIBC}
config.guess:	exit ;;
config.guess:    ppcle:Linux:*:*)
config.guess:	echo powerpcle-unknown-linux-${LIBC}
config.guess:	exit ;;
config.guess:    s390:Linux:*:* | s390x:Linux:*:*)
config.guess:	echo ${UNAME_MACHINE}-ibm-linux-${LIBC}
config.guess:	exit ;;
config.guess:    sh64*:Linux:*:*)
config.guess:	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
config.guess:	exit ;;
config.guess:    sh*:Linux:*:*)
config.guess:	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
config.guess:	exit ;;
config.guess:    sparc:Linux:*:* | sparc64:Linux:*:*)
config.guess:	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
config.guess:	exit ;;
config.guess:    tile*:Linux:*:*)
config.guess:	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
config.guess:	exit ;;
config.guess:    vax:Linux:*:*)
config.guess:	echo ${UNAME_MACHINE}-dec-linux-${LIBC}
config.guess:	exit ;;
config.guess:    x86_64:Linux:*:*)
config.guess:	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
config.guess:	exit ;;
config.guess:    xtensa*:Linux:*:*)
config.guess:	echo ${UNAME_MACHINE}-unknown-linux-${LIBC}
config.guess:	exit ;;
config.guess:    i*86:DYNIX/ptx:4*:*)
config.guess:	# ptx 4.0 does uname -s correctly, with DYNIX/ptx in there.
config.guess:	exit ;;
config.guess:	# Unixware is an offshoot of SVR4, but it has its own version
config.guess:	exit ;;
config.guess:	# If we were able to find `uname', then EMX Unix compatibility
config.guess:	echo ${UNAME_MACHINE}-pc-os2-emx
config.guess:	exit ;;
config.guess:	exit ;;
config.guess:	exit ;;
config.guess:	exit ;;
config.guess:    i*86:LynxOS:2.*:* | i*86:LynxOS:3.[01]*:* | i*86:LynxOS:4.[02]*:*)
config.guess:	echo i386-unknown-lynxos${UNAME_RELEASE}
config.guess:	exit ;;
config.guess:	exit ;;
config.guess:	exit ;;
config.guess:	# UnixWare 7.x, OpenUNIX and OpenServer 6.
config.guess:	exit ;;
config.guess:	exit ;;
config.guess:	exit ;;
config.guess:	exit ;;
config.guess:	exit ;;
config.guess:	exit ;;
config.guess:	exit ;;
config.guess:	exit ;;
config.guess:	echo m68k-diab-dnix
config.guess:	exit ;;
config.guess:	test -r /sysV68 && { echo 'm68k-motorola-sysv'; exit; } ;;
config.guess:	  && { echo i486-ncr-sysv4.3${OS_REL}; exit; }
config.guess:	  && { echo i586-ncr-sysv4.3${OS_REL}; exit; } ;;
config.guess:	  && { echo i486-ncr-sysv4; exit; } ;;
config.guess:	    && { echo i486-ncr-sysv4.3${OS_REL}; exit; }
config.guess:	    && { echo i586-ncr-sysv4.3${OS_REL}; exit; }
config.guess:	    && { echo i586-ncr-sysv4.3${OS_REL}; exit; } ;;
config.guess:    m68*:LynxOS:2.*:* | m68*:LynxOS:3.0*:*)
config.guess:	echo m68k-unknown-lynxos${UNAME_RELEASE}
config.guess:	exit ;;
config.guess:	exit ;;
config.guess:    TSUNAMI:LynxOS:2.*:*)
config.guess:	echo sparc-unknown-lynxos${UNAME_RELEASE}
config.guess:	exit ;;
config.guess:    rs6000:LynxOS:2.*:*)
config.guess:	echo rs6000-unknown-lynxos${UNAME_RELEASE}
config.guess:	exit ;;
config.guess:    PowerPC:LynxOS:2.*:* | PowerPC:LynxOS:3.[01]*:* | PowerPC:LynxOS:4.[02]*:*)
config.guess:	echo powerpc-unknown-lynxos${UNAME_RELEASE}
config.guess:	exit ;;
config.guess:	exit ;;
config.guess:	exit ;;
config.guess:	exit ;;
config.guess:	exit ;;
config.guess:	exit ;;
config.guess:	exit ;;
config.guess:	exit ;;
config.guess:	exit ;;
config.guess:	exit ;;
config.guess:	echo m68k-apple-aux${UNAME_RELEASE}
config.guess:	exit ;;
config.guess:	exit ;;
config.guess:	exit ;;
config.guess:    BeBox:BeOS:*:*)	# BeOS running on hardware made by Be, PPC only.
config.guess:	exit ;;
config.guess:	exit ;;
config.guess:	exit ;;
config.guess:	exit ;;
config.guess:    x86_64:Haiku:*:*)
config.guess:	echo x86_64-unknown-haiku
config.guess:	exit ;;
config.guess:	echo sx4-nec-superux${UNAME_RELEASE}
config.guess:	exit ;;
config.guess:	echo sx5-nec-superux${UNAME_RELEASE}
config.guess:	exit ;;
config.guess:	echo sx6-nec-superux${UNAME_RELEASE}
config.guess:	exit ;;
config.guess:	echo sx7-nec-superux${UNAME_RELEASE}
config.guess:	exit ;;
config.guess:	echo sx8-nec-superux${UNAME_RELEASE}
config.guess:	exit ;;
config.guess:	echo sx8r-nec-superux${UNAME_RELEASE}
config.guess:	exit ;;
config.guess:	exit ;;
config.guess:	exit ;;
config.guess:			i386) UNAME_PROCESSOR=x86_64 ;;
config.guess:	    # Avoid executing cc on OS X 10.9, as it ships with a stub
config.guess:	    UNAME_PROCESSOR=x86_64
config.guess:	exit ;;
config.guess:	if test "$UNAME_PROCESSOR" = "x86"; then
config.guess:	echo ${UNAME_PROCESSOR}-${UNAME_MACHINE}-nto-qnx${UNAME_RELEASE}
config.guess:	exit ;;
config.guess:	echo i386-pc-qnx
config.guess:	exit ;;
config.guess:	exit ;;
config.guess:	exit ;;
config.guess:	exit ;;
config.guess:	echo mips-compaq-nonstopux
config.guess:	exit ;;
config.guess:	exit ;;
config.guess:	exit ;;
config.guess:	# is converted to i386 for consistency with other x86
config.guess:	exit ;;
config.guess:	exit ;;
config.guess:	echo pdp10-unknown-tenex
config.guess:	exit ;;
config.guess:	exit ;;
config.guess:	echo pdp10-xkl-tops20
config.guess:	exit ;;
config.guess:	exit ;;
config.guess:	exit ;;
config.guess:	echo mips-sei-seiux${UNAME_RELEASE}
config.guess:	exit ;;
config.guess:	exit ;;
config.guess:	    A*) echo alpha-dec-vms ; exit ;;
config.guess:	    I*) echo ia64-dec-vms ; exit ;;
config.guess:	    V*) echo vax-dec-vms ; exit ;;
config.guess:	echo i386-pc-xenix
config.guess:	exit ;;
config.guess:	exit ;;
config.guess:	exit ;;
config.guess:	exit ;;
config.guess:    x86_64:VMkernel:*:*)
config.guess:	echo ${UNAME_MACHINE}-unknown-esx
config.guess:	exit ;;
config.guess:  printf ("mips-sony-bsd\n"); exit (0);
config.guess:	); exit (0);
config.guess:#if defined (__arm) && defined (__acorn) && defined (__unix)
config.guess:  printf ("arm-acorn-riscix\n"); exit (0);
config.guess:#if defined (hp300) && !defined (hpux)
config.guess:  printf ("m68k-hp-bsd\n"); exit (0);
config.guess:    printf ("%s-next-nextstep%d\n", __ARCHITECTURE__, version);
config.guess:    printf ("%s-next-openstep%d\n", __ARCHITECTURE__, version);
config.guess:  exit (0);
config.guess:  printf ("ns32k-encore-sysv\n"); exit (0);
config.guess:  printf ("ns32k-encore-mach\n"); exit (0);
config.guess:  printf ("ns32k-encore-bsd\n"); exit (0);
config.guess:  printf ("i386-pc-bsd\n"); exit (0);
config.guess:  printf ("i386-sequent-dynix\n"); exit (0);
config.guess:  printf ("ns32k-sequent-dynix\n"); exit (0);
config.guess:	printf ("i386-sequent-ptx2\n"); exit (0);
config.guess:	printf ("i386-sequent-ptx1\n"); exit (0);
config.guess:    printf ("i386-sequent-ptx\n"); exit (0);
config.guess:#if defined (vax)
config.guess:# if !defined (ultrix)
config.guess:      printf ("vax-dec-bsd4.3\n"); exit (0);
config.guess:      printf ("vax-dec-bsd4.3reno\n"); exit (0);
config.guess:      printf ("vax-dec-bsd\n"); exit (0);
config.guess:    printf ("vax-dec-bsd\n"); exit (0);
config.guess:    printf ("vax-dec-ultrix\n"); exit (0);
config.guess:  printf ("i860-alliant-bsd\n"); exit (0);
config.guess:  exit (1);
config.guess:	{ echo "$SYSTEM_NAME"; exit; }
config.guess:test -d /usr/apollo && { echo ${ISP}-apollo-${SYSTYPE}; exit; }
config.guess:# Convex versions that predate uname can use getsysinfo(1)
config.guess:if [ -x /usr/convex/getsysinfo ]
config.guess:	echo c1-convex-bsd
config.guess:	exit ;;
config.guess:	then echo c32-convex-bsd
config.guess:	else echo c2-convex-bsd
config.guess:	exit ;;
config.guess:	echo c34-convex-bsd
config.guess:	exit ;;
config.guess:	echo c38-convex-bsd
config.guess:	exit ;;
config.guess:	echo c4-convex-bsd
config.guess:	exit ;;
config.guess:/usr/convex/getsysinfo = `(/usr/convex/getsysinfo) 2>/dev/null`
config.guess:exit 1
config.h:/* Define to 1 if you have the `feenableexcept' function. */
config.h.in:/* Define to 1 if you have the `feenableexcept' function. */
config.log:  $ ./configure --prefix=/Users/ananyu/csci3081/Photoshop/libpng-1.6.16/ --enable-shared=no
config.log:uname -m = x86_64
config.log:uname -v = Darwin Kernel Version 13.4.0: Wed Dec 17 19:05:52 PST 2014; root:xnu-2422.115.10~1/RELEASE_X86_64
config.log:/usr/convex/getsysinfo = unknown
config.log:	 Darwin Kernel Version 13.4.0: Wed Dec 17 19:05:52 PST 2014; root:xnu-2422.115.10~1/RELEASE_X86_64
config.log:PATH: /usr/texbin
config.log:Target: x86_64-apple-darwin13.4.0
config.log:Thread model: posix
config.log:Configured with: --prefix=/Applications/Xcode.app/Contents/Developer/usr --with-gxx-include-dir=/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/c++/4.2.1
config.log:Configured with: --prefix=/Applications/Xcode.app/Contents/Developer/usr --with-gxx-include-dir=/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/c++/4.2.1
config.log:Target: x86_64-apple-darwin13.4.0
config.log:Thread model: posix
config.log:clang: error: argument to '-V' is missing (expected 1 value)
config.log:configure:3355: checking for suffix of executables
config.log:configure:3453: checking for suffix of object files
config.log:configure:4116: result: x86_64-apple-darwin13.4.0
config.log:configure:4149: result: x86_64-apple-darwin13.4.0
config.log:configure:4597: result: /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/ld
config.log:configure:4604: checking if the linker (/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/ld) is GNU ld
config.log:conftest.c:11:10: fatal error: 'ac_nonexistent.h' file not found
config.log:#include <ac_nonexistent.h>
config.log:| #include <ac_nonexistent.h>
config.log:conftest.c:11:10: fatal error: 'ac_nonexistent.h' file not found
config.log:#include <ac_nonexistent.h>
config.log:| #include <ac_nonexistent.h>
config.log:configure:5099: checking the maximum length of command line arguments
config.log:configure:5301: checking how to convert x86_64-apple-darwin13.4.0 file names to x86_64-apple-darwin13.4.0 format
config.log:configure:5348: checking how to convert x86_64-apple-darwin13.4.0 file names to toolchain format
config.log:configure:5375: checking for /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/ld option to reload object files
config.log:configure:7496: checking for -exported_symbols_list linker flag
config.log:configure:7516: gcc -o conftest -g -O2   -Wl,-exported_symbols_list,conftest.sym conftest.c  >&5
config.log:configure:8520: checking if gcc supports -fno-rtti -fno-exceptions
config.log:configure:8538: gcc -c -g -O2  -fno-rtti -fno-exceptions conftest.c >&5
config.log:configure:9139: checking whether the gcc linker (/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/ld) supports shared libraries
config.log:conftest.c:60:21: error: expected expression
config.log:configure:12686: checking for feenableexcept in -lm
config.log:Undefined symbols for architecture x86_64:
config.log:  "_feenableexcept", referenced from:
config.log:ld: symbol(s) not found for architecture x86_64
config.log:clang: error: linker command failed with exit code 1 (use -v to see invocation)
config.log:| extern "C"
config.log:| char feenableexcept ();
config.log:| return feenableexcept ();
config.log:configure:12733: checking for feenableexcept
config.log:Undefined symbols for architecture x86_64:
config.log:  "_feenableexcept", referenced from:
config.log:ld: symbol(s) not found for architecture x86_64
config.log:clang: error: linker command failed with exit code 1 (use -v to see invocation)
config.log:| /* Define feenableexcept to an innocuous variant, in case <limits.h> declares feenableexcept.
config.log:|    For example, HP-UX 11i <limits.h> declares gettimeofday.  */
config.log:| #define feenableexcept innocuous_feenableexcept
config.log:|     which can conflict with char feenableexcept (); below.
config.log:|     <limits.h> exists even on freestanding compilers.  */
config.log:| #undef feenableexcept
config.log:| extern "C"
config.log:| char feenableexcept ();
config.log:| #if defined __stub_feenableexcept || defined __stub___feenableexcept
config.log:| return feenableexcept ();
config.log:configure:12983: Extra options for compiler: 
config.log:This file was extended by libpng config.status 1.6.16, which was
config.log:config.status:1348: executing depfiles commands
config.log:config.status:1348: executing libtool commands
config.log:ac_cv_build=x86_64-apple-darwin13.4.0
config.log:ac_cv_func_feenableexcept=no
config.log:ac_cv_host=x86_64-apple-darwin13.4.0
config.log:ac_cv_lib_m_feenableexcept=no
config.log:ac_cv_objext=o
config.log:lt_cv_ld_exported_symbols_list=yes
config.log:lt_cv_path_LD=/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/ld
config.log:lt_cv_prog_compiler_rtti_exceptions=yes
config.log:lt_cv_sys_global_symbol_to_c_name_address_lib_prefix='sed -n -e '\''s/^: \([^ ]*\)[ ]*$/  {\"\1\", (void *) 0},/p'\'' -e '\''s/^[BCDEGRST]* \([^ ]*\) \(lib[^ ]*\)$/  {"\2", (void *) \&\2},/p'\'' -e '\''s/^[BCDEGRST]* \([^ ]*\) \([^ ]*\)$/  {"lib\2", (void *) \&\2},/p'\'''
config.log:lt_cv_sys_global_symbol_to_cdecl='sed -n -e '\''s/^T .* \(.*\)$/extern int \1();/p'\'' -e '\''s/^[BCDEGRST]* .* \(.*\)$/extern char \1;/p'\'''
config.log:lt_cv_sys_max_cmd_len=196608
config.log:LD='/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/ld'
config.log:am__untar='$${TAR-tar} xf -'
config.log:bindir='${exec_prefix}/bin'
config.log:build='x86_64-apple-darwin13.4.0'
config.log:build_cpu='x86_64'
config.log:datarootdir='${prefix}/share'
config.log:exec_prefix='${prefix}'
config.log:host='x86_64-apple-darwin13.4.0'
config.log:host_cpu='x86_64'
config.log:includedir='${prefix}/include'
config.log:libdir='${exec_prefix}/lib'
config.log:libexecdir='${exec_prefix}/libexec'
config.log:localstatedir='${prefix}/var'
config.log:prefix='/Users/ananyu/csci3081/Photoshop/libpng-1.6.16'
config.log:program_transform_name='s,x,x,'
config.log:sbindir='${exec_prefix}/sbin'
config.log:sharedstatedir='${prefix}/com'
config.log:sysconfdir='${prefix}/etc'
config.log:configure: exit 0
config.status:# configure, is in config.log if it exists.
config.status:export SHELL
config.status:DUALCASE=1; export DUALCASE # for MKS sh
config.status:  *posix*) :
config.status:    set -o posix ;; #(
config.status:export as_nl
config.status:# Prefer a ksh shell builtin over an external printf program on Solaris,
config.status:    as_echo_body='eval expr "X$1" : "X\\(.*\\)"'
config.status:	expr "X$arg" : "X\\(.*\\)$as_nl";
config.status:	arg=`expr "X$arg" : ".*$as_nl\\(.*\\)"`;;
config.status:      expr "X$arg" : "X\\(.*\\)" | tr -d "$as_nl"
config.status:    export as_echo_n_body
config.status:  export as_echo_body
config.status:if test "x$as_myself" = x; then
config.status:  exit 1
config.status:# pre-3.0 UWIN ksh).  But do not cause bugs in bash 2.01; the "|| exit 1"
config.status:do eval test x\${$as_var+set} = xset \
config.status:  && ( (unset $as_var) || exit 1) >/dev/null 2>&1 && unset $as_var || :
config.status:export LC_ALL
config.status:export LANGUAGE
config.status:# provided, also output the error to LOG_FD, referencing LINENO. Then exit the
config.status:  as_fn_exit $as_status
config.status:# as_fn_exit STATUS
config.status:# Exit the shell with STATUS, even in a "trap 0" or "set -e" context.
config.status:as_fn_exit ()
config.status:  exit $1
config.status:} # as_fn_exit
config.status:# Append the text in VALUE to the end of the definition contained in VAR. Take
config.status:if (eval "as_var=1; as_var+=2; test x\$as_var = x12") 2>/dev/null; then :
config.status:# must be portable across $(()) and expr.
config.status:    as_val=`expr "$@" || test $? -eq 1`
config.status:if expr a : '\(a\)' >/dev/null 2>&1 &&
config.status:   test "X`expr 00001 : '.*\(...\)'`" = X001; then
config.status:  as_expr=expr
config.status:  as_expr=false
config.status:$as_expr X/"$0" : '.*/\([^/][^/]*\)/*$' \| \
config.status:as_cr_letters='abcdefghijklmnopqrstuvwxyz'
config.status:case `echo -n x` in #(((((
config.status:  case `echo 'xy\c'` in
config.status:  xy)  ECHO_C='\c';;
config.status:rm -f conf$$ conf$$.exe conf$$.file
config.status:    # 2) DJGPP < 2.04 has no symlinks; `ln -s' creates a wrapper executable.
config.status:    ln -s conf$$.file conf$$.dir 2>/dev/null && test ! -f conf$$.exe ||
config.status:rm -f conf$$ conf$$.exe conf$$.dir/conf$$.file conf$$.file
config.status:$as_expr X"$as_dir" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
config.status:# as_fn_executable_p FILE
config.status:# Test if FILE is an executable regular file.
config.status:as_fn_executable_p ()
config.status:  test -f "$1" && test -x "$1"
config.status:} # as_fn_executable_p
config.status:as_test_x='test -x'
config.status:as_executable_p=as_fn_executable_p
config.status:# Sed expression to map a string onto a valid CPP name.
config.status:# Sed expression to map a string onto a valid variable name.
config.status:exec 6>&1
config.status:This file was extended by libpng $as_me 1.6.16, which was
config.status:  -h, --help       print this help, then exit
config.status:  -V, --version    print version number and configuration settings, then exit
config.status:      --config     print configuration, then exit
config.status:ac_cs_config="'--prefix=/Users/ananyu/csci3081/Photoshop/libpng-1.6.16/' '--enable-shared=no'"
config.status:    ac_option=`expr "X$1" : 'X\([^=]*\)='`
config.status:    ac_optarg=`expr "X$1" : 'X[^=]*=\(.*\)'`
config.status:    ac_option=`expr "X$1" : 'X\([^=]*\)='`
config.status:    $as_echo "$ac_cs_version"; exit ;;
config.status:    $as_echo "$ac_cs_config"; exit ;;
config.status:    $as_echo "$ac_cs_usage"; exit ;;
config.status:ac_configure_extra_args=
config.status:  exec 6>/dev/null
config.status:  ac_configure_extra_args="$ac_configure_extra_args --silent"
config.status:  set X /bin/sh './configure'  '--prefix=/Users/ananyu/csci3081/Photoshop/libpng-1.6.16/' '--enable-shared=no' $ac_configure_extra_args --no-create --no-recursion
config.status:  export CONFIG_SHELL
config.status:  exec "$@"
config.status:exec 5>>config.log
config.status:  sed 'h;s/./-/g;s/^.../## /;s/...$/ ##/;p;x;p;x' <<_ASBOX
config.status:AMDEP_TRUE="" ac_aux_dir="."
config.status:LD='/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/ld'
config.status:host='x86_64-apple-darwin13.4.0'
config.status:build='x86_64-apple-darwin13.4.0'
config.status:max_cmd_len='196608'
config.status:ac_objext='o'
config.status:exeext=''
config.status:lock_old_archive_extraction='yes'
config.status:lt_cv_sys_global_symbol_to_cdecl='sed -n -e '\''s/^T .* \(.*\)$/extern int \1();/p'\'' -e '\''s/^[BCDEGRST]* .* \(.*\)$/extern char \1;/p'\'''
config.status:lt_cv_sys_global_symbol_to_c_name_address_lib_prefix='sed -n -e '\''s/^: \([^ ]*\)[ ]*$/  {\"\1\", (void *) 0},/p'\'' -e '\''s/^[BCDEGRST]* \([^ ]*\) \(lib[^ ]*\)$/  {"\2", (void *) \&\2},/p'\'' -e '\''s/^[BCDEGRST]* \([^ ]*\) \([^ ]*\)$/  {"lib\2", (void *) \&\2},/p'\'''
config.status:lt_prog_compiler_no_builtin_flag=' -fno-builtin -fno-rtti -fno-exceptions'
config.status:libext='a'
config.status:shrext_cmds='`test .$module = .yes && echo .so || echo .dylib`'
config.status:extract_expsyms_cmds=''
config.status:export_dynamic_flag_spec=''
config.status:old_archive_from_expsyms_cmds=''
config.status:archive_expsym_cmds='sed '\''s,^,_,'\'' < $export_symbols > $output_objdir/${libname}-symbols.expsym~$CC -dynamiclib $allow_undefined_flag -o $lib $libobjs $deplibs $compiler_flags -install_name $rpath/$soname $verstring $single_module ${wl}-exported_symbols_list,$output_objdir/${libname}-symbols.expsym'
config.status:module_expsym_cmds='sed -e '\''s,^,_,'\'' < $export_symbols > $output_objdir/${libname}-symbols.expsym~$CC $allow_undefined_flag -o $lib -bundle $libobjs $deplibs $compiler_flags ${wl}-exported_symbols_list,$output_objdir/${libname}-symbols.expsym'
config.status:always_export_symbols='no'
config.status:export_symbols_cmds='$NM $libobjs $convenience | $global_symbol_pipe | $SED '\''s/.* //'\'' | sort | uniq > $export_symbols'
config.status:exclude_expsyms='_GLOBAL_OFFSET_TABLE_|_GLOBAL__F[ID]_.*'
config.status:include_expsyms=''
config.status:need_lib_prefix='no'
config.status:library_names_spec='${libname}${release}${major}$shared_ext ${libname}$shared_ext'
config.status:soname_spec='${libname}${release}${major}$shared_ext'
config.status:sys_lib_search_path_spec='/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/6.0  /usr/local/lib'
config.status:striplib='strip -x'
config.status:for var in SED GREP EGREP FGREP SHELL ECHO LD AS DLLTOOL OBJDUMP PATH_SEPARATOR NM LN_S lt_SP2NL lt_NL2SP reload_flag deplibs_check_method file_magic_cmd file_magic_glob want_nocaseglob sharedlib_from_linklib_cmd AR AR_FLAGS archiver_list_spec STRIP RANLIB CC CFLAGS compiler lt_cv_sys_global_symbol_pipe lt_cv_sys_global_symbol_to_cdecl lt_cv_sys_global_symbol_to_c_name_address lt_cv_sys_global_symbol_to_c_name_address_lib_prefix nm_file_list_spec lt_prog_compiler_no_builtin_flag lt_prog_compiler_pic lt_prog_compiler_wl lt_prog_compiler_static lt_cv_prog_compiler_c_o need_locks MANIFEST_TOOL DSYMUTIL NMEDIT LIPO OTOOL OTOOL64 shrext_cmds export_dynamic_flag_spec whole_archive_flag_spec compiler_needs_object with_gnu_ld allow_undefined_flag no_undefined_flag hardcode_libdir_flag_spec hardcode_libdir_separator exclude_expsyms include_expsyms file_list_spec variables_saved_for_relink libname_spec library_names_spec soname_spec install_override_mode finish_eval old_striplib striplib; do
config.status:for var in reload_cmds old_postinstall_cmds old_postuninstall_cmds old_archive_cmds extract_expsyms_cmds old_archive_from_new_cmds old_archive_from_expsyms_cmds archive_cmds archive_expsym_cmds module_cmds module_expsym_cmds export_symbols_cmds prelink_cmds postlink_cmds postinstall_cmds postuninstall_cmds finish_cmds sys_lib_search_path_spec sys_lib_dlsearch_path_spec; do
config.status:ac_aux_dir='.'
config.status:xsi_shell='yes'
config.status:# We use the long form for the default assignment because of an extremely
config.status:  trap 'exit_status=$?
config.status:  { test ! -d "$ac_tmp" || rm -fr "$ac_tmp"; } && exit $exit_status
config.status:  trap 'as_fn_exit 1' 1 2 13 15
config.status:if test "x$ac_cr" = x; then
config.status:S["LD"]="/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/ld"
config.status:S["host_cpu"]="x86_64"
config.status:S["host"]="x86_64-apple-darwin13.4.0"
config.status:S["build_cpu"]="x86_64"
config.status:S["build"]="x86_64-apple-darwin13.4.0"
config.status:S["am__untar"]="$${TAR-tar} xf -"
config.status:S["libdir"]="${exec_prefix}/lib"
config.status:S["includedir"]="${prefix}/include"
config.status:S["localstatedir"]="${prefix}/var"
config.status:S["sharedstatedir"]="${prefix}/com"
config.status:S["sysconfdir"]="${prefix}/etc"
config.status:S["datarootdir"]="${prefix}/share"
config.status:S["libexecdir"]="${exec_prefix}/libexec"
config.status:S["sbindir"]="${exec_prefix}/sbin"
config.status:S["bindir"]="${exec_prefix}/bin"
config.status:S["program_transform_name"]="s,x,x,"
config.status:S["prefix"]="/Users/ananyu/csci3081/Photoshop/libpng-1.6.16"
config.status:S["exec_prefix"]="${prefix}"
config.status:/^[\t ]*#[\t ]*(define|undef)[\t ]+[_abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ][_abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789]*([\t (]|$)/ {
config.status:  prefix = substr(line, 1, index(line, defundef) - 1)
config.status:    print prefix "define", macro P[macro] D[macro]
config.status:    next
config.status:    # Replace #undef with comments.  This is necessary, for example,
config.status:      print "/*", prefix defundef, macro, "*/"
config.status:      next
config.status:  set x $ac_tag
config.status:    if test x"$ac_file" != x-; then
config.status:$as_expr X"$ac_file" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
config.status:.) ac_dir_suffix= ac_top_builddir_sub=. ac_top_build_prefix= ;;
config.status:  ac_dir_suffix=/`$as_echo "$ac_dir" | sed 's|^\.[\\/]||'`
config.status:  # A ".." for each directory in $ac_dir_suffix.
config.status:  ac_top_builddir_sub=`$as_echo "$ac_dir_suffix" | sed 's|/[^\\/]*|/..|g;s|/||'`
config.status:  "") ac_top_builddir_sub=. ac_top_build_prefix= ;;
config.status:  *)  ac_top_build_prefix=$ac_top_builddir_sub/ ;;
config.status:ac_abs_builddir=$ac_pwd$ac_dir_suffix
config.status:ac_top_builddir=$ac_top_build_prefix
config.status:    ac_srcdir=$srcdir$ac_dir_suffix;
config.status:    ac_srcdir=$ac_top_build_prefix$srcdir$ac_dir_suffix
config.status:    ac_top_srcdir=$ac_top_build_prefix$srcdir
config.status:ac_abs_srcdir=$ac_abs_top_srcdir$ac_dir_suffix
config.status:  *) ac_INSTALL=$ac_top_build_prefix$INSTALL ;;
config.status:  */*) ac_MKDIR_P=$ac_top_build_prefix$MKDIR_P ;;
config.status:# If the template does not know about datarootdir, expand it.
config.status:  s&\${datarootdir}&${prefix}/share&g' ;;
config.status:ac_sed_extra="/^[	 ]*VPATH[	 ]*=[	 ]*/{
config.status:x
config.status:s&@top_build_prefix@&$ac_top_build_prefix&;t t
config.status:eval sed \"\$ac_sed_extra\" "$ac_file_inputs" | $AWK -f "$ac_tmp/subs.awk" \
config.status:  if test x"$ac_file" != x-; then
config.status:# Compute "$ac_file"'s index in $config_headers.
config.status:      _am_stamp_count=`expr $_am_stamp_count + 1` ;;
config.status:$as_expr X"$_am_arg" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
config.status:  :C)  { $as_echo "$as_me:${as_lineno-$LINENO}: executing $ac_file commands" >&5
config.status:$as_echo "$as_me: executing $ac_file commands" >&6;}
config.status:    "depfiles":C) test x"$AMDEP_TRUE" != x"" || {
config.status:  *\'*) eval set x "$CONFIG_FILES" ;;
config.status:  *)   set x $CONFIG_FILES ;;
config.status:$as_expr X"$mf" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
config.status:    # Extract the definition of DEPDIR, am__include, and am__quote
config.status:    # expansion.
config.status:      # Make sure the directory exists.
config.status:$as_expr X"$file" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
config.status:    trap "$RM \"$cfgfile\"; exit 1" 1 2 15
config.status:# As a special exception to the GNU General Public License,
config.status:# What is the maximum length of a command?
config.status:max_cmd_len=$max_cmd_len
config.status:# Object file suffix (normally "o").
config.status:objext=$ac_objext
config.status:# Executable file suffix (normally "").
config.status:exeext=$exeext
config.status:# Whether to use a lock for old archive extraction.
config.status:lock_old_archive_extraction=$lock_old_archive_extraction
config.status:# Transform the output of nm in a C name address pair when lib prefix is needed.
config.status:global_symbol_to_c_name_address_lib_prefix=$lt_lt_cv_sys_global_symbol_to_c_name_address_lib_prefix
config.status:# Used to examine libraries when file_magic_cmd begins with "file".
config.status:# Old archive suffix (normally "a").
config.status:libext=$libext
config.status:# Shared library suffix (normally ".so").
config.status:shrext_cmds=$lt_shrext_cmds
config.status:# The commands to extract the exported symbol list from a shared archive.
config.status:extract_expsyms_cmds=$lt_extract_expsyms_cmds
config.status:# Do we need the "lib" prefix for modules?
config.status:need_lib_prefix=$need_lib_prefix
config.status:# Format of library name prefix.
config.status:# As "finish_cmds", except a single script fragment to be evaled but
config.status:# Compiler flag to allow reflexive dlopens.
config.status:export_dynamic_flag_spec=$lt_export_dynamic_flag_spec
config.status:old_archive_from_expsyms_cmds=$lt_old_archive_from_expsyms_cmds
config.status:archive_expsym_cmds=$lt_archive_expsym_cmds
config.status:module_expsym_cmds=$lt_module_expsym_cmds
config.status:# This must work even if \$libdir does not exist
config.status:# Set to "yes" if using DIR/libNAME\${shared_ext} during linking hardcodes
config.status:# Set to "yes" if using DIR/libNAME\${shared_ext} during linking hardcodes
config.status:# into the library and all subsequent libraries and executables linked
config.status:# Set to "yes" if exported symbols are required.
config.status:always_export_symbols=$always_export_symbols
config.status:# The commands to list exported symbols.
config.status:export_symbols_cmds=$lt_export_symbols_cmds
config.status:exclude_expsyms=$lt_exclude_expsyms
config.status:# Symbols that must always be exported.
config.status:include_expsyms=$lt_include_expsyms
config.status:# How to hardcode a shared library path into an executable.
config.status:  aix3*)
config.status:  export COLLECT_NAMES
config.status:ltmain="$ac_aux_dir/ltmain.sh"
config.status:  # if finds mixed CR/LF and LF-only lines.  Since sed operates in
config.status:  # text mode, it properly converts lines to CR/LF.  This bash problem
config.status:  # is reportedly fixed, but why not run on old versions too?
config.status:     || (rm -f "$cfgfile"; exit 1)
config.status:  if test x"$xsi_shell" = xyes; then
config.status:} # Extended-shell func_dirname implementation' "$cfgfile" > $cfgfile.tmp \
config.status:} # Extended-shell func_basename implementation' "$cfgfile" > $cfgfile.tmp \
config.status:} # Extended-shell func_dirname_and_basename implementation' "$cfgfile" > $cfgfile.tmp \
config.status:} # Extended-shell func_stripname implementation' "$cfgfile" > $cfgfile.tmp \
config.status:} # Extended-shell func_split_long_opt implementation' "$cfgfile" > $cfgfile.tmp \
config.status:} # Extended-shell func_split_short_opt implementation' "$cfgfile" > $cfgfile.tmp \
config.status:\      *.lo) func_lo2o_result=${1%.lo}.${objext} ;;\
config.status:} # Extended-shell func_lo2o implementation' "$cfgfile" > $cfgfile.tmp \
config.status:  sed -e '/^func_xform ()$/,/^} # func_xform /c\
config.status:func_xform ()\
config.status:    func_xform_result=${1%.*}.lo\
config.status:} # Extended-shell func_xform implementation' "$cfgfile" > $cfgfile.tmp \
config.status:} # Extended-shell func_arith implementation' "$cfgfile" > $cfgfile.tmp \
config.status:} # Extended-shell func_len implementation' "$cfgfile" > $cfgfile.tmp \
config.status:if test x"$lt_shell_append" = xyes; then
config.status:} # Extended-shell func_append implementation' "$cfgfile" > $cfgfile.tmp \
config.status:} # Extended-shell func_append_quoted implementation' "$cfgfile" > $cfgfile.tmp \
config.status:if test x"$_lt_function_replace_fail" = x":"; then
config.status:  { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: Unable to substitute extended shell functions in $ofile" >&5
config.status:$as_echo "$as_me: WARNING: Unable to substitute extended shell functions in $ofile" >&2;}
config.status:  chmod +x "$ofile"
config.status:    "libpng-config":F) chmod +x libpng-config ;;
config.status:as_fn_exit 0
config.sub:# As a special exception to the GNU General Public License, if you
config.sub:# program.  This Exception is an additional permission under section 7
config.sub:# If it is invalid, we print an error message on stderr and exit with code 1.
config.sub:  -h, --help         print this help, then exit
config.sub:  -t, --time-stamp   print date of last modification, then exit
config.sub:  -v, --version      print version number, then exit
config.sub:       echo "$timestamp" ; exit ;;
config.sub:       echo "$version" ; exit ;;
config.sub:       echo "$usage"; exit ;;
config.sub:       exit 1 ;;
config.sub:       exit ;;
config.sub:    exit 1;;
config.sub:    exit 1;;
config.sub:  nto-qnx* | linux-gnu* | linux-android* | linux-dietlibc | linux-newlib* | \
config.sub:  linux-musl* | linux-uclibc* | uclinux-uclibc* | uclinux-gnu* | kfreebsd*-gnu* | \
config.sub:  storm-chaos* | os2-emx* | rtmk-nova*)
config.sub:  android-linux)
config.sub:    os=-linux-android
config.sub:	-unicom* | -ibm* | -next | -hp | -isi* | -apollo | -altos* | \
config.sub:	-c[123]* | -convex* | -sun | -crds | -omron* | -dg | -ultra | -tti* | \
config.sub:	-apple | -axis | -knuth | -cray | -microblaze*)
config.sub:		os=-vxworks
config.sub:	-hiux*)
config.sub:		os=-hiuxwe2
config.sub:	-clix*)
config.sub:	-lynx*178)
config.sub:		os=-lynxos178
config.sub:	-lynx*5)
config.sub:		os=-lynxos5
config.sub:	-lynx*)
config.sub:		os=-lynxos
config.sub:	-ptx*)
config.sub:	| c4x | c8051 | clipper \
config.sub:	| d10v | d30v | dlx | dsp16xx \
config.sub:	| hexagon \
config.sub:	| maxq | mb | microblaze | microblazeel | mcore | mep | metag \
config.sub:	| mipstx39 | mipstx39el \
config.sub:	| moxie \
config.sub:	| rl78 | rx \
config.sub:	| sparc | sparc64 | sparc64b | sparc64v | sparc86x | sparclet | sparclite \
config.sub:	| tahoe | tic4x | tic54x | tic55x | tic6x | tic80 | tron \
config.sub:	| x86 | xc16x | xstormy16 | xtensa \
config.sub:	c54x)
config.sub:		basic_machine=tic54x-unknown
config.sub:	c55x)
config.sub:		basic_machine=tic55x-unknown
config.sub:	c6x)
config.sub:		basic_machine=tic6x-unknown
config.sub:	m6811 | m68hc11 | m6812 | m68hc12 | m68hcs12x | nvptx | picochip)
config.sub:	strongarm | thumb | xscale)
config.sub:	xgate)
config.sub:	xscaleeb)
config.sub:	xscaleel)
config.sub:	i*86 | x86_64)
config.sub:		exit 1
config.sub:	| c[123]* | c30-* | [cjt]90-* | c4x-* \
config.sub:	| d10v-* | d30v-* | dlx-* \
config.sub:	| elxsi-* \
config.sub:	| f30[01]-* | f700-* | fido-* | fr30-* | frv-* | fx80-* \
config.sub:	| hexagon-* \
config.sub:	| m88110-* | m88k-* | maxq-* | mcore-* | metag-* \
config.sub:	| mipstx39-* | mipstx39el-* \
config.sub:	| mmix-* \
config.sub:	| rl78-* | romp-* | rs6000-* | rx-* \
config.sub:	| sparc-* | sparc64-* | sparc64b-* | sparc64v-* | sparc86x-* | sparclet-* \
config.sub:	| sparcv8-* | sparcv9-* | sparcv9b-* | sparcv9v-* | sv1-* | sx?-* \
config.sub:	| tic30-* | tic4x-* | tic54x-* | tic55x-* | tic6x-* | tic80-* \
config.sub:	| vax-* \
config.sub:	| x86-* | x86_64-* | xc16x-* | xps100-* \
config.sub:	| xstormy16-* | xtensa*-* \
config.sub:	xtensa*)
config.sub:	3b1 | 7300 | 7300-att | att-7300 | pc7300 | safari | unixpc)
config.sub:	alliant | fx80)
config.sub:		basic_machine=fx80-alliant
config.sub:		basic_machine=x86_64-pc
config.sub:		basic_machine=x86_64-`echo $basic_machine | sed 's/^[^-]*-//'`
config.sub:	amigaunix | amix)
config.sub:	aux)
config.sub:		os=-aux
config.sub:		os=-dynix
config.sub:		os=-linux
config.sub:		os=-linux
config.sub:	c54x-*)
config.sub:		basic_machine=tic54x-`echo $basic_machine | sed 's/^[^-]*-//'`
config.sub:	c55x-*)
config.sub:		basic_machine=tic55x-`echo $basic_machine | sed 's/^[^-]*-//'`
config.sub:	c6x-*)
config.sub:		basic_machine=tic6x-`echo $basic_machine | sed 's/^[^-]*-//'`
config.sub:	convex-c1)
config.sub:		basic_machine=c1-convex
config.sub:	convex-c2)
config.sub:		basic_machine=c2-convex
config.sub:	convex-c32)
config.sub:		basic_machine=c32-convex
config.sub:	convex-c34)
config.sub:		basic_machine=c34-convex
config.sub:	convex-c38)
config.sub:		basic_machine=c38-convex
config.sub:	crisv32 | crisv32-* | etraxfs*)
config.sub:		basic_machine=crisv32-axis
config.sub:	cris | cris-* | etrax*)
config.sub:		basic_machine=cris-axis
config.sub:	crx)
config.sub:		basic_machine=crx-unknown
config.sub:	decstation | decstation-3100 | pmax | pmax-* | pmin | dec3100 | decstatn)
config.sub:	dpx20 | dpx20-*)
config.sub:		os=-bosx
config.sub:	dpx2* | dpx2*-bull)
config.sub:	elxsi)
config.sub:		basic_machine=elxsi-elxsi
config.sub:	encore | umax | mmax)
config.sub:	fx2800)
config.sub:	genix)
config.sub:	h3050r* | hiux*)
config.sub:		os=-hiuxwe2
config.sub:	h8300xray)
config.sub:		os=-xray
config.sub:	hp300hpux)
config.sub:		os=-hpux
config.sub:	hppa-next)
config.sub:		os=-nextstep3
config.sub:		    -irix*)
config.sub:			os=-irix4
config.sub:		os=-linux
config.sub:		os=-linux
config.sub:		basic_machine=microblaze-xilinx
config.sub:		basic_machine=x86_64-pc
config.sub:		os=-linux
config.sub:	next | m*-next )
config.sub:		basic_machine=m68k-next
config.sub:		    -nextstep* )
config.sub:		      os=-nextstep2
config.sub:		      os=-nextstep3
config.sub:		os=-cxux
config.sub:		os=-cxux
config.sub:	nonstopux)
config.sub:		os=-nonstopux
config.sub:		os=-hiuxwe2
config.sub:		os=-linux
config.sub:		os=-linux
config.sub:	pentium | p5 | k5 | k6 | nexgen | viac3)
config.sub:	pentiumpro | p6 | 6x86 | athlon | athlon_*)
config.sub:	pentium-* | p5-* | k5-* | k6-* | nexgen-* | viac3-*)
config.sub:	pentiumpro-* | p6-* | 6x86-* | athlon-*)
config.sub:		basic_machine=x86_64-pc
config.sub:	s390x | s390x-*)
config.sub:		basic_machine=s390x-ibm
config.sub:		os=-seiux
config.sub:		os=-vxworks
config.sub:		os=-dynix
config.sub:		os=-linux-gnu
config.sub:	tx39)
config.sub:		basic_machine=mipstx39-unknown
config.sub:	tx39el)
config.sub:		basic_machine=mipstx39el-unknown
config.sub:		basic_machine=pdp10-xkl
config.sub:		basic_machine=s390x-ibm
config.sub:	vaxv)
config.sub:		basic_machine=vax-dec
config.sub:		basic_machine=vax-dec
config.sub:	vpp*|vx|vx-*)
config.sub:	vxworks960)
config.sub:		os=-vxworks
config.sub:	vxworks68)
config.sub:		os=-vxworks
config.sub:	vxworks29k)
config.sub:		os=-vxworks
config.sub:	xbox)
config.sub:	xps | xps100)
config.sub:		basic_machine=xps100-honeywell
config.sub:	xscale-* | xscalee[bl]-*)
config.sub:		basic_machine=`echo $basic_machine | sed 's/^xscale/arm/'`
config.sub:	mmix)
config.sub:		basic_machine=mmix-knuth
config.sub:	vax)
config.sub:		basic_machine=vax-dec
config.sub:		exit 1
config.sub:if [ x"$os" != x"" ]
config.sub:	# -solaris* is a basic system type, with this one exception.
config.sub:	-auroraux)
config.sub:		os=-auroraux
config.sub:	-unixware*)
config.sub:	-gnu/linux*)
config.sub:		os=`echo $os | sed -e 's|gnu/linux|linux-gnu|'`
config.sub:	-gnu* | -bsd* | -mach* | -minix* | -genix* | -ultrix* | -irix* \
config.sub:	      | -*vms* | -sco* | -esix* | -isc* | -aix* | -cnk* | -sunos | -sunos[34]*\
config.sub:	      | -hpux* | -unos* | -osf* | -luna* | -dgux* | -auroraux* | -solaris* \
config.sub:	      | -nindy* | -vxsim* | -vxworks* | -ebmon* | -hms* | -mvs* \
config.sub:	      | -clix* | -riscos* | -uniplus* | -iris* | -rtu* | -xenix* \
config.sub:	      | -hiux* | -386bsd* | -knetbsd* | -mirbsd* | -netbsd* \
config.sub:	      | -ekkobsd* | -kfreebsd* | -freebsd* | -riscix* | -lynxos* \
config.sub:	      | -bosx* | -nextstep* | -cxux* | -aout* | -elf* | -oabi* \
config.sub:	      | -ptx* | -coff* | -ecoff* | -winnt* | -domain* | -vsta* \
config.sub:	      | -udi* | -eabi* | -lites* | -ieee* | -go32* | -aux* \
config.sub:	      | -mingw32* | -mingw64* | -linux-gnu* | -linux-android* \
config.sub:	      | -linux-newlib* | -linux-musl* | -linux-uclibc* \
config.sub:	      | -uxpv* | -beos* | -mpeix* | -udk* \
config.sub:	      | -interix* | -uwin* | -mks* | -rhapsody* | -darwin* | -opened* \
config.sub:	      | -openstep* | -oskit* | -conix* | -pw32* | -nonstopux* \
config.sub:	      | -storm-chaos* | -tops10* | -tenex* | -tops20* | -its* \
config.sub:	      | -os2* | -vos* | -palmos* | -uclinux* | -nucleus* \
config.sub:	      | -morphos* | -superux* | -rtmk* | -rtmk-nova* | -windiss* \
config.sub:	      | -powermax* | -dnix* | -nx6 | -nx7 | -sei* | -dragonfly* \
config.sub:	-qnx*)
config.sub:		    x86-* | i*86-*)
config.sub:	-nto-qnx*)
config.sub:		os=`echo $os | sed -e 's|nto|nto-qnx|'`
config.sub:	-sim | -es1800* | -hms* | -xray | -os68k* | -none* | -v88r* \
config.sub:	      | -windows* | -osx | -abug | -netware* | -os9* | -beos* | -haiku* \
config.sub:	      | -macos* | -mpw* | -magic* | -mmixware* | -mon960* | -lnews*)
config.sub:	-linux-dietlibc)
config.sub:		os=-linux-dietlibc
config.sub:	-linux*)
config.sub:		os=`echo $os | sed -e 's|linux|linux-gnu|'`
config.sub:	-dynix*)
config.sub:	-ctix* | -uts*)
config.sub:		os=-nextstep2
config.sub:	# Preserve the version number of sinix5.
config.sub:	-sinix5.*)
config.sub:		os=`echo $os | sed -e 's|sinix|sysv|'`
config.sub:	-sinix*)
config.sub:	-xenix)
config.sub:		os=-xenix
config.sub:		exit 1
config.sub:		os=-riscix1.2
config.sub:		os=-linux
config.sub:	c4x-* | tic4x-*)
config.sub:	hexagon-*)
config.sub:	tic54x-*)
config.sub:	tic55x-*)
config.sub:	tic6x-*)
config.sub:	*-dec | vax-*)
config.sub:		os=-ultrix4.2
config.sub:		os=-aix
config.sub:		os=-mmixware
config.sub:		os=-hpux
config.sub:		os=-hiux
config.sub:		os=-dgux
config.sub:	*-next )
config.sub:		os=-nextstep
config.sub:		os=-ptx
config.sub:		os=-genix
config.sub:	*-next)
config.sub:		os=-nextstep3
config.sub:		os=-irix
config.sub:		os=-uxpv
config.sub:			-riscix*)
config.sub:			-cnk*|-aix*)
config.sub:			-hpux*)
config.sub:			-mpeix*)
config.sub:			-hiux*)
config.sub:			-dgux*)
config.sub:			-genix*)
config.sub:			-ptx*)
config.sub:			-vxsim* | -vxworks* | -windiss*)
config.sub:			-aux*)
config.sub:exit
configure:DUALCASE=1; export DUALCASE # for MKS sh
configure:  *posix*) :
configure:    set -o posix ;; #(
configure:export as_nl
configure:# Prefer a ksh shell builtin over an external printf program on Solaris,
configure:    as_echo_body='eval expr "X$1" : "X\\(.*\\)"'
configure:	expr "X$arg" : "X\\(.*\\)$as_nl";
configure:	arg=`expr "X$arg" : ".*$as_nl\\(.*\\)"`;;
configure:      expr "X$arg" : "X\\(.*\\)" | tr -d "$as_nl"
configure:    export as_echo_n_body
configure:  export as_echo_body
configure:if test "x$as_myself" = x; then
configure:  exit 1
configure:# pre-3.0 UWIN ksh).  But do not cause bugs in bash 2.01; the "|| exit 1"
configure:do eval test x\${$as_var+set} = xset \
configure:  && ( (unset $as_var) || exit 1) >/dev/null 2>&1 && unset $as_var || :
configure:export LC_ALL
configure:export LANGUAGE
configure:  # into an infinite loop, continuously re-executing ourselves.
configure:  if test x"${_as_can_reexec}" != xno && test "x$CONFIG_SHELL" != x; then
configure:    _as_can_reexec=no; export _as_can_reexec;
configure:# works around shells that cannot unset nonexistent variables.
configure:# Preserve -v and -x to the replacement shell.
configure:  *v*x* | *x*v* ) as_opts=-vx ;;
configure:  *x* ) as_opts=-x ;;
configure:exec $CONFIG_SHELL $as_opts "$as_myself" ${1+"$@"}
configure:# out after a failed `exec'.
configure:$as_echo "$0: could not re-execute with $CONFIG_SHELL" >&2
configure:as_fn_exit 255
configure:          { _as_can_reexec=; unset _as_can_reexec;}
configure:if test "x$CONFIG_SHELL" = x; then
configure:  *posix*) :
configure:    set -o posix ;; #(
configure:  as_required="as_fn_return () { (exit \$1); }
configure:exitcode=0
configure:as_fn_success || { exitcode=1; echo as_fn_success failed.; }
configure:as_fn_failure && { exitcode=1; echo as_fn_failure succeeded.; }
configure:as_fn_ret_success || { exitcode=1; echo as_fn_ret_success failed.; }
configure:as_fn_ret_failure && { exitcode=1; echo as_fn_ret_failure succeeded.; }
configure:if ( set x; as_fn_ret_success y && test x = \"\$1\" ); then :
configure:  exitcode=1; echo positional parameters were not saved.
configure:test x\$exitcode = x0 || exit 1
configure:test -x / || exit 1"
configure:  eval 'test \"x\$as_lineno_1'\$as_run'\" != \"x\$as_lineno_2'\$as_run'\" &&
configure:  test \"x\`expr \$as_lineno_1'\$as_run' + 1\`\" = \"x\$as_lineno_2'\$as_run'\"' || exit 1
configure:test \$(( 1 + 1 )) = 2 || exit 1
configure:    PATH=/empty FPATH=/empty; export PATH FPATH
configure:      || test \"X\`print -r -- \$ECHO\`\" = \"X\$ECHO\" ) || exit 1"
configure:  if test x$as_have_required = xyes && (eval "$as_suggested") 2>/dev/null; then :
configure:	     # Try only shells that exist, to save several forks.
configure:	     if { test -f "$as_shell" || test -f "$as_shell.exe"; } &&
configure:$as_found || { if { test -f "$SHELL" || test -f "$SHELL.exe"; } &&
configure:      if test "x$CONFIG_SHELL" != x; then :
configure:  export CONFIG_SHELL
configure:# works around shells that cannot unset nonexistent variables.
configure:# Preserve -v and -x to the replacement shell.
configure:  *v*x* | *x*v* ) as_opts=-vx ;;
configure:  *x* ) as_opts=-x ;;
configure:exec $CONFIG_SHELL $as_opts "$as_myself" ${1+"$@"}
configure:# out after a failed `exec'.
configure:$as_echo "$0: could not re-execute with $CONFIG_SHELL" >&2
configure:exit 255
configure:    if test x$as_have_required = xno; then :
configure:  if test x${ZSH_VERSION+set} = xset ; then
configure:  exit 1
configure:export SHELL
configure:# as_fn_exit STATUS
configure:# Exit the shell with STATUS, even in a "trap 0" or "set -e" context.
configure:as_fn_exit ()
configure:  exit $1
configure:} # as_fn_exit
configure:$as_expr X"$as_dir" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
configure:# as_fn_executable_p FILE
configure:# Test if FILE is an executable regular file.
configure:as_fn_executable_p ()
configure:  test -f "$1" && test -x "$1"
configure:} # as_fn_executable_p
configure:# Append the text in VALUE to the end of the definition contained in VAR. Take
configure:if (eval "as_var=1; as_var+=2; test x\$as_var = x12") 2>/dev/null; then :
configure:# must be portable across $(()) and expr.
configure:    as_val=`expr "$@" || test $? -eq 1`
configure:# provided, also output the error to LOG_FD, referencing LINENO. Then exit the
configure:  as_fn_exit $as_status
configure:if expr a : '\(a\)' >/dev/null 2>&1 &&
configure:   test "X`expr 00001 : '.*\(...\)'`" = X001; then
configure:  as_expr=expr
configure:  as_expr=false
configure:$as_expr X/"$0" : '.*/\([^/][^/]*\)/*$' \| \
configure:as_cr_letters='abcdefghijklmnopqrstuvwxyz'
configure:  eval 'test "x$as_lineno_1'$as_run'" != "x$as_lineno_2'$as_run'" &&
configure:  test "x`expr $as_lineno_1'$as_run' + 1`" = "x$as_lineno_2'$as_run'"' || {
configure:  # Blame Lee E. McMahon (1931-1989) for sed's syntax.  :-)
configure:  chmod +x "$as_me.lineno" ||
configure:    { $as_echo "$as_me: error: cannot create $as_me.lineno; rerun with a POSIX shell" >&2; as_fn_exit 1; }
configure:  # If we had to re-execute with $CONFIG_SHELL, we're ensured to have
configure:  _as_can_reexec=no; export _as_can_reexec
configure:  # Don't try to exec as it changes $[0], causing all sort of problems
configure:  # Exit status is that of the last command.
configure:  exit
configure:case `echo -n x` in #(((((
configure:  case `echo 'xy\c'` in
configure:  xy)  ECHO_C='\c';;
configure:rm -f conf$$ conf$$.exe conf$$.file
configure:    # 2) DJGPP < 2.04 has no symlinks; `ln -s' creates a wrapper executable.
configure:    ln -s conf$$.file conf$$.dir 2>/dev/null && test ! -f conf$$.exe ||
configure:rm -f conf$$ conf$$.exe conf$$.dir/conf$$.file conf$$.file
configure:as_test_x='test -x'
configure:as_executable_p=as_fn_executable_p
configure:# Sed expression to map a string onto a valid CPP name.
configure:# Sed expression to map a string onto a valid variable name.
configure:test -n "$DJDIR" || exec 7<&0 </dev/null
configure:exec 6>&1
configure:# hostname on some systems (SVR3.2, old GNU/Linux) returns a bogus exit status,
configure:ac_default_prefix=/usr/local
configure:libexecdir
configure:prefix
configure:exec_prefix
configure:with_zlib_prefix
configure:with_libpng_prefix
configure:exec_prefix=NONE
configure:prefix=NONE
configure:program_prefix=NONE
configure:program_suffix=NONE
configure:program_transform_name=s,x,x,
configure:x_includes=NONE
configure:x_libraries=NONE
configure:# These are left unexpanded so users can "make install exec_prefix=/foo"
configure:# and all the variables that are supposed to be based on exec_prefix
configure:bindir='${exec_prefix}/bin'
configure:sbindir='${exec_prefix}/sbin'
configure:libexecdir='${exec_prefix}/libexec'
configure:datarootdir='${prefix}/share'
configure:sysconfdir='${prefix}/etc'
configure:sharedstatedir='${prefix}/com'
configure:localstatedir='${prefix}/var'
configure:includedir='${prefix}/include'
configure:libdir='${exec_prefix}/lib'
configure:  *=?*) ac_optarg=`expr "X$ac_option" : '[^=]*=\(.*\)'` ;;
configure:    ac_useropt=`expr "x$ac_option" : 'x-*disable-\(.*\)'`
configure:    expr "x$ac_useropt" : ".*[^-+._$as_cr_alnum]" >/dev/null &&
configure:    ac_useropt=`expr "x$ac_option" : 'x-*enable-\([^=]*\)'`
configure:    expr "x$ac_useropt" : ".*[^-+._$as_cr_alnum]" >/dev/null &&
configure:  -exec-prefix | --exec_prefix | --exec-prefix | --exec-prefi \
configure:  | --exec-pref | --exec-pre | --exec-pr | --exec-p | --exec- \
configure:  | --exec | --exe | --ex)
configure:    ac_prev=exec_prefix ;;
configure:  -exec-prefix=* | --exec_prefix=* | --exec-prefix=* | --exec-prefi=* \
configure:  | --exec-pref=* | --exec-pre=* | --exec-pr=* | --exec-p=* | --exec-=* \
configure:  | --exec=* | --exe=* | --ex=*)
configure:    exec_prefix=$ac_optarg ;;
configure:  -libexecdir | --libexecdir | --libexecdi | --libexecd | --libexec \
configure:  | --libexe | --libex | --libe)
configure:    ac_prev=libexecdir ;;
configure:  -libexecdir=* | --libexecdir=* | --libexecdi=* | --libexecd=* | --libexec=* \
configure:  | --libexe=* | --libex=* | --libe=*)
configure:    libexecdir=$ac_optarg ;;
configure:  -prefix | --prefix | --prefi | --pref | --pre | --pr | --p)
configure:    ac_prev=prefix ;;
configure:  -prefix=* | --prefix=* | --prefi=* | --pref=* | --pre=* | --pr=* | --p=*)
configure:    prefix=$ac_optarg ;;
configure:  -program-prefix | --program-prefix | --program-prefi | --program-pref \
configure:    ac_prev=program_prefix ;;
configure:  -program-prefix=* | --program-prefix=* | --program-prefi=* \
configure:    program_prefix=$ac_optarg ;;
configure:  -program-suffix | --program-suffix | --program-suffi | --program-suff \
configure:    ac_prev=program_suffix ;;
configure:  -program-suffix=* | --program-suffix=* | --program-suffi=* \
configure:    program_suffix=$ac_optarg ;;
configure:    ac_useropt=`expr "x$ac_option" : 'x-*with-\([^=]*\)'`
configure:    expr "x$ac_useropt" : ".*[^-+._$as_cr_alnum]" >/dev/null &&
configure:    ac_useropt=`expr "x$ac_option" : 'x-*without-\(.*\)'`
configure:    expr "x$ac_useropt" : ".*[^-+._$as_cr_alnum]" >/dev/null &&
configure:  --x)
configure:    # Obsolete; use --with-x.
configure:    with_x=yes ;;
configure:  -x-includes | --x-includes | --x-include | --x-includ | --x-inclu \
configure:  | --x-incl | --x-inc | --x-in | --x-i)
configure:    ac_prev=x_includes ;;
configure:  -x-includes=* | --x-includes=* | --x-include=* | --x-includ=* | --x-inclu=* \
configure:  | --x-incl=* | --x-inc=* | --x-in=* | --x-i=*)
configure:    x_includes=$ac_optarg ;;
configure:  -x-libraries | --x-libraries | --x-librarie | --x-librari \
configure:  | --x-librar | --x-libra | --x-libr | --x-lib | --x-li | --x-l)
configure:    ac_prev=x_libraries ;;
configure:  -x-libraries=* | --x-libraries=* | --x-librarie=* | --x-librari=* \
configure:  | --x-librar=* | --x-libra=* | --x-libr=* | --x-lib=* | --x-li=* | --x-l=*)
configure:    x_libraries=$ac_optarg ;;
configure:    ac_envvar=`expr "x$ac_option" : 'x\([^=]*\)='`
configure:    export $ac_envvar ;;
configure:    expr "x$ac_option" : ".*[^-._$as_cr_alnum]" >/dev/null &&
configure:for ac_var in	exec_prefix prefix bindir sbindir libexecdir datarootdir \
configure:      ac_val=`expr "X$ac_val" : 'X\(.*[^/]\)' \| "X$ac_val" : 'X\(.*\)'`
configure:    NONE | '' ) case $ac_var in *prefix ) continue;; esac;;
configure:  as_fn_error $? "expected an absolute directory name for --$ac_var: $ac_val"
configure:if test "x$host_alias" != x; then
configure:  if test "x$build_alias" = x; then
configure:  elif test "x$build_alias" != "x$host_alias"; then
configure:ac_tool_prefix=
configure:test -n "$host_alias" && ac_tool_prefix=$host_alias-
configure:test "$silent" = yes && exec 6>/dev/null
configure:$as_expr X"$as_myself" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
configure:# mess up M-x gdb in Emacs.
configure:*/) srcdir=`expr "X$srcdir" : 'X\(.*[^/]\)' \| "X$srcdir" : 'X\(.*\)'`;;
configure:  -h, --help              display this help and exit
configure:  -V, --version           display version information and exit
configure:  --prefix=PREFIX         install architecture-independent files in PREFIX
configure:                          [$ac_default_prefix]
configure:  --exec-prefix=EPREFIX   install architecture-dependent files in EPREFIX
configure:\`$ac_default_prefix/bin', \`$ac_default_prefix/lib' etc.  You can specify
configure:an installation prefix other than \`$ac_default_prefix' using \`--prefix',
configure:for instance \`--prefix=\$HOME'.
configure:  --bindir=DIR            user executables [EPREFIX/bin]
configure:  --sbindir=DIR           system admin executables [EPREFIX/sbin]
configure:  --libexecdir=DIR        program executables [EPREFIX/libexec]
configure:  --program-prefix=PREFIX            prepend PREFIX to installed program names
configure:  --program-suffix=SUFFIX            append SUFFIX to installed program names
configure:                          do not reject slow dependency extractors
configure:  --with-zlib-prefix    prefix that may have been used in installed zlib
configure:  --with-libpng-prefix  prefix libpng exported function (API) names with the
configure:  for ac_dir in : $ac_subdirs_all; do test "x$ac_dir" = x: && continue
configure:.) ac_dir_suffix= ac_top_builddir_sub=. ac_top_build_prefix= ;;
configure:  ac_dir_suffix=/`$as_echo "$ac_dir" | sed 's|^\.[\\/]||'`
configure:  # A ".." for each directory in $ac_dir_suffix.
configure:  ac_top_builddir_sub=`$as_echo "$ac_dir_suffix" | sed 's|/[^\\/]*|/..|g;s|/||'`
configure:  "") ac_top_builddir_sub=. ac_top_build_prefix= ;;
configure:  *)  ac_top_build_prefix=$ac_top_builddir_sub/ ;;
configure:ac_abs_builddir=$ac_pwd$ac_dir_suffix
configure:ac_top_builddir=$ac_top_build_prefix
configure:    ac_srcdir=$srcdir$ac_dir_suffix;
configure:    ac_srcdir=$ac_top_build_prefix$srcdir$ac_dir_suffix
configure:    ac_top_srcdir=$ac_top_build_prefix$srcdir
configure:ac_abs_srcdir=$ac_abs_top_srcdir$ac_dir_suffix
configure:test -n "$ac_init_help" && exit $ac_status
configure:  exit
configure:# Try to compile conftest.$ac_ext, and return whether this succeeded.
configure:  rm -f conftest.$ac_objext
configure:       } && test -s conftest.$ac_objext; then :
configure:sed 's/^/| /' conftest.$ac_ext >&5
configure:# Try to preprocess conftest.$ac_ext, and return whether this succeeded.
configure:  if { { ac_try="$ac_cpp conftest.$ac_ext"
configure:  (eval "$ac_cpp conftest.$ac_ext") 2>conftest.err
configure:sed 's/^/| /' conftest.$ac_ext >&5
configure:# Try to link conftest.$ac_ext, and return whether this succeeded.
configure:  rm -f conftest.$ac_objext conftest$ac_exeext
configure:       } && test -s conftest$ac_exeext && {
configure:	 test -x conftest$ac_exeext
configure:sed 's/^/| /' conftest.$ac_ext >&5
configure:  # interfere with the next link command; also delete a directory that is
configure:  # left behind by Apple's compiler.  We do this before executing the actions.
configure:# Tests whether HEADER exists and can be compiled using the include files in
configure:  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
configure:rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
configure:# Try to link conftest.$ac_ext, and return whether this succeeded. Assumes
configure:# that executables *can* be run.
configure:  test $ac_status = 0; } && { ac_try='./conftest$ac_exeext'
configure:  $as_echo "$as_me: program exited with status $ac_status" >&5
configure:sed 's/^/| /' conftest.$ac_ext >&5
configure:# Tests whether FUNC exists, setting the cache variable VAR accordingly
configure:  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
configure:   For example, HP-UX 11i <limits.h> declares gettimeofday.  */
configure:    <limits.h> exists even on freestanding compilers.  */
configure:extern "C"
configure:rm -f core conftest.err conftest.$ac_objext \
configure:    conftest$ac_exeext conftest.$ac_ext
configure:# Tests whether TYPE exists after having included INCLUDES, setting cache
configure:  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
configure:  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
configure:rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
configure:rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
configure:exec 5>>config.log
configure:/usr/convex/getsysinfo = `(/usr/convex/getsysinfo) 2>/dev/null || echo unknown`
configure:ac_must_keep_next=false
configure:      if test $ac_must_keep_next = true; then
configure:	ac_must_keep_next=false # Got value, back to normal.
configure:	  | -with-* | --with-* | -without-* | --without-* | --x)
configure:	  -* ) ac_must_keep_next=true ;;
configure:# When interrupted or exit'd, cleanup temporary files, and complete
configure:trap 'exit_status=$?
configure:    $as_echo "$as_me: exit $exit_status"
configure:    exit $exit_status
configure:  trap 'ac_signal='$ac_signal'; as_fn_exit 1' $ac_signal
configure:# confdefs.h avoids OS command line length limits that DEFS can exceed.
configure:# Prefer an explicitly selected file to automatically selected ones.
configure:elif test "x$prefix" != xNONE; then
configure:  ac_site_file1=$prefix/share/config.site
configure:  ac_site_file2=$prefix/etc/config.site
configure:  ac_site_file1=$ac_default_prefix/share/config.site
configure:  ac_site_file2=$ac_default_prefix/etc/config.site
configure:  test "x$ac_site_file" = xNONE && continue
configure:      if test "x$ac_old_val" != "x$ac_new_val"; then
configure:	ac_old_val_w=`echo x $ac_old_val`
configure:	ac_new_val_w=`echo x $ac_new_val`
configure:ac_ext=c
configure:ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
configure:ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
configure:# dist-xz requires automake 1.11 or later
configure:# 1.12.2 fixes a security issue in 1.11.2 and 1.12.1
configure:ac_aux_dir=
configure:    ac_aux_dir=$ac_dir
configure:    ac_install_sh="$ac_aux_dir/install-sh -c"
configure:    ac_aux_dir=$ac_dir
configure:    ac_install_sh="$ac_aux_dir/install.sh -c"
configure:    ac_aux_dir=$ac_dir
configure:    ac_install_sh="$ac_aux_dir/shtool install -c"
configure:if test -z "$ac_aux_dir"; then
configure:ac_config_guess="$SHELL $ac_aux_dir/config.guess"  # Please don't use this var.
configure:ac_config_sub="$SHELL $ac_aux_dir/config.sub"  # Please don't use this var.
configure:ac_configure="$SHELL $ac_aux_dir/configure"  # Please don't use this var.
configure:# AFS /usr/afsws/bin/install, which mishandles nonexistent args
configure:# SVR4 /usr/ucb/install, which tries to use the nonexistent group "staff"
configure:      for ac_exec_ext in '' $ac_executable_extensions; do
configure:	if as_fn_executable_p "$as_dir/$ac_prog$ac_exec_ext"; then
configure:	    grep dspmsg "$as_dir/$ac_prog$ac_exec_ext" >/dev/null 2>&1; then
configure:	    grep pwplus "$as_dir/$ac_prog$ac_exec_ext" >/dev/null 2>&1; then
configure:	    if "$as_dir/$ac_prog$ac_exec_ext" -c conftest.one conftest.two "`pwd`/conftest.dir" &&
configure:	      ac_cv_path_install="$as_dir/$ac_prog$ac_exec_ext -c"
configure:test "$program_prefix" != NONE &&
configure:  program_transform_name="s&^&$program_prefix&;$program_transform_name"
configure:test "$program_suffix" != NONE &&
configure:  program_transform_name="s&\$&$program_suffix&;$program_transform_name"
configure:# By default was `s,x,x', remove it if useless.
configure:ac_script='s/[\\$]/&&/g;s/;s,x,x,$//'
configure:# expand $ac_aux_dir to an absolute path
configure:am_aux_dir=`cd $ac_aux_dir && pwd`
configure:if test x"${MISSING+set}" != xset; then
configure:  case $am_aux_dir in
configure:    MISSING="\${SHELL} \"$am_aux_dir/missing\"" ;;
configure:    MISSING="\${SHELL} $am_aux_dir/missing" ;;
configure:# Use eval to expand $SHELL
configure:if test x"${install_sh}" != xset; then
configure:  case $am_aux_dir in
configure:    install_sh="\${SHELL} '$am_aux_dir/install-sh'" ;;
configure:    install_sh="\${SHELL} $am_aux_dir/install-sh"
configure:  if test -n "$ac_tool_prefix"; then
configure:  # Extract the first word of "${ac_tool_prefix}strip", so it can be a program name with args.
configure:set dummy ${ac_tool_prefix}strip; ac_word=$2
configure:    for ac_exec_ext in '' $ac_executable_extensions; do
configure:  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
configure:    ac_cv_prog_STRIP="${ac_tool_prefix}strip"
configure:    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
configure:  # Extract the first word of "strip", so it can be a program name with args.
configure:    for ac_exec_ext in '' $ac_executable_extensions; do
configure:  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
configure:    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
configure:  if test "x$ac_ct_STRIP" = x; then
configure:{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
configure:$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
configure:	 for ac_exec_ext in '' $ac_executable_extensions; do
configure:	   as_fn_executable_p "$as_dir/$ac_prog$ac_exec_ext" || continue
configure:	   case `"$as_dir/$ac_prog$ac_exec_ext" --version 2>&1` in #(
configure:	       ac_cv_path_mkdir=$as_dir/$ac_prog$ac_exec_ext
configure:  # Extract the first word of "$ac_prog", so it can be a program name with args.
configure:    for ac_exec_ext in '' $ac_executable_extensions; do
configure:  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
configure:    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
configure:set x ${MAKE-make}
configure:# For better backward compatibility.  To be removed once Automake 1.9.x
configure:_am_tools='gnutar  pax cpio none'
configure:am__tar='$${TAR-tar} chof - "$$tardir"' am__untar='$${TAR-tar} xf -'
configure:# by default if the 'rm' program in use doesn't match our expectations; the
configure:  if test x"$ACCEPT_INFERIOR_RM_PROGRAM" = x"yes"; then
configure:'rm' anyway, export the environment variable ACCEPT_INFERIOR_RM_PROGRAM
configure:ac_ext=c
configure:ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
configure:ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
configure:ac_ext=c
configure:ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
configure:ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
configure:if test -n "$ac_tool_prefix"; then
configure:  # Extract the first word of "${ac_tool_prefix}gcc", so it can be a program name with args.
configure:set dummy ${ac_tool_prefix}gcc; ac_word=$2
configure:    for ac_exec_ext in '' $ac_executable_extensions; do
configure:  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
configure:    ac_cv_prog_CC="${ac_tool_prefix}gcc"
configure:    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
configure:  # Extract the first word of "gcc", so it can be a program name with args.
configure:    for ac_exec_ext in '' $ac_executable_extensions; do
configure:  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
configure:    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
configure:  if test "x$ac_ct_CC" = x; then
configure:{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
configure:$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
configure:          if test -n "$ac_tool_prefix"; then
configure:    # Extract the first word of "${ac_tool_prefix}cc", so it can be a program name with args.
configure:set dummy ${ac_tool_prefix}cc; ac_word=$2
configure:    for ac_exec_ext in '' $ac_executable_extensions; do
configure:  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
configure:    ac_cv_prog_CC="${ac_tool_prefix}cc"
configure:    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
configure:  # Extract the first word of "cc", so it can be a program name with args.
configure:    for ac_exec_ext in '' $ac_executable_extensions; do
configure:  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
configure:    if test "$as_dir/$ac_word$ac_exec_ext" = "/usr/ucb/cc"; then
configure:    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
configure:  if test -n "$ac_tool_prefix"; then
configure:  for ac_prog in cl.exe
configure:    # Extract the first word of "$ac_tool_prefix$ac_prog", so it can be a program name with args.
configure:set dummy $ac_tool_prefix$ac_prog; ac_word=$2
configure:    for ac_exec_ext in '' $ac_executable_extensions; do
configure:  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
configure:    ac_cv_prog_CC="$ac_tool_prefix$ac_prog"
configure:    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
configure:  for ac_prog in cl.exe
configure:  # Extract the first word of "$ac_prog", so it can be a program name with args.
configure:    for ac_exec_ext in '' $ac_executable_extensions; do
configure:  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
configure:    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
configure:  if test "x$ac_ct_CC" = x; then
configure:{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
configure:$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
configure:cat confdefs.h - <<_ACEOF >conftest.$ac_ext
configure:ac_clean_files="$ac_clean_files a.out a.out.dSYM a.exe b.out"
configure:# Try to create an executable without -o first, disregard a.out.
configure:# of exeext.
configure:ac_files="a.out conftest.exe conftest a.exe a_out.exe b.out conftest.*"
configure:    *.$ac_ext | *.xcoff | *.tds | *.d | *.pdb | *.xSYM | *.bb | *.bbg | *.map | *.inf | *.dSYM | *.o | *.obj ) ;;
configure:  # Autoconf-2.13 could set the ac_cv_exeext variable to `no'.
configure:# in a Makefile.  We should not override ac_cv_exeext if it was cached,
configure:    *.$ac_ext | *.xcoff | *.tds | *.d | *.pdb | *.xSYM | *.bb | *.bbg | *.map | *.inf | *.dSYM | *.o | *.obj )
configure:	# We found the default executable, but exeext='' is most
configure:	if test "${ac_cv_exeext+set}" = set && test "$ac_cv_exeext" != no;
configure:	   ac_cv_exeext=`expr "$ac_file" : '[^.]*\(\..*\)'`
configure:	# We set ac_cv_exeext here because the later test for it is not
configure:	# safe: cross compilers may not add the suffix if given an `-o'
configure:test "$ac_cv_exeext" = no && ac_cv_exeext=
configure:sed 's/^/| /' conftest.$ac_ext >&5
configure:as_fn_error 77 "C compiler cannot create executables
configure:ac_exeext=$ac_cv_exeext
configure:rm -f -r a.out a.out.dSYM a.exe conftest$ac_cv_exeext b.out
configure:{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for suffix of executables" >&5
configure:$as_echo_n "checking for suffix of executables... " >&6; }
configure:  # If both `conftest.exe' and `conftest' are `present' (well, observable)
configure:# catch `conftest.exe'.  For instance with Cygwin, `ls conftest' will
configure:# work properly (i.e., refer to `conftest.exe'), while it won't with
configure:for ac_file in conftest.exe conftest conftest.*; do
configure:    *.$ac_ext | *.xcoff | *.tds | *.d | *.pdb | *.xSYM | *.bb | *.bbg | *.map | *.inf | *.dSYM | *.o | *.obj ) ;;
configure:    *.* ) ac_cv_exeext=`expr "$ac_file" : '[^.]*\(\..*\)'`
configure:as_fn_error $? "cannot compute suffix of executables: cannot compile and link
configure:rm -f conftest conftest$ac_cv_exeext
configure:{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_exeext" >&5
configure:$as_echo "$ac_cv_exeext" >&6; }
configure:rm -f conftest.$ac_ext
configure:EXEEXT=$ac_cv_exeext
configure:ac_exeext=$EXEEXT
configure:cat confdefs.h - <<_ACEOF >conftest.$ac_ext
configure:# Check that the compiler produces executables we can run.  If not, either
configure:  if { ac_try='./conftest$ac_cv_exeext'
configure:rm -f conftest.$ac_ext conftest$ac_cv_exeext conftest.out
configure:{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for suffix of object files" >&5
configure:$as_echo_n "checking for suffix of object files... " >&6; }
configure:if ${ac_cv_objext+:} false; then :
configure:  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
configure:    *.$ac_ext | *.xcoff | *.tds | *.d | *.pdb | *.xSYM | *.bb | *.bbg | *.map | *.inf | *.dSYM ) ;;
configure:    *) ac_cv_objext=`expr "$ac_file" : '.*\.\(.*\)'`
configure:sed 's/^/| /' conftest.$ac_ext >&5
configure:as_fn_error $? "cannot compute suffix of object files: cannot compile
configure:rm -f conftest.$ac_cv_objext conftest.$ac_ext
configure:{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_objext" >&5
configure:$as_echo "$ac_cv_objext" >&6; }
configure:OBJEXT=$ac_cv_objext
configure:ac_objext=$OBJEXT
configure:  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
configure:rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
configure:   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
configure:      cat confdefs.h - <<_ACEOF >conftest.$ac_ext
configure:	 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
configure:rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
configure:rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
configure:rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
configure:cat confdefs.h - <<_ACEOF >conftest.$ac_ext
configure:struct buf { int x; };
configure:   function prototypes and stuff, but not '\xHH' hex character constants.
configure:   as 'x'.  The following induces an error, until -std is added to get
configure:   proper ANSI mode.  Curiously '\x00'!='x' always comes out true, for an
configure:   array size at least.  It's necessary to write '\x00'==0 to get something
configure:int osf4_cc_array ['\x00' == 0 ? 1 : -1];
configure:#define FOO(x) 'x'
configure:int xlc6_cc_array[FOO(a) == 'x' ? 1 : -1];
configure:int test (int i, double x);
configure:for ac_arg in '' -qlanglvl=extc89 -qlanglvl=ansi -std \
configure:rm -f core conftest.err conftest.$ac_objext
configure:  test "x$ac_cv_prog_cc_c89" != "xno" && break
configure:rm -f conftest.$ac_ext
configure:case "x$ac_cv_prog_cc_c89" in
configure:  x)
configure:  xno)
configure:if test "x$ac_cv_prog_cc_c89" != xno; then :
configure:ac_ext=c
configure:ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
configure:ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
configure:ac_ext=c
configure:ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
configure:ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
configure:  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
configure:  # compilers refuse to overwrite an existing .o file with -o,
configure:    if { echo "$as_me:$LINENO: $CC -c conftest.$ac_ext -o conftest2.$ac_objext" >&5
configure:   ($CC -c conftest.$ac_ext -o conftest2.$ac_objext) >&5 2>&5
configure:   (exit $ac_status); } \
configure:         && test -f conftest2.$ac_objext; then
configure:   # A longer-term fix would be to have automake use am__CC in this case,
configure:   CC="$am_aux_dir/compile $CC"
configure:ac_ext=c
configure:ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
configure:ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
configure:if test "x$enable_dependency_tracking" != xno; then
configure:  am_depcomp="$ac_aux_dir/depcomp"
configure: if test "x$enable_dependency_tracking" != xno; then
configure:      # only be used when explicitly requested.
configure:      if test "x$enable_dependency_tracking" = xyes; then
configure:  test "x$enable_dependency_tracking" != xno \
configure:      # only be used when explicitly requested.
configure:      if test "x$enable_dependency_tracking" = xyes; then
configure:  test "x$enable_dependency_tracking" != xno \
configure:$SHELL "$ac_aux_dir/config.sub" sun4 >/dev/null 2>&1 ||
configure:  as_fn_error $? "cannot run $SHELL $ac_aux_dir/config.sub" "$LINENO" 5
configure:test "x$ac_build_alias" = x &&
configure:  ac_build_alias=`$SHELL "$ac_aux_dir/config.guess"`
configure:test "x$ac_build_alias" = x &&
configure:ac_cv_build=`$SHELL "$ac_aux_dir/config.sub" $ac_build_alias` ||
configure:  as_fn_error $? "$SHELL $ac_aux_dir/config.sub $ac_build_alias failed" "$LINENO" 5
configure:set x $ac_cv_build
configure:# except with old shells:
configure:  if test "x$host_alias" = x; then
configure:  ac_cv_host=`$SHELL "$ac_aux_dir/config.sub" $host_alias` ||
configure:    as_fn_error $? "$SHELL $ac_aux_dir/config.sub $host_alias failed" "$LINENO" 5
configure:set x $ac_cv_host
configure:# except with old shells:
configure:    for ac_exec_ext in '' $ac_executable_extensions; do
configure:      ac_path_SED="$as_dir/$ac_prog$ac_exec_ext"
configure:      as_fn_executable_p "$ac_path_SED" || continue
configure:    if test $ac_count -gt ${ac_path_SED_max-0}; then
configure:      ac_path_SED_max=$ac_count
configure:for as_dir in $PATH$PATH_SEPARATOR/usr/xpg4/bin
configure:    for ac_exec_ext in '' $ac_executable_extensions; do
configure:      ac_path_GREP="$as_dir/$ac_prog$ac_exec_ext"
configure:      as_fn_executable_p "$ac_path_GREP" || continue
configure:    if test $ac_count -gt ${ac_path_GREP_max-0}; then
configure:      ac_path_GREP_max=$ac_count
configure:    as_fn_error $? "no acceptable grep could be found in $PATH$PATH_SEPARATOR/usr/xpg4/bin" "$LINENO" 5
configure:for as_dir in $PATH$PATH_SEPARATOR/usr/xpg4/bin
configure:    for ac_exec_ext in '' $ac_executable_extensions; do
configure:      ac_path_EGREP="$as_dir/$ac_prog$ac_exec_ext"
configure:      as_fn_executable_p "$ac_path_EGREP" || continue
configure:    if test $ac_count -gt ${ac_path_EGREP_max-0}; then
configure:      ac_path_EGREP_max=$ac_count
configure:    as_fn_error $? "no acceptable egrep could be found in $PATH$PATH_SEPARATOR/usr/xpg4/bin" "$LINENO" 5
configure:for as_dir in $PATH$PATH_SEPARATOR/usr/xpg4/bin
configure:    for ac_exec_ext in '' $ac_executable_extensions; do
configure:      ac_path_FGREP="$as_dir/$ac_prog$ac_exec_ext"
configure:      as_fn_executable_p "$ac_path_FGREP" || continue
configure:    if test $ac_count -gt ${ac_path_FGREP_max-0}; then
configure:      ac_path_FGREP_max=$ac_count
configure:    as_fn_error $? "no acceptable fgrep could be found in $PATH$PATH_SEPARATOR/usr/xpg4/bin" "$LINENO" 5
configure:    if test -f "$ac_dir/$ac_prog" || test -f "$ac_dir/$ac_prog$ac_exeext"; then
configure:ac_ext=c
configure:ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
configure:ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
configure:      # Double quotes because CPP needs to be expanded
configure:  # <limits.h> exists even on freestanding compilers.
configure:  # not just through cpp. "Syntax error" is here to catch this case.
configure:  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
configure:		     Syntax error
configure:rm -f conftest.err conftest.i conftest.$ac_ext
configure:  # OK, works on sane cases.  Now check whether nonexistent headers
configure:  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
configure:#include <ac_nonexistent.h>
configure:rm -f conftest.err conftest.i conftest.$ac_ext
configure:rm -f conftest.i conftest.err conftest.$ac_ext
configure:  # <limits.h> exists even on freestanding compilers.
configure:  # not just through cpp. "Syntax error" is here to catch this case.
configure:  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
configure:		     Syntax error
configure:rm -f conftest.err conftest.i conftest.$ac_ext
configure:  # OK, works on sane cases.  Now check whether nonexistent headers
configure:  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
configure:#include <ac_nonexistent.h>
configure:rm -f conftest.err conftest.i conftest.$ac_ext
configure:rm -f conftest.i conftest.err conftest.$ac_ext
configure:ac_ext=c
configure:ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
configure:ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
configure:  # Extract the first word of "$ac_prog", so it can be a program name with args.
configure:    for ac_exec_ext in '' $ac_executable_extensions; do
configure:  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
configure:    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
configure:set x ${MAKE-make}
configure:ltmain="$ac_aux_dir/ltmain.sh"
configure:# Sed substitution to delay expansion of an escaped shell variable in a
configure:# Sed substitution to delay expansion of an escaped single quote.
configure:# Sed substitution to avoid accidental globbing in evaled expressions
configure:  lt_nm_to_check="${ac_tool_prefix}nm"
configure:  if test -n "$ac_tool_prefix" && test "$build" = "$host"; then
configure:      if test -f "$tmp_nm" || test -f "$tmp_nm$ac_exeext" ; then
configure:    if test -n "$ac_tool_prefix"; then
configure:    # Extract the first word of "$ac_tool_prefix$ac_prog", so it can be a program name with args.
configure:set dummy $ac_tool_prefix$ac_prog; ac_word=$2
configure:    for ac_exec_ext in '' $ac_executable_extensions; do
configure:  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
configure:    ac_cv_prog_DUMPBIN="$ac_tool_prefix$ac_prog"
configure:    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
configure:  # Extract the first word of "$ac_prog", so it can be a program name with args.
configure:    for ac_exec_ext in '' $ac_executable_extensions; do
configure:  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
configure:    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
configure:  if test "x$ac_ct_DUMPBIN" = x; then
configure:{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
configure:$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
configure:  echo "int some_variable = 0;" > conftest.$ac_ext
configure:  (eval echo "\"\$as_me:$LINENO: $NM \\\"conftest.$ac_objext\\\"\"" >&5)
configure:  (eval "$NM \"conftest.$ac_objext\"" 2>conftest.err > conftest.out)
configure:  if $GREP 'External.*some_variable' conftest.out > /dev/null; then
configure:# find the maximum length of command line arguments
configure:{ $as_echo "$as_me:${as_lineno-$LINENO}: checking the maximum length of command line arguments" >&5
configure:$as_echo_n "checking the maximum length of command line arguments... " >&6; }
configure:if ${lt_cv_sys_max_cmd_len+:} false; then :
configure:    # (any single argument exceeding 2000 bytes causes a buffer overrun
configure:    # during glob expansion).  Even if it were fixed, the result of this
configure:    lt_cv_sys_max_cmd_len=12288;    # 12K is about right
configure:    lt_cv_sys_max_cmd_len=-1;
configure:    # On Win9x/ME, this test blows up -- it succeeds, but takes
configure:    # about 5 minutes as the teststring grows exponentially.
configure:    # Worse, since 9x/ME are not pre-emptively multitasking,
configure:    # the test eventually succeeds (with a max line length of 256k).
configure:    lt_cv_sys_max_cmd_len=8192;
configure:    lt_cv_sys_max_cmd_len=8192;
configure:    lt_cv_sys_max_cmd_len=8192;
configure:    if test -x /sbin/sysctl; then
configure:      lt_cv_sys_max_cmd_len=`/sbin/sysctl -n kern.argmax`
configure:    elif test -x /usr/sbin/sysctl; then
configure:      lt_cv_sys_max_cmd_len=`/usr/sbin/sysctl -n kern.argmax`
configure:      lt_cv_sys_max_cmd_len=65536	# usable default for all BSDs
configure:    lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \/ 4`
configure:    lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \* 3`
configure:  interix*)
configure:    lt_cv_sys_max_cmd_len=196608
configure:    lt_cv_sys_max_cmd_len=8192
configure:    # due to this test when exec_disable_arg_limit is 1 on Tru64. It is not
configure:    lt_cv_sys_max_cmd_len=16384
configure:    if test -x /sbin/sysconfig; then
configure:      case `/sbin/sysconfig -q proc exec_disable_arg_limit` in
configure:        *1*) lt_cv_sys_max_cmd_len=-1 ;;
configure:    lt_cv_sys_max_cmd_len=102400
configure:    kargmax=`grep ARG_MAX /etc/conf/cf.d/stune 2>/dev/null`
configure:    if test -n "$kargmax"; then
configure:      lt_cv_sys_max_cmd_len=`echo $kargmax | sed 's/.*[	 ]//'`
configure:      lt_cv_sys_max_cmd_len=32768
configure:    lt_cv_sys_max_cmd_len=`(getconf ARG_MAX) 2> /dev/null`
configure:    if test -n "$lt_cv_sys_max_cmd_len"; then
configure:      lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \/ 4`
configure:      lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \* 3`
configure:      # maximum length that is only half of the actual maximum length, but
configure:        i=`expr $i + 1`
configure:      lt_cv_sys_max_cmd_len=`expr "X$teststring" : ".*" 2>&1`
configure:      lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \/ 2`
configure:if test -n $lt_cv_sys_max_cmd_len ; then
configure:  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_sys_max_cmd_len" >&5
configure:$as_echo "$lt_cv_sys_max_cmd_len" >&6; }
configure:max_cmd_len=$lt_cv_sys_max_cmd_len
configure:xsi_shell=no
configure:  && xsi_shell=yes
configure:{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $xsi_shell" >&5
configure:$as_echo "$xsi_shell" >&6; }
configure:if ( (MAIL=60; unset MAIL) || exit) >/dev/null 2>&1; then
configure:      * ) # otherwise, assume *nix
configure:        lt_cv_to_host_file_cmd=func_convert_file_nix_to_w32
configure:      * ) # otherwise, assume *nix
configure:        lt_cv_to_host_file_cmd=func_convert_file_nix_to_cygwin
configure:if test -n "$ac_tool_prefix"; then
configure:  # Extract the first word of "${ac_tool_prefix}objdump", so it can be a program name with args.
configure:set dummy ${ac_tool_prefix}objdump; ac_word=$2
configure:    for ac_exec_ext in '' $ac_executable_extensions; do
configure:  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
configure:    ac_cv_prog_OBJDUMP="${ac_tool_prefix}objdump"
configure:    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
configure:  # Extract the first word of "objdump", so it can be a program name with args.
configure:    for ac_exec_ext in '' $ac_executable_extensions; do
configure:  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
configure:    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
configure:  if test "x$ac_ct_OBJDUMP" = x; then
configure:{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
configure:$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
configure:# 'file_magic [[regex]]' -- check by looking for files in library path
configure:# which responds to the $file_magic_cmd with a given extended regex.
configure:aix[4-9]*)
configure:  lt_cv_deplibs_check_method='file_magic ^x86 archive import|^x86 DLL'
configure:  # unless we find 'file', for example because we are cross-compiling.
configure:    lt_cv_deplibs_check_method='file_magic ^x86 archive import|^x86 DLL'
configure:    lt_cv_deplibs_check_method='file_magic file format (pei*-i386(.*architecture: i386)?|pe-arm-wince|pe-x86-64)'
configure:hpux10.20* | hpux11*)
configure:    lt_cv_file_magic_test_file=/usr/lib/hpux32/libc.so
configure:interix[3-9]*)
configure:  # PIC code is broken on Interix 3.x, that's why |\.a not |_pic\.a here
configure:irix5* | irix6* | nonstopux*)
configure:linux* | k*bsd*-gnu | kopensolaris*-gnu)
configure:  lt_cv_deplibs_check_method='file_magic ELF [0-9][0-9]*-bit [ML]SB (executable|dynamic lib)'
configure:*nto* | *qnx*)
configure:sysv5* | sco3.2v5* | sco5v6* | unixware* | OpenUNIX* | sysv4*uw2*)
configure:      file_magic_glob=`echo aAbBcCdDeEfFgGhHiIjJkKlLmMnNoOpPqQrRsStTuUvVwWxXyYzZ | $SED -e "s/\(..\)/s\/[\1]\/[\1]\/g;/g"`
configure:if test -n "$ac_tool_prefix"; then
configure:  # Extract the first word of "${ac_tool_prefix}dlltool", so it can be a program name with args.
configure:set dummy ${ac_tool_prefix}dlltool; ac_word=$2
configure:    for ac_exec_ext in '' $ac_executable_extensions; do
configure:  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
configure:    ac_cv_prog_DLLTOOL="${ac_tool_prefix}dlltool"
configure:    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
configure:  # Extract the first word of "dlltool", so it can be a program name with args.
configure:    for ac_exec_ext in '' $ac_executable_extensions; do
configure:  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
configure:    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
configure:  if test "x$ac_ct_DLLTOOL" = x; then
configure:{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
configure:$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
configure:if test -n "$ac_tool_prefix"; then
configure:    # Extract the first word of "$ac_tool_prefix$ac_prog", so it can be a program name with args.
configure:set dummy $ac_tool_prefix$ac_prog; ac_word=$2
configure:    for ac_exec_ext in '' $ac_executable_extensions; do
configure:  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
configure:    ac_cv_prog_AR="$ac_tool_prefix$ac_prog"
configure:    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
configure:  # Extract the first word of "$ac_prog", so it can be a program name with args.
configure:    for ac_exec_ext in '' $ac_executable_extensions; do
configure:  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
configure:    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
configure:  if test "x$ac_ct_AR" = x; then
configure:{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
configure:$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
configure:   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
configure:  echo conftest.$ac_objext > conftest.lst
configure:	rm -f conftest.$ac_objext libconftest.a
configure:rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
configure:if test "x$lt_cv_ar_at_file" = xno; then
configure:if test -n "$ac_tool_prefix"; then
configure:  # Extract the first word of "${ac_tool_prefix}strip", so it can be a program name with args.
configure:set dummy ${ac_tool_prefix}strip; ac_word=$2
configure:    for ac_exec_ext in '' $ac_executable_extensions; do
configure:  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
configure:    ac_cv_prog_STRIP="${ac_tool_prefix}strip"
configure:    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
configure:  # Extract the first word of "strip", so it can be a program name with args.
configure:    for ac_exec_ext in '' $ac_executable_extensions; do
configure:  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
configure:    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
configure:  if test "x$ac_ct_STRIP" = x; then
configure:{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
configure:$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
configure:if test -n "$ac_tool_prefix"; then
configure:  # Extract the first word of "${ac_tool_prefix}ranlib", so it can be a program name with args.
configure:set dummy ${ac_tool_prefix}ranlib; ac_word=$2
configure:    for ac_exec_ext in '' $ac_executable_extensions; do
configure:  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
configure:    ac_cv_prog_RANLIB="${ac_tool_prefix}ranlib"
configure:    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
configure:  # Extract the first word of "ranlib", so it can be a program name with args.
configure:    for ac_exec_ext in '' $ac_executable_extensions; do
configure:  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
configure:    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
configure:  if test "x$ac_ct_RANLIB" = x; then
configure:{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
configure:$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
configure:    lock_old_archive_extraction=yes ;;
configure:    lock_old_archive_extraction=no ;;
configure:# [They come from Ultrix.  What could be older than Ultrix?!! ;)]
configure:# Regexp to match symbols that can be accessed directly from C.
configure:aix*)
configure:hpux*)
configure:irix* | nonstopux*)
configure:sysv5* | sco5v6* | unixware* | OpenUNIX*)
configure:# Transform an extracted symbol line into a proper C declaration.
configure:lt_cv_sys_global_symbol_to_cdecl="sed -n -e 's/^T .* \(.*\)$/extern int \1();/p' -e 's/^$symcode* .* \(.*\)$/extern char \1;/p'"
configure:# Transform an extracted symbol line into symbol name and symbol address
configure:lt_cv_sys_global_symbol_to_c_name_address_lib_prefix="sed -n -e 's/^: \([^ ]*\)[ ]*$/  {\\\"\1\\\", (void *) 0},/p' -e 's/^$symcode* \([^ ]*\) \(lib[^ ]*\)$/  {\"\2\", (void *) \&\2},/p' -e 's/^$symcode* \([^ ]*\) \([^ ]*\)$/  {\"lib\2\", (void *) \&\2},/p'"
configure:  opt_cr=`$ECHO 'x\{0,1\}' | tr x '\015'` # option cr in regexp
configure:# Try without a prefix underscore, then with it.
configure:for ac_symprfx in "" "_"; do
configure:  # Transform symcode, sympat, and symprfx into a raw symbol and a C symbol.
configure:  symxfrm="\\1 $ac_symprfx\\2 \\2"
configure:"     \$ 0!~/External *\|/{next};"\
configure:"     / 0+ UNDEF /{next}; / UNDEF \([^|]\)*()/{next};"\
configure:"     {if(hide[section]) next};"\
configure:"     s[1]~/^[@?]/{print s[1], s[1]; next};"\
configure:"     s[1]~prfx {split(s[1],t,\"@\"); print t[1], substr(t[1],length(prfx))}"\
configure:"     ' prfx=^$ac_symprfx"
configure:    lt_cv_sys_global_symbol_pipe="sed -n -e 's/^.*[	 ]\($symcode$symcode*\)[	 ][	 ]*$ac_symprfx$sympat$opt_cr$/$symxfrm/p'"
configure:  cat > conftest.$ac_ext <<_LT_EOF
configure:extern "C" {
configure:    if { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$NM conftest.$ac_objext \| "$lt_cv_sys_global_symbol_pipe" \> $nlist\""; } >&5
configure:  (eval $NM conftest.$ac_objext \| "$lt_cv_sys_global_symbol_pipe" \> $nlist) 2>&5
configure:	  cat <<_LT_EOF > conftest.$ac_ext
configure:extern "C" {
configure:	  eval "$lt_cv_sys_global_symbol_to_cdecl"' < "$nlist" | $GREP -v main >> conftest.$ac_ext'
configure:	  cat <<_LT_EOF >> conftest.$ac_ext
configure:	  $SED "s/^$symcode$symcode* \(.*\) \(.*\)$/  {\"\2\", (void *) \&\2},/" < "$nlist" | $GREP -v main >> conftest.$ac_ext
configure:	  cat <<\_LT_EOF >> conftest.$ac_ext
configure:	  mv conftest.$ac_objext conftstm.$ac_objext
configure:	  LIBS="conftstm.$ac_objext"
configure:  test $ac_status = 0; } && test -s conftest${ac_exeext}; then
configure:    cat conftest.$ac_ext >&5
configure:test "x$enable_libtool_lock" != xno && enable_libtool_lock=yes
configure:ia64-*-hpux*)
configure:  echo 'int i;' > conftest.$ac_ext
configure:    case `/usr/bin/file conftest.$ac_objext` in
configure:*-*-irix6*)
configure:  echo '#line '$LINENO' "configure"' > conftest.$ac_ext
configure:      case `/usr/bin/file conftest.$ac_objext` in
configure:      case `/usr/bin/file conftest.$ac_objext` in
configure:x86_64-*kfreebsd*-gnu|x86_64-*linux*|ppc*-*linux*|powerpc*-*linux*| \
configure:s390*-*linux*|s390*-*tpf*|sparc*-*linux*)
configure:  echo 'int i;' > conftest.$ac_ext
configure:	  x86_64-*kfreebsd*-gnu)
configure:	  x86_64-*linux*)
configure:	  ppc64-*linux*|powerpc64-*linux*)
configure:	    LD="${LD-ld} -m elf32ppclinux"
configure:	  s390x-*linux*)
configure:	  sparc64-*linux*)
configure:	  x86_64-*kfreebsd*-gnu)
configure:	    LD="${LD-ld} -m elf_x86_64_fbsd"
configure:	  x86_64-*linux*)
configure:	    LD="${LD-ld} -m elf_x86_64"
configure:	  ppc*-*linux*|powerpc*-*linux*)
configure:	  s390*-*linux*|s390*-*tpf*)
configure:	  sparc*-*linux*)
configure:  ac_ext=c
configure:ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
configure:ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
configure:     cat confdefs.h - <<_ACEOF >conftest.$ac_ext
configure:rm -f core conftest.err conftest.$ac_objext \
configure:    conftest$ac_exeext conftest.$ac_ext
configure:     ac_ext=c
configure:ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
configure:ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
configure:  if test x"$lt_cv_cc_needs_belf" != x"yes"; then
configure:  echo 'int i;' > conftest.$ac_ext
configure:          LD="${LD-ld} -m elf_x86_64"
configure:if test -n "$ac_tool_prefix"; then
configure:  # Extract the first word of "${ac_tool_prefix}mt", so it can be a program name with args.
configure:set dummy ${ac_tool_prefix}mt; ac_word=$2
configure:    for ac_exec_ext in '' $ac_executable_extensions; do
configure:  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
configure:    ac_cv_prog_MANIFEST_TOOL="${ac_tool_prefix}mt"
configure:    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
configure:  # Extract the first word of "mt", so it can be a program name with args.
configure:    for ac_exec_ext in '' $ac_executable_extensions; do
configure:  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
configure:    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
configure:  if test "x$ac_ct_MANIFEST_TOOL" = x; then
configure:{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
configure:$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
configure:if test "x$lt_cv_path_mainfest_tool" != xyes; then
configure:    if test -n "$ac_tool_prefix"; then
configure:  # Extract the first word of "${ac_tool_prefix}dsymutil", so it can be a program name with args.
configure:set dummy ${ac_tool_prefix}dsymutil; ac_word=$2
configure:    for ac_exec_ext in '' $ac_executable_extensions; do
configure:  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
configure:    ac_cv_prog_DSYMUTIL="${ac_tool_prefix}dsymutil"
configure:    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
configure:  # Extract the first word of "dsymutil", so it can be a program name with args.
configure:    for ac_exec_ext in '' $ac_executable_extensions; do
configure:  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
configure:    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
configure:  if test "x$ac_ct_DSYMUTIL" = x; then
configure:{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
configure:$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
configure:    if test -n "$ac_tool_prefix"; then
configure:  # Extract the first word of "${ac_tool_prefix}nmedit", so it can be a program name with args.
configure:set dummy ${ac_tool_prefix}nmedit; ac_word=$2
configure:    for ac_exec_ext in '' $ac_executable_extensions; do
configure:  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
configure:    ac_cv_prog_NMEDIT="${ac_tool_prefix}nmedit"
configure:    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
configure:  # Extract the first word of "nmedit", so it can be a program name with args.
configure:    for ac_exec_ext in '' $ac_executable_extensions; do
configure:  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
configure:    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
configure:  if test "x$ac_ct_NMEDIT" = x; then
configure:{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
configure:$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
configure:    if test -n "$ac_tool_prefix"; then
configure:  # Extract the first word of "${ac_tool_prefix}lipo", so it can be a program name with args.
configure:set dummy ${ac_tool_prefix}lipo; ac_word=$2
configure:    for ac_exec_ext in '' $ac_executable_extensions; do
configure:  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
configure:    ac_cv_prog_LIPO="${ac_tool_prefix}lipo"
configure:    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
configure:  # Extract the first word of "lipo", so it can be a program name with args.
configure:    for ac_exec_ext in '' $ac_executable_extensions; do
configure:  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
configure:    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
configure:  if test "x$ac_ct_LIPO" = x; then
configure:{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
configure:$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
configure:    if test -n "$ac_tool_prefix"; then
configure:  # Extract the first word of "${ac_tool_prefix}otool", so it can be a program name with args.
configure:set dummy ${ac_tool_prefix}otool; ac_word=$2
configure:    for ac_exec_ext in '' $ac_executable_extensions; do
configure:  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
configure:    ac_cv_prog_OTOOL="${ac_tool_prefix}otool"
configure:    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
configure:  # Extract the first word of "otool", so it can be a program name with args.
configure:    for ac_exec_ext in '' $ac_executable_extensions; do
configure:  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
configure:    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
configure:  if test "x$ac_ct_OTOOL" = x; then
configure:{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
configure:$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
configure:    if test -n "$ac_tool_prefix"; then
configure:  # Extract the first word of "${ac_tool_prefix}otool64", so it can be a program name with args.
configure:set dummy ${ac_tool_prefix}otool64; ac_word=$2
configure:    for ac_exec_ext in '' $ac_executable_extensions; do
configure:  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
configure:    ac_cv_prog_OTOOL64="${ac_tool_prefix}otool64"
configure:    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
configure:  # Extract the first word of "otool64", so it can be a program name with args.
configure:    for ac_exec_ext in '' $ac_executable_extensions; do
configure:  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
configure:    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
configure:  if test "x$ac_ct_OTOOL64" = x; then
configure:{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
configure:$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
configure:	# Otherwise, if the output was created with a 0 exit code from
configure:    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for -exported_symbols_list linker flag" >&5
configure:$as_echo_n "checking for -exported_symbols_list linker flag... " >&6; }
configure:if ${lt_cv_ld_exported_symbols_list+:} false; then :
configure:  lt_cv_ld_exported_symbols_list=no
configure:      LDFLAGS="$LDFLAGS -Wl,-exported_symbols_list,conftest.sym"
configure:      cat confdefs.h - <<_ACEOF >conftest.$ac_ext
configure:  lt_cv_ld_exported_symbols_list=yes
configure:  lt_cv_ld_exported_symbols_list=no
configure:rm -f core conftest.err conftest.$ac_objext \
configure:    conftest$ac_exeext conftest.$ac_ext
configure:{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_ld_exported_symbols_list" >&5
configure:$as_echo "$lt_cv_ld_exported_symbols_list" >&6; }
configure:    darwin*) # darwin 5.x on
configure:      # to the OS version, if on x86, and 10.4, the deployment
configure:    if test "$lt_cv_ld_exported_symbols_list" = "yes"; then
configure:      _lt_dar_export_syms=' ${wl}-exported_symbols_list,$output_objdir/${libname}-symbols.expsym'
configure:      _lt_dar_export_syms='~$NMEDIT -s $output_objdir/${libname}-symbols.expsym ${lib}'
configure:  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
configure:rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
configure:  # SunOS 4.x string.h does not declare mem*, contrary to ANSI.
configure:  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
configure:if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
configure:  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
configure:if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
configure:  # /bin/cc in Irix-4.0.5 gets non-ANSI ctype macros unless using -ansi.
configure:  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
configure:#if ((' ' & 0x0FF) == 0x020)
configure:# define TOUPPER(c) (ISLOWER(c) ? ((c) | 0x40) : (c))
configure:rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext \
configure:  conftest.$ac_objext conftest.beam conftest.$ac_ext
configure:if eval test \"x\$"$as_ac_Header"\" = x"yes"; then :
configure:if test "x$ac_cv_header_dlfcn_h" = xyes; then :
configure:  if test -n "$ac_tool_prefix"; then
configure:  # Extract the first word of "${ac_tool_prefix}as", so it can be a program name with args.
configure:set dummy ${ac_tool_prefix}as; ac_word=$2
configure:    for ac_exec_ext in '' $ac_executable_extensions; do
configure:  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
configure:    ac_cv_prog_AS="${ac_tool_prefix}as"
configure:    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
configure:  # Extract the first word of "as", so it can be a program name with args.
configure:    for ac_exec_ext in '' $ac_executable_extensions; do
configure:  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
configure:    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
configure:  if test "x$ac_ct_AS" = x; then
configure:{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
configure:$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
configure:  if test -n "$ac_tool_prefix"; then
configure:  # Extract the first word of "${ac_tool_prefix}dlltool", so it can be a program name with args.
configure:set dummy ${ac_tool_prefix}dlltool; ac_word=$2
configure:    for ac_exec_ext in '' $ac_executable_extensions; do
configure:  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
configure:    ac_cv_prog_DLLTOOL="${ac_tool_prefix}dlltool"
configure:    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
configure:  # Extract the first word of "dlltool", so it can be a program name with args.
configure:    for ac_exec_ext in '' $ac_executable_extensions; do
configure:  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
configure:    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
configure:  if test "x$ac_ct_DLLTOOL" = x; then
configure:{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
configure:$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
configure:  if test -n "$ac_tool_prefix"; then
configure:  # Extract the first word of "${ac_tool_prefix}objdump", so it can be a program name with args.
configure:set dummy ${ac_tool_prefix}objdump; ac_word=$2
configure:    for ac_exec_ext in '' $ac_executable_extensions; do
configure:  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
configure:    ac_cv_prog_OBJDUMP="${ac_tool_prefix}objdump"
configure:    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
configure:  # Extract the first word of "objdump", so it can be a program name with args.
configure:    for ac_exec_ext in '' $ac_executable_extensions; do
configure:  if as_fn_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
configure:    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
configure:  if test "x$ac_ct_OBJDUMP" = x; then
configure:{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
configure:$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
configure:aix3*)
configure:    export COLLECT_NAMES
configure:# All known linkers require a `.a' archive for static linking (except MSVC,
configure:libext=a
configure:test -z "$ac_objext" && ac_objext=o
configure:    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for ${ac_tool_prefix}file" >&5
configure:$as_echo_n "checking for ${ac_tool_prefix}file... " >&6; }
configure:    if test -f $ac_dir/${ac_tool_prefix}file; then
configure:      lt_cv_path_MAGIC_CMD="$ac_dir/${ac_tool_prefix}file"
configure:	  file_magic_regex=`expr "$deplibs_check_method" : "file_magic \(.*\)"`
configure:	    $EGREP "$file_magic_regex" > /dev/null; then
configure:  if test -n "$ac_tool_prefix"; then
configure:	  file_magic_regex=`expr "$deplibs_check_method" : "file_magic \(.*\)"`
configure:	    $EGREP "$file_magic_regex" > /dev/null; then
configure:ac_ext=c
configure:ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
configure:ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
configure:# Source file extension for C test sources.
configure:ac_ext=c
configure:# Object file extension for compiled C test sources.
configure:objext=o
configure:objext=$objext
configure:ac_outfile=conftest.$ac_objext
configure:echo "$lt_simple_compile_test_code" >conftest.$ac_ext
configure:ac_outfile=conftest.$ac_objext
configure:echo "$lt_simple_link_test_code" >conftest.$ac_ext
configure:## the running order or otherwise move them around unless you know exactly
configure:  { $as_echo "$as_me:${as_lineno-$LINENO}: checking if $compiler supports -fno-rtti -fno-exceptions" >&5
configure:$as_echo_n "checking if $compiler supports -fno-rtti -fno-exceptions... " >&6; }
configure:if ${lt_cv_prog_compiler_rtti_exceptions+:} false; then :
configure:  lt_cv_prog_compiler_rtti_exceptions=no
configure:   ac_outfile=conftest.$ac_objext
configure:   echo "$lt_simple_compile_test_code" > conftest.$ac_ext
configure:   lt_compiler_flag="-fno-rtti -fno-exceptions"
configure:   if (exit $ac_status) && test -s "$ac_outfile"; then
configure:     $ECHO "$_lt_compiler_boilerplate" | $SED '/^$/d' >conftest.exp
configure:     if test ! -s conftest.er2 || diff conftest.exp conftest.er2 >/dev/null; then
configure:       lt_cv_prog_compiler_rtti_exceptions=yes
configure:{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_prog_compiler_rtti_exceptions" >&5
configure:$as_echo "$lt_cv_prog_compiler_rtti_exceptions" >&6; }
configure:if test x"$lt_cv_prog_compiler_rtti_exceptions" = xyes; then
configure:    lt_prog_compiler_no_builtin_flag="$lt_prog_compiler_no_builtin_flag -fno-rtti -fno-exceptions"
configure:      aix*)
configure:    beos* | irix5* | irix6* | nonstopux* | osf3* | osf4* | osf5*)
configure:      # built for inclusion in a dll (and should export symbols for example).
configure:      # The "-static" flag exists, but is broken.
configure:    hpux*)
configure:    interix[3-9]*)
configure:      # Interix 3.x gcc -fpic/-fPIC options generate broken code.
configure:    *nto* | *qnx*)
configure:    aix*)
configure:	lt_prog_compiler_static='-bnso -bI:/lib/syscalls.exp'
configure:      # built for inclusion in a dll (and should export symbols for example).
configure:    hpux9* | hpux10* | hpux11*)
configure:    irix5* | irix6* | nonstopux*)
configure:    linux* | k*bsd*-gnu | kopensolaris*-gnu)
configure:      # old Intel for x86_64 which still supported -KPIC.
configure:      xl* | bgxl* | bgf* | mpixl*)
configure:    *nto* | *qnx*)
configure:    sysv5* | unixware* | sco3.2v5* | sco5v6* | OpenUNIX*)
configure:   ac_outfile=conftest.$ac_objext
configure:   echo "$lt_simple_compile_test_code" > conftest.$ac_ext
configure:   if (exit $ac_status) && test -s "$ac_outfile"; then
configure:     $ECHO "$_lt_compiler_boilerplate" | $SED '/^$/d' >conftest.exp
configure:     if test ! -s conftest.er2 || diff conftest.exp conftest.er2 >/dev/null; then
configure:if test x"$lt_cv_prog_compiler_pic_works" = xyes; then
configure:   echo "$lt_simple_link_test_code" > conftest.$ac_ext
configure:   if (eval $ac_link 2>conftest.err) && test -s conftest$ac_exeext; then
configure:       $ECHO "$_lt_linker_boilerplate" | $SED '/^$/d' > conftest.exp
configure:       if diff conftest.exp conftest.er2 >/dev/null; then
configure:if test x"$lt_cv_prog_compiler_static_works" = xyes; then
configure:  { $as_echo "$as_me:${as_lineno-$LINENO}: checking if $compiler supports -c -o file.$ac_objext" >&5
configure:$as_echo_n "checking if $compiler supports -c -o file.$ac_objext... " >&6; }
configure:   echo "$lt_simple_compile_test_code" > conftest.$ac_ext
configure:   lt_compiler_flag="-o out/conftest2.$ac_objext"
configure:   if (exit $ac_status) && test -s out/conftest2.$ac_objext
configure:     $ECHO "$_lt_compiler_boilerplate" | $SED '/^$/d' > out/conftest.exp
configure:     if test ! -s out/conftest.er2 || diff out/conftest.exp out/conftest.er2 >/dev/null; then
configure:  { $as_echo "$as_me:${as_lineno-$LINENO}: checking if $compiler supports -c -o file.$ac_objext" >&5
configure:$as_echo_n "checking if $compiler supports -c -o file.$ac_objext... " >&6; }
configure:   echo "$lt_simple_compile_test_code" > conftest.$ac_ext
configure:   lt_compiler_flag="-o out/conftest2.$ac_objext"
configure:   if (exit $ac_status) && test -s out/conftest2.$ac_objext
configure:     $ECHO "$_lt_compiler_boilerplate" | $SED '/^$/d' > out/conftest.exp
configure:     if test ! -s out/conftest.er2 || diff out/conftest.exp out/conftest.er2 >/dev/null; then
configure:  always_export_symbols=no
configure:  archive_expsym_cmds=
configure:  export_dynamic_flag_spec=
configure:  export_symbols_cmds='$NM $libobjs $convenience | $global_symbol_pipe | $SED '\''s/.* //'\'' | sort | uniq > $export_symbols'
configure:  module_expsym_cmds=
configure:  old_archive_from_expsyms_cmds=
configure:  # include_expsyms should be a list of space-separated symbols to be *always*
configure:  include_expsyms=
configure:  # exclude_expsyms can be an extended regexp of symbols to exclude
configure:  # end of line.  Example: `a|bc|.*d.*' will exclude the symbols `a' and `bc',
configure:  exclude_expsyms='_GLOBAL_OFFSET_TABLE_|_GLOBAL__F[ID]_.*'
configure:  # the symbol is explicitly referenced.  Since portable code cannot
configure:  # Exclude shared library initialization/finalization symbols.
configure:  extract_expsyms_cmds=
configure:  interix*)
configure:      aix*)
configure:    export_dynamic_flag_spec='${wl}--export-dynamic'
configure:    aix[3-9]*)
configure:            archive_expsym_cmds=''
configure:            archive_cmds='$RM $output_objdir/a2ixlibrary.data~$ECHO "#define NAME $libname" > $output_objdir/a2ixlibrary.data~$ECHO "#define LIBRARY_ID 1" >> $output_objdir/a2ixlibrary.data~$ECHO "#define VERSION $major" >> $output_objdir/a2ixlibrary.data~$ECHO "#define REVISION $revision" >> $output_objdir/a2ixlibrary.data~$AR $AR_FLAGS $lib $libobjs~$RANLIB $lib~(cd $output_objdir && a2ixlibrary -32)'
configure:      export_dynamic_flag_spec='${wl}--export-all-symbols'
configure:      always_export_symbols=no
configure:      export_symbols_cmds='$NM $libobjs $convenience | $global_symbol_pipe | $SED -e '\''/^[BCDGRS][ ]/s/.*[ ]\([^ ]*\)/\1 DATA/;s/^.*[ ]__nm__\([^ ]*\)[ ][^ ]*/\1 DATA/;/^I[ ]/d;/^[AITW][ ]/s/.* //'\'' | sort | uniq > $export_symbols'
configure:      exclude_expsyms='[_]+GLOBAL_OFFSET_TABLE_|[_]+GLOBAL__[FID]_.*|[_]+head_[A-Za-z0-9_]+_dll|[A-Za-z0-9_]+_dll_iname'
configure:	# If the export-symbols file already is a .def file (1st line
configure:	archive_expsym_cmds='if test "x`$SED 1q $export_symbols`" = xEXPORTS; then
configure:	  cp $export_symbols $output_objdir/$soname.def;
configure:	  cat $export_symbols >> $output_objdir/$soname.def;
configure:    interix[3-9]*)
configure:      export_dynamic_flag_spec='${wl}-E'
configure:      # Hack: On Interix 3.x, we cannot compile PIC because of a broken gcc.
configure:      # Instead, shared libraries are loaded at an image base (0x10000000 by
configure:      # 256 KiB-aligned image base between 0x50000000 and 0x6FFC0000 at link
configure:      # time.  Moving up from 0x10000000 also allows more sbrk(2) space.
configure:      archive_cmds='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-h,$soname ${wl}--image-base,`expr ${RANDOM-$$} % 4096 / 2 \* 262144 + 1342177280` -o $lib'
configure:      archive_expsym_cmds='sed "s,^,_," $export_symbols >$output_objdir/$soname.expsym~$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-h,$soname ${wl}--retain-symbols-file,$output_objdir/$soname.expsym ${wl}--image-base,`expr ${RANDOM-$$} % 4096 / 2 \* 262144 + 1342177280` -o $lib'
configure:    gnu* | linux* | tpf* | k*bsd*-gnu | kopensolaris*-gnu)
configure:      if test "$host_os" = linux-dietlibc; then
configure:	  diet\ *) tmp_diet=yes;;	# linux-dietlibc with static linking (!diet-dyn)
configure:	xl[cC]* | bgxl[cC]* | mpixl[cC]*) # IBM XL C 8.0 on PPC (deal with xlf below)
configure:        if test "x$supports_anon_versioning" = xyes; then
configure:          archive_expsym_cmds='echo "{ global:" > $output_objdir/$libname.ver~
configure:	    cat $export_symbols | sed -e "s/\(.*\)/\1;/" >> $output_objdir/$libname.ver~
configure:	xlf* | bgf* | bgxlf* | mpixlf*)
configure:	  if test "x$supports_anon_versioning" = xyes; then
configure:	    archive_expsym_cmds='echo "{ global:" > $output_objdir/$libname.ver~
configure:	      cat $export_symbols | sed -e "s/\(.*\)/\1;/" >> $output_objdir/$libname.ver~
configure:	archive_expsym_cmds='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'
configure:	archive_expsym_cmds='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'
configure:    sysv5* | sco3.2v5* | sco5v6* | unixware* | OpenUNIX*)
configure:	  # use absolute paths for naming shared libraries, and exclude the
configure:	  # DT_RUNPATH tag from executables and libraries.  But doing so
configure:	    archive_expsym_cmds='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'
configure:      archive_cmds='$LD -assert pure-text -Bshareable -o $lib $libobjs $deplibs $linker_flags'
configure:	archive_expsym_cmds='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'
configure:      export_dynamic_flag_spec=
configure:    aix3*)
configure:      always_export_symbols=yes
configure:      archive_expsym_cmds='$LD -o $output_objdir/$soname $libobjs $deplibs $linker_flags -bE:$export_symbols -T512 -H512 -bM:SRE~$AR $AR_FLAGS $lib $output_objdir/$soname'
configure:    aix[4-9]*)
configure:	aix_use_runtimelinking=no
configure:	exp_sym_flag='-Bexport'
configure:	  export_symbols_cmds='$NM -Bpg $libobjs $convenience | awk '\''{ if (((\$ 2 == "T") || (\$ 2 == "D") || (\$ 2 == "B") || (\$ 2 == "W")) && (substr(\$ 3,1,1) != ".")) { print \$ 3 } }'\'' | sort -u > $export_symbols'
configure:	  export_symbols_cmds='$NM -BCpg $libobjs $convenience | awk '\''{ if (((\$ 2 == "T") || (\$ 2 == "D") || (\$ 2 == "B")) && (substr(\$ 3,1,1) != ".")) { print \$ 3 } }'\'' | sort -u > $export_symbols'
configure:	aix_use_runtimelinking=no
configure:	case $host_os in aix4.[23]|aix4.[23].*|aix[5-9]*)
configure:	    aix_use_runtimelinking=yes
configure:	exp_sym_flag='-bexport'
configure:      # When large executables or shared objects are built, AIX ld can
configure:      # enough to fix the problem, add -Wl,-bbigtoc to LDFLAGS.
configure:	case $host_os in aix4.[012]|aix4.[012].*)
configure:	if test "$aix_use_runtimelinking" = yes; then
configure:	  if test "$aix_use_runtimelinking" = yes; then
configure:      export_dynamic_flag_spec='${wl}-bexpall'
configure:      # It seems that -bexpall does not export symbols beginning with
configure:      # underscore (_), so it is better to generate a list of symbols to export.
configure:      always_export_symbols=yes
configure:      if test "$aix_use_runtimelinking" = yes; then
configure:        # empty executable.
configure:        if test "${lt_cv_aix_libpath+set}" = set; then
configure:  aix_libpath=$lt_cv_aix_libpath
configure:  if ${lt_cv_aix_libpath_+:} false; then :
configure:  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
configure:  lt_aix_libpath_sed='
configure:  lt_cv_aix_libpath_=`dump -H conftest$ac_exeext 2>/dev/null | $SED -n -e "$lt_aix_libpath_sed"`
configure:  if test -z "$lt_cv_aix_libpath_"; then
configure:    lt_cv_aix_libpath_=`dump -HX64 conftest$ac_exeext 2>/dev/null | $SED -n -e "$lt_aix_libpath_sed"`
configure:rm -f core conftest.err conftest.$ac_objext \
configure:    conftest$ac_exeext conftest.$ac_ext
configure:  if test -z "$lt_cv_aix_libpath_"; then
configure:    lt_cv_aix_libpath_="/usr/lib:/lib"
configure:  aix_libpath=$lt_cv_aix_libpath_
configure:        hardcode_libdir_flag_spec='${wl}-blibpath:$libdir:'"$aix_libpath"
configure:        archive_expsym_cmds='$CC -o $output_objdir/$soname $libobjs $deplibs '"\${wl}$no_entry_flag"' $compiler_flags `if test "x${allow_undefined_flag}" != "x"; then func_echo_all "${wl}${allow_undefined_flag}"; else :; fi` '"\${wl}$exp_sym_flag:\$export_symbols $shared_flag"
configure:	  archive_expsym_cmds="\$CC $shared_flag"' -o $output_objdir/$soname $libobjs $deplibs '"\${wl}$no_entry_flag"' $compiler_flags ${wl}${allow_undefined_flag} '"\${wl}$exp_sym_flag:\$export_symbols"
configure:	 # empty executable.
configure:	 if test "${lt_cv_aix_libpath+set}" = set; then
configure:  aix_libpath=$lt_cv_aix_libpath
configure:  if ${lt_cv_aix_libpath_+:} false; then :
configure:  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
configure:  lt_aix_libpath_sed='
configure:  lt_cv_aix_libpath_=`dump -H conftest$ac_exeext 2>/dev/null | $SED -n -e "$lt_aix_libpath_sed"`
configure:  if test -z "$lt_cv_aix_libpath_"; then
configure:    lt_cv_aix_libpath_=`dump -HX64 conftest$ac_exeext 2>/dev/null | $SED -n -e "$lt_aix_libpath_sed"`
configure:rm -f core conftest.err conftest.$ac_objext \
configure:    conftest$ac_exeext conftest.$ac_ext
configure:  if test -z "$lt_cv_aix_libpath_"; then
configure:    lt_cv_aix_libpath_="/usr/lib:/lib"
configure:  aix_libpath=$lt_cv_aix_libpath_
configure:	 hardcode_libdir_flag_spec='${wl}-blibpath:$libdir:'"$aix_libpath"
configure:	    # Exported symbols can be pulled into shared objects from archives
configure:	  archive_expsym_cmds="\$CC $shared_flag"' -o $output_objdir/$soname $libobjs $deplibs ${wl}-bnoentry $compiler_flags ${wl}-bE:$export_symbols${allow_undefined_flag}~$AR $AR_FLAGS $output_objdir/$libname$release.a $output_objdir/$soname'
configure:            archive_expsym_cmds=''
configure:            archive_cmds='$RM $output_objdir/a2ixlibrary.data~$ECHO "#define NAME $libname" > $output_objdir/a2ixlibrary.data~$ECHO "#define LIBRARY_ID 1" >> $output_objdir/a2ixlibrary.data~$ECHO "#define VERSION $major" >> $output_objdir/a2ixlibrary.data~$ECHO "#define REVISION $revision" >> $output_objdir/a2ixlibrary.data~$AR $AR_FLAGS $lib $libobjs~$RANLIB $lib~(cd $output_objdir && a2ixlibrary -32)'
configure:      export_dynamic_flag_spec=-rdynamic
configure:	always_export_symbols=yes
configure:	libext=lib
configure:	shrext_cmds=".dll"
configure:	archive_expsym_cmds='if test "x`$SED 1q $export_symbols`" = xEXPORTS; then
configure:	    sed -n -e 's/\\\\\\\(.*\\\\\\\)/-link\\\ -EXPORT:\\\\\\\1/' -e '1\\\!p' < $export_symbols > $output_objdir/$soname.exp;
configure:	    sed -e 's/\\\\\\\(.*\\\\\\\)/-link\\\ -EXPORT:\\\\\\\1/' < $export_symbols > $output_objdir/$soname.exp;
configure:	  $CC -o $tool_output_objdir$soname $libobjs $compiler_flags $deplibs "@$tool_output_objdir$soname.exp" -Wl,-DLL,-IMPLIB:"$tool_output_objdir$libname.dll.lib"~
configure:	exclude_expsyms='_NULL_IMPORT_DESCRIPTOR|_IMPORT_DESCRIPTOR_.*'
configure:	export_symbols_cmds='$NM $libobjs $convenience | $global_symbol_pipe | $SED -e '\''/^[BCDGRS][ ]/s/.*[ ]\([^ ]*\)/\1,DATA/'\'' | $SED -e '\''/^[AITW][ ]/s/.*[ ]//'\'' | sort | uniq > $export_symbols'
configure:	    *.exe|*.EXE) ;;
configure:	      lt_outputfile="$lt_outputfile.exe"
configure:	      lt_tool_outputfile="$lt_tool_outputfile.exe"
configure:	    $MANIFEST_TOOL -manifest "$lt_tool_outputfile.manifest" -outputresource:"$lt_tool_outputfile" || exit 1;
configure:	libext=lib
configure:	shrext_cmds=".dll"
configure:    archive_expsym_cmds="sed 's,^,_,' < \$export_symbols > \$output_objdir/\${libname}-symbols.expsym~\$CC -dynamiclib \$allow_undefined_flag -o \$lib \$libobjs \$deplibs \$compiler_flags -install_name \$rpath/\$soname \$verstring ${_lt_dar_single_mod}${_lt_dar_export_syms}${_lt_dsymutil}"
configure:    module_expsym_cmds="sed -e 's,^,_,' < \$export_symbols > \$output_objdir/\${libname}-symbols.expsym~\$CC \$allow_undefined_flag -o \$lib -bundle \$libobjs \$deplibs \$compiler_flags${_lt_dar_export_syms}${_lt_dsymutil}"
configure:    dgux*)
configure:    # support.  Future versions do this automatically, but an explicit c++rt0.o
configure:    # extra space).
configure:    hpux9*)
configure:      export_dynamic_flag_spec='${wl}-E'
configure:    hpux10*)
configure:	export_dynamic_flag_spec='${wl}-E'
configure:    hpux11*)
configure:   echo "$lt_simple_link_test_code" > conftest.$ac_ext
configure:   if (eval $ac_link 2>conftest.err) && test -s conftest$ac_exeext; then
configure:       $ECHO "$_lt_linker_boilerplate" | $SED '/^$/d' > conftest.exp
configure:       if diff conftest.exp conftest.er2 >/dev/null; then
configure:if test x"$lt_cv_prog_compiler__b" = xyes; then
configure:	  export_dynamic_flag_spec='${wl}-E'
configure:    irix5* | irix6* | nonstopux*)
configure:	# Try to use the -exported_symbol ld option, if it does not
configure:	# work, assume that -exports_file does not work either and
configure:	# implicitly export all symbols.
configure:	{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether the $host_os linker accepts -exported_symbol" >&5
configure:$as_echo_n "checking whether the $host_os linker accepts -exported_symbol... " >&6; }
configure:if ${lt_cv_irix_exported_symbol+:} false; then :
configure:	   LDFLAGS="$LDFLAGS -shared ${wl}-exported_symbol ${wl}foo ${wl}-update_registry ${wl}/dev/null"
configure:	   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
configure:  lt_cv_irix_exported_symbol=yes
configure:  lt_cv_irix_exported_symbol=no
configure:rm -f core conftest.err conftest.$ac_objext \
configure:    conftest$ac_exeext conftest.$ac_ext
configure:{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $lt_cv_irix_exported_symbol" >&5
configure:$as_echo "$lt_cv_irix_exported_symbol" >&6; }
configure:	if test "$lt_cv_irix_exported_symbol" = yes; then
configure:          archive_expsym_cmds='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-soname ${wl}$soname `test -n "$verstring" && func_echo_all "${wl}-set_version ${wl}$verstring"` ${wl}-update_registry ${wl}${output_objdir}/so_locations ${wl}-exports_file ${wl}$export_symbols -o $lib'
configure:	archive_expsym_cmds='$CC -shared $libobjs $deplibs $compiler_flags -soname $soname `test -n "$verstring" && func_echo_all "-set_version $verstring"` -update_registry ${output_objdir}/so_locations -exports_file $export_symbols -o $lib'
configure:    *nto* | *qnx*)
configure:      if test -f /usr/libexec/ld.so; then
configure:	  archive_expsym_cmds='$CC -shared $pic_flag -o $lib $libobjs $deplibs $compiler_flags ${wl}-retain-symbols-file,$export_symbols'
configure:	  export_dynamic_flag_spec='${wl}-E'
configure:      archive_cmds='$ECHO "LIBRARY $libname INITINSTANCE" > $output_objdir/$libname.def~$ECHO "DESCRIPTION \"$libname\"" >> $output_objdir/$libname.def~echo DATA >> $output_objdir/$libname.def~echo " SINGLE NONSHARED" >> $output_objdir/$libname.def~echo EXPORTS >> $output_objdir/$libname.def~emxexp $libobjs >> $output_objdir/$libname.def~$CC -Zdll -Zcrtdll -o $lib $libobjs $deplibs $compiler_flags $output_objdir/$libname.def'
configure:      old_archive_from_new_cmds='emximp -o $output_objdir/$libname.a $output_objdir/$libname.def'
configure:	allow_undefined_flag=' ${wl}-expect_unresolved ${wl}\*'
configure:	allow_undefined_flag=' -expect_unresolved \*'
configure:	allow_undefined_flag=' ${wl}-expect_unresolved ${wl}\*'
configure:	allow_undefined_flag=' -expect_unresolved \*'
configure:	archive_expsym_cmds='for i in `cat $export_symbols`; do printf "%s %s\\n" -exported_symbol "\$i" >> $lib.exp; done; printf "%s\\n" "-hidden">> $lib.exp~
configure:	$CC -shared${allow_undefined_flag} ${wl}-input ${wl}$lib.exp $compiler_flags $libobjs $deplibs -soname $soname `test -n "$verstring" && $ECHO "-set_version $verstring"` -update_registry ${output_objdir}/so_locations -o $lib~$RM $lib.exp'
configure:	# Both c and cxx compiler support -rpath directly
configure:	archive_cmds='$CC -shared $pic_flag ${wl}-z ${wl}text ${wl}-h ${wl}$soname -o $lib $libobjs $deplibs $compiler_flags'
configure:	archive_expsym_cmds='echo "{ global:" > $lib.exp~cat $export_symbols | $SED -e "s/\(.*\)/\1;/" >> $lib.exp~echo "local: *; };" >> $lib.exp~
configure:	  $CC -shared $pic_flag ${wl}-z ${wl}text ${wl}-M ${wl}$lib.exp ${wl}-h ${wl}$soname -o $lib $libobjs $deplibs $compiler_flags~$RM $lib.exp'
configure:	  archive_expsym_cmds='echo "{ global:" > $lib.exp~cat $export_symbols | $SED -e "s/\(.*\)/\1;/" >> $lib.exp~echo "local: *; };" >> $lib.exp~
configure:	  $LD -G${allow_undefined_flag} -M $lib.exp -h $soname -o $lib $libobjs $deplibs $linker_flags~$RM $lib.exp'
configure:	  archive_expsym_cmds='echo "{ global:" > $lib.exp~cat $export_symbols | $SED -e "s/\(.*\)/\1;/" >> $lib.exp~echo "local: *; };" >> $lib.exp~
configure:	  $CC -G${allow_undefined_flag} -M $lib.exp -h $soname -o $lib $libobjs $deplibs $compiler_flags~$RM $lib.exp'
configure:	  whole_archive_flag_spec='${wl}-z ${wl}allextract$convenience ${wl}-z ${wl}defaultextract'
configure:	  whole_archive_flag_spec='-z allextract$convenience -z defaultextract'
configure:      if test "x$host_vendor" = xsequent; then
configure:	# Use $CC to link under sequent, because it throws in some extra .o
configure:	archive_cmds='$LD -assert pure-text -Bstatic -o $lib $libobjs $deplibs $linker_flags'
configure:      export_dynamic_flag_spec='-Bexport'
configure:    sysv4*uw2* | sysv5OpenUNIX* | sysv5UnixWare7.[01].[10]* | unixware7* | sco3.2v5.0.[024]*)
configure:      no_undefined_flag='${wl}-z,text'
configure:	archive_expsym_cmds='$CC -shared ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
configure:	archive_expsym_cmds='$CC -G ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
configure:      # ever link correctly.  If we're not using GNU ld we use -z text
configure:      no_undefined_flag='${wl}-z,text'
configure:      export_dynamic_flag_spec='${wl}-Bexport'
configure:	archive_expsym_cmds='$CC -shared ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
configure:	archive_expsym_cmds='$CC -G ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
configure:    if test x$host_vendor = xsni; then
configure:	export_dynamic_flag_spec='${wl}-Blargedynsym'
configure:# Do we need to explicitly link libc?
configure:case "x$archive_cmds_need_lc" in
configure:x|xyes)
configure:      { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether -lc should be explicitly linked in" >&5
configure:$as_echo_n "checking whether -lc should be explicitly linked in... " >&6; }
configure:	echo "$lt_simple_compile_test_code" > conftest.$ac_ext
configure:	  libobjs=conftest.$ac_objext
configure:shrext_cmds=".so"
configure:need_lib_prefix=unknown
configure:aix3*)
configure:  version_type=linux # correct to gnu/linux during the next big refactor
configure:  library_names_spec='${libname}${release}${shared_ext}$versuffix $libname.a'
configure:  soname_spec='${libname}${release}${shared_ext}$major'
configure:aix[4-9]*)
configure:  version_type=linux # correct to gnu/linux during the next big refactor
configure:  need_lib_prefix=no
configure:    library_names_spec='${libname}${release}${shared_ext}$major ${libname}${release}${shared_ext}$versuffix $libname${shared_ext}'
configure:    # With GCC up to 2.95.x, collect2 would create an import file
configure:    # depend on `.', always an invalid library.  This was fixed in
configure:      aix4 | aix4.[01] | aix4.[01].*)
configure:    # soname into executable. Probably we can add versioning support to
configure:    if test "$aix_use_runtimelinking" = yes; then
configure:      library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
configure:      # We preserve .a as extension for shared libraries through AIX4.2
configure:      soname_spec='${libname}${release}${shared_ext}$major'
configure:    # When compiling the executable, add -use-dynld -Lsobjs: to the compileline.
configure:    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
configure:    library_names_spec='$libname.ixlibrary $libname.a'
configure:    # Create ${libname}_ixlibrary.a entries in /sys/libs.
configure:    finish_eval='for lib in `ls $libdir/*.ixlibrary 2>/dev/null`; do libname=`func_echo_all "$lib" | $SED '\''s%^.*/\([^/]*\)\.ixlibrary$%\1%'\''`; test $RM /sys/libs/${libname}_ixlibrary.a; $show "cd /sys/libs && $LN_S $lib ${libname}_ixlibrary.a"; cd /sys/libs && $LN_S $lib ${libname}_ixlibrary.a || exit 1; done'
configure:  library_names_spec='${libname}${shared_ext}'
configure:  version_type=linux # correct to gnu/linux during the next big refactor
configure:  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
configure:  soname_spec='${libname}${release}${shared_ext}$major'
configure:  shrext_cmds=".dll"
configure:  need_lib_prefix=no
configure:      chmod a+x \$dldir/$dlname~
configure:        eval '\''$striplib \$dldir/$dlname'\'' || exit \$?;
configure:      # Cygwin DLLs use 'cyg' prefix rather than 'lib'
configure:      soname_spec='`echo ${libname} | sed -e 's/^lib/cyg/'``echo ${release} | $SED -e 's/[.]/-/g'`${versuffix}${shared_ext}'
configure:      # MinGW DLLs use traditional 'lib' prefix
configure:      soname_spec='${libname}`echo ${release} | $SED -e 's/[.]/-/g'`${versuffix}${shared_ext}'
configure:      # pw32 DLLs use 'pw' prefix rather than 'lib'
configure:      library_names_spec='`echo ${libname} | sed -e 's/^lib/pw/'``echo ${release} | $SED -e 's/[.]/-/g'`${versuffix}${shared_ext}'
configure:    dynamic_linker='Win32 ld.exe'
configure:    soname_spec='${libname}`echo ${release} | $SED -e 's/[.]/-/g'`${versuffix}${shared_ext}'
configure:        # Let DOS variable expansion print the short 8.3 style file name.
configure:      # Convert to unix form, then to dos form, then back to unix form
configure:      # but this time dos style (no spaces!) so that the unix form looks
configure:      sys_lib_search_path_spec=`cygpath --path --unix "$LIB"`
configure:      sys_lib_search_path_spec=`cygpath --path --unix "$sys_lib_search_path_spec" | $SED -e "s/$PATH_SEPARATOR/ /g"`
configure:    dynamic_linker='Win32 link.exe'
configure:    library_names_spec='${libname}`echo ${release} | $SED -e 's/[.]/-/g'`${versuffix}${shared_ext} $libname.lib'
configure:    dynamic_linker='Win32 ld.exe'
configure:  # FIXME: first we should search . and the directory the executable is in
configure:  need_lib_prefix=no
configure:  library_names_spec='${libname}${release}${major}$shared_ext ${libname}$shared_ext'
configure:  soname_spec='${libname}${release}${major}$shared_ext'
configure:  shrext_cmds='`test .$module = .yes && echo .so || echo .dylib`'
configure:dgux*)
configure:  version_type=linux # correct to gnu/linux during the next big refactor
configure:  need_lib_prefix=no
configure:  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname$shared_ext'
configure:  soname_spec='${libname}${release}${shared_ext}$major'
configure:  if test -x /usr/bin/objformat; then
configure:      library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext} $libname${shared_ext}'
configure:      need_lib_prefix=no
configure:      library_names_spec='${libname}${release}${shared_ext}$versuffix $libname${shared_ext}$versuffix'
configure:  version_type=linux # correct to gnu/linux during the next big refactor
configure:  need_lib_prefix=no
configure:  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}${major} ${libname}${shared_ext}'
configure:  soname_spec='${libname}${release}${shared_ext}$major'
configure:  version_type=linux # correct to gnu/linux during the next big refactor
configure:  need_lib_prefix=no
configure:  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}${major} ${libname}${shared_ext}'
configure:  soname_spec='${libname}${release}${shared_ext}$major'
configure:hpux9* | hpux10* | hpux11*)
configure:  need_lib_prefix=no
configure:    shrext_cmds='.so'
configure:    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
configure:    soname_spec='${libname}${release}${shared_ext}$major'
configure:      sys_lib_search_path_spec="/usr/lib/hpux32 /usr/local/lib/hpux32 /usr/local/lib"
configure:      sys_lib_search_path_spec="/usr/lib/hpux64 /usr/local/lib/hpux64"
configure:    shrext_cmds='.sl'
configure:    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
configure:    soname_spec='${libname}${release}${shared_ext}$major'
configure:    shrext_cmds='.sl'
configure:    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
configure:    soname_spec='${libname}${release}${shared_ext}$major'
configure:interix[3-9]*)
configure:  version_type=linux # correct to gnu/linux during the next big refactor
configure:  need_lib_prefix=no
configure:  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major ${libname}${shared_ext}'
configure:  soname_spec='${libname}${release}${shared_ext}$major'
configure:  dynamic_linker='Interix 3.x ld.so.1 (PE, like ELF)'
configure:irix5* | irix6* | nonstopux*)
configure:    nonstopux*) version_type=nonstopux ;;
configure:		version_type=linux # correct to gnu/linux during the next big refactor
configure:		version_type=irix
configure:  need_lib_prefix=no
configure:  soname_spec='${libname}${release}${shared_ext}$major'
configure:  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major ${libname}${release}${shared_ext} $libname${shared_ext}'
configure:  irix5* | nonstopux*)
configure:# No shared lib support for Linux oldld, aout, or coff.
configure:linux*oldld* | linux*aout* | linux*coff*)
configure:linux* | k*bsd*-gnu | kopensolaris*-gnu)
configure:  version_type=linux # correct to gnu/linux during the next big refactor
configure:  need_lib_prefix=no
configure:  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
configure:  soname_spec='${libname}${release}${shared_ext}$major'
configure:    cat confdefs.h - <<_ACEOF >conftest.$ac_ext
configure:  if  ($OBJDUMP -p conftest$ac_exeext) 2>/dev/null | grep "RUNPATH.*$libdir" >/dev/null; then :
configure:rm -f core conftest.err conftest.$ac_objext \
configure:    conftest$ac_exeext conftest.$ac_ext
configure:    lt_ld_extra=`awk '/^include / { system(sprintf("cd /etc; cat %s 2>/dev/null", \$2)); skip = 1; } { if (!skip) print \$0; skip = 0; }' < /etc/ld.so.conf | $SED -e 's/#.*//;/^[	 ]*hwcap[	 ]/d;s/[:,	]/ /g;s/=[^=]*$//;s/=[^= ]* / /g;s/"//g;/^$/d' | tr '\n' ' '`
configure:    sys_lib_dlsearch_path_spec="/lib /usr/lib $lt_ld_extra"
configure:  # powerpc, because MkLinux only supported shared libraries with the
configure:  # most powerpc-linux boxes support dynamic linking these days and
configure:  # assume the GNU/Linux dynamic linker is in use.
configure:  dynamic_linker='GNU/Linux ld.so'
configure:  need_lib_prefix=no
configure:    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${shared_ext}$versuffix'
configure:    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major ${libname}${shared_ext}'
configure:    soname_spec='${libname}${release}${shared_ext}$major'
configure:  version_type=linux # correct to gnu/linux during the next big refactor
configure:  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
configure:*nto* | *qnx*)
configure:  version_type=qnx
configure:  need_lib_prefix=no
configure:  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
configure:  soname_spec='${libname}${release}${shared_ext}$major'
configure:  dynamic_linker='ldqnx.so'
configure:  need_lib_prefix=no
configure:  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${shared_ext}$versuffix'
configure:  shrext_cmds=".dll"
configure:  need_lib_prefix=no
configure:  library_names_spec='$libname${shared_ext} $libname.a'
configure:  dynamic_linker='OS/2 ld.exe'
configure:  need_lib_prefix=no
configure:  soname_spec='${libname}${release}${shared_ext}$major'
configure:  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
configure:  version_type=linux # correct to gnu/linux during the next big refactor
configure:  need_lib_prefix=no
configure:  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
configure:  soname_spec='${libname}${release}${shared_ext}$major'
configure:  # ldd complains unless libraries are executable
configure:  postinstall_cmds='chmod +x $lib'
configure:  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${shared_ext}$versuffix'
configure:    need_lib_prefix=no
configure:  version_type=linux # correct to gnu/linux during the next big refactor
configure:  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
configure:  soname_spec='${libname}${release}${shared_ext}$major'
configure:      need_lib_prefix=no
configure:      need_lib_prefix=no
configure:      need_lib_prefix=no
configure:    version_type=linux # correct to gnu/linux during the next big refactor
configure:    library_names_spec='$libname${shared_ext}.$versuffix $libname${shared_ext}.$major $libname${shared_ext}'
configure:    soname_spec='$libname${shared_ext}.$major'
configure:sysv5* | sco3.2v5* | sco5v6* | unixware* | OpenUNIX* | sysv4*uw2*)
configure:  need_lib_prefix=no
configure:  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext} $libname${shared_ext}'
configure:  soname_spec='${libname}${release}${shared_ext}$major'
configure:  # TPF is a cross-target only.  Preferred cross-host = GNU/Linux.
configure:  version_type=linux # correct to gnu/linux during the next big refactor
configure:  need_lib_prefix=no
configure:  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
configure:  version_type=linux # correct to gnu/linux during the next big refactor
configure:  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
configure:  soname_spec='${libname}${release}${shared_ext}$major'
configure:  # We can hardcode non-existent directories.
configure:    # We can link without hardcoding, and we can hardcode nonexisting dirs.
configure:  # We cannot hardcode anything, or else we can only hardcode existing
configure:  if test "x$enable_dlopen" != xyes; then
configure:cat confdefs.h - <<_ACEOF >conftest.$ac_ext
configure:extern "C"
configure:rm -f core conftest.err conftest.$ac_objext \
configure:    conftest$ac_exeext conftest.$ac_ext
configure:if test "x$ac_cv_lib_dl_dlopen" = xyes; then :
configure:if test "x$ac_cv_func_shl_load" = xyes; then :
configure:cat confdefs.h - <<_ACEOF >conftest.$ac_ext
configure:extern "C"
configure:rm -f core conftest.err conftest.$ac_objext \
configure:    conftest$ac_exeext conftest.$ac_ext
configure:if test "x$ac_cv_lib_dld_shl_load" = xyes; then :
configure:if test "x$ac_cv_func_dlopen" = xyes; then :
configure:cat confdefs.h - <<_ACEOF >conftest.$ac_ext
configure:extern "C"
configure:rm -f core conftest.err conftest.$ac_objext \
configure:    conftest$ac_exeext conftest.$ac_ext
configure:if test "x$ac_cv_lib_dl_dlopen" = xyes; then :
configure:cat confdefs.h - <<_ACEOF >conftest.$ac_ext
configure:extern "C"
configure:rm -f core conftest.err conftest.$ac_objext \
configure:    conftest$ac_exeext conftest.$ac_ext
configure:if test "x$ac_cv_lib_svld_dlopen" = xyes; then :
configure:cat confdefs.h - <<_ACEOF >conftest.$ac_ext
configure:extern "C"
configure:rm -f core conftest.err conftest.$ac_objext \
configure:    conftest$ac_exeext conftest.$ac_ext
configure:if test "x$ac_cv_lib_dld_dld_link" = xyes; then :
configure:  if test "x$lt_cv_dlopen" != xno; then
configure:    test "x$ac_cv_header_dlfcn_h" = xyes && CPPFLAGS="$CPPFLAGS -DHAVE_DLFCN_H"
configure:    wl=$lt_prog_compiler_wl eval LDFLAGS=\"\$LDFLAGS $export_dynamic_flag_spec\"
configure:  cat > conftest.$ac_ext <<_LT_EOF
configure:  test $ac_status = 0; } && test -s conftest${ac_exeext} 2>/dev/null; then
configure:    (./conftest; exit; ) >&5 2>/dev/null
configure:    case x$lt_status in
configure:      x$lt_dlno_uscore) lt_cv_dlopen_self=yes ;;
configure:      x$lt_dlneed_uscore) lt_cv_dlopen_self=yes ;;
configure:      x$lt_dlunknown|x*) lt_cv_dlopen_self=no ;;
configure:    if test "x$lt_cv_dlopen_self" = xyes; then
configure:  cat > conftest.$ac_ext <<_LT_EOF
configure:  test $ac_status = 0; } && test -s conftest${ac_exeext} 2>/dev/null; then
configure:    (./conftest; exit; ) >&5 2>/dev/null
configure:    case x$lt_status in
configure:      x$lt_dlno_uscore) lt_cv_dlopen_self_static=yes ;;
configure:      x$lt_dlneed_uscore) lt_cv_dlopen_self_static=yes ;;
configure:      x$lt_dlunknown|x*) lt_cv_dlopen_self_static=no ;;
configure:      striplib="$STRIP -x"
configure:  aix3*)
configure:  aix[4-9]*)
configure:    if test "$host_cpu" != ia64 && test "$aix_use_runtimelinking" = no ; then
configure:ac_ext=c
configure:ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
configure:ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
configure:# Only expand once:
configure:      cat confdefs.h - <<_ACEOF >conftest.$ac_ext
configure:rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
configure:  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
configure:rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
configure:  # SunOS 4.x string.h does not declare mem*, contrary to ANSI.
configure:  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
configure:if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
configure:  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
configure:if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
configure:  # /bin/cc in Irix-4.0.5 gets non-ANSI ctype macros unless using -ansi.
configure:  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
configure:#if ((' ' & 0x0FF) == 0x020)
configure:# define TOUPPER(c) (ISLOWER(c) ? ((c) | 0x40) : (c))
configure:rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext \
configure:  conftest.$ac_objext conftest.beam conftest.$ac_ext
configure:  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
configure:  /* Ultrix mips cc rejects this sort of thing.  */
configure:  struct point {int x, y;};
configure:     an arm of an if-expression whose if-part is not a constant
configure:     expression */
configure:    char tx;
configure:    char *t = &tx;
configure:    int x[] = {25, 17};
configure:    const int *foo = &x[0];
configure:    struct s { int j; const int *ap[3]; } bx;
configure:    struct s *b = &bx; b->j = 5;
configure:  return !cs[0] && !zero.x;
configure:rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
configure:if test "x$ac_cv_type_size_t" = xyes; then :
configure:  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
configure:rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
configure:     cat confdefs.h - <<_ACEOF >conftest.$ac_ext
configure:rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
configure:  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
configure:    /* Some versions of Linux strtod mis-parse strings with leading '+'.  */
configure:rm -f core *.core core.conftest.* gmon.out bb.out conftest$ac_exeext \
configure:  conftest.$ac_objext conftest.beam conftest.$ac_ext
configure:  *" strtod.$ac_objext "* ) ;;
configure:  *) LIBOBJS="$LIBOBJS strtod.$ac_objext"
configure:if test "x$ac_cv_func_pow" = xyes; then :
configure:cat confdefs.h - <<_ACEOF >conftest.$ac_ext
configure:extern "C"
configure:rm -f core conftest.err conftest.$ac_objext \
configure:    conftest$ac_exeext conftest.$ac_ext
configure:if test "x$ac_cv_lib_m_pow" = xyes; then :
configure:if test "x$ac_cv_func_memset" = xyes; then :
configure:if test "x$ac_cv_func_pow" = xyes; then :
configure:cat confdefs.h - <<_ACEOF >conftest.$ac_ext
configure:extern "C"
configure:rm -f core conftest.err conftest.$ac_objext \
configure:    conftest$ac_exeext conftest.$ac_ext
configure:if test "x$ac_cv_lib_m_pow" = xyes; then :
configure:# Check whether --with-zlib-prefix was given.
configure:if test "${with_zlib_prefix+set}" = set; then :
configure:  withval=$with_zlib_prefix; ZPREFIX=${withval}
configure:cat confdefs.h - <<_ACEOF >conftest.$ac_ext
configure:extern "C"
configure:rm -f core conftest.err conftest.$ac_objext \
configure:    conftest$ac_exeext conftest.$ac_ext
configure:if test "x$ac_cv_lib_z_zlibVersion" = xyes; then :
configure:cat confdefs.h - <<_ACEOF >conftest.$ac_ext
configure:extern "C"
configure:rm -f core conftest.err conftest.$ac_objext \
configure:    conftest$ac_exeext conftest.$ac_ext
configure:if eval test \"x\$"$as_ac_Lib"\" = x"yes"; then :
configure:# platforms that don't enable FP exceptions, the function appears in the math
configure:{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for feenableexcept in -lm" >&5
configure:$as_echo_n "checking for feenableexcept in -lm... " >&6; }
configure:if ${ac_cv_lib_m_feenableexcept+:} false; then :
configure:cat confdefs.h - <<_ACEOF >conftest.$ac_ext
configure:extern "C"
configure:char feenableexcept ();
configure:return feenableexcept ();
configure:  ac_cv_lib_m_feenableexcept=yes
configure:  ac_cv_lib_m_feenableexcept=no
configure:rm -f core conftest.err conftest.$ac_objext \
configure:    conftest$ac_exeext conftest.$ac_ext
configure:{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_m_feenableexcept" >&5
configure:$as_echo "$ac_cv_lib_m_feenableexcept" >&6; }
configure:if test "x$ac_cv_lib_m_feenableexcept" = xyes; then :
configure:for ac_func in feenableexcept
configure:  ac_fn_c_check_func "$LINENO" "feenableexcept" "ac_cv_func_feenableexcept"
configure:if test "x$ac_cv_func_feenableexcept" = xyes; then :
configure:*cygwin* | *mingw32* | *interix* )
configure:    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for symbol prefix" >&5
configure:$as_echo_n "checking for symbol prefix... " >&6; }
configure:# Support for prefixes to the API function names; this will generate defines
configure:# at the start of the build to rename exported library functions
configure:# Check whether --with-libpng-prefix was given.
configure:if test "${with_libpng_prefix+set}" = set; then :
configure:  withval=$with_libpng_prefix; if test "${withval:-no}" != "no"; then
configure: if test "${with_libpng_prefix:-no}" != "no"; then
configure:# where ARM optimizations were explicitly requested (this allows a fallback if a
configure:{ $as_echo "$as_me:${as_lineno-$LINENO}: Extra options for compiler: $PNG_COPTS" >&5
configure:$as_echo "$as_me: Extra options for compiler: $PNG_COPTS" >&6;}
configure:# Ultrix sh set writes to stderr and can't be redirected directly,
configure:    if test "x$cache_file" != "x/dev/null"; then
configure:test "x$prefix" = xNONE && prefix=$ac_default_prefix
configure:# Let make expand exec_prefix.
configure:test "x$exec_prefix" = xNONE && exec_prefix='${prefix}'
configure:for ac_i in : $LIBOBJS; do test "x$ac_i" = x: && continue
configure:  # 1. Remove the extension, and $U if already installed.
configure:  as_fn_append ac_libobjs " \${LIBOBJDIR}$ac_i\$U.$ac_objext"
configure:# configure, is in config.log if it exists.
configure:export SHELL
configure:DUALCASE=1; export DUALCASE # for MKS sh
configure:  *posix*) :
configure:    set -o posix ;; #(
configure:export as_nl
configure:# Prefer a ksh shell builtin over an external printf program on Solaris,
configure:    as_echo_body='eval expr "X$1" : "X\\(.*\\)"'
configure:	expr "X$arg" : "X\\(.*\\)$as_nl";
configure:	arg=`expr "X$arg" : ".*$as_nl\\(.*\\)"`;;
configure:      expr "X$arg" : "X\\(.*\\)" | tr -d "$as_nl"
configure:    export as_echo_n_body
configure:  export as_echo_body
configure:if test "x$as_myself" = x; then
configure:  exit 1
configure:# pre-3.0 UWIN ksh).  But do not cause bugs in bash 2.01; the "|| exit 1"
configure:do eval test x\${$as_var+set} = xset \
configure:  && ( (unset $as_var) || exit 1) >/dev/null 2>&1 && unset $as_var || :
configure:export LC_ALL
configure:export LANGUAGE
configure:# provided, also output the error to LOG_FD, referencing LINENO. Then exit the
configure:  as_fn_exit $as_status
configure:# as_fn_exit STATUS
configure:# Exit the shell with STATUS, even in a "trap 0" or "set -e" context.
configure:as_fn_exit ()
configure:  exit $1
configure:} # as_fn_exit
configure:# Append the text in VALUE to the end of the definition contained in VAR. Take
configure:if (eval "as_var=1; as_var+=2; test x\$as_var = x12") 2>/dev/null; then :
configure:# must be portable across $(()) and expr.
configure:    as_val=`expr "$@" || test $? -eq 1`
configure:if expr a : '\(a\)' >/dev/null 2>&1 &&
configure:   test "X`expr 00001 : '.*\(...\)'`" = X001; then
configure:  as_expr=expr
configure:  as_expr=false
configure:$as_expr X/"$0" : '.*/\([^/][^/]*\)/*$' \| \
configure:as_cr_letters='abcdefghijklmnopqrstuvwxyz'
configure:case `echo -n x` in #(((((
configure:  case `echo 'xy\c'` in
configure:  xy)  ECHO_C='\c';;
configure:rm -f conf$$ conf$$.exe conf$$.file
configure:    # 2) DJGPP < 2.04 has no symlinks; `ln -s' creates a wrapper executable.
configure:    ln -s conf$$.file conf$$.dir 2>/dev/null && test ! -f conf$$.exe ||
configure:rm -f conf$$ conf$$.exe conf$$.dir/conf$$.file conf$$.file
configure:$as_expr X"$as_dir" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
configure:# as_fn_executable_p FILE
configure:# Test if FILE is an executable regular file.
configure:as_fn_executable_p ()
configure:  test -f "$1" && test -x "$1"
configure:} # as_fn_executable_p
configure:as_test_x='test -x'
configure:as_executable_p=as_fn_executable_p
configure:# Sed expression to map a string onto a valid CPP name.
configure:# Sed expression to map a string onto a valid variable name.
configure:exec 6>&1
configure:test $as_write_fail = 0 && chmod +x $CONFIG_STATUS || ac_write_fail=1
configure:This file was extended by libpng $as_me 1.6.16, which was
configure:"*) set x $ac_config_files; shift; ac_config_files=$*;;
configure:"*) set x $ac_config_headers; shift; ac_config_headers=$*;;
configure:  -h, --help       print this help, then exit
configure:  -V, --version    print version number and configuration settings, then exit
configure:      --config     print configuration, then exit
configure:    ac_option=`expr "X$1" : 'X\([^=]*\)='`
configure:    ac_optarg=`expr "X$1" : 'X[^=]*=\(.*\)'`
configure:    ac_option=`expr "X$1" : 'X\([^=]*\)='`
configure:    $as_echo "$ac_cs_version"; exit ;;
configure:    $as_echo "$ac_cs_config"; exit ;;
configure:    $as_echo "$ac_cs_usage"; exit ;;
configure:ac_configure_extra_args=
configure:  exec 6>/dev/null
configure:  ac_configure_extra_args="$ac_configure_extra_args --silent"
configure:  set X $SHELL '$0' $ac_configure_args \$ac_configure_extra_args --no-create --no-recursion
configure:  export CONFIG_SHELL
configure:  exec "\$@"
configure:exec 5>>config.log
configure:  sed 'h;s/./-/g;s/^.../## /;s/...$/ ##/;p;x;p;x' <<_ASBOX
configure:AMDEP_TRUE="$AMDEP_TRUE" ac_aux_dir="$ac_aux_dir"
configure:max_cmd_len='`$ECHO "$max_cmd_len" | $SED "$delay_single_quote_subst"`'
configure:ac_objext='`$ECHO "$ac_objext" | $SED "$delay_single_quote_subst"`'
configure:exeext='`$ECHO "$exeext" | $SED "$delay_single_quote_subst"`'
configure:lock_old_archive_extraction='`$ECHO "$lock_old_archive_extraction" | $SED "$delay_single_quote_subst"`'
configure:lt_cv_sys_global_symbol_to_c_name_address_lib_prefix='`$ECHO "$lt_cv_sys_global_symbol_to_c_name_address_lib_prefix" | $SED "$delay_single_quote_subst"`'
configure:libext='`$ECHO "$libext" | $SED "$delay_single_quote_subst"`'
configure:shrext_cmds='`$ECHO "$shrext_cmds" | $SED "$delay_single_quote_subst"`'
configure:extract_expsyms_cmds='`$ECHO "$extract_expsyms_cmds" | $SED "$delay_single_quote_subst"`'
configure:export_dynamic_flag_spec='`$ECHO "$export_dynamic_flag_spec" | $SED "$delay_single_quote_subst"`'
configure:old_archive_from_expsyms_cmds='`$ECHO "$old_archive_from_expsyms_cmds" | $SED "$delay_single_quote_subst"`'
configure:archive_expsym_cmds='`$ECHO "$archive_expsym_cmds" | $SED "$delay_single_quote_subst"`'
configure:module_expsym_cmds='`$ECHO "$module_expsym_cmds" | $SED "$delay_single_quote_subst"`'
configure:always_export_symbols='`$ECHO "$always_export_symbols" | $SED "$delay_single_quote_subst"`'
configure:export_symbols_cmds='`$ECHO "$export_symbols_cmds" | $SED "$delay_single_quote_subst"`'
configure:exclude_expsyms='`$ECHO "$exclude_expsyms" | $SED "$delay_single_quote_subst"`'
configure:include_expsyms='`$ECHO "$include_expsyms" | $SED "$delay_single_quote_subst"`'
configure:need_lib_prefix='`$ECHO "$need_lib_prefix" | $SED "$delay_single_quote_subst"`'
configure:lt_cv_sys_global_symbol_to_c_name_address_lib_prefix \
configure:shrext_cmds \
configure:export_dynamic_flag_spec \
configure:exclude_expsyms \
configure:include_expsyms \
configure:extract_expsyms_cmds \
configure:old_archive_from_expsyms_cmds \
configure:archive_expsym_cmds \
configure:module_expsym_cmds \
configure:export_symbols_cmds \
configure:ac_aux_dir='$ac_aux_dir'
configure:xsi_shell='$xsi_shell'
configure:# We use the long form for the default assignment because of an extremely
configure:  trap 'exit_status=$?
configure:  { test ! -d "$ac_tmp" || rm -fr "$ac_tmp"; } && exit $exit_status
configure:  trap 'as_fn_exit 1' 1 2 13 15
configure:if test "x$ac_cr" = x; then
configure:if test "x$srcdir" = x.; then
configure:x
configure:# Create a delimiter string that does not exist in confdefs.h, to ease
configure:  prefix = substr(line, 1, index(line, defundef) - 1)
configure:    print prefix "define", macro P[macro] D[macro]
configure:    next
configure:    # Replace #undef with comments.  This is necessary, for example,
configure:      print "/*", prefix defundef, macro, "*/"
configure:      next
configure:  set x $ac_tag
configure:    if test x"$ac_file" != x-; then
configure:$as_expr X"$ac_file" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
configure:.) ac_dir_suffix= ac_top_builddir_sub=. ac_top_build_prefix= ;;
configure:  ac_dir_suffix=/`$as_echo "$ac_dir" | sed 's|^\.[\\/]||'`
configure:  # A ".." for each directory in $ac_dir_suffix.
configure:  ac_top_builddir_sub=`$as_echo "$ac_dir_suffix" | sed 's|/[^\\/]*|/..|g;s|/||'`
configure:  "") ac_top_builddir_sub=. ac_top_build_prefix= ;;
configure:  *)  ac_top_build_prefix=$ac_top_builddir_sub/ ;;
configure:ac_abs_builddir=$ac_pwd$ac_dir_suffix
configure:ac_top_builddir=$ac_top_build_prefix
configure:    ac_srcdir=$srcdir$ac_dir_suffix;
configure:    ac_srcdir=$ac_top_build_prefix$srcdir$ac_dir_suffix
configure:    ac_top_srcdir=$ac_top_build_prefix$srcdir
configure:ac_abs_srcdir=$ac_abs_top_srcdir$ac_dir_suffix
configure:  *) ac_INSTALL=$ac_top_build_prefix$INSTALL ;;
configure:  */*) ac_MKDIR_P=$ac_top_build_prefix$MKDIR_P ;;
configure:# If the template does not know about datarootdir, expand it.
configure:# Shell code in configure.ac might set extrasub.
configure:ac_sed_extra="$ac_vpsub
configure:$extrasub
configure:s&@top_build_prefix@&$ac_top_build_prefix&;t t
configure:eval sed \"\$ac_sed_extra\" "$ac_file_inputs" | $AWK -f "$ac_tmp/subs.awk" \
configure:  if test x"$ac_file" != x-; then
configure:# Compute "$ac_file"'s index in $config_headers.
configure:      _am_stamp_count=`expr $_am_stamp_count + 1` ;;
configure:$as_expr X"$_am_arg" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
configure:  :C)  { $as_echo "$as_me:${as_lineno-$LINENO}: executing $ac_file commands" >&5
configure:$as_echo "$as_me: executing $ac_file commands" >&6;}
configure:    "depfiles":C) test x"$AMDEP_TRUE" != x"" || {
configure:  *\'*) eval set x "$CONFIG_FILES" ;;
configure:  *)   set x $CONFIG_FILES ;;
configure:$as_expr X"$mf" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
configure:    # Extract the definition of DEPDIR, am__include, and am__quote
configure:    # expansion.
configure:      # Make sure the directory exists.
configure:$as_expr X"$file" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
configure:    trap "$RM \"$cfgfile\"; exit 1" 1 2 15
configure:# As a special exception to the GNU General Public License,
configure:# What is the maximum length of a command?
configure:max_cmd_len=$max_cmd_len
configure:# Object file suffix (normally "o").
configure:objext=$ac_objext
configure:# Executable file suffix (normally "").
configure:exeext=$exeext
configure:# Whether to use a lock for old archive extraction.
configure:lock_old_archive_extraction=$lock_old_archive_extraction
configure:# Transform the output of nm in a C name address pair when lib prefix is needed.
configure:global_symbol_to_c_name_address_lib_prefix=$lt_lt_cv_sys_global_symbol_to_c_name_address_lib_prefix
configure:# Used to examine libraries when file_magic_cmd begins with "file".
configure:# Old archive suffix (normally "a").
configure:libext=$libext
configure:# Shared library suffix (normally ".so").
configure:shrext_cmds=$lt_shrext_cmds
configure:# The commands to extract the exported symbol list from a shared archive.
configure:extract_expsyms_cmds=$lt_extract_expsyms_cmds
configure:# Do we need the "lib" prefix for modules?
configure:need_lib_prefix=$need_lib_prefix
configure:# Format of library name prefix.
configure:# As "finish_cmds", except a single script fragment to be evaled but
configure:# Compiler flag to allow reflexive dlopens.
configure:export_dynamic_flag_spec=$lt_export_dynamic_flag_spec
configure:old_archive_from_expsyms_cmds=$lt_old_archive_from_expsyms_cmds
configure:archive_expsym_cmds=$lt_archive_expsym_cmds
configure:module_expsym_cmds=$lt_module_expsym_cmds
configure:# This must work even if \$libdir does not exist
configure:# Set to "yes" if using DIR/libNAME\${shared_ext} during linking hardcodes
configure:# Set to "yes" if using DIR/libNAME\${shared_ext} during linking hardcodes
configure:# into the library and all subsequent libraries and executables linked
configure:# Set to "yes" if exported symbols are required.
configure:always_export_symbols=$always_export_symbols
configure:# The commands to list exported symbols.
configure:export_symbols_cmds=$lt_export_symbols_cmds
configure:exclude_expsyms=$lt_exclude_expsyms
configure:# Symbols that must always be exported.
configure:include_expsyms=$lt_include_expsyms
configure:# How to hardcode a shared library path into an executable.
configure:  aix3*)
configure:  export COLLECT_NAMES
configure:ltmain="$ac_aux_dir/ltmain.sh"
configure:  # if finds mixed CR/LF and LF-only lines.  Since sed operates in
configure:  # text mode, it properly converts lines to CR/LF.  This bash problem
configure:  # is reportedly fixed, but why not run on old versions too?
configure:     || (rm -f "$cfgfile"; exit 1)
configure:  if test x"$xsi_shell" = xyes; then
configure:} # Extended-shell func_dirname implementation' "$cfgfile" > $cfgfile.tmp \
configure:} # Extended-shell func_basename implementation' "$cfgfile" > $cfgfile.tmp \
configure:} # Extended-shell func_dirname_and_basename implementation' "$cfgfile" > $cfgfile.tmp \
configure:} # Extended-shell func_stripname implementation' "$cfgfile" > $cfgfile.tmp \
configure:} # Extended-shell func_split_long_opt implementation' "$cfgfile" > $cfgfile.tmp \
configure:} # Extended-shell func_split_short_opt implementation' "$cfgfile" > $cfgfile.tmp \
configure:\      *.lo) func_lo2o_result=${1%.lo}.${objext} ;;\
configure:} # Extended-shell func_lo2o implementation' "$cfgfile" > $cfgfile.tmp \
configure:  sed -e '/^func_xform ()$/,/^} # func_xform /c\
configure:func_xform ()\
configure:    func_xform_result=${1%.*}.lo\
configure:} # Extended-shell func_xform implementation' "$cfgfile" > $cfgfile.tmp \
configure:} # Extended-shell func_arith implementation' "$cfgfile" > $cfgfile.tmp \
configure:} # Extended-shell func_len implementation' "$cfgfile" > $cfgfile.tmp \
configure:if test x"$lt_shell_append" = xyes; then
configure:} # Extended-shell func_append implementation' "$cfgfile" > $cfgfile.tmp \
configure:} # Extended-shell func_append_quoted implementation' "$cfgfile" > $cfgfile.tmp \
configure:if test x"$_lt_function_replace_fail" = x":"; then
configure:  { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: Unable to substitute extended shell functions in $ofile" >&5
configure:$as_echo "$as_me: WARNING: Unable to substitute extended shell functions in $ofile" >&2;}
configure:  chmod +x "$ofile"
configure:    "libpng-config":F) chmod +x libpng-config ;;
configure:as_fn_exit 0
configure:# output is simply discarded.  So we exec the FD to /dev/null,
configure:  exec 5>/dev/null
configure:  exec 5>>config.log
configure:  # Use ||, not &&, to avoid exiting from the if with $? = 1, which
configure:  $ac_cs_success || as_fn_exit 1
configure.ac:# dist-xz requires automake 1.11 or later
configure.ac:# 1.12.2 fixes a security issue in 1.11.2 and 1.12.1
configure.ac:AM_INIT_AUTOMAKE([1.13 foreign dist-xz color-tests silent-rules subdir-objects])
configure.ac:dnl configure.ac and Makefile.am expect automake 1.11.2 or a compatible later
configure.ac:AC_ARG_WITH(zlib-prefix,
configure.ac:   AS_HELP_STRING([[[--with-zlib-prefix]]],
configure.ac:      [prefix that may have been used in installed zlib]),
configure.ac:# platforms that don't enable FP exceptions, the function appears in the math
configure.ac:AC_CHECK_LIB([m], [feenableexcept])
configure.ac:AC_CHECK_FUNCS([feenableexcept])
configure.ac:*cygwin* | *mingw32* | *interix* )
configure.ac:    AC_MSG_CHECKING([for symbol prefix])
configure.ac:# Support for prefixes to the API function names; this will generate defines
configure.ac:# at the start of the build to rename exported library functions
configure.ac:AC_ARG_WITH(libpng-prefix,
configure.ac:   AS_HELP_STRING([[[--with-libpng-prefix]]],
configure.ac:      [prefix libpng exported function (API) names with the given value]),
configure.ac:AM_CONDITIONAL([DO_PNG_PREFIX], [test "${with_libpng_prefix:-no}" != "no"])
configure.ac:# where ARM optimizations were explicitly requested (this allows a fallback if a
configure.ac:AC_MSG_NOTICE([[Extra options for compiler: $PNG_COPTS]])
configure.ac:   [chmod +x libpng-config])
contrib/conftest/read.dfa:#  To the extent possible under law, the author has waived all copyright and
contrib/conftest/read.dfa:# Likewise it is pointless enabling both fixed and floating point APIs.  Choose
contrib/conftest/read.dfa:#Fixed point:
contrib/conftest/read.dfa:# If your app always expands the image to a limited set of bit layouts you
contrib/conftest/README:Examples:
contrib/conftest/README:long (excluding the .dfa extension).  Submitted .dfa files should have names
contrib/conftest/s_read.dfa:#  To the extent possible under law, the author has waived all copyright and
contrib/conftest/s_read.dfa:# It isn't necessary to chose fixed or floating point for the APIs because the
contrib/conftest/s_read.dfa:# simplified API doesn't need fixed or floating point numbers.  It is necessary
contrib/conftest/s_read.dfa:# = off') is fixed point - turn the floating point implementation on if you have
contrib/conftest/write.dfa:#  To the extent possible under law, the author has waived all copyright and
contrib/conftest/write.dfa:# Choose fixed or floating point APIs and arithmetic.  The choices are
contrib/conftest/write.dfa:# (perhaps) to make libpng smaller used fixed point throughout.
contrib/conftest/write.dfa:#Fixed point:
contrib/conftest/write.dfa:# you really do write!  For example you might only write sRGB images, sometimes
contrib/conftest/s_write.dfa:#  To the extent possible under law, the author has waived all copyright and
contrib/conftest/s_write.dfa:# It isn't necessary to chose fixed or floating point for the APIs because the
contrib/conftest/s_write.dfa:# simplified API doesn't need fixed or floating point numbers.  It is necessary
contrib/conftest/s_write.dfa:# = off') is fixed point - turn the floating point implementation on if you have
contrib/conftest/simple.dfa:#  To the extent possible under law, the author has waived all copyright and
contrib/conftest/simple.dfa:# It isn't necessary to chose fixed or floating point for the APIs because the
contrib/conftest/simple.dfa:# simplified API doesn't need fixed or floating point numbers.  It is necessary
contrib/conftest/simple.dfa:# = off') is fixed point - turn the floating point implementation on if you have
contrib/visupng/VisualPng.dsp:# TARGTYPE "Win32 (x86) Application" 0x0101
contrib/visupng/VisualPng.dsp:!MESSAGE use the Export Makefile command and run
contrib/visupng/VisualPng.dsp:!MESSAGE by defining the macro CFG on the command line. For example:
contrib/visupng/VisualPng.dsp:!MESSAGE "VisualPng - Win32 Release" (based on "Win32 (x86) Application")
contrib/visupng/VisualPng.dsp:!MESSAGE "VisualPng - Win32 Debug" (based on "Win32 (x86) Application")
contrib/visupng/VisualPng.dsp:CPP=cl.exe
contrib/visupng/VisualPng.dsp:MTL=midl.exe
contrib/visupng/VisualPng.dsp:RSC=rc.exe
contrib/visupng/VisualPng.dsp:# PROP BASE Ignore_Export_Lib 0
contrib/visupng/VisualPng.dsp:# PROP Ignore_Export_Lib 0
contrib/visupng/VisualPng.dsp:# ADD BASE RSC /l 0x409 /d "NDEBUG"
contrib/visupng/VisualPng.dsp:# ADD RSC /l 0x409 /d "NDEBUG"
contrib/visupng/VisualPng.dsp:BSC32=bscmake.exe
contrib/visupng/VisualPng.dsp:LINK32=link.exe
contrib/visupng/VisualPng.dsp:PostBuild_Cmds=$(outdir)\VisualPng.exe ..\..\contrib\pngsuite\basn6a16.png
contrib/visupng/VisualPng.dsp:# PROP BASE Ignore_Export_Lib 0
contrib/visupng/VisualPng.dsp:# PROP Ignore_Export_Lib 0
contrib/visupng/VisualPng.dsp:# ADD BASE RSC /l 0x409 /d "_DEBUG"
contrib/visupng/VisualPng.dsp:# ADD RSC /l 0x409 /d "_DEBUG"
contrib/visupng/VisualPng.dsp:BSC32=bscmake.exe
contrib/visupng/VisualPng.dsp:LINK32=link.exe
contrib/visupng/VisualPng.dsp:PostBuild_Cmds=$(outdir)\VisualPng.exe ..\..\contrib\pngsuite\basn6a16.png
contrib/visupng/VisualPng.dsp:# PROP Default_Filter "cpp;c;cxx;rc;def;r;odl;idl;hpj;bat"
contrib/visupng/VisualPng.dsp:# PROP Default_Filter "h;hpp;hxx;hm;inl"
contrib/visupng/VisualPng.dsp:SOURCE=.\cexcept.h
contrib/visupng/VisualPng.rc:#include "afxres.h"
contrib/visupng/VisualPng.rc:    "#include ""afxres.h""\r\n"
contrib/visupng/VisualPng.rc:        MENUITEM "&Next Image\tCtrl+N",         IDM_FILE_NEXT
contrib/visupng/VisualPng.rc:        MENUITEM "E&xit\tAlt+X",                IDM_FILE_EXIT
contrib/visupng/resource.h:// Next default values for new objects
contrib/visupng/VisualPng.c:        int *pFileIndex);
contrib/visupng/VisualPng.c:BOOL SearchPngList (TCHAR *pFileList, int FileCount, int *pFileIndex,
contrib/visupng/VisualPng.c:        PTSTR pstrPrevName, PTSTR pstrNextName);
contrib/visupng/VisualPng.c:        png_byte **ppbImage, int *pxImgSize, int *pyImgSize, int *piChannels,
contrib/visupng/VisualPng.c:        BYTE **ppDiData, int cxWinSize, int cyWinSize,
contrib/visupng/VisualPng.c:        BYTE *pbImage, int cxImgSize, int cyImgSize, int cImgChannels,
contrib/visupng/VisualPng.c:        BYTE *pDiData, int cxWinSize, int cyWinSize);
contrib/visupng/VisualPng.c:        BYTE *pDiData, int cxWinSize, int cyWinSize,
contrib/visupng/VisualPng.c:        BYTE *pbImage, int cxImgSize, int cyImgSize, int cImgChannels,
contrib/visupng/VisualPng.c:    int ixBorders, iyBorders;
contrib/visupng/VisualPng.c:    wndclass.cbClsExtra    = 0;
contrib/visupng/VisualPng.c:    wndclass.cbWndExtra    = 0;
contrib/visupng/VisualPng.c:        MessageBox (NULL, TEXT ("Error: this program requires Windows NT!"),
contrib/visupng/VisualPng.c:    ixBorders = 2 * (GetSystemMetrics (SM_CXBORDER) +
contrib/visupng/VisualPng.c:        512 + 2 * MARGIN + ixBorders, 384 + 2 * MARGIN + iyBorders,
contrib/visupng/VisualPng.c:    static int                cxWinSize, cyWinSize;
contrib/visupng/VisualPng.c:    static int                cxImgSize, cyImgSize;
contrib/visupng/VisualPng.c:    static int                iPngFileIndex;
contrib/visupng/VisualPng.c:            /* next/previous commands */
contrib/visupng/VisualPng.c:                          &iPngFileIndex);
contrib/visupng/VisualPng.c:                &pbImage, &cxImgSize, &cyImgSize, &cImgChannels, &bkgColor))
contrib/visupng/VisualPng.c:            DisplayImage (hwnd, &pDib, &pDiData, cxWinSize, cyWinSize,
contrib/visupng/VisualPng.c:                pbImage, cxImgSize, cyImgSize, cImgChannels, bStretched);
contrib/visupng/VisualPng.c:        cxWinSize = LOWORD (lParam);
contrib/visupng/VisualPng.c:        DisplayImage (hwnd, &pDib, &pDiData, cxWinSize, cyWinSize,
contrib/visupng/VisualPng.c:            pbImage, cxImgSize, cyImgSize, cImgChannels, bStretched);
contrib/visupng/VisualPng.c:            /* show the File Open dialog box */
contrib/visupng/VisualPng.c:            /* next/previous commands */
contrib/visupng/VisualPng.c:                          &iPngFileIndex);
contrib/visupng/VisualPng.c:                &pbImage, &cxImgSize, &cyImgSize, &cImgChannels, &bkgColor))
contrib/visupng/VisualPng.c:            DisplayImage (hwnd, &pDib, &pDiData, cxWinSize, cyWinSize,
contrib/visupng/VisualPng.c:                pbImage, cxImgSize, cyImgSize, cImgChannels, bStretched);
contrib/visupng/VisualPng.c:            /* show the File Save dialog box */
contrib/visupng/VisualPng.c:            bOk = PngSaveImage (szImgPathName, pDiData, cxWinSize, cyWinSize,
contrib/visupng/VisualPng.c:                MessageBox (hwnd, TEXT ("Error in saving the PNG image"),
contrib/visupng/VisualPng.c:            /* read next entry in the directory */
contrib/visupng/VisualPng.c:            if (SearchPngList (pPngFileList, iPngFileCount, &iPngFileIndex,
contrib/visupng/VisualPng.c:                        &cxImgSize, &cyImgSize, &cImgChannels, &bkgColor))
contrib/visupng/VisualPng.c:                DisplayImage (hwnd, &pDib, &pDiData, cxWinSize, cyWinSize,
contrib/visupng/VisualPng.c:                    pbImage, cxImgSize, cyImgSize, cImgChannels, bStretched);
contrib/visupng/VisualPng.c:            if (SearchPngList (pPngFileList, iPngFileCount, &iPngFileIndex,
contrib/visupng/VisualPng.c:                if (!LoadImageFile (hwnd, szImgPathName, &pbImage, &cxImgSize,
contrib/visupng/VisualPng.c:                DisplayImage (hwnd, &pDib, &pDiData, cxWinSize, cyWinSize,
contrib/visupng/VisualPng.c:                    pbImage, cxImgSize, cyImgSize, cImgChannels, bStretched);
contrib/visupng/VisualPng.c:            exit (0);
contrib/visupng/VisualPng.c:            DisplayImage (hwnd, &pDib, &pDiData, cxWinSize, cyWinSize,
contrib/visupng/VisualPng.c:                pbImage, cxImgSize, cyImgSize, cImgChannels, bStretched);
contrib/visupng/VisualPng.c:            DialogBox (hInstance, TEXT ("AboutBox"), hwnd, AboutDlgProc) ;
contrib/visupng/VisualPng.c:            SetDIBitsToDevice (hdc, 0, 0, cxWinSize, cyWinSize, 0, 0,
contrib/visupng/VisualPng.c:   int     xNew, yNew;
contrib/visupng/VisualPng.c:   xNew = rParent.left + ((wParent - wChild) /2);
contrib/visupng/VisualPng.c:   if (xNew < rWorkArea.left) {
contrib/visupng/VisualPng.c:      xNew = rWorkArea.left;
contrib/visupng/VisualPng.c:   } else if ((xNew+wChild) > rWorkArea.right) {
contrib/visupng/VisualPng.c:      xNew = rWorkArea.right - wChild;
contrib/visupng/VisualPng.c:   return SetWindowPos (hwndChild, NULL, xNew, yNew, 0, 0, SWP_NOSIZE |
contrib/visupng/VisualPng.c:     int *pFileIndex)
contrib/visupng/VisualPng.c:    /* extract foldername, filename and search-name */
contrib/visupng/VisualPng.c:        bOk = FindNextFile(hFind, &finddata);
contrib/visupng/VisualPng.c:            *pFileIndex = i;
contrib/visupng/VisualPng.c:        bOk = FindNextFile(hFind, &finddata);
contrib/visupng/VisualPng.c:                if (*pFileIndex == i)
contrib/visupng/VisualPng.c:                    *pFileIndex = j;
contrib/visupng/VisualPng.c:                    if (*pFileIndex == j)
contrib/visupng/VisualPng.c:                        *pFileIndex = i;
contrib/visupng/VisualPng.c:        TCHAR *pFileList, int FileCount, int *pFileIndex,
contrib/visupng/VisualPng.c:        PTSTR pstrPrevName, PTSTR pstrNextName)
contrib/visupng/VisualPng.c:            if (*pFileIndex > 0)
contrib/visupng/VisualPng.c:                *pFileIndex -= 1;
contrib/visupng/VisualPng.c:                *pFileIndex = FileCount - 1;
contrib/visupng/VisualPng.c:            strcpy (pstrPrevName, pFileList + (*pFileIndex * MAX_PATH));
contrib/visupng/VisualPng.c:        /* get next entry */
contrib/visupng/VisualPng.c:        if (pstrNextName != NULL)
contrib/visupng/VisualPng.c:            if (*pFileIndex < FileCount - 1)
contrib/visupng/VisualPng.c:                *pFileIndex += 1;
contrib/visupng/VisualPng.c:                *pFileIndex = 0;
contrib/visupng/VisualPng.c:            strcpy (pstrNextName, pFileList + (*pFileIndex * MAX_PATH));
contrib/visupng/VisualPng.c:                png_byte **ppbImage, int *pxImgSize, int *pyImgSize,
contrib/visupng/VisualPng.c:    /* if there's an existing PNG, free the memory */
contrib/visupng/VisualPng.c:    PngLoadImage (pstrPathName, ppbImage, pxImgSize, pyImgSize, piChannels,
contrib/visupng/VisualPng.c:        SetWindowText (hwnd, szTmp);
contrib/visupng/VisualPng.c:        MessageBox (hwnd, TEXT ("Error in loading the PNG image"),
contrib/visupng/VisualPng.c:        BYTE **ppDiData, int cxWinSize, int cyWinSize,
contrib/visupng/VisualPng.c:        BYTE *pbImage, int cxImgSize, int cyImgSize, int cImgChannels,
contrib/visupng/VisualPng.c:    wDIRowBytes = (WORD) ((3 * cxWinSize + 3L) >> 2) << 2;
contrib/visupng/VisualPng.c:        MessageBox (hwnd, TEXT ("Error in displaying the PNG image"),
contrib/visupng/VisualPng.c:    pbmih->biWidth = cxWinSize;
contrib/visupng/VisualPng.c:    InitBitmap (pDiData, cxWinSize, cyWinSize);
contrib/visupng/VisualPng.c:            pDiData, cxWinSize, cyWinSize,
contrib/visupng/VisualPng.c:            pbImage, cxImgSize, cyImgSize, cImgChannels,
contrib/visupng/VisualPng.c:BOOL InitBitmap (BYTE *pDiData, int cxWinSize, int cyWinSize)
contrib/visupng/VisualPng.c:    int x, y, col;
contrib/visupng/VisualPng.c:        for (x = 0; x < cxWinSize; x++)
contrib/visupng/VisualPng.c:        BYTE *pDiData, int cxWinSize, int cyWinSize,
contrib/visupng/VisualPng.c:        BYTE *pbImage, int cxImgSize, int cyImgSize, int cImgChannels,
contrib/visupng/VisualPng.c:    int cxNewSize, cyNewSize;
contrib/visupng/VisualPng.c:    int cxImgPos, cyImgPos;
contrib/visupng/VisualPng.c:    int xImg, yImg;
contrib/visupng/VisualPng.c:    int xWin, yWin;
contrib/visupng/VisualPng.c:    int xOld, yOld;
contrib/visupng/VisualPng.c:    int xNew, yNew;
contrib/visupng/VisualPng.c:        cxNewSize = cxWinSize - 2 * MARGIN;
contrib/visupng/VisualPng.c:/*      if ((cyNewSize / cxNewSize) > (cyImgSize / cxImgSize)) */
contrib/visupng/VisualPng.c:        if ((cyNewSize * cxImgSize) > (cyImgSize * cxNewSize))
contrib/visupng/VisualPng.c:            cyNewSize = cxNewSize * cyImgSize / cxImgSize;
contrib/visupng/VisualPng.c:            cxImgPos = MARGIN;
contrib/visupng/VisualPng.c:            cxNewSize = cyNewSize * cxImgSize / cyImgSize;
contrib/visupng/VisualPng.c:            cxImgPos = (cxWinSize - cxNewSize) / 2;
contrib/visupng/VisualPng.c:        pStretchedImage = malloc (cImgChannels * cxNewSize * cyNewSize);
contrib/visupng/VisualPng.c:            for (xNew = 0; xNew < cxNewSize; xNew++)
contrib/visupng/VisualPng.c:                xOld = xNew * cxImgSize / cxNewSize;
contrib/visupng/VisualPng.c:                r = *(pbImage + cImgChannels * ((yOld * cxImgSize) + xOld) + 0);
contrib/visupng/VisualPng.c:                g = *(pbImage + cImgChannels * ((yOld * cxImgSize) + xOld) + 1);
contrib/visupng/VisualPng.c:                b = *(pbImage + cImgChannels * ((yOld * cxImgSize) + xOld) + 2);
contrib/visupng/VisualPng.c:                    a = *(pbImage + cImgChannels * ((yOld * cxImgSize) + xOld)
contrib/visupng/VisualPng.c:        wImgRowBytes = cImgChannels * cxNewSize;
contrib/visupng/VisualPng.c:        wDIRowBytes = (WORD) ((cDIChannels * cxWinSize + 3L) >> 2) << 2;
contrib/visupng/VisualPng.c:            dst = pDiData + yWin * wDIRowBytes + cxImgPos * cDIChannels;
contrib/visupng/VisualPng.c:            for (xImg = 0, xWin = cxImgPos; xImg < cxNewSize; xImg++, xWin++)
contrib/visupng/VisualPng.c:                if (xWin >= cxWinSize - cxImgPos)
contrib/visupng/VisualPng.c:        cxImgPos = (cxWinSize - cxImgSize) / 2;
contrib/visupng/VisualPng.c:        if (cxImgPos < MARGIN)
contrib/visupng/VisualPng.c:            cxImgPos = MARGIN;
contrib/visupng/VisualPng.c:        wImgRowBytes = cImgChannels * cxImgSize;
contrib/visupng/VisualPng.c:        wDIRowBytes = (WORD) ((cDIChannels * cxWinSize + 3L) >> 2) << 2;
contrib/visupng/VisualPng.c:            dst = pDiData + yWin * wDIRowBytes + cxImgPos * cDIChannels;
contrib/visupng/VisualPng.c:            for (xImg = 0, xWin = cxImgPos; xImg < cxImgSize; xImg++, xWin++)
contrib/visupng/VisualPng.c:                if (xWin >= cxWinSize - MARGIN)
contrib/visupng/cexcept.h:cexcept.h 2.0.1 (2008-Jul-19-Sat)
contrib/visupng/cexcept.h:http://www.nicemice.net/cexcept/
contrib/visupng/cexcept.h:An interface for exception-handling in ANSI C (C89 and subsequent ISO
contrib/visupng/cexcept.h:The cexcept interface is not compatible with and cannot interact
contrib/visupng/cexcept.h:with system exceptions (like division by zero or memory segmentation
contrib/visupng/cexcept.h:violation), compiler-generated exceptions (like C++ exceptions), or
contrib/visupng/cexcept.h:other exception-handling interfaces.
contrib/visupng/cexcept.h:includes this header file and then invokes the define_exception_type
contrib/visupng/cexcept.h:The interface consists of one type, one well-known name, and six macros.
contrib/visupng/cexcept.h:define_exception_type(type_name);
contrib/visupng/cexcept.h:    This macro is used like an external declaration.  It specifies
contrib/visupng/cexcept.h:    the type of object that gets copied from the exception thrower to
contrib/visupng/cexcept.h:    the exception catcher.  The type_name can be any type that can be
contrib/visupng/cexcept.h:    or pointer.  Examples:
contrib/visupng/cexcept.h:        define_exception_type(int);
contrib/visupng/cexcept.h:        enum exception { out_of_memory, bad_arguments, disk_full };
contrib/visupng/cexcept.h:        define_exception_type(enum exception);
contrib/visupng/cexcept.h:        struct exception { int code; const char *msg; };
contrib/visupng/cexcept.h:        define_exception_type(struct exception);
contrib/visupng/cexcept.h:    Because throwing an exception causes the object to be copied (not
contrib/visupng/cexcept.h:    choosing the exception type.
contrib/visupng/cexcept.h:struct exception_context;
contrib/visupng/cexcept.h:    This type may be used after the define_exception_type() macro has
contrib/visupng/cexcept.h:    been invoked.  A struct exception_context must be known to both
contrib/visupng/cexcept.h:    the thrower and the catcher.  It is expected that there be one
contrib/visupng/cexcept.h:    context for each thread that uses exceptions.  It would certainly
contrib/visupng/cexcept.h:    be dangerous for multiple threads to access the same context.
contrib/visupng/cexcept.h:    One thread can use multiple contexts, but that is likely to be
contrib/visupng/cexcept.h:struct exception_context *the_exception_context;
contrib/visupng/cexcept.h:    refer to a context, using the name the_exception_context.  It is
contrib/visupng/cexcept.h:    the address of a mutable (non-constant) struct exception_context
contrib/visupng/cexcept.h:    (inside a function, in a parameter list, or externally), and may
contrib/visupng/cexcept.h:    use whatever storage class specifiers (static, extern, etc) or type
contrib/visupng/cexcept.h:    qualifiers (const, volatile, etc) it likes.  Examples:
contrib/visupng/cexcept.h:        static struct exception_context
contrib/visupng/cexcept.h:          * const the_exception_context = &foo;
contrib/visupng/cexcept.h:        { struct exception_context *the_exception_context = bar; ... }
contrib/visupng/cexcept.h:        int blah(struct exception_context *the_exception_context, ...);
contrib/visupng/cexcept.h:        extern struct exception_context the_exception_context[1];
contrib/visupng/cexcept.h:    The last example illustrates a trick that avoids creating a pointer
contrib/visupng/cexcept.h:    The name could even be a macro, for example:
contrib/visupng/cexcept.h:        struct exception_context ec_array[numthreads];
contrib/visupng/cexcept.h:        #define the_exception_context (ec_array + thread_id)
contrib/visupng/cexcept.h:    Be aware that the_exception_context is used several times by the
contrib/visupng/cexcept.h:    Try/Catch/Throw macros, so it shouldn't be expensive or have side
contrib/visupng/cexcept.h:    effects.  The expansion must be a drop-in replacement for an
contrib/visupng/cexcept.h:void init_exception_context(struct exception_context *ec);
contrib/visupng/cexcept.h:    For context structures allocated statically (by an external
contrib/visupng/cexcept.h:    initialization to all zeros is sufficient, but contexts allocated
contrib/visupng/cexcept.h:    a context more than once (by using this macro on a statically
contrib/visupng/cexcept.h:    allocated context, or using this macro twice on the same context),
contrib/visupng/cexcept.h:    but a context must not be re-initialized after it has been used by a
contrib/visupng/cexcept.h:Catch (expression) statement
contrib/visupng/cexcept.h:    A Try/Catch statement has a syntax similar to an if/else statement,
contrib/visupng/cexcept.h:    except that the parenthesized expression goes after the second
contrib/visupng/cexcept.h:    expression must be a modifiable lvalue (something capable of being
contrib/visupng/cexcept.h:    was passed to define_exception_type().
contrib/visupng/cexcept.h:    If a Throw that uses the same exception context as the Try/Catch is
contrib/visupng/cexcept.h:    executed within the Try clause (typically within a function called
contrib/visupng/cexcept.h:    by the Try clause), and the exception is not caught by a nested
contrib/visupng/cexcept.h:    Try/Catch statement, then a copy of the exception will be assigned
contrib/visupng/cexcept.h:    to the expression, and control will jump to the Catch clause.  If no
contrib/visupng/cexcept.h:    such Throw is executed, then the assignment is not performed, and
contrib/visupng/cexcept.h:    the Catch clause is not executed.
contrib/visupng/cexcept.h:    The expression is not evaluated unless and until the exception is
contrib/visupng/cexcept.h:    caught, which is significant if it has side effects, for example:
contrib/visupng/cexcept.h:    IMPORTANT: Jumping into or out of a Try clause (for example via
contrib/visupng/cexcept.h:    changed within the Try clause are undefined after an exception is
contrib/visupng/cexcept.h:Throw expression;
contrib/visupng/cexcept.h:    A Throw statement is very much like a return statement, except that
contrib/visupng/cexcept.h:    the expression is required.  Whereas return jumps back to the place
contrib/visupng/cexcept.h:    clause of the innermost enclosing Try clause.  The expression must
contrib/visupng/cexcept.h:    be compatible with the type passed to define_exception_type().  The
contrib/visupng/cexcept.h:    exception must be caught, otherwise the program may crash.
contrib/visupng/cexcept.h:    Slight limitation:  If the expression is a comma-expression, it must
contrib/visupng/cexcept.h:    When the value of the exception is not needed, a Try/Catch statement
contrib/visupng/cexcept.h:    can use Catch_anonymous instead of Catch (expression).
contrib/visupng/cexcept.h:#define define_exception_type(etype) \
contrib/visupng/cexcept.h:struct exception_context { \
contrib/visupng/cexcept.h:/* storage for the_exception_context, and etmp is modified between   */
contrib/visupng/cexcept.h:#define init_exception_context(ec) ((void)((ec)->penv = 0))
contrib/visupng/cexcept.h:    jmp_buf *exception__prev, exception__env; \
contrib/visupng/cexcept.h:    exception__prev = the_exception_context->penv; \
contrib/visupng/cexcept.h:    the_exception_context->penv = &exception__env; \
contrib/visupng/cexcept.h:    if (setjmp(exception__env) == 0) { \
contrib/visupng/cexcept.h:#define exception__catch(action) \
contrib/visupng/cexcept.h:      while (the_exception_context->caught = 0, \
contrib/visupng/cexcept.h:             the_exception_context->caught); \
contrib/visupng/cexcept.h:      the_exception_context->caught = 1; \
contrib/visupng/cexcept.h:    the_exception_context->penv = exception__prev; \
contrib/visupng/cexcept.h:  if (!the_exception_context->caught || action) { } \
contrib/visupng/cexcept.h:#define Catch(e) exception__catch(((e) = the_exception_context->v.etmp, 0))
contrib/visupng/cexcept.h:#define Catch_anonymous exception__catch(0)
contrib/visupng/cexcept.h:/* else, to ensure that Try/Catch syntax is similar to if/else        */
contrib/visupng/cexcept.h:/* syntax.                                                            */
contrib/visupng/cexcept.h:/* The 0 in while(0) is expressed as x=0,x in order to appease        */
contrib/visupng/cexcept.h:/* compilers that warn about constant expressions inside while().     */
contrib/visupng/cexcept.h:  for (;; longjmp(*the_exception_context->penv, 1)) \
contrib/visupng/cexcept.h:    the_exception_context->v.etmp =
contrib/visupng/README.txt:the program's objective. However, further extensions (like support for other
contrib/visupng/README.txt:   include the executable from the ./lib directory in your distribution.
contrib/visupng/README.txt:   in your distribution the executable from the ./dll directory and the dll's
contrib/visupng/README.txt:    - Simon-Pierre Cadieux
contrib/visupng/PngFile.c:#include "cexcept.h"
contrib/visupng/PngFile.c:define_exception_type(const char *);
contrib/visupng/PngFile.c:extern struct exception_context the_exception_context[1];
contrib/visupng/PngFile.c:struct exception_context the_exception_context[1];
contrib/visupng/PngFile.c:/* cexcept interface */
contrib/visupng/PngFile.c:png_cexcept_error(png_structp png_ptr, png_const_charp msg)
contrib/visupng/PngFile.c:    ofn.nMaxCustFilter    = 0;
contrib/visupng/PngFile.c:    ofn.nFilterIndex      = 0;
contrib/visupng/PngFile.c:    ofn.nMaxFile          = MAX_PATH;
contrib/visupng/PngFile.c:    ofn.nMaxFileTitle     = MAX_PATH;
contrib/visupng/PngFile.c:    ofn.nFileExtension    = 0;
contrib/visupng/PngFile.c:    ofn.lpstrDefExt       = TEXT ("png");
contrib/visupng/PngFile.c:      (png_error_ptr)png_cexcept_error, (png_error_ptr)NULL);
contrib/visupng/PngFile.c:        /* expand images of all color-type and bit-depth to 3x8-bit RGB */
contrib/visupng/PngFile.c:            png_set_expand(png_ptr);
contrib/visupng/PngFile.c:            png_set_expand(png_ptr);
contrib/visupng/PngFile.c:            png_set_expand(png_ptr);
contrib/visupng/PngFile.c:        /* row_bytes is the width x number of channels */
contrib/visupng/PngFile.c:      (png_error_ptr)png_cexcept_error, (png_error_ptr)NULL);
contrib/visupng/PngFile.c:        /* we're going to write a very simple 3x8-bit RGB image */
contrib/visupng/PngFile.c:        /* swap the BGR pixels in the DiData structure to RGB */
contrib/visupng/PngFile.c:        /* row_bytes is the width x number of channels */
contrib/libtests/pngimage.c: * The exception is _SHIFT, which destroys the low order bits marked as not
contrib/libtests/pngimage.c: * is expected to do anything.  Conditions are defined as follows:
contrib/libtests/pngimage.c: *    these must be present for the transform to fire, except that 0 means
contrib/libtests/pngimage.c:      /* expands PLTE PNG files to RGB (no tRNS) or RGBA (tRNS) *
contrib/libtests/pngimage.c:      /* expands grayscale PNG files to RGB, or RGBA */
contrib/libtests/pngimage.c:      /* expands the tRNS chunk in files without alpha */
contrib/libtests/pngimage.c:      /* reverses the rgb component values of true-color pixels */
contrib/libtests/pngimage.c:      /* swaps the alpha channel of RGBA or GA pixels to the front - ARGB or
contrib/libtests/pngimage.c:      /* expands grayscale images to RGB, also causes the palette part of
contrib/libtests/pngimage.c:       * 'EXPAND' to happen.  Low bit depth grayscale images are expanded to
contrib/libtests/pngimage.c:      /* expands images to 16-bits per component, as a side effect expands
contrib/libtests/pngimage.c:       * palette images to RGB and expands the tRNS chunk if present, so it can
contrib/libtests/pngimage.c:      /* side effect of EXPAND_16 - expands the tRNS chunk in an RGB or G 16-bit
contrib/libtests/pngimage.c: * values are used (unsigned compares in the 'exhaustive' iterator.)
contrib/libtests/pngimage.c:   struct buffer_list *next;         /* next buffer in list */
contrib/libtests/pngimage.c:   buffer->first.next = NULL;
contrib/libtests/pngimage.c:      struct buffer_list *next = list->next;
contrib/libtests/pngimage.c:      buffer_destroy_list(next);
contrib/libtests/pngimage.c:   struct buffer_list *list = buffer->first.next;
contrib/libtests/pngimage.c:buffer_extend(struct buffer_list *current)
contrib/libtests/pngimage.c:   assert(current->next == NULL);
contrib/libtests/pngimage.c:   add->next = NULL;
contrib/libtests/pngimage.c:   current->next = add;
contrib/libtests/pngimage.c:            if (last->next == NULL)
contrib/libtests/pngimage.c:               last = buffer_extend(last);
contrib/libtests/pngimage.c:               last = last->next;
contrib/libtests/pngimage.c:#define LEVEL_MASK      0xf   /* where the level is in 'options' */
contrib/libtests/pngimage.c:#define EXHAUSTIVE      0x010 /* Test all combinations of active options */
contrib/libtests/pngimage.c:#define STRICT          0x020 /* Fail on warnings as well as errors */
contrib/libtests/pngimage.c:#define LOG             0x040 /* Log pass/fail to stdout */
contrib/libtests/pngimage.c:#define CONTINUE        0x080 /* Continue on APP_FAIL errors */
contrib/libtests/pngimage.c:#define SKIP_BUGS       0x100 /* Skip over known bugs */
contrib/libtests/pngimage.c:#define LOG_SKIPPED     0x200 /* Log skipped bugs */
contrib/libtests/pngimage.c:#define FIND_BAD_COMBOS 0x400 /* Attempt to deduce bad combos */
contrib/libtests/pngimage.c: * warnings (--relaxes) or nothing worse than information (--strict)
contrib/libtests/pngimage.c:   dp->results = 0; /* reset for next time */
contrib/libtests/pngimage.c:      exit(99); /* prevents a crash */
contrib/libtests/pngimage.c:         case INTERNAL_ERROR: /* anything unexpected is an internal error: */
contrib/libtests/pngimage.c:            fprintf(stderr, "(0x%x)", tr);
contrib/libtests/pngimage.c:   /* Errors cause this routine to exit to the fail code */
contrib/libtests/pngimage.c:         /* Move to the next buffer: */
contrib/libtests/pngimage.c:         last = last->next;
contrib/libtests/pngimage.c:      png_set_user_limits(pp, 0x7fffffff, 0x7fffffff);
contrib/libtests/pngimage.c:      fprintf(stderr, "%.4x %2d (%3lu bytes):", transforms, png_get_bit_depth(pp,ip), (unsigned long)rb);
contrib/libtests/pngimage.c:         fputc(c, stderr), fprintf(stderr, "%.2x", pr[cb]), c='.';
contrib/libtests/pngimage.c:   dp->chunks = png_get_valid(pp, ip, 0xffffffff);
contrib/libtests/pngimage.c:      dp->ignored_transforms = inactive; /* excluding write-only transforms */
contrib/libtests/pngimage.c:         png_get_valid(dp->read_pp, dp->read_ip, 0xffffffff);
contrib/libtests/pngimage.c:         display_log(dp, APP_FAIL, "PNG chunks changed from 0x%lx to 0x%lx",
contrib/libtests/pngimage.c:          * exact multiple of 8 bits this gives a mask of 0, not 0xff.
contrib/libtests/pngimage.c:         mask = 0xff & (0xff00 >> ((bit_depth * width) & 7));
contrib/libtests/pngimage.c:               size_t x;
contrib/libtests/pngimage.c:               for (x=0; x<rowbytes-1; ++x) if (row[x] != orig[x])
contrib/libtests/pngimage.c:                  "byte(%lu,%lu) changed 0x%.2x -> 0x%.2x",
contrib/libtests/pngimage.c:                  (unsigned long)x, (unsigned long)y, orig[x], row[x]);
contrib/libtests/pngimage.c:         int bpp;   /* bits-per-pixel then bytes-per-pixel */
contrib/libtests/pngimage.c:                  unsigned int sig = (unsigned int)(0xffff0000 >> sig_bits[b]);
contrib/libtests/pngimage.c:                  sig_bits[b] = (png_byte)(0xff00 >> sig_bits[b]);
contrib/libtests/pngimage.c:               sig_bits[0] = 0xff;
contrib/libtests/pngimage.c:               b = 0x3 & ((0x3<<2) >> sig_bits[0]);
contrib/libtests/pngimage.c:               b = 0xf & ((0xf << 4) >> sig_bits[0]);
contrib/libtests/pngimage.c:          * where there are multiple pixels per byte.
contrib/libtests/pngimage.c:            unsigned long x;
contrib/libtests/pngimage.c:            for (x=0; x<(width-(mask!=0)); ++x)
contrib/libtests/pngimage.c:                        "significant bits at (%lu[%u],%lu) changed %.2x->%.2x",
contrib/libtests/pngimage.c:                        x, b, y, orig[-1], row[-1]);
contrib/libtests/pngimage.c:                  "significant bits at (%lu[end],%lu) changed", x, y);
contrib/libtests/pngimage.c:         if (last->next == NULL)
contrib/libtests/pngimage.c:            last = buffer_extend(last);
contrib/libtests/pngimage.c:            last = last->next;
contrib/libtests/pngimage.c:      png_set_user_limits(dp->write_pp, 0x7fffffff, 0x7fffffff);
contrib/libtests/pngimage.c:            int next = first_transform(tr);
contrib/libtests/pngimage.c:            tr &= ~next;
contrib/libtests/pngimage.c:            printf("%s", transform_name(next));
contrib/libtests/pngimage.c:         display_log(dp, INFORMATION, "%s: skipped known bad combo 0x%x",
contrib/libtests/pngimage.c:       * the possibilities exhaustively has to use a compare and that must be
contrib/libtests/pngimage.c:      const int exhaustive = (dp->options & EXHAUSTIVE) != 0;
contrib/libtests/pngimage.c:                * 'exhaustive' tests.  Notice that each transform is tested on
contrib/libtests/pngimage.c:                * its own before testing combos in the exhaustive case.
contrib/libtests/pngimage.c:         /* Now move to the next transform */
contrib/libtests/pngimage.c:         if (exhaustive) /* all combinations */
contrib/libtests/pngimage.c:            unsigned int next = current;
contrib/libtests/pngimage.c:               if (next == read_transforms) /* Everything tested */
contrib/libtests/pngimage.c:               ++next;
contrib/libtests/pngimage.c:            while (  (next & read_transforms) <= current
contrib/libtests/pngimage.c:                  || (next & active) == 0 /* skip cases that do nothing */
contrib/libtests/pngimage.c:                  || (next & bad_transforms) != 0
contrib/libtests/pngimage.c:                  || skip_transform(dp, next));
contrib/libtests/pngimage.c:            assert((next & read_transforms) == next);
contrib/libtests/pngimage.c:            current = next;
contrib/libtests/pngimage.c:            printf("%s[0x%x]: PROBLEM: 0x%x[0x%x] ANTIDOTE: 0x%x\n",
contrib/libtests/pngimage.c:   /* Exists solely to isolate the setjmp clobbers */
contrib/libtests/pngimage.c:      display_log(dp, INTERNAL_ERROR, "unexpected return code %d", ret);
contrib/libtests/pngimage.c:      else if (strcmp(name, "--exhaustive") == 0)
contrib/libtests/pngimage.c:      else if (strcmp(name, "--relaxed") == 0)
contrib/libtests/pngimage.c:         /* Here on any return, including failures, except user/internal issues
contrib/libtests/fakepng.c:   put_uLong(length-4); /* Exclude the tag */
Binary file contrib/libtests/pngvalid.o matches
Binary file contrib/libtests/pngstest.o matches
Binary file contrib/libtests/pngimage.o matches
contrib/libtests/gentests.sh:   exec >&2
contrib/libtests/gentests.sh:   exit 1
contrib/libtests/gentests.sh:test -x "$mp" || {
contrib/libtests/gentests.sh:   exec >&2
contrib/libtests/gentests.sh:   echo "$0: the 'makepng' program must exist"
contrib/libtests/gentests.sh:   echo "  is executed"
contrib/libtests/gentests.sh:   exec >&2
contrib/libtests/gentests.sh:   exec >&2
contrib/libtests/gentests.sh:   echo "  This is unexpected.  You have a spurion; "'"'"test$$.png"'"'"."
contrib/libtests/gentests.sh:   exit 1
contrib/libtests/tarith.c:#define png_fixed_error png_fixed_warning
contrib/libtests/tarith.c:void png_fixed_warning(png_const_structrp png_ptr, png_const_charp msg)
contrib/libtests/tarith.c:   double max_error=2;      /* As a percentage error-in-last-digit/.5 */
contrib/libtests/tarith.c:   double max_error_abs=17; /* Used when precision is DBL_DIG */
contrib/libtests/tarith.c:   double max = 0;
contrib/libtests/tarith.c:   double max_abs = 0;
contrib/libtests/tarith.c:         max_error = atof(*++argv);
contrib/libtests/tarith.c:         max_error_abs = atof(*++argv);
contrib/libtests/tarith.c:      png_size_t index;
contrib/libtests/tarith.c:      /* Allow for a three digit exponent, this stuff will fail if
contrib/libtests/tarith.c:       * the exponent is bigger than this!
contrib/libtests/tarith.c:      index = 0;
contrib/libtests/tarith.c:         /* Expect 'inf' */
contrib/libtests/tarith.c:            fprintf(stderr, "%g[%d] -> '%s' but expected 'inf'\n", test,
contrib/libtests/tarith.c:      else if (!png_check_fp_number(buffer, precision+10, &state, &index) ||
contrib/libtests/tarith.c:          buffer[index] != 0)
contrib/libtests/tarith.c:         precision, buffer, buffer[index]);
contrib/libtests/tarith.c:            double percent = (precision >= DBL_DIG) ? max_error_abs : max_error;
contrib/libtests/tarith.c:               if (max_abs < allowp) max_abs = allowp;
contrib/libtests/tarith.c:               if (max < allowp) max = allowp;
contrib/libtests/tarith.c:         /* Derive the exponent from the previous rand() value. */
contrib/libtests/tarith.c:         int exponent = precision % (DBL_MAX_EXP - DBL_MIN_EXP) + DBL_MIN_EXP;
contrib/libtests/tarith.c:         test = frexp(test * rand(), &tmp);
contrib/libtests/tarith.c:         test = ldexp(test, exponent);
contrib/libtests/tarith.c:      precision = (precision & 0x1f) + 1;
contrib/libtests/tarith.c:   printf(" Error with >=%d digit precision %.2f%%\n", DBL_DIG, max_abs);
contrib/libtests/tarith.c:   printf(" Error with < %d digit precision %.2f%%\n", DBL_DIG, max);
contrib/libtests/tarith.c:/* Observe that valid FP numbers have the forms listed in the PNG extensions
contrib/libtests/tarith.c:   start, fraction, exponent, states
contrib/libtests/tarith.c:static const char hexdigits[16] = "0123456789ABCDEF";
contrib/libtests/tarith.c:   /* exponent: */ { "+-", none,  "+-.eE^0258" }
contrib/libtests/tarith.c:   int           cnumber;          /* Index into number string */
contrib/libtests/tarith.c:   png_size_t index = 0;
contrib/libtests/tarith.c:   const int number_is_valid = png_check_fp_number(&test, 1, &c.state, &index);
contrib/libtests/tarith.c:   const int character_accepted = (index == 1);
contrib/libtests/tarith.c:   if (c.check_state != exponent && isdigit(ch) && ch != '0')
contrib/libtests/tarith.c:      co->number[c.cnumber++] = hexdigits[(ch >> 4) & 0xf];
contrib/libtests/tarith.c:      co->number[c.cnumber++] = hexdigits[ch & 0xf];
contrib/libtests/tarith.c:   if (index != 0 && index != 1)
contrib/libtests/tarith.c:         (unsigned long)index);
contrib/libtests/tarith.c:               c.check_state != exponent))
contrib/libtests/tarith.c:       * is valid at this point set the at_start to false to allow an exponent
contrib/libtests/tarith.c:       * 'e' to come next.
contrib/libtests/tarith.c:      else if (c.check_state < exponent && (ch == 'e' || ch == 'E'))
contrib/libtests/tarith.c:         c.check_state = exponent;
contrib/libtests/tarith.c:         fprintf(stderr, "%s: character '%c' [0x%.2x] accepted\n", co->number,
contrib/libtests/tarith.c:            "%s: character '%c' [0x%.2x] changed number validity\n", co->number,
contrib/libtests/tarith.c:       * the next character.
contrib/libtests/tarith.c:   /* Successful return (the caller will try the next character.) */
contrib/libtests/tarith.c:   png_fixed_point a;
contrib/libtests/tarith.c:      png_fixed_point result;
contrib/libtests/tarith.c:            /* -x = ~x+1 */
contrib/libtests/tarith.c:            lo = ((~lo) + 1) & 0xffffffff;
contrib/libtests/tarith.c:      if ((fp & 0xffffffff) != lo || ((fp >> 32) & 0xffffffff) != hi)
contrib/libtests/tarith.c:         fprintf(stderr, "png_64bit_product %d * %d -> %lx|%.8lx not %llx\n",
contrib/libtests/tarith.c:             fprintf(stderr, "%d * %d / %d -> overflow (expected %lld)\n", a,
contrib/libtests/tarith.c:             fprintf(stderr, "%d * %d / %d -> %d (expected overflow %lld)\n", a,
contrib/libtests/tarith.c:static png_uint_32 png_log8bit(unsigned x)
contrib/libtests/tarith.c:   if (x > 0)
contrib/libtests/tarith.c:      return (png_uint_32)floor(.5-log(x/255.)*L2INV);
contrib/libtests/tarith.c:   return 0xffffffff;
contrib/libtests/tarith.c:static png_uint_32 png_log16bit(png_uint_32 x)
contrib/libtests/tarith.c:   if (x > 0)
contrib/libtests/tarith.c:      return (png_uint_32)floor(.5-log(x/65535.)*L2INV);
contrib/libtests/tarith.c:   return 0xffffffff;
contrib/libtests/tarith.c:static png_uint_32 png_exp(png_uint_32 x)
contrib/libtests/tarith.c:   return (png_uint_32)floor(.5 + exp(x * -LN2) * 0xffffffffU);
contrib/libtests/tarith.c:static png_byte png_exp8bit(png_uint_32 log)
contrib/libtests/tarith.c:   return (png_byte)floor(.5 + exp(log * -LN2) * 255);
contrib/libtests/tarith.c:static png_uint_16 png_exp16bit(png_uint_32 log)
contrib/libtests/tarith.c:   return (png_uint_16)floor(.5 + exp(log * -LN2) * 65535);
contrib/libtests/tarith.c:   double maxerr;
contrib/libtests/tarith.c:      maxerr = 0;
contrib/libtests/tarith.c:         if (i != 0 && fabs(error) > maxerr)
contrib/libtests/tarith.c:            maxerr = fabs(error);
contrib/libtests/tarith.c:         if (i == 0 && png_log8bit(i) != 0xffffffff ||
contrib/libtests/tarith.c:            fprintf(stderr, "8 bit log error: %d: got %u, expected %f\n",
contrib/libtests/tarith.c:         printf("maximum 8 bit log error = %f\n", maxerr);
contrib/libtests/tarith.c:      maxerr = 0;
contrib/libtests/tarith.c:         if (i != 0 && fabs(error) > maxerr)
contrib/libtests/tarith.c:            maxerr = fabs(error);
contrib/libtests/tarith.c:         if (i == 0 && png_log16bit(i) != 0xffffffff ||
contrib/libtests/tarith.c:            if (error > .68) /* By experiment error is less than .68 */
contrib/libtests/tarith.c:               fprintf(stderr, "16 bit log error: %d: got %u, expected %f"
contrib/libtests/tarith.c:         printf("maximum 16 bit log error = %f\n", maxerr);
contrib/libtests/tarith.c:      /* Now exponentiations. */
contrib/libtests/tarith.c:      maxerr = 0;
contrib/libtests/tarith.c:      for (i=0; i<=0xfffff; ++i)
contrib/libtests/tarith.c:         double correct = exp(-i/65536. * log(2.)) * (65536. * 65536);
contrib/libtests/tarith.c:         double error = png_exp(i) - correct;
contrib/libtests/tarith.c:         if (fabs(error) > maxerr)
contrib/libtests/tarith.c:            maxerr = fabs(error);
contrib/libtests/tarith.c:         if (fabs(error) > 1883) /* By experiment. */
contrib/libtests/tarith.c:            fprintf(stderr, "32 bit exp error: %d: got %u, expected %f"
contrib/libtests/tarith.c:                  " error: %f\n", i, png_exp(i), correct, error);
contrib/libtests/tarith.c:         printf("maximum 32 bit exp error = %f\n", maxerr);
contrib/libtests/tarith.c:      maxerr = 0;
contrib/libtests/tarith.c:      for (i=0; i<=0xfffff; ++i)
contrib/libtests/tarith.c:         double correct = exp(-i/65536. * log(2.)) * 255;
contrib/libtests/tarith.c:         double error = png_exp8bit(i) - correct;
contrib/libtests/tarith.c:         if (fabs(error) > maxerr)
contrib/libtests/tarith.c:            maxerr = fabs(error);
contrib/libtests/tarith.c:         if (fabs(error) > .50002) /* By experiment */
contrib/libtests/tarith.c:            fprintf(stderr, "8 bit exp error: %d: got %u, expected %f"
contrib/libtests/tarith.c:                  " error: %f\n", i, png_exp8bit(i), correct, error);
contrib/libtests/tarith.c:         printf("maximum 8 bit exp error = %f\n", maxerr);
contrib/libtests/tarith.c:      maxerr = 0;
contrib/libtests/tarith.c:      for (i=0; i<=0xfffff; ++i)
contrib/libtests/tarith.c:         double correct = exp(-i/65536. * log(2.)) * 65535;
contrib/libtests/tarith.c:         double error = png_exp16bit(i) - correct;
contrib/libtests/tarith.c:         if (fabs(error) > maxerr)
contrib/libtests/tarith.c:            maxerr = fabs(error);
contrib/libtests/tarith.c:         if (fabs(error) > .524) /* By experiment */
contrib/libtests/tarith.c:            fprintf(stderr, "16 bit exp error: %d: got %u, expected %f"
contrib/libtests/tarith.c:                  " error: %f\n", i, png_exp16bit(i), correct, error);
contrib/libtests/tarith.c:         printf("maximum 16 bit exp error = %f\n", maxerr);
contrib/libtests/tarith.c:      png_fixed_point gfp = floor(g * PNG_FP_1 + .5);
contrib/libtests/tarith.c:      maxerr = 0;
contrib/libtests/tarith.c:         if (fabs(error) > maxerr)
contrib/libtests/tarith.c:            maxerr = fabs(error);
contrib/libtests/tarith.c:            fprintf(stderr, "8bit %d ^ %f: got %d expected %f error %f\n",
contrib/libtests/tarith.c:         printf("gamma %f: maximum 8 bit error %f\n", g, maxerr);
contrib/libtests/tarith.c:      maxerr = 0;
contrib/libtests/tarith.c:         if (fabs(error) > maxerr)
contrib/libtests/tarith.c:            maxerr = fabs(error);
contrib/libtests/tarith.c:            fprintf(stderr, "16bit %d ^ %f: got %d expected %f error %f\n",
contrib/libtests/tarith.c:         printf("gamma %f: maximum 16 bit error %f\n", g, maxerr);
contrib/libtests/tarith.c: * 3: accuracy test of fixed point gamma tables
contrib/libtests/tarith.c:   fprintf(stderr, "            checkfp [-l max-number-chars]\n");
contrib/libtests/timepng.c:   /* Exit code 0 on success. */
contrib/libtests/pngunknown.c:#define PNG_COL_FROM_PASS_COL(xIn, pass) \
contrib/libtests/pngunknown.c:   (((xIn)<<PNG_PASS_COL_SHIFT(pass))+PNG_PASS_START_COL(pass))
contrib/libtests/pngunknown.c:   ((0x110145AFU>>(((7-(off))-(pass))<<2)) & 0xFU) | \
contrib/libtests/pngunknown.c:   ((0x01145AF0U>>(((7-(off))-(pass))<<2)) & 0xF0U))
contrib/libtests/pngunknown.c:#define PNG_COL_IN_INTERLACE_PASS(x, pass) \
contrib/libtests/pngunknown.c:   ((PNG_PASS_MASK(pass,1) >> ((x)&7)) & 1)
contrib/libtests/pngunknown.c:   ((png_fixed_point)(PNG_GAMMA_THRESHOLD * PNG_FP_1))
contrib/libtests/pngunknown.c:   /* 1.6.0 constifies many APIs. The following exists to allow pngvalid to be
contrib/libtests/pngunknown.c:#define png_gIFx PNG_U32(103,  73,  70, 120)
contrib/libtests/pngunknown.c: * expected to have no bad effects on performance.
contrib/libtests/pngunknown.c:#define PNG_INFO_tEXt 0x10000000U
contrib/libtests/pngunknown.c:#define PNG_INFO_iTXt 0x20000000U
contrib/libtests/pngunknown.c:#define PNG_INFO_zTXt 0x40000000U
contrib/libtests/pngunknown.c:#define PNG_INFO_sTER 0x01000000U
contrib/libtests/pngunknown.c:#define PNG_INFO_vpAg 0x02000000U
contrib/libtests/pngunknown.c:   exit(4);
contrib/libtests/pngunknown.c:      exit(1);
contrib/libtests/pngunknown.c:PNG_FUNCTION(void, display_exit, (display *d), static PNG_NORETURN)
contrib/libtests/pngunknown.c:    * exit now - there is only one test, otherwise longjmp to do the next test.
contrib/libtests/pngunknown.c:      exit(1);
contrib/libtests/pngunknown.c:   display_exit(d);
contrib/libtests/pngunknown.c:   /* Map the text chunks back into the flags */
contrib/libtests/pngunknown.c:      png_textp text;
contrib/libtests/pngunknown.c:      png_uint_32 ntext = png_get_text(d->png_ptr, info_ptr, &text, NULL);
contrib/libtests/pngunknown.c:      while (ntext-- > 0) switch (text[ntext].compression)
contrib/libtests/pngunknown.c:            fprintf(stderr, "%s(%s): unknown text compression %d\n", d->file,
contrib/libtests/pngunknown.c:               d->test, text[ntext].compression);
contrib/libtests/pngunknown.c:            display_exit(d);
contrib/libtests/pngunknown.c:         display_exit(d);
contrib/libtests/pngunknown.c:   /* Some of these errors are permanently fatal and cause an exit here, others
contrib/libtests/pngunknown.c:      exit(1);
contrib/libtests/pngunknown.c:      exit(1);
contrib/libtests/pngunknown.c:            display_exit(d);
contrib/libtests/pngunknown.c:      display_exit(d);
contrib/libtests/pngunknown.c:         exit(1);
contrib/libtests/pngunknown.c:      const char *errorx = NULL;
contrib/libtests/pngunknown.c:            errorx = "chunk processed";
contrib/libtests/pngunknown.c:                  errorx = "DEFAULT: unknown chunk saved";
contrib/libtests/pngunknown.c:                  errorx = "DISCARD: unknown chunk saved";
contrib/libtests/pngunknown.c:                     errorx = "IF-SAFE: unknown ancillary chunk lost";
contrib/libtests/pngunknown.c:                  errorx = "IF-SAFE: unknown critical chunk saved";
contrib/libtests/pngunknown.c:                  errorx = "SAVE: unknown chunk lost";
contrib/libtests/pngunknown.c:               errorx = "internal error: bad keep";
contrib/libtests/pngunknown.c:               errorx = "!DEFAULT: known chunk processed";
contrib/libtests/pngunknown.c:               errorx = "DEFAULT: known chunk not processed";
contrib/libtests/pngunknown.c:                  errorx = "DISCARD: known chunk saved";
contrib/libtests/pngunknown.c:                     errorx = "IF-SAFE: known ancillary chunk lost";
contrib/libtests/pngunknown.c:                  errorx = "IF-SAFE: known critical chunk saved";
contrib/libtests/pngunknown.c:                  errorx = "SAVE: known chunk lost";
contrib/libtests/pngunknown.c:               errorx = "internal error: bad keep (2)";
contrib/libtests/pngunknown.c:      if (errorx != NULL)
contrib/libtests/pngunknown.c:            type, chunk_info[i].name, position, errorx);
contrib/libtests/pngunknown.c:   exit(99);
contrib/libtests/pngunknown.c:      usage(d.program, "extra arguments");
contrib/libtests/pngunknown.c:      exit(99);
contrib/libtests/pngunknown.c:      exit(99);
contrib/libtests/pngunknown.c:      d.test = cmd; /* acts as a flag to say exit, do not longjmp */
contrib/libtests/pngunknown.c:      /* Set the exit_test pointer here so we can continue after a libpng error.
contrib/libtests/pngunknown.c:         const char **next = test;
contrib/libtests/pngunknown.c:         while (*next) ++next, ++arg_count;
contrib/libtests/pngunknown.c:         test = next+1;
contrib/libtests/pngunknown.c:               exit(99);
contrib/libtests/pngunknown.c:            exit(99);
contrib/libtests/.deps/pngstest.Po:  /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/6.0/include/stddef.h \
contrib/libtests/.deps/pngstest.Po:  /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/sys/_posix_availability.h \
contrib/libtests/.deps/pngstest.Po:  /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/machine/_mcontext.h \
contrib/libtests/.deps/pngstest.Po:  /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/i386/_mcontext.h \
contrib/libtests/.deps/pngstest.Po:  /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/sys/_types/_ucontext.h \
contrib/libtests/.deps/pngstest.Po:  /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/6.0/include/stdint.h \
contrib/libtests/.deps/pngstest.Po:  /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/_types/_intmax_t.h \
contrib/libtests/.deps/pngstest.Po:  /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/_types/_uintmax_t.h \
contrib/libtests/.deps/pngstest.Po:  /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/6.0/include/limits.h \
contrib/libtests/.deps/pngstest.Po:/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/6.0/include/stddef.h:
contrib/libtests/.deps/pngstest.Po:/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/sys/_posix_availability.h:
contrib/libtests/.deps/pngstest.Po:/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/machine/_mcontext.h:
contrib/libtests/.deps/pngstest.Po:/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/i386/_mcontext.h:
contrib/libtests/.deps/pngstest.Po:/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/sys/_types/_ucontext.h:
contrib/libtests/.deps/pngstest.Po:/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/6.0/include/stdint.h:
contrib/libtests/.deps/pngstest.Po:/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/_types/_intmax_t.h:
contrib/libtests/.deps/pngstest.Po:/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/_types/_uintmax_t.h:
contrib/libtests/.deps/pngstest.Po:/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/6.0/include/limits.h:
contrib/libtests/.deps/pngimage.Po:  /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/6.0/include/stdarg.h \
contrib/libtests/.deps/pngimage.Po:  /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/sys/_posix_availability.h \
contrib/libtests/.deps/pngimage.Po:  /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/machine/_mcontext.h \
contrib/libtests/.deps/pngimage.Po:  /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/i386/_mcontext.h \
contrib/libtests/.deps/pngimage.Po:  /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/sys/_types/_ucontext.h \
contrib/libtests/.deps/pngimage.Po:  /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/6.0/include/stdint.h \
contrib/libtests/.deps/pngimage.Po:  /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/_types/_intmax_t.h \
contrib/libtests/.deps/pngimage.Po:  /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/_types/_uintmax_t.h \
contrib/libtests/.deps/pngimage.Po:  /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/6.0/include/limits.h \
contrib/libtests/.deps/pngimage.Po:  /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/6.0/include/stddef.h \
contrib/libtests/.deps/pngimage.Po:/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/6.0/include/stdarg.h:
contrib/libtests/.deps/pngimage.Po:/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/sys/_posix_availability.h:
contrib/libtests/.deps/pngimage.Po:/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/machine/_mcontext.h:
contrib/libtests/.deps/pngimage.Po:/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/i386/_mcontext.h:
contrib/libtests/.deps/pngimage.Po:/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/sys/_types/_ucontext.h:
contrib/libtests/.deps/pngimage.Po:/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/6.0/include/stdint.h:
contrib/libtests/.deps/pngimage.Po:/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/_types/_intmax_t.h:
contrib/libtests/.deps/pngimage.Po:/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/_types/_uintmax_t.h:
contrib/libtests/.deps/pngimage.Po:/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/6.0/include/limits.h:
contrib/libtests/.deps/pngimage.Po:/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/6.0/include/stddef.h:
contrib/libtests/.deps/pngunknown.Po:  /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/sys/_posix_availability.h \
contrib/libtests/.deps/pngunknown.Po:  /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/machine/_mcontext.h \
contrib/libtests/.deps/pngunknown.Po:  /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/i386/_mcontext.h \
contrib/libtests/.deps/pngunknown.Po:  /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/sys/_types/_ucontext.h \
contrib/libtests/.deps/pngunknown.Po:  /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/6.0/include/stdint.h \
contrib/libtests/.deps/pngunknown.Po:  /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/_types/_intmax_t.h \
contrib/libtests/.deps/pngunknown.Po:  /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/_types/_uintmax_t.h \
contrib/libtests/.deps/pngunknown.Po:  /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/6.0/include/limits.h \
contrib/libtests/.deps/pngunknown.Po:  /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/6.0/include/stddef.h \
contrib/libtests/.deps/pngunknown.Po:/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/sys/_posix_availability.h:
contrib/libtests/.deps/pngunknown.Po:/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/machine/_mcontext.h:
contrib/libtests/.deps/pngunknown.Po:/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/i386/_mcontext.h:
contrib/libtests/.deps/pngunknown.Po:/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/sys/_types/_ucontext.h:
contrib/libtests/.deps/pngunknown.Po:/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/6.0/include/stdint.h:
contrib/libtests/.deps/pngunknown.Po:/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/_types/_intmax_t.h:
contrib/libtests/.deps/pngunknown.Po:/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/_types/_uintmax_t.h:
contrib/libtests/.deps/pngunknown.Po:/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/6.0/include/limits.h:
contrib/libtests/.deps/pngunknown.Po:/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/6.0/include/stddef.h:
contrib/libtests/.deps/pngvalid.Po:  /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/sys/_posix_availability.h \
contrib/libtests/.deps/pngvalid.Po:  /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/machine/_mcontext.h \
contrib/libtests/.deps/pngvalid.Po:  /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/i386/_mcontext.h \
contrib/libtests/.deps/pngvalid.Po:  /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/sys/_types/_ucontext.h \
contrib/libtests/.deps/pngvalid.Po:  /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/6.0/include/limits.h \
contrib/libtests/.deps/pngvalid.Po:  /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/6.0/include/stddef.h \
contrib/libtests/.deps/pngvalid.Po:  /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/sys/_pthread/_pthread_mutex_t.h \
contrib/libtests/.deps/pngvalid.Po:  /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/sys/_pthread/_pthread_mutexattr_t.h \
contrib/libtests/.deps/pngvalid.Po:  /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/sys/_types/_posix_vdisable.h \
contrib/libtests/.deps/pngvalid.Po:  /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/6.0/include/float.h \
contrib/libtests/.deps/pngvalid.Po:  contrib/libtests/../visupng/cexcept.h
contrib/libtests/.deps/pngvalid.Po:/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/sys/_posix_availability.h:
contrib/libtests/.deps/pngvalid.Po:/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/machine/_mcontext.h:
contrib/libtests/.deps/pngvalid.Po:/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/i386/_mcontext.h:
contrib/libtests/.deps/pngvalid.Po:/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/sys/_types/_ucontext.h:
contrib/libtests/.deps/pngvalid.Po:/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/6.0/include/limits.h:
contrib/libtests/.deps/pngvalid.Po:/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/6.0/include/stddef.h:
contrib/libtests/.deps/pngvalid.Po:/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/sys/_pthread/_pthread_mutex_t.h:
contrib/libtests/.deps/pngvalid.Po:/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/sys/_pthread/_pthread_mutexattr_t.h:
contrib/libtests/.deps/pngvalid.Po:/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/sys/_types/_posix_vdisable.h:
contrib/libtests/.deps/pngvalid.Po:/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/6.0/include/float.h:
contrib/libtests/.deps/pngvalid.Po:contrib/libtests/../visupng/cexcept.h:
Binary file contrib/libtests/pngunknown.o matches
contrib/libtests/pngvalid.c: *   The program can be modified and extended to test the correctness of
contrib/libtests/pngvalid.c:#define _GNU_SOURCE 1 /* For the floating point exception extension */
contrib/libtests/pngvalid.c:/* pngvalid requires write support and one of the fixed or floating point APIs.
contrib/libtests/pngvalid.c:#define PNG_COL_FROM_PASS_COL(xIn, pass) \
contrib/libtests/pngvalid.c:   (((xIn)<<PNG_PASS_COL_SHIFT(pass))+PNG_PASS_START_COL(pass))
contrib/libtests/pngvalid.c:   ((0x110145AFU>>(((7-(off))-(pass))<<2)) & 0xFU) | \
contrib/libtests/pngvalid.c:   ((0x01145AF0U>>(((7-(off))-(pass))<<2)) & 0xF0U))
contrib/libtests/pngvalid.c:#define PNG_COL_IN_INTERLACE_PASS(x, pass) \
contrib/libtests/pngvalid.c:   ((PNG_PASS_MASK(pass,1) >> ((x)&7)) & 1)
contrib/libtests/pngvalid.c:   ((png_fixed_point)(PNG_GAMMA_THRESHOLD * PNG_FP_1))
contrib/libtests/pngvalid.c:   /* 1.6.0 constifies many APIs, the following exists to allow pngvalid to be
contrib/libtests/pngvalid.c: * expected to have no bad effects on performance.
contrib/libtests/pngvalid.c:#  include <cexcept.h>
contrib/libtests/pngvalid.c:#  include "../visupng/cexcept.h"
contrib/libtests/pngvalid.c:define_exception_type(struct png_store*);
contrib/libtests/pngvalid.c: * name 'the_exception_context' must be defined.
contrib/libtests/pngvalid.c:#define anon_context(ps) struct exception_context *the_exception_context = \
contrib/libtests/pngvalid.c:   &(ps)->exception_context
contrib/libtests/pngvalid.c:#define context(ps,fault) anon_context(ps); png_store *fault
contrib/libtests/pngvalid.c:   "grayscale", invalid, "truecolour", "indexed-colour",
contrib/libtests/pngvalid.c:/* Convert a double precision value to fixed point. */
contrib/libtests/pngvalid.c:static png_fixed_point
contrib/libtests/pngvalid.c:fix(double d)
contrib/libtests/pngvalid.c:   return (png_fixed_point)d;
contrib/libtests/pngvalid.c:   /* There are thirty three bits, the next bit in the sequence is bit-33 XOR
contrib/libtests/pngvalid.c:      png_uint_32 u = ((u0 >> (20-8)) ^ ((u1 << 7) | (u0 >> (32-7)))) & 0xff;
contrib/libtests/pngvalid.c:   static png_uint_32 random_seed[2] = {0x56789abc, 0xd};
contrib/libtests/pngvalid.c:random_mod(unsigned int max)
contrib/libtests/pngvalid.c:   unsigned int x;
contrib/libtests/pngvalid.c:   RANDOMIZE(x);
contrib/libtests/pngvalid.c:   return x % max; /* 0 .. max-1 */
contrib/libtests/pngvalid.c:   unsigned char x;
contrib/libtests/pngvalid.c:   RANDOMIZE(x);
contrib/libtests/pngvalid.c:   return x & 1;
contrib/libtests/pngvalid.c: * index of the palette to use for formats with a palette (0 otherwise.)
contrib/libtests/pngvalid.c:#define COL_FROM_ID(id) ((png_byte)((id)& 0x7U))
contrib/libtests/pngvalid.c:#define DEPTH_FROM_ID(id) ((png_byte)(((id) >> 3) & 0x1fU))
contrib/libtests/pngvalid.c:#define PALETTE_FROM_ID(id) (((id) >> 8) & 0x1f)
contrib/libtests/pngvalid.c:#define INTERLACE_FROM_ID(id) ((int)(((id) >> 13) & 0x3))
contrib/libtests/pngvalid.c:#define WIDTH_FROM_ID(id) (((id)>>16) & 0xff)
contrib/libtests/pngvalid.c:#define HEIGHT_FROM_ID(id) (((id)>>24) & 0xff)
contrib/libtests/pngvalid.c:      pos = safecat(buffer, bufsize, pos, "x");
contrib/libtests/pngvalid.c:next_format(png_bytep colour_type, png_bytep bit_depth,
contrib/libtests/pngvalid.c:   /* Move to the next color type, or return 0 at the end. */
contrib/libtests/pngvalid.c:    png_uint_32 x, unsigned int sample_index)
contrib/libtests/pngvalid.c:   png_uint_32 bit_index, result;
contrib/libtests/pngvalid.c:   /* Find a sample index for the desired sample: */
contrib/libtests/pngvalid.c:   x *= bit_depth;
contrib/libtests/pngvalid.c:   bit_index = x;
contrib/libtests/pngvalid.c:         bit_index *= 3;
contrib/libtests/pngvalid.c:         bit_index += x; /* Alpha channel */
contrib/libtests/pngvalid.c:         bit_index += sample_index * bit_depth;
contrib/libtests/pngvalid.c:   row += bit_index >> 3;
contrib/libtests/pngvalid.c:   bit_index &= 7;
contrib/libtests/pngvalid.c:   return (result >> (8-bit_index-bit_depth)) & ((1U<<bit_depth)-1);
contrib/libtests/pngvalid.c:/* Copy a single pixel, of a given size, from one buffer to another -
contrib/libtests/pngvalid.c: * that pixels 8 or more bits in size are byte aligned and that pixels
contrib/libtests/pngvalid.c:pixel_copy(png_bytep toBuffer, png_uint_32 toIndex,
contrib/libtests/pngvalid.c:   png_const_bytep fromBuffer, png_uint_32 fromIndex, unsigned int pixelSize)
contrib/libtests/pngvalid.c:   toIndex *= pixelSize;
contrib/libtests/pngvalid.c:   fromIndex *= pixelSize;
contrib/libtests/pngvalid.c:   if (pixelSize < 8) /* Sub-byte */
contrib/libtests/pngvalid.c:      /* Mask to select the location of the copied pixel: */
contrib/libtests/pngvalid.c:      unsigned int destMask = ((1U<<pixelSize)-1) << (8-pixelSize-(toIndex&7));
contrib/libtests/pngvalid.c:      /* The following read the entire pixels and clears the extra: */
contrib/libtests/pngvalid.c:      unsigned int destByte = toBuffer[toIndex >> 3] & ~destMask;
contrib/libtests/pngvalid.c:      unsigned int sourceByte = fromBuffer[fromIndex >> 3];
contrib/libtests/pngvalid.c:      fromIndex &= 7;
contrib/libtests/pngvalid.c:      if (fromIndex > 0) sourceByte <<= fromIndex;
contrib/libtests/pngvalid.c:      if ((toIndex & 7) > 0) sourceByte >>= toIndex & 7;
contrib/libtests/pngvalid.c:      toBuffer[toIndex >> 3] = (png_byte)(destByte | (sourceByte & destMask));
contrib/libtests/pngvalid.c:      memmove(toBuffer+(toIndex>>3), fromBuffer+(fromIndex>>3), pixelSize>>3);
contrib/libtests/pngvalid.c:/* Copy a complete row of pixels, taking into account potential partial
contrib/libtests/pngvalid.c:      mask = 0xff >> (bitWidth & 7);
contrib/libtests/pngvalid.c:/* Compare pixels - they are assumed to start at the first byte in the
contrib/libtests/pngvalid.c:pixel_cmp(png_const_bytep pa, png_const_bytep pb, png_uint_32 bit_width)
contrib/libtests/pngvalid.c:   /* From libpng-1.5.6 the overwrite should be fixed, so compare the trailing
contrib/libtests/pngvalid.c:   /* Return the index of the changed byte. */
contrib/libtests/pngvalid.c:   struct png_store_file*  next;      /* as many as you like... */
contrib/libtests/pngvalid.c:   png_alloc_size_t     max;     /* Maximum single allocation */
contrib/libtests/pngvalid.c:   png_alloc_size_t     max_max;
contrib/libtests/pngvalid.c:   png_alloc_size_t     max_limit;
contrib/libtests/pngvalid.c:   png_alloc_size_t     max_total;
contrib/libtests/pngvalid.c:   /* For cexcept.h exception handling - simply store one of these;
contrib/libtests/pngvalid.c:    * the context is a self pointer but it may point to a different
contrib/libtests/pngvalid.c:   struct exception_context
contrib/libtests/pngvalid.c:                      exception_context;
contrib/libtests/pngvalid.c:   unsigned int       expect_error :1;
contrib/libtests/pngvalid.c:   unsigned int       expect_warning :1;
contrib/libtests/pngvalid.c:   png_store_buffer*  next;     /* Set when reading */
contrib/libtests/pngvalid.c:   png_size_t         readpos;  /* Position in *next */
contrib/libtests/pngvalid.c:   static png_uint_32 store_seed[2] = { 0x12345678, 1};
contrib/libtests/pngvalid.c:   pool->max = pool->current = pool->limit = pool->total = 0;
contrib/libtests/pngvalid.c:   pool->max_max = pool->max_limit = pool->max_total = 0;
contrib/libtests/pngvalid.c:   init_exception_context(&ps->exception_context);
contrib/libtests/pngvalid.c:   ps->expect_error = 0;
contrib/libtests/pngvalid.c:   ps->expect_warning = 0;
contrib/libtests/pngvalid.c:   ps->next = NULL;
contrib/libtests/pngvalid.c:      store_freefile(&(*ppf)->next);
contrib/libtests/pngvalid.c:   pf->next = ps->saved;
contrib/libtests/pngvalid.c:store_verbose(png_store *ps, png_const_structp pp, png_const_charp prefix,
contrib/libtests/pngvalid.c:   if (prefix)
contrib/libtests/pngvalid.c:      fputs(prefix, stderr);
contrib/libtests/pngvalid.c:   /* And finally throw an exception. */
contrib/libtests/pngvalid.c:      struct exception_context *the_exception_context = &ps->exception_context;
contrib/libtests/pngvalid.c:   if (!ps->expect_error)
contrib/libtests/pngvalid.c:   /* And finally throw an exception. */
contrib/libtests/pngvalid.c:      struct exception_context *the_exception_context = &ps->exception_context;
contrib/libtests/pngvalid.c:   if (!ps->expect_warning)
contrib/libtests/pngvalid.c:      if (image[-1] != 0xed || image[ps->cb_image] != 0xfe)
contrib/libtests/pngvalid.c:      image[-1] = 0xed;
contrib/libtests/pngvalid.c:      image[cb] = 0xfe;
contrib/libtests/pngvalid.c:   /* For error checking, the whole buffer is set to 10110010 (0xb2 - 178).
contrib/libtests/pngvalid.c:    * outside the image; these are set to 0xff (all 1).  To make the row
contrib/libtests/pngvalid.c:   if (image[-1] != 0xed || image[ps->cb_image] != 0xfe)
contrib/libtests/pngvalid.c:   if (ps->next != &ps->current->data)
contrib/libtests/pngvalid.c:   if (ps->current != NULL && ps->next != NULL)
contrib/libtests/pngvalid.c:      png_store_buffer *next = &ps->current->data;
contrib/libtests/pngvalid.c:      while (next != ps->next && next != NULL)
contrib/libtests/pngvalid.c:         next = next->prev;
contrib/libtests/pngvalid.c:      if (next != ps->next)
contrib/libtests/pngvalid.c:store_read_buffer_next(png_store *ps)
contrib/libtests/pngvalid.c:   png_store_buffer *pbOld = ps->next;
contrib/libtests/pngvalid.c:         ps->next = pbNew;
contrib/libtests/pngvalid.c:   if (ps->current == NULL || ps->next == NULL)
contrib/libtests/pngvalid.c:         memcpy(pb, ps->next->buffer + ps->readpos, cbAvail);
contrib/libtests/pngvalid.c:      else if (!store_read_buffer_next(ps))
contrib/libtests/pngvalid.c:   if (ps->pread != pp || ps->current == NULL || ps->next == NULL)
contrib/libtests/pngvalid.c:      png_process_data(pp, pi, ps->next->buffer, store_read_buffer_size(ps));
contrib/libtests/pngvalid.c:   while (store_read_buffer_next(ps));
contrib/libtests/pngvalid.c:   struct store_memory *next;    /* Singly linked list */
contrib/libtests/pngvalid.c:      if (cb > pool->max)
contrib/libtests/pngvalid.c:         store_memory *next = pool->list;
contrib/libtests/pngvalid.c:         pool->list = next->next;
contrib/libtests/pngvalid.c:         next->next = NULL;
contrib/libtests/pngvalid.c:             (unsigned long)next->size, (PNG_CONST void*)(next+1));
contrib/libtests/pngvalid.c:         store_memory_free(NULL, pool, next);
contrib/libtests/pngvalid.c:   /* And reset the other fields too for the next time. */
contrib/libtests/pngvalid.c:   if (pool->max > pool->max_max) pool->max_max = pool->max;
contrib/libtests/pngvalid.c:   pool->max = 0;
contrib/libtests/pngvalid.c:   if (pool->current != 0) /* unexpected internal error */
contrib/libtests/pngvalid.c:   if (pool->limit > pool->max_limit)
contrib/libtests/pngvalid.c:      pool->max_limit = pool->limit;
contrib/libtests/pngvalid.c:   if (pool->total > pool->max_total)
contrib/libtests/pngvalid.c:      pool->max_total = pool->total;
contrib/libtests/pngvalid.c:      if (cb > pool->max)
contrib/libtests/pngvalid.c:         pool->max = cb;
contrib/libtests/pngvalid.c:      new->next = pool->list;
contrib/libtests/pngvalid.c:   for (test = &pool->list; *test != this; test = &(*test)->next)
contrib/libtests/pngvalid.c:   *test = this->next;
contrib/libtests/pngvalid.c:   this->next = NULL;
contrib/libtests/pngvalid.c:      anon_context(ps);
contrib/libtests/pngvalid.c:   anon_context(ps);
contrib/libtests/pngvalid.c: * This routine exists even when there is no read support to make the code
contrib/libtests/pngvalid.c:         anon_context(ps);
contrib/libtests/pngvalid.c:   ps->next = NULL;
contrib/libtests/pngvalid.c:         ps->next = NULL;
contrib/libtests/pngvalid.c:         store_read_buffer_next(ps);
contrib/libtests/pngvalid.c:      pf = pf->next;
contrib/libtests/pngvalid.c:    * we don't ever expect NULL in this program.
contrib/libtests/pngvalid.c:      struct exception_context *the_exception_context = &ps->exception_context;
contrib/libtests/pngvalid.c:      store_log(ps, NULL, "png_create_read_struct returned NULL (unexpected)",
contrib/libtests/pngvalid.c: * png_store together with extra members to handle modification and a special
contrib/libtests/pngvalid.c:chromaticity_x(CIE_color c)
contrib/libtests/pngvalid.c:   double                   maxout8;  /* Maximum output value error */
contrib/libtests/pngvalid.c:   double                   maxabs8;  /* Absolute sample error 0..1 */
contrib/libtests/pngvalid.c:   double                   maxcalc8; /* Absolute sample error 0..1 */
contrib/libtests/pngvalid.c:   double                   maxpc8;   /* Percentage sample error 0..100% */
contrib/libtests/pngvalid.c:   double                   maxout16; /* Maximum output value error */
contrib/libtests/pngvalid.c:   double                   maxabs16; /* Absolute sample error 0..1 */
contrib/libtests/pngvalid.c:   double                   maxcalc16;/* Absolute sample error 0..1 */
contrib/libtests/pngvalid.c:   double                   maxcalcG; /* Absolute sample error 0..1 */
contrib/libtests/pngvalid.c:   double                   maxpc16;  /* Percentage sample error 0..100% */
contrib/libtests/pngvalid.c:   double                   error_indexed;
contrib/libtests/pngvalid.c:    * result should always be exact within the permitted error limits.
contrib/libtests/pngvalid.c:   unsigned int             test_gamma_expand16 :1;
contrib/libtests/pngvalid.c:   unsigned int             test_exhaustive :1;
contrib/libtests/pngvalid.c:   unsigned int             log :1;   /* Log max error */
contrib/libtests/pngvalid.c:   pm->maxout8 = pm->maxpc8 = pm->maxabs8 = pm->maxcalc8 = 0;
contrib/libtests/pngvalid.c:   pm->maxout16 = pm->maxpc16 = pm->maxabs16 = pm->maxcalc16 = 0;
contrib/libtests/pngvalid.c:   pm->maxcalcG = 0;
contrib/libtests/pngvalid.c:   pm->error_indexed = 0;
contrib/libtests/pngvalid.c:   pm->test_gamma_expand16 = 0;
contrib/libtests/pngvalid.c:   pm->test_exhaustive = 0;
contrib/libtests/pngvalid.c:/* This controls use of checks that explicitly know how libpng digitizes the
contrib/libtests/pngvalid.c: * in the rgb_to_gray check, replacing it with an exact copy of the libpng 1.5
contrib/libtests/pngvalid.c:      return pm->maxabs16;
contrib/libtests/pngvalid.c:      return pm->maxabs8;
contrib/libtests/pngvalid.c:      return pm->maxcalc16;
contrib/libtests/pngvalid.c:      return pm->maxcalcG;
contrib/libtests/pngvalid.c:      return pm->maxcalc8;
contrib/libtests/pngvalid.c:      return pm->maxpc16 * .01;
contrib/libtests/pngvalid.c:      return pm->maxpc8 * .01;
contrib/libtests/pngvalid.c: * the expand_16 case with the current code in libpng the expand happens after
contrib/libtests/pngvalid.c:    * TODO: fix this in libpng
contrib/libtests/pngvalid.c:      return pm->maxout16;
contrib/libtests/pngvalid.c:      return pm->maxout8 * 257;
contrib/libtests/pngvalid.c:      return pm->maxout8;
contrib/libtests/pngvalid.c: * exactly what set of parameters cause high error values.
contrib/libtests/pngvalid.c: * suitable chunk does not exist.
contrib/libtests/pngvalid.c:   struct png_modification *next;
contrib/libtests/pngvalid.c:      modification_reset(pmm->next);
contrib/libtests/pngvalid.c:   pmm->next = NULL;
contrib/libtests/pngvalid.c: * which is used depends on the setting of the 'test_exhaustive' flag.  Notice
contrib/libtests/pngvalid.c:      if (pm->test_exhaustive)
contrib/libtests/pngvalid.c:         /* Not exhaustive - choose an encoding at random; generate a number in
contrib/libtests/pngvalid.c:          * the range 1..(max-1), so the result is always non-zero:
contrib/libtests/pngvalid.c:   /* The following must be set in the next run.  In particular
contrib/libtests/pngvalid.c: * png_modifier explicitly) and the callback, which gets the modifier from the
contrib/libtests/pngvalid.c:               mod = mod->next;
contrib/libtests/pngvalid.c:                  mod = mod->next;
contrib/libtests/pngvalid.c:                  mod = mod->next;
contrib/libtests/pngvalid.c:       pm->this.next == NULL)
contrib/libtests/pngvalid.c:      noise = (noise << 9) | ((noise ^ (noise >> (9-5))) & 0x1ff);
contrib/libtests/pngvalid.c:      cb = noise & 0x1ff;
contrib/libtests/pngvalid.c:       pm->this.next != &pm->this.current->data ||
contrib/libtests/pngvalid.c:   png_fixed_point  gamma;
contrib/libtests/pngvalid.c:   g = fix(gammad);
contrib/libtests/pngvalid.c:   me->gamma = (png_fixed_point)g;
contrib/libtests/pngvalid.c:   me->this.next = pm->modifications;
contrib/libtests/pngvalid.c:   png_fixed_point           wx, wy, rx, ry, gx, gy, bx, by;
contrib/libtests/pngvalid.c:   png_save_uint_32(pm->buffer+ 8, ((chrm_modification*)me)->wx);
contrib/libtests/pngvalid.c:   png_save_uint_32(pm->buffer+16, ((chrm_modification*)me)->rx);
contrib/libtests/pngvalid.c:   png_save_uint_32(pm->buffer+24, ((chrm_modification*)me)->gx);
contrib/libtests/pngvalid.c:   png_save_uint_32(pm->buffer+32, ((chrm_modification*)me)->bx);
contrib/libtests/pngvalid.c:   /* Chromaticities (in fixed point): */
contrib/libtests/pngvalid.c:   me->wx = fix(chromaticity_x(white));
contrib/libtests/pngvalid.c:   me->wy = fix(chromaticity_y(white));
contrib/libtests/pngvalid.c:   me->rx = fix(chromaticity_x(encoding->red));
contrib/libtests/pngvalid.c:   me->ry = fix(chromaticity_y(encoding->red));
contrib/libtests/pngvalid.c:   me->gx = fix(chromaticity_x(encoding->green));
contrib/libtests/pngvalid.c:   me->gy = fix(chromaticity_y(encoding->green));
contrib/libtests/pngvalid.c:   me->bx = fix(chromaticity_x(encoding->blue));
contrib/libtests/pngvalid.c:   me->by = fix(chromaticity_y(encoding->blue));
contrib/libtests/pngvalid.c:   me->this.next = pm->modifications;
contrib/libtests/pngvalid.c:   me->this.next = pm->modifications;
contrib/libtests/pngvalid.c:               "unexpected colour type in sBIT modification");
contrib/libtests/pngvalid.c:   me->this.next = pm->modifications;
contrib/libtests/pngvalid.c: * all the possible pixel values (not possible for 16bpp images, but a range of
contrib/libtests/pngvalid.c: * format every row has 128 pixels (giving 1024 bytes for 64bpp formats).
contrib/libtests/pngvalid.c: * The size files ar constructed with rows a maximum of 128 bytes wide, allowing
contrib/libtests/pngvalid.c: * a maximum width of 16 pixels (for the 64bpp case.)  They also have a maximum
contrib/libtests/pngvalid.c: * (maximum) this actually makes a random palette in the hope that enough tests
contrib/libtests/pngvalid.c:   static png_uint_32 palette_seed[2] = { 0x87654321, 9 };
contrib/libtests/pngvalid.c:   /* Always put in black and white plus the six primary and secondary colors.
contrib/libtests/pngvalid.c:    * chance is the same, so we get a duplicate or extra gray less than 1 time
contrib/libtests/pngvalid.c:       * no relationship between palette index and the color value therein!)
contrib/libtests/pngvalid.c:#define SIZE_ROWMAX (16*8U) /* 16 pixels, max 8 bytes each - 128 bytes */
contrib/libtests/pngvalid.c:#define SIZE_HEIGHTMAX 16 /* Maximum range of size images */
contrib/libtests/pngvalid.c:         return 1;   /* Total of 128 pixels */
contrib/libtests/pngvalid.c:         return 2;   /* Total of 256 pixels/bytes */
contrib/libtests/pngvalid.c:         return 512; /* Total of 65536 pixels */
contrib/libtests/pngvalid.c:         return 512; /* 65536 pixels */
contrib/libtests/pngvalid.c:         return 2048;/* 4 x 65536 pixels. */
contrib/libtests/pngvalid.c:         while (i<128/8) buffer[i] = (png_byte)(v & 0xff), v += 17, ++i;
contrib/libtests/pngvalid.c:         while (i<128/4) buffer[i] = (png_byte)(v & 0xff), v += 33, ++i;
contrib/libtests/pngvalid.c:         while (i<128/2) buffer[i] = (png_byte)(v & 0xff), v += 65, ++i;
contrib/libtests/pngvalid.c:         while (i<128) buffer[i] = (png_byte)(v & 0xff), ++v, ++i;
contrib/libtests/pngvalid.c:         /* Generate all 65536 pixel values in order, which includes the 8 bit
contrib/libtests/pngvalid.c:            buffer[2*i] = (png_byte)((v>>8) & 0xff);
contrib/libtests/pngvalid.c:            buffer[2*i+1] = (png_byte)(v & 0xff);
contrib/libtests/pngvalid.c:         /* 65535 pixels, but rotate the values. */
contrib/libtests/pngvalid.c:            /* Three bytes per pixel, r, g, b, make b by r^g */
contrib/libtests/pngvalid.c:            buffer[3*i+0] = (png_byte)((v >> 8) & 0xff);
contrib/libtests/pngvalid.c:            buffer[3*i+1] = (png_byte)(v & 0xff);
contrib/libtests/pngvalid.c:            buffer[3*i+2] = (png_byte)(((v >> 8) ^ v) & 0xff);
contrib/libtests/pngvalid.c:         /* 65535 pixels, r, g, b, a; just replicate */
contrib/libtests/pngvalid.c:            buffer[4*i+0] = (png_byte)((v >> 8) & 0xff);
contrib/libtests/pngvalid.c:            buffer[4*i+1] = (png_byte)(v & 0xff);
contrib/libtests/pngvalid.c:            buffer[4*i+2] = (png_byte)((v >> 8) & 0xff);
contrib/libtests/pngvalid.c:            buffer[4*i+3] = (png_byte)(v & 0xff);
contrib/libtests/pngvalid.c:         /* y is maximum 2047, giving 4x65536 pixels, make 'r' increase by 1 at
contrib/libtests/pngvalid.c:          * each pixel, g increase by 257 (0x101) and 'b' by 0x1111:
contrib/libtests/pngvalid.c:            buffer[6*i+0] = (png_byte)((t >> 8) & 0xff);
contrib/libtests/pngvalid.c:            buffer[6*i+1] = (png_byte)(t & 0xff);
contrib/libtests/pngvalid.c:            buffer[6*i+2] = (png_byte)((t >> 8) & 0xff);
contrib/libtests/pngvalid.c:            buffer[6*i+3] = (png_byte)(t & 0xff);
contrib/libtests/pngvalid.c:            buffer[6*i+4] = (png_byte)((t >> 8) & 0xff);
contrib/libtests/pngvalid.c:            buffer[6*i+5] = (png_byte)(t & 0xff);
contrib/libtests/pngvalid.c:            buffer[8*i+0] = (png_byte)((t >> 8) & 0xff);
contrib/libtests/pngvalid.c:            buffer[8*i+1] = (png_byte)(t & 0xff);
contrib/libtests/pngvalid.c:            buffer[8*i+4] = (png_byte)((t >> 8) & 0xff);
contrib/libtests/pngvalid.c:            buffer[8*i+5] = (png_byte)(t & 0xff);
contrib/libtests/pngvalid.c:            buffer[8*i+2] = (png_byte)((t >> 8) & 0xff);
contrib/libtests/pngvalid.c:            buffer[8*i+3] = (png_byte)(t & 0xff);
contrib/libtests/pngvalid.c:            buffer[8*i+6] = (png_byte)((t >> 8) & 0xff);
contrib/libtests/pngvalid.c:            buffer[8*i+7] = (png_byte)(t & 0xff);
contrib/libtests/pngvalid.c:      exit(99);
contrib/libtests/pngvalid.c:   context(ps, fault);
contrib/libtests/pngvalid.c:         png_text text;
contrib/libtests/pngvalid.c:         /* Use a compressed text string to test the correct interaction of text
contrib/libtests/pngvalid.c:         text.compression = TEXT_COMPRESSION;
contrib/libtests/pngvalid.c:         text.key = key;
contrib/libtests/pngvalid.c:         /* Yuck: the text must be writable! */
contrib/libtests/pngvalid.c:         text.text = copy;
contrib/libtests/pngvalid.c:         text.text_length = pos;
contrib/libtests/pngvalid.c:         text.itxt_length = 0;
contrib/libtests/pngvalid.c:         text.lang = 0;
contrib/libtests/pngvalid.c:         text.lang_key = 0;
contrib/libtests/pngvalid.c:         png_set_text(pp, pi, &text, 1);
contrib/libtests/pngvalid.c:         png_text text;
contrib/libtests/pngvalid.c:         /* Use a compressed text string to test the correct interaction of text
contrib/libtests/pngvalid.c:         text.compression = TEXT_COMPRESSION;
contrib/libtests/pngvalid.c:         text.key = key;
contrib/libtests/pngvalid.c:         text.text = comment;
contrib/libtests/pngvalid.c:         text.text_length = (sizeof comment)-1;
contrib/libtests/pngvalid.c:         text.itxt_length = 0;
contrib/libtests/pngvalid.c:         text.lang = 0;
contrib/libtests/pngvalid.c:         text.lang_key = 0;
contrib/libtests/pngvalid.c:         png_set_text(pp, pi, &text, 1);
contrib/libtests/pngvalid.c:      /* Use the png_store returned by the exception. This may help the compiler
contrib/libtests/pngvalid.c:   /* Use next_format to enumerate all the combinations we test, including
contrib/libtests/pngvalid.c:   while (next_format(&colour_type, &bit_depth, &palette_number, 0))
contrib/libtests/pngvalid.c:   unsigned int pixel_size, png_uint_32 w, int pass)
contrib/libtests/pngvalid.c:   png_uint_32 xin, xout, xstep;
contrib/libtests/pngvalid.c:   xin = PNG_PASS_START_COL(pass);
contrib/libtests/pngvalid.c:   xstep = 1U<<PNG_PASS_COL_SHIFT(pass);
contrib/libtests/pngvalid.c:   for (xout=0; xin<w; xin+=xstep)
contrib/libtests/pngvalid.c:      pixel_copy(buffer, xout, imageRow, xin, pixel_size);
contrib/libtests/pngvalid.c:      ++xout;
contrib/libtests/pngvalid.c:   unsigned int pixel_size, png_uint_32 w, int pass)
contrib/libtests/pngvalid.c:    * the pixels of row into buffer and return the number written (to allow
contrib/libtests/pngvalid.c:   png_uint_32 xin, xout, xstep;
contrib/libtests/pngvalid.c:   xout = PNG_PASS_START_COL(pass);
contrib/libtests/pngvalid.c:   xstep = 1U<<PNG_PASS_COL_SHIFT(pass);
contrib/libtests/pngvalid.c:   for (xin=0; xout<w; xout+=xstep)
contrib/libtests/pngvalid.c:      pixel_copy(buffer, xout, row, xin, pixel_size);
contrib/libtests/pngvalid.c:      ++xin;
contrib/libtests/pngvalid.c:   y ^= 0xA5;
contrib/libtests/pngvalid.c:   context(ps, fault);
contrib/libtests/pngvalid.c:    * does the pixel interlace itself, so:
contrib/libtests/pngvalid.c:      unsigned int pixel_size;
contrib/libtests/pngvalid.c:         png_text text;
contrib/libtests/pngvalid.c:         /* Use a compressed text string to test the correct interaction of text
contrib/libtests/pngvalid.c:         text.compression = TEXT_COMPRESSION;
contrib/libtests/pngvalid.c:         text.key = key;
contrib/libtests/pngvalid.c:         /* Yuck: the text must be writable! */
contrib/libtests/pngvalid.c:         text.text = copy;
contrib/libtests/pngvalid.c:         text.text_length = pos;
contrib/libtests/pngvalid.c:         text.itxt_length = 0;
contrib/libtests/pngvalid.c:         text.lang = 0;
contrib/libtests/pngvalid.c:         text.lang_key = 0;
contrib/libtests/pngvalid.c:         png_set_text(pp, pi, &text, 1);
contrib/libtests/pngvalid.c:      pixel_size = bit_size(pp, colour_type, bit_depth);
contrib/libtests/pngvalid.c:      if (png_get_rowbytes(pp, pi) != ((w * pixel_size) + 7) / 8)
contrib/libtests/pngvalid.c:         memset(image, 0xff, sizeof image);
contrib/libtests/pngvalid.c:            size_row(image[y], w * pixel_size, y);
contrib/libtests/pngvalid.c:             * row because some of them are empty.  In fact, for a 1x1 image,
contrib/libtests/pngvalid.c:                  /* The row must not be written if it doesn't exist, notice
contrib/libtests/pngvalid.c:                   * enough to contribute any pixels.  In fact the wPass test
contrib/libtests/pngvalid.c:                     memset(tempRow, 0xff, sizeof tempRow);
contrib/libtests/pngvalid.c:                     interlace_row(tempRow, row, pixel_size, w, pass);
contrib/libtests/pngvalid.c:               /* Only get to here if the row has some pixels in it, set the
contrib/libtests/pngvalid.c:         png_text text;
contrib/libtests/pngvalid.c:         /* Use a compressed text string to test the correct interaction of text
contrib/libtests/pngvalid.c:         text.compression = TEXT_COMPRESSION;
contrib/libtests/pngvalid.c:         text.key = key;
contrib/libtests/pngvalid.c:         text.text = comment;
contrib/libtests/pngvalid.c:         text.text_length = (sizeof comment)-1;
contrib/libtests/pngvalid.c:         text.itxt_length = 0;
contrib/libtests/pngvalid.c:         text.lang = 0;
contrib/libtests/pngvalid.c:         text.lang_key = 0;
contrib/libtests/pngvalid.c:         png_set_text(pp, pi, &text, 1);
contrib/libtests/pngvalid.c:      /* Use the png_store returned by the exception. This may help the compiler
contrib/libtests/pngvalid.c:   make_size(ps, 3, 0, 3 /*palette: max 8 bits*/);
contrib/libtests/pngvalid.c:   context(ps, fault);
contrib/libtests/pngvalid.c:#     define exception__prev exception_prev_1
contrib/libtests/pngvalid.c:#     define exception__env exception_env_1
contrib/libtests/pngvalid.c:         /* Expect this to throw: */
contrib/libtests/pngvalid.c:         ps->expect_error = !error_test[test].warning;
contrib/libtests/pngvalid.c:         ps->expect_warning = error_test[test].warning;
contrib/libtests/pngvalid.c:         if (ps->expect_warning && ps->saw_warning)
contrib/libtests/pngvalid.c:         ps = fault; /* expected exit, make sure ps is not clobbered */
contrib/libtests/pngvalid.c:#undef exception__prev
contrib/libtests/pngvalid.c:#undef exception__env
contrib/libtests/pngvalid.c:      ps->expect_error = 0;
contrib/libtests/pngvalid.c:      ps->expect_warning = 0;
contrib/libtests/pngvalid.c:   context(ps, fault);
contrib/libtests/pngvalid.c:   png_uint_32 pixel_size;     /* Width of one pixel in bits */
contrib/libtests/pngvalid.c:   dp->pixel_size = 0;
contrib/libtests/pngvalid.c:   memset(dp->palette, 0xff, sizeof dp->palette);
contrib/libtests/pngvalid.c:      /* Oops, if a palette tRNS gets expanded png_read_update_info (at least so
contrib/libtests/pngvalid.c:      !(trans_alpha != NULL && num == 0)) /* TODO: fix this in libpng. */
contrib/libtests/pngvalid.c:         png_error(pp, "validate: unexpected png_get_tRNS (palette) result");
contrib/libtests/pngvalid.c: * directly by the sequential code, the functions suffixed "_imp" are the
contrib/libtests/pngvalid.c: * implementations, the functions without the suffix are the callbacks.
contrib/libtests/pngvalid.c:            png_error(pp, "validate: unexpected png_get_sBIT result");
contrib/libtests/pngvalid.c:            png_error(pp, "validate: unexpected png_get_tRNS (color) result");
contrib/libtests/pngvalid.c:            /* Not expected because it should result in the array case
contrib/libtests/pngvalid.c:            png_error(pp, "validate: unexpected png_get_tRNS result");
contrib/libtests/pngvalid.c:   /* Read the number of passes - expected to match the value used when
contrib/libtests/pngvalid.c:   dp->pixel_size = bit_size(pp, png_get_color_type(pp, pi),
contrib/libtests/pngvalid.c:   dp->bit_width = png_get_image_width(pp, pi) * dp->pixel_size;
contrib/libtests/pngvalid.c:    * exists for decoding the image.
contrib/libtests/pngvalid.c:            deinterlace_row(row, new_row, dp->pixel_size, dp->w, pass);
contrib/libtests/pngvalid.c:            row_copy(row, new_row, dp->pixel_size * dp->w);
contrib/libtests/pngvalid.c:               /* The following aids (to some extent) error detection - we can
contrib/libtests/pngvalid.c:                * display to make this easier.  Don't use 0xff (which is used in
contrib/libtests/pngvalid.c:               memset(row, 0xc5, sizeof row);
contrib/libtests/pngvalid.c:               memset(display, 0x5c, sizeof display);
contrib/libtests/pngvalid.c:                     dp->pixel_size, dp->w, pass);
contrib/libtests/pngvalid.c:                     dp->pixel_size, dp->w, pass);
contrib/libtests/pngvalid.c:standard_check_text(png_const_structp pp, png_const_textp tp,
contrib/libtests/pngvalid.c:   png_const_charp keyword, png_const_charp text)
contrib/libtests/pngvalid.c:   size_t pos = safecat(msg, sizeof msg, 0, "text: ");
contrib/libtests/pngvalid.c:   if (tp->text == NULL)
contrib/libtests/pngvalid.c:      pos = safecat(msg, sizeof msg, pos, "text lost, ");
contrib/libtests/pngvalid.c:      if (tp->text_length != strlen(text))
contrib/libtests/pngvalid.c:         sprintf(buf, "text length changed[%lu->%lu], ",
contrib/libtests/pngvalid.c:            (unsigned long)strlen(text), (unsigned long)tp->text_length);
contrib/libtests/pngvalid.c:      if (strcmp(tp->text, text) != 0)
contrib/libtests/pngvalid.c:         pos = safecat(msg, sizeof msg, pos, "text becomes \"");
contrib/libtests/pngvalid.c:         pos = safecat(msg, sizeof msg, pos, tp->text);
contrib/libtests/pngvalid.c:         pos = safecat(msg, sizeof msg, pos, text);
contrib/libtests/pngvalid.c:   if (tp->itxt_length != 0)
contrib/libtests/pngvalid.c:standard_text_validate(standard_display *dp, png_const_structp pp,
contrib/libtests/pngvalid.c:   png_textp tp = NULL;
contrib/libtests/pngvalid.c:   png_uint_32 num_text = png_get_text(pp, pi, &tp, NULL);
contrib/libtests/pngvalid.c:   if (num_text == 2 && tp != NULL)
contrib/libtests/pngvalid.c:      standard_check_text(pp, tp, "image name", dp->ps->current->name);
contrib/libtests/pngvalid.c:      /* This exists because prior to 1.5.18 the progressive reader left the
contrib/libtests/pngvalid.c:         standard_check_text(pp, tp+1, "end marker", "end");
contrib/libtests/pngvalid.c:      sprintf(msg, "expected two text items, got %lu",
contrib/libtests/pngvalid.c:         (unsigned long)num_text);
contrib/libtests/pngvalid.c:#  define standard_text_validate(dp,pp,pi,check_end) ((void)0)
contrib/libtests/pngvalid.c:    * In earlier passes 'row' will be partially filled in, with only the pixels
contrib/libtests/pngvalid.c:    * that have been read so far, but 'display' will have those pixels
contrib/libtests/pngvalid.c:    * replicated to fill the unread pixels while reading an interlaced image.
contrib/libtests/pngvalid.c:    * array retains the correct values for unwritten pixels within the row
contrib/libtests/pngvalid.c:    * row bytes are always trashed, so we always do a pixel_cmp here even though
contrib/libtests/pngvalid.c:      (where = pixel_cmp(std, store_image_row(dp->ps, pp, iImage, y),
contrib/libtests/pngvalid.c:      sprintf(msg, "PNG image row[%lu][%d] changed from %.2x to %.2x",
contrib/libtests/pngvalid.c:   /* In this case use pixel_cmp because we need to compare a partial
contrib/libtests/pngvalid.c:    * byte at the end of the row if the row is not an exact multiple
contrib/libtests/pngvalid.c:    * of 8 bits wide.  (This is fixed in libpng-1.5.6 and pixel_cmp is
contrib/libtests/pngvalid.c:      (where = pixel_cmp(std, store_image_row(dp->ps, pp, iDisplay, y),
contrib/libtests/pngvalid.c:      sprintf(msg, "display  row[%lu][%d] changed from %.2x to %.2x",
contrib/libtests/pngvalid.c:   standard_text_validate(dp, pp, pi,
contrib/libtests/pngvalid.c:   context(psIn, fault);
contrib/libtests/pngvalid.c:          * unless the PNG file values have been checked against the expected
contrib/libtests/pngvalid.c:               standard_text_validate(&d, pp, pi, 1/*check_end*/);
contrib/libtests/pngvalid.c:   /* Test each colour type over the valid range of bit depths (expressed as
contrib/libtests/pngvalid.c:    * NOTE: on my 32 bit x86 each of the following blocks takes
contrib/libtests/pngvalid.c:   /* Test each colour type over the valid range of bit depths (expressed as
contrib/libtests/pngvalid.c:typedef struct image_pixel
contrib/libtests/pngvalid.c:   /* A local (pngvalid) representation of a PNG pixel, in all its
contrib/libtests/pngvalid.c:   unsigned int palette_index;           /* For a palette image. */
contrib/libtests/pngvalid.c:    * at the end of the application of the transforms to the pixel.
contrib/libtests/pngvalid.c:} image_pixel;
contrib/libtests/pngvalid.c:image_pixel_setf(image_pixel *this, unsigned int max)
contrib/libtests/pngvalid.c:   this->redf = this->red / (double)max;
contrib/libtests/pngvalid.c:   this->greenf = this->green / (double)max;
contrib/libtests/pngvalid.c:   this->bluef = this->blue / (double)max;
contrib/libtests/pngvalid.c:   this->alphaf = this->alpha / (double)max;
contrib/libtests/pngvalid.c:   if (this->red < max)
contrib/libtests/pngvalid.c:   if (this->green < max)
contrib/libtests/pngvalid.c:   if (this->blue < max)
contrib/libtests/pngvalid.c:   if (this->alpha < max)
contrib/libtests/pngvalid.c:/* Initialize the structure for the next pixel - call this before doing any
contrib/libtests/pngvalid.c: * transforms and call it for each pixel since all the fields may need to be
contrib/libtests/pngvalid.c:image_pixel_init(image_pixel *this, png_const_bytep row, png_byte colour_type,
contrib/libtests/pngvalid.c:    png_byte bit_depth, png_uint_32 x, store_palette palette)
contrib/libtests/pngvalid.c:   PNG_CONST unsigned int max = (1U<<sample_depth)-1;
contrib/libtests/pngvalid.c:    * Note that this currently assumes a simple palette where entry x has colour
contrib/libtests/pngvalid.c:    * rgb(x,x,x)!
contrib/libtests/pngvalid.c:   this->palette_index = this->red = this->green = this->blue =
contrib/libtests/pngvalid.c:      sample(row, colour_type, bit_depth, x, 0);
contrib/libtests/pngvalid.c:   this->alpha = max;
contrib/libtests/pngvalid.c:         PNG_CONST unsigned int i = this->palette_index;
contrib/libtests/pngvalid.c:         this->green = sample(row, colour_type, bit_depth, x, 1);
contrib/libtests/pngvalid.c:         this->blue = sample(row, colour_type, bit_depth, x, 2);
contrib/libtests/pngvalid.c:         this->alpha = sample(row, colour_type, bit_depth, x, ++i);
contrib/libtests/pngvalid.c:    * 'max' and the error is initialized to the double precision epsilon value
contrib/libtests/pngvalid.c:   image_pixel_setf(this, max);
contrib/libtests/pngvalid.c: * instead the image_pixel value from the row contains the RGB of the
contrib/libtests/pngvalid.c:image_pixel_convert_PLTE(image_pixel *this)
contrib/libtests/pngvalid.c:image_pixel_add_alpha(image_pixel *this, PNG_CONST standard_display *display)
contrib/libtests/pngvalid.c:      image_pixel_convert_PLTE(this);
contrib/libtests/pngvalid.c:            /* Again, check the exact input values, not the current transformed
contrib/libtests/pngvalid.c:   /* The next transform in the list, each transform must call its own next
contrib/libtests/pngvalid.c:    * transform after it has processed the pixel successfully.
contrib/libtests/pngvalid.c:   PNG_CONST struct image_transform *next;
contrib/libtests/pngvalid.c:   /* A single transform for the image, expressed as a series of function
contrib/libtests/pngvalid.c:   /* Then a transform that takes an input pixel in one PNG format or another
contrib/libtests/pngvalid.c:   void (*mod)(PNG_CONST struct image_transform *this, image_pixel *that,
contrib/libtests/pngvalid.c:/* At the end of the list recalculate the output image pixel value from the
contrib/libtests/pngvalid.c:image_transform_mod_end(PNG_CONST image_transform *this, image_pixel *that,
contrib/libtests/pngvalid.c:    * to the current sample_depth of the pixel.
contrib/libtests/pngvalid.c:    * The sample value is simply scaled to the maximum, checking for over
contrib/libtests/pngvalid.c:      that->alphae = 0;    /* It's exact ;-) */
contrib/libtests/pngvalid.c:   0, /* next */
contrib/libtests/pngvalid.c:   /* Plus the extra stuff we need for the transform tests: */
contrib/libtests/pngvalid.c:   /* Use a test pixel to check that the output agrees with what we expect -
contrib/libtests/pngvalid.c:    * this avoids running the whole test if the output is unexpected.
contrib/libtests/pngvalid.c:      image_pixel test_pixel;
contrib/libtests/pngvalid.c:      memset(&test_pixel, 0, sizeof test_pixel);
contrib/libtests/pngvalid.c:      test_pixel.colour_type = dp->this.colour_type; /* input */
contrib/libtests/pngvalid.c:      test_pixel.bit_depth = dp->this.bit_depth;
contrib/libtests/pngvalid.c:      if (test_pixel.colour_type == PNG_COLOR_TYPE_PALETTE)
contrib/libtests/pngvalid.c:         test_pixel.sample_depth = 8;
contrib/libtests/pngvalid.c:         test_pixel.sample_depth = test_pixel.bit_depth;
contrib/libtests/pngvalid.c:      test_pixel.have_tRNS = dp->this.is_transparent;
contrib/libtests/pngvalid.c:      test_pixel.red_sBIT = test_pixel.green_sBIT = test_pixel.blue_sBIT =
contrib/libtests/pngvalid.c:         test_pixel.alpha_sBIT = test_pixel.sample_depth;
contrib/libtests/pngvalid.c:      dp->transform_list->mod(dp->transform_list, &test_pixel, pp, dp);
contrib/libtests/pngvalid.c:      if (test_pixel.colour_type != dp->output_colour_type)
contrib/libtests/pngvalid.c:         pos = safecat(message, sizeof message, pos, " expected ");
contrib/libtests/pngvalid.c:         pos = safecatn(message, sizeof message, pos, test_pixel.colour_type);
contrib/libtests/pngvalid.c:      if (test_pixel.bit_depth != dp->output_bit_depth)
contrib/libtests/pngvalid.c:         pos = safecat(message, sizeof message, pos, " expected ");
contrib/libtests/pngvalid.c:         pos = safecatn(message, sizeof message, pos, test_pixel.bit_depth);
contrib/libtests/pngvalid.c:      if (test_pixel.colour_type == PNG_COLOR_TYPE_PALETTE)
contrib/libtests/pngvalid.c:         if (test_pixel.sample_depth != 8) /* oops - internal error! */
contrib/libtests/pngvalid.c:      else if (test_pixel.sample_depth != dp->output_bit_depth)
contrib/libtests/pngvalid.c:         pos = safecat(message, sizeof message, pos, " expected ");
contrib/libtests/pngvalid.c:         pos = safecatn(message, sizeof message, pos, test_pixel.sample_depth);
contrib/libtests/pngvalid.c:    * digitization depth of the libpng output colors (the bit depth except for
contrib/libtests/pngvalid.c:   unsigned int max = (1U<<sample_depth)-1;
contrib/libtests/pngvalid.c:   double in_min = ceil((in-err)*max - digitization_error);
contrib/libtests/pngvalid.c:   double in_max = floor((in+err)*max + digitization_error);
contrib/libtests/pngvalid.c:   if (err > limit || !(out >= in_min && out <= in_max))
contrib/libtests/pngvalid.c:      pos = safecat(message, sizeof message, pos, " expected: ");
contrib/libtests/pngvalid.c:      pos = safecatd(message, sizeof message, pos, (in-err)*max, 3);
contrib/libtests/pngvalid.c:      pos = safecatd(message, sizeof message, pos, (in+err)*max, 3);
contrib/libtests/pngvalid.c:       * expected.
contrib/libtests/pngvalid.c:         png_error(pp, "unexpected change in palette size");
contrib/libtests/pngvalid.c:      memset(out_palette, 0x5e, sizeof out_palette);
contrib/libtests/pngvalid.c:      png_uint_32 x;
contrib/libtests/pngvalid.c:      /* Go through each original pixel transforming it and comparing with what
contrib/libtests/pngvalid.c:       * libpng did to the same pixel.
contrib/libtests/pngvalid.c:      for (x=0; x<w; ++x)
contrib/libtests/pngvalid.c:         image_pixel in_pixel, out_pixel;
contrib/libtests/pngvalid.c:         /* Find out what we think the pixel should be: */
contrib/libtests/pngvalid.c:         image_pixel_init(&in_pixel, std, in_ct, in_bd, x, dp->this.palette);
contrib/libtests/pngvalid.c:         in_pixel.red_sBIT = red_sBIT;
contrib/libtests/pngvalid.c:         in_pixel.green_sBIT = green_sBIT;
contrib/libtests/pngvalid.c:         in_pixel.blue_sBIT = blue_sBIT;
contrib/libtests/pngvalid.c:         in_pixel.alpha_sBIT = alpha_sBIT;
contrib/libtests/pngvalid.c:         in_pixel.have_tRNS = have_tRNS;
contrib/libtests/pngvalid.c:         r = in_pixel.red;
contrib/libtests/pngvalid.c:         g = in_pixel.green;
contrib/libtests/pngvalid.c:         b = in_pixel.blue;
contrib/libtests/pngvalid.c:         a = in_pixel.alpha;
contrib/libtests/pngvalid.c:         dp->transform_list->mod(dp->transform_list, &in_pixel, pp, dp);
contrib/libtests/pngvalid.c:         /* Read the output pixel and compare it to what we got, we don't
contrib/libtests/pngvalid.c:         image_pixel_init(&out_pixel, pRow, out_ct, out_bd, x, out_palette);
contrib/libtests/pngvalid.c:         /* We don't expect changes to the index here even if the bit depth is
contrib/libtests/pngvalid.c:            if (in_pixel.palette_index != out_pixel.palette_index)
contrib/libtests/pngvalid.c:               png_error(pp, "unexpected transformed palette index");
contrib/libtests/pngvalid.c:         if (in_pixel.red != out_pixel.red)
contrib/libtests/pngvalid.c:            transform_range_check(pp, r, g, b, a, in_pixel.red, in_pixel.redf,
contrib/libtests/pngvalid.c:               out_pixel.red, sample_depth, in_pixel.rede,
contrib/libtests/pngvalid.c:               dp->pm->limit + 1./(2*((1U<<in_pixel.red_sBIT)-1)), "red/gray",
contrib/libtests/pngvalid.c:            in_pixel.green != out_pixel.green)
contrib/libtests/pngvalid.c:            transform_range_check(pp, r, g, b, a, in_pixel.green,
contrib/libtests/pngvalid.c:               in_pixel.greenf, out_pixel.green, sample_depth, in_pixel.greene,
contrib/libtests/pngvalid.c:               dp->pm->limit + 1./(2*((1U<<in_pixel.green_sBIT)-1)), "green",
contrib/libtests/pngvalid.c:            in_pixel.blue != out_pixel.blue)
contrib/libtests/pngvalid.c:            transform_range_check(pp, r, g, b, a, in_pixel.blue, in_pixel.bluef,
contrib/libtests/pngvalid.c:               out_pixel.blue, sample_depth, in_pixel.bluee,
contrib/libtests/pngvalid.c:               dp->pm->limit + 1./(2*((1U<<in_pixel.blue_sBIT)-1)), "blue",
contrib/libtests/pngvalid.c:            in_pixel.alpha != out_pixel.alpha)
contrib/libtests/pngvalid.c:            transform_range_check(pp, r, g, b, a, in_pixel.alpha,
contrib/libtests/pngvalid.c:               in_pixel.alphaf, out_pixel.alpha, sample_depth, in_pixel.alphae,
contrib/libtests/pngvalid.c:               dp->pm->limit + 1./(2*((1U<<in_pixel.alpha_sBIT)-1)), "alpha",
contrib/libtests/pngvalid.c:      } /* pixel (x) loop */
contrib/libtests/pngvalid.c:   context(&pmIn->this, fault);
contrib/libtests/pngvalid.c:         /* modifier_read expects a png_modifier* */
contrib/libtests/pngvalid.c:   0, /*next*/\
contrib/libtests/pngvalid.c:   this->next->ini(this->next, that);
contrib/libtests/pngvalid.c:   this->next = *that;
contrib/libtests/pngvalid.c:   this->next->set(this->next, that, pp, pi);
contrib/libtests/pngvalid.c:    image_pixel *that, png_const_structp pp,
contrib/libtests/pngvalid.c:      image_pixel_convert_PLTE(that);
contrib/libtests/pngvalid.c:   this->next->mod(this->next, that, pp, display);
contrib/libtests/pngvalid.c:   this->next = *that;
contrib/libtests/pngvalid.c:   this->next->set(this->next, that, pp, pi);
contrib/libtests/pngvalid.c:   image_pixel *that, png_const_structp pp,
contrib/libtests/pngvalid.c:      image_pixel_convert_PLTE(that);
contrib/libtests/pngvalid.c:   /* This effectively does an 'expand' only if there is some transparency to
contrib/libtests/pngvalid.c:      image_pixel_add_alpha(that, &display->this);
contrib/libtests/pngvalid.c:   /* LIBPNG BUG: otherwise libpng still expands to 8 bits! */
contrib/libtests/pngvalid.c:   this->next->mod(this->next, that, pp, display);
contrib/libtests/pngvalid.c:   this->next = *that;
contrib/libtests/pngvalid.c:   this->next->set(this->next, that, pp, pi);
contrib/libtests/pngvalid.c:    image_pixel *that, png_const_structp pp,
contrib/libtests/pngvalid.c:    * can correctly recognize the original pixel value even though we have
contrib/libtests/pngvalid.c:      image_pixel_add_alpha(that, &display->this);
contrib/libtests/pngvalid.c:   /* Simply expand the bit depth and alter the colour type as required. */
contrib/libtests/pngvalid.c:   this->next->mod(this->next, that, pp, display);
contrib/libtests/pngvalid.c:   this->next = *that;
contrib/libtests/pngvalid.c:/* png_set_expand */
contrib/libtests/pngvalid.c:image_transform_png_set_expand_set(PNG_CONST image_transform *this,
contrib/libtests/pngvalid.c:   png_set_expand(pp);
contrib/libtests/pngvalid.c:   this->next->set(this->next, that, pp, pi);
contrib/libtests/pngvalid.c:image_transform_png_set_expand_mod(PNG_CONST image_transform *this,
contrib/libtests/pngvalid.c:    image_pixel *that, png_const_structp pp,
contrib/libtests/pngvalid.c:   /* The general expand case depends on what the colour type is: */
contrib/libtests/pngvalid.c:      image_pixel_convert_PLTE(that);
contrib/libtests/pngvalid.c:      image_pixel_add_alpha(that, &display->this);
contrib/libtests/pngvalid.c:   this->next->mod(this->next, that, pp, display);
contrib/libtests/pngvalid.c:image_transform_png_set_expand_add(image_transform *this,
contrib/libtests/pngvalid.c:   this->next = *that;
contrib/libtests/pngvalid.c:   /* 'expand' should do nothing for RGBA or GA input - no tRNS and the bit
contrib/libtests/pngvalid.c:IT(expand);
contrib/libtests/pngvalid.c:#define PT ITSTRUCT(expand)
contrib/libtests/pngvalid.c:/* png_set_expand_gray_1_2_4_to_8
contrib/libtests/pngvalid.c: * LIBPNG BUG: this just does an 'expand'
contrib/libtests/pngvalid.c:image_transform_png_set_expand_gray_1_2_4_to_8_set(
contrib/libtests/pngvalid.c:   png_set_expand_gray_1_2_4_to_8(pp);
contrib/libtests/pngvalid.c:   this->next->set(this->next, that, pp, pi);
contrib/libtests/pngvalid.c:image_transform_png_set_expand_gray_1_2_4_to_8_mod(
contrib/libtests/pngvalid.c:    PNG_CONST image_transform *this, image_pixel *that, png_const_structp pp,
contrib/libtests/pngvalid.c:   image_transform_png_set_expand_mod(this, that, pp, display);
contrib/libtests/pngvalid.c:image_transform_png_set_expand_gray_1_2_4_to_8_add(image_transform *this,
contrib/libtests/pngvalid.c:   return image_transform_png_set_expand_add(this, that, colour_type,
contrib/libtests/pngvalid.c:IT(expand_gray_1_2_4_to_8);
contrib/libtests/pngvalid.c:#define PT ITSTRUCT(expand_gray_1_2_4_to_8)
contrib/libtests/pngvalid.c:/* png_set_expand_16 */
contrib/libtests/pngvalid.c:image_transform_png_set_expand_16_set(PNG_CONST image_transform *this,
contrib/libtests/pngvalid.c:   png_set_expand_16(pp);
contrib/libtests/pngvalid.c:   this->next->set(this->next, that, pp, pi);
contrib/libtests/pngvalid.c:image_transform_png_set_expand_16_mod(PNG_CONST image_transform *this,
contrib/libtests/pngvalid.c:    image_pixel *that, png_const_structp pp,
contrib/libtests/pngvalid.c:   /* Expect expand_16 to expand everything to 16 bits as a result of also
contrib/libtests/pngvalid.c:    * causing 'expand' to happen.
contrib/libtests/pngvalid.c:      image_pixel_convert_PLTE(that);
contrib/libtests/pngvalid.c:      image_pixel_add_alpha(that, &display->this);
contrib/libtests/pngvalid.c:   this->next->mod(this->next, that, pp, display);
contrib/libtests/pngvalid.c:image_transform_png_set_expand_16_add(image_transform *this,
contrib/libtests/pngvalid.c:   this->next = *that;
contrib/libtests/pngvalid.c:   /* expand_16 does something unless the bit depth is already 16. */
contrib/libtests/pngvalid.c:IT(expand_16);
contrib/libtests/pngvalid.c:#define PT ITSTRUCT(expand_16)
contrib/libtests/pngvalid.c:   this->next->set(this->next, that, pp, pi);
contrib/libtests/pngvalid.c:    image_pixel *that, png_const_structp pp,
contrib/libtests/pngvalid.c:   this->next->mod(this->next, that, pp, display);
contrib/libtests/pngvalid.c:   this->next = *that;
contrib/libtests/pngvalid.c:   this->next->set(this->next, that, pp, pi);
contrib/libtests/pngvalid.c:    image_pixel *that, png_const_structp pp,
contrib/libtests/pngvalid.c:   this->next->mod(this->next, that, pp, display);
contrib/libtests/pngvalid.c:   this->next = *that;
contrib/libtests/pngvalid.c:   this->next->set(this->next, that, pp, pi);
contrib/libtests/pngvalid.c:    image_pixel *that, png_const_structp pp,
contrib/libtests/pngvalid.c:   this->next->mod(this->next, that, pp, display);
contrib/libtests/pngvalid.c:   this->next = *that;
contrib/libtests/pngvalid.c: * png_set_rgb_to_gray_fixed(png_structp, int err_action, png_fixed_point red,
contrib/libtests/pngvalid.c: *    png_fixed_point green)
contrib/libtests/pngvalid.c:      png_fixed_point red_to_set;
contrib/libtests/pngvalid.c:      png_fixed_point green_to_set;
contrib/libtests/pngvalid.c:    * by the color space encoding.  If doing exhaustive checks do the override
contrib/libtests/pngvalid.c:   if (pm->test_exhaustive)
contrib/libtests/pngvalid.c:      data.green_coefficient = total = (ru & 0xffff) / 65535.;
contrib/libtests/pngvalid.c:      data.red_coefficient = (1 - total) * (ru & 0xffff) / 65535.;
contrib/libtests/pngvalid.c:         data.red_to_set = fix(data.red_coefficient);
contrib/libtests/pngvalid.c:         data.green_to_set = fix(data.green_coefficient);
contrib/libtests/pngvalid.c:          * will trigger the error check in transform_range_check.  Fix that
contrib/libtests/pngvalid.c:          * NOTE: this magic number was determined by experiment to be 1.1 (when
contrib/libtests/pngvalid.c:          * using fixed point arithmetic).  There's no great merit to the value
contrib/libtests/pngvalid.c:      png_set_rgb_to_gray_fixed(pp, error_action, data.red_to_set,
contrib/libtests/pngvalid.c:#           define API_cvt(x) (x)
contrib/libtests/pngvalid.c:#           define API_function png_get_cHRM_XYZ_fixed
contrib/libtests/pngvalid.c:#           define API_form "fixed"
contrib/libtests/pngvalid.c:#           define API_type png_fixed_point
contrib/libtests/pngvalid.c:#           define API_cvt(x) ((double)(x)/PNG_FP_1)
contrib/libtests/pngvalid.c:            double maxe;
contrib/libtests/pngvalid.c:            /* Expect libpng to return a normalized result, but the original
contrib/libtests/pngvalid.c:             * the range permitted by the libpng fixed point representation.
contrib/libtests/pngvalid.c:            maxe = 0;
contrib/libtests/pngvalid.c:#           define CHECK(col,x)\
contrib/libtests/pngvalid.c:               double err = fabs(o.col.x - e.col.x);\
contrib/libtests/pngvalid.c:               if (err > maxe)\
contrib/libtests/pngvalid.c:                  maxe = err;\
contrib/libtests/pngvalid.c:                  el = #col "(" #x ")";\
contrib/libtests/pngvalid.c:            /* Here in both fixed and floating cases to check the values read
contrib/libtests/pngvalid.c:             * from the cHRm chunk.  PNG uses fixed point in the cHRM chunk, so
contrib/libtests/pngvalid.c:             * we can't expect better than +/-.5E-5 on the result, allow 1E-5.
contrib/libtests/pngvalid.c:            if (maxe >= 1E-5)
contrib/libtests/pngvalid.c:               pos = safecatd(buffer, sizeof buffer, pos, maxe, 7);
contrib/libtests/pngvalid.c:   this->next->set(this->next, that, pp, pi);
contrib/libtests/pngvalid.c:    image_pixel *that, png_const_structp pp,
contrib/libtests/pngvalid.c:         image_pixel_convert_PLTE(that);
contrib/libtests/pngvalid.c:          * was used) the maxium error in an individual coefficient is always
contrib/libtests/pngvalid.c:               pos = safecat(buffer, sizeof buffer, pos, " exceeds limit ");
contrib/libtests/pngvalid.c:               pos = safecat(buffer, sizeof buffer, pos, " exceeds limit ");
contrib/libtests/pngvalid.c:   this->next->mod(this->next, that, pp, display);
contrib/libtests/pngvalid.c:   this->next = *that;
contrib/libtests/pngvalid.c: *    int background_gamma_code, int need_expand, double background_gamma)
contrib/libtests/pngvalid.c: * png_set_background_fixed(png_structp, png_const_color_16p background_color,
contrib/libtests/pngvalid.c: *    int background_gamma_code, int need_expand,
contrib/libtests/pngvalid.c: *    png_fixed_point background_gamma)
contrib/libtests/pngvalid.c:static image_pixel data;
contrib/libtests/pngvalid.c:   png_byte random_bytes[8]; /* 8 bytes - 64 bits - the biggest pixel */
contrib/libtests/pngvalid.c:   int expand;
contrib/libtests/pngvalid.c:   /* We need a background colour, because we don't know exactly what transforms
contrib/libtests/pngvalid.c:    * expressed as a 24bit rgb, not an index.
contrib/libtests/pngvalid.c:      expand = 0; /* passing in an RGB not a pixel index */
contrib/libtests/pngvalid.c:      expand = 1;
contrib/libtests/pngvalid.c:   image_pixel_init(&data, random_bytes, colour_type,
contrib/libtests/pngvalid.c:      bit_depth, 0/*x*/, 0/*unused: palette*/);
contrib/libtests/pngvalid.c:   /* Extract the background colour from this image_pixel, but make sure the
contrib/libtests/pngvalid.c:      png_set_background(pp, &back, PNG_BACKGROUND_GAMMA_FILE, expand, 0);
contrib/libtests/pngvalid.c:      png_set_background_fixed(pp, &back, PNG_BACKGROUND_GAMMA_FILE, expand, 0);
contrib/libtests/pngvalid.c:   this->next->set(this->next, that, pp, pi);
contrib/libtests/pngvalid.c:    image_pixel *that, png_const_structp pp,
contrib/libtests/pngvalid.c:      image_pixel_add_alpha(that, &display->this);
contrib/libtests/pngvalid.c:   this->next->mod(this->next, that, pp, display);
contrib/libtests/pngvalid.c:      exit(99);
contrib/libtests/pngvalid.c:   exit(99);
contrib/libtests/pngvalid.c:   image_transform *next = image_transform_first;
contrib/libtests/pngvalid.c:   while (next != &image_transform_end)
contrib/libtests/pngvalid.c:      next->local_use = 0;
contrib/libtests/pngvalid.c:      next->next = 0;
contrib/libtests/pngvalid.c:      next = next->list;
contrib/libtests/pngvalid.c:   /* This can only happen if we every have more than 32 transforms (excluding
contrib/libtests/pngvalid.c:image_transform_test_counter(png_uint_32 counter, unsigned int max)
contrib/libtests/pngvalid.c:    * counter and a 'max' value.
contrib/libtests/pngvalid.c:   image_transform *next = image_transform_first;
contrib/libtests/pngvalid.c:   while (next != &image_transform_end)
contrib/libtests/pngvalid.c:      /* For max 0 or 1 continue until the counter overflows: */
contrib/libtests/pngvalid.c:      /* Continue if any entry hasn't reacked the max. */
contrib/libtests/pngvalid.c:      if (max > 1 && next->local_use < max)
contrib/libtests/pngvalid.c:      next = next->list;
contrib/libtests/pngvalid.c:   return max <= 1 && counter == 0;
contrib/libtests/pngvalid.c:image_transform_add(PNG_CONST image_transform **this, unsigned int max,
contrib/libtests/pngvalid.c:      /* Find the next counter value, if the counter is zero this is the start
contrib/libtests/pngvalid.c:       * next) so it returns 0 at the end and expects 0 at the beginning.
contrib/libtests/pngvalid.c:         if (max <= 1)
contrib/libtests/pngvalid.c:         switch (max)
contrib/libtests/pngvalid.c:             (max == 0 || list->local_use < max))
contrib/libtests/pngvalid.c:            if (list->add(list, this, colour_type, bit_depth) || max == 0)
contrib/libtests/pngvalid.c:               /* Not useful and max>0, so remove it from *this: */
contrib/libtests/pngvalid.c:               *this = list->next;
contrib/libtests/pngvalid.c:               list->next = 0;
contrib/libtests/pngvalid.c:               list->local_use = max;
contrib/libtests/pngvalid.c:      if (!image_transform_test_counter(counter, max))
contrib/libtests/pngvalid.c:   this->next->set(this->next, that, pp, pi);
contrib/libtests/pngvalid.c:    image_pixel *that, png_const_structp pp,
contrib/libtests/pngvalid.c:   this->next->mod(this->next, that, pp, display);
contrib/libtests/pngvalid.c:   this->next = *that;
contrib/libtests/pngvalid.c: *    int maximum_colors, png_const_uint_16p histogram, int full_quantize)
contrib/libtests/pngvalid.c: * semantic of the channels changes after these are executed.  Some of these,
contrib/libtests/pngvalid.c:   while (next_format(&colour_type, &bit_depth, &palette_number, 0))
contrib/libtests/pngvalid.c:         /* 'max' is currently hardwired to '1'; this should be settable on the
contrib/libtests/pngvalid.c:         counter = image_transform_add(&list, 1/*max*/, counter,
contrib/libtests/pngvalid.c:   int              expand16;
contrib/libtests/pngvalid.c:   double       maxerrout;
contrib/libtests/pngvalid.c:   double       maxerrpc;
contrib/libtests/pngvalid.c:   double       maxerrabs;
contrib/libtests/pngvalid.c:    int use_input_precision, int scale16, int expand16,
contrib/libtests/pngvalid.c:   dp->expand16 = expand16;
contrib/libtests/pngvalid.c:   dp->maxerrout = dp->maxerrpc = dp->maxerrabs = 0;
contrib/libtests/pngvalid.c:   if (dp->expand16)
contrib/libtests/pngvalid.c:         png_set_expand_16(pp);
contrib/libtests/pngvalid.c:         png_error(pp, "expand16 (8 to 16 bit conversion) not supported");
contrib/libtests/pngvalid.c:            PNG_CONST png_fixed_point g = fix(sg);
contrib/libtests/pngvalid.c:            png_set_alpha_mode_fixed(pp, mode, g);
contrib/libtests/pngvalid.c:               png_fixed_point f = fix(dp->file_gamma);
contrib/libtests/pngvalid.c:               png_set_gamma_fixed(pp, g, f);
contrib/libtests/pngvalid.c:         png_fixed_point s = fix(dp->screen_gamma);
contrib/libtests/pngvalid.c:         png_fixed_point f = fix(dp->file_gamma);
contrib/libtests/pngvalid.c:         png_set_gamma_fixed(pp, s, f);
contrib/libtests/pngvalid.c:            PNG_CONST png_fixed_point g = fix(bg);
contrib/libtests/pngvalid.c:               0/*need_expand*/, bg);
contrib/libtests/pngvalid.c:            png_set_background_fixed(pp, &dp->background_color,
contrib/libtests/pngvalid.c:               dp->do_background, 0/*need_expand*/, g);
contrib/libtests/pngvalid.c:   unsigned int sbit_max;
contrib/libtests/pngvalid.c:   unsigned int outmax;
contrib/libtests/pngvalid.c:   double maxabs;
contrib/libtests/pngvalid.c:   double maxpc;
contrib/libtests/pngvalid.c:   double maxcalc;
contrib/libtests/pngvalid.c:   double maxout;
contrib/libtests/pngvalid.c:   double maxout_total;     /* Total including quantization error */
contrib/libtests/pngvalid.c:   PNG_CONST unsigned int outmax = (1U<<out_depth)-1;
contrib/libtests/pngvalid.c:   vi->sbit_max = (1U << vi->sbit)-1;
contrib/libtests/pngvalid.c:   vi->outmax = outmax;
contrib/libtests/pngvalid.c:   vi->maxabs = abserr(dp->pm, in_depth, out_depth);
contrib/libtests/pngvalid.c:   vi->maxpc = pcerr(dp->pm, in_depth, out_depth);
contrib/libtests/pngvalid.c:   vi->maxcalc = calcerr(dp->pm, in_depth, out_depth);
contrib/libtests/pngvalid.c:   vi->maxout = outerr(dp->pm, in_depth, out_depth);
contrib/libtests/pngvalid.c:   vi->maxout_total = vi->maxout + vi->outquant * .5;
contrib/libtests/pngvalid.c:         r = dp->background_color.red; r /= outmax;
contrib/libtests/pngvalid.c:         g = dp->background_color.green; g /= outmax;
contrib/libtests/pngvalid.c:         b = dp->background_color.blue; b /= outmax;
contrib/libtests/pngvalid.c:          * gamma encoded (to get standard Porter-Duff we expect the output
contrib/libtests/pngvalid.c:          * while the opaque pixels are gamma encoded, but this only affects the
contrib/libtests/pngvalid.c:   PNG_CONST unsigned int sbit_max = vi->sbit_max;
contrib/libtests/pngvalid.c:   PNG_CONST unsigned int outmax = vi->outmax;
contrib/libtests/pngvalid.c:   i = isbit; i /= sbit_max;
contrib/libtests/pngvalid.c:    * this is the alpha channel ('alpha' < 0) or if the pixel is opaque then
contrib/libtests/pngvalid.c:   if (alpha == 1 /* opaque pixel component */ || !do_background
contrib/libtests/pngvalid.c:      encoded_sample *= outmax;
contrib/libtests/pngvalid.c:      if (encoded_error > vi->dp->maxerrout)
contrib/libtests/pngvalid.c:         vi->dp->maxerrout = encoded_error;
contrib/libtests/pngvalid.c:      if (encoded_error < vi->maxout_total && encoded_error < vi->outlog)
contrib/libtests/pngvalid.c:      int log_max_error = 1;     /* Check maximum error values */
contrib/libtests/pngvalid.c:      output /= outmax;
contrib/libtests/pngvalid.c:            log_max_error = 0;
contrib/libtests/pngvalid.c:            if (alpha > 0) log_max_error = 0;
contrib/libtests/pngvalid.c:      encoded_sample *= outmax;
contrib/libtests/pngvalid.c:      if (log_max_error && encoded_error > vi->dp->maxerrout)
contrib/libtests/pngvalid.c:         vi->dp->maxerrout = encoded_error;
contrib/libtests/pngvalid.c:      if (encoded_error < vi->maxout_total)
contrib/libtests/pngvalid.c:         pass = "less than maxout:\n";
contrib/libtests/pngvalid.c:      if (log_max_error && error > vi->dp->maxerrabs)
contrib/libtests/pngvalid.c:         vi->dp->maxerrabs = error;
contrib/libtests/pngvalid.c:      if (log_max_error && input_sample > .5)
contrib/libtests/pngvalid.c:         if (percentage_error > vi->dp->maxerrpc)
contrib/libtests/pngvalid.c:            vi->dp->maxerrpc = percentage_error;
contrib/libtests/pngvalid.c:       * 'max' values.  Note that maxout is in the encoded space but maxpc and
contrib/libtests/pngvalid.c:       * maxabs are in linear light space.
contrib/libtests/pngvalid.c:       * First find the maximum error in linear light space, range 0..1:
contrib/libtests/pngvalid.c:         double tmp = input_sample * vi->maxpc;
contrib/libtests/pngvalid.c:         if (tmp < vi->maxabs) tmp = vi->maxabs;
contrib/libtests/pngvalid.c:          * integer arithmetic.  This introduces an extra error of +/- 0.5 (at
contrib/libtests/pngvalid.c:          * least) in the integer space used.  'maxcalc' records this, taking
contrib/libtests/pngvalid.c:         if (compose && tmp < vi->maxcalc) tmp = vi->maxcalc;
contrib/libtests/pngvalid.c:         /* The 'maxout' value refers to the encoded result, to compare with
contrib/libtests/pngvalid.c:          * this encode input_sample adjusted by the maximum error (tmp) above.
contrib/libtests/pngvalid.c:         es_lo = encoded_sample - vi->maxout;
contrib/libtests/pngvalid.c:            low_value *= outmax;
contrib/libtests/pngvalid.c:         es_hi = encoded_sample + vi->maxout;
contrib/libtests/pngvalid.c:         if (es_hi < outmax && input_sample+tmp < 1)
contrib/libtests/pngvalid.c:            high_value *= outmax;
contrib/libtests/pngvalid.c:            es_hi = outmax;
contrib/libtests/pngvalid.c:            double tmp = (isbit - SBIT_ERROR)/sbit_max;
contrib/libtests/pngvalid.c:            is_lo = ceil(outmax * tmp - vi->maxout_total);
contrib/libtests/pngvalid.c:            tmp = (isbit + SBIT_ERROR)/sbit_max;
contrib/libtests/pngvalid.c:            is_hi = floor(outmax * tmp + vi->maxout_total);
contrib/libtests/pngvalid.c:            if (is_hi > outmax)
contrib/libtests/pngvalid.c:               is_hi = outmax;
contrib/libtests/pngvalid.c:                        is_lo = ceil(outmax * tmp - vi->maxout_total);
contrib/libtests/pngvalid.c:                        is_hi = floor(outmax * tmp + vi->maxout_total);
contrib/libtests/pngvalid.c:                        if (is_hi > outmax) is_hi = outmax;
contrib/libtests/pngvalid.c:                        is_hi = outmax;
contrib/libtests/pngvalid.c:             * places.  Just use outmax to work out which.
contrib/libtests/pngvalid.c:            int precision = (outmax >= 1000 ? 6 : 3);
contrib/libtests/pngvalid.c:               /* The output is either "id/max" or "id sbit(sbit): isbit/max" */
contrib/libtests/pngvalid.c:               pos = safecatn(msg, sizeof msg, pos, vi->sbit_max);
contrib/libtests/pngvalid.c:            pos = safecatn(msg, sizeof msg, pos, outmax);
contrib/libtests/pngvalid.c:    * precision it is possible to calculate an exact answer given an input
contrib/libtests/pngvalid.c:    * pixel value.  Therefore we assume that the *input* value is exact -
contrib/libtests/pngvalid.c:    * sample/maxsample - calculate the corresponding gamma corrected
contrib/libtests/pngvalid.c:    *     png-sample = floor( input-sample * (max-out/max-in) + .5);
contrib/libtests/pngvalid.c:    * variety of approximations to the above and doesn't require any
contrib/libtests/pngvalid.c:   PNG_CONST unsigned int samples_per_pixel = (out_ct & 2U) ? 3U : 1U;
contrib/libtests/pngvalid.c:   /* Supply the input and output sample depths here - 8 for an indexed image,
contrib/libtests/pngvalid.c:         unsigned int x;
contrib/libtests/pngvalid.c:         for (x=0; x<w; ++x)
contrib/libtests/pngvalid.c:            /* Record the palette index for index images. */
contrib/libtests/pngvalid.c:            PNG_CONST unsigned int in_index =
contrib/libtests/pngvalid.c:               in_ct == 3 ? sample(std, 3, in_bd, x, 0) : 256;
contrib/libtests/pngvalid.c:            PNG_CONST unsigned int out_index =
contrib/libtests/pngvalid.c:               out_ct == 3 ? sample(std, 3, out_bd, x, 0) : 256;
contrib/libtests/pngvalid.c:                  dp->this.palette[in_index].alpha :
contrib/libtests/pngvalid.c:                  sample(std, in_ct, in_bd, x, samples_per_pixel);
contrib/libtests/pngvalid.c:                     output_alpha = out_palette[out_index].alpha;
contrib/libtests/pngvalid.c:                  output_alpha = sample(pRow, out_ct, out_bd, x,
contrib/libtests/pngvalid.c:                     samples_per_pixel);
contrib/libtests/pngvalid.c:                  alpha /= vi.sbit_max;
contrib/libtests/pngvalid.c:                  sample(std, in_ct, in_bd, x, 0),
contrib/libtests/pngvalid.c:                  sample(pRow, out_ct, out_bd, x, 0), alpha/*component*/,
contrib/libtests/pngvalid.c:                  in_ct == 3 ? in_palette[in_index].red :
contrib/libtests/pngvalid.c:                     sample(std, in_ct, in_bd, x, 0),
contrib/libtests/pngvalid.c:                  out_ct == 3 ? out_palette[out_index].red :
contrib/libtests/pngvalid.c:                     sample(pRow, out_ct, out_bd, x, 0),
contrib/libtests/pngvalid.c:                  in_ct == 3 ? in_palette[in_index].green :
contrib/libtests/pngvalid.c:                     sample(std, in_ct, in_bd, x, 1),
contrib/libtests/pngvalid.c:                  out_ct == 3 ? out_palette[out_index].green :
contrib/libtests/pngvalid.c:                     sample(pRow, out_ct, out_bd, x, 1),
contrib/libtests/pngvalid.c:                  in_ct == 3 ? in_palette[in_index].blue :
contrib/libtests/pngvalid.c:                     sample(std, in_ct, in_bd, x, 2),
contrib/libtests/pngvalid.c:                  out_ct == 3 ? out_palette[out_index].blue :
contrib/libtests/pngvalid.c:                     sample(pRow, out_ct, out_bd, x, 2),
contrib/libtests/pngvalid.c:         /* No transform is expected on the threshold tests. */
contrib/libtests/pngvalid.c: * maxabs: maximum absolute error as a fraction
contrib/libtests/pngvalid.c: * maxout: maximum output error in the output units
contrib/libtests/pngvalid.c: * maxpc:  maximum percentage error (as a percentage)
contrib/libtests/pngvalid.c:    PNG_CONST int expand16In, PNG_CONST int do_backgroundIn,
contrib/libtests/pngvalid.c:   context(&pmIn->this, fault);
contrib/libtests/pngvalid.c:      expand16In, do_backgroundIn, bkgd_colorIn, bkgd_gammaIn);
contrib/libtests/pngvalid.c:         /* modifier_read expects a png_modifier* */
contrib/libtests/pngvalid.c:         fprintf(stderr, "%d bit %s %s: max error %f (%.2g, %2g%%)\n",
contrib/libtests/pngvalid.c:            d.maxerrout, d.maxerrabs, 100*d.maxerrpc);
contrib/libtests/pngvalid.c:            if (d.maxerrout > d.pm->error_gray_2)
contrib/libtests/pngvalid.c:               d.pm->error_gray_2 = d.maxerrout;
contrib/libtests/pngvalid.c:            if (d.maxerrout > d.pm->error_gray_4)
contrib/libtests/pngvalid.c:               d.pm->error_gray_4 = d.maxerrout;
contrib/libtests/pngvalid.c:            if (d.maxerrout > d.pm->error_gray_8)
contrib/libtests/pngvalid.c:               d.pm->error_gray_8 = d.maxerrout;
contrib/libtests/pngvalid.c:            if (d.maxerrout > d.pm->error_gray_16)
contrib/libtests/pngvalid.c:               d.pm->error_gray_16 = d.maxerrout;
contrib/libtests/pngvalid.c:            if (d.maxerrout > d.pm->error_color_8)
contrib/libtests/pngvalid.c:               d.pm->error_color_8 = d.maxerrout;
contrib/libtests/pngvalid.c:            if (d.maxerrout > d.pm->error_color_16)
contrib/libtests/pngvalid.c:               d.pm->error_color_16 = d.maxerrout;
contrib/libtests/pngvalid.c:         if (d.maxerrout > d.pm->error_indexed)
contrib/libtests/pngvalid.c:            d.pm->error_indexed = d.maxerrout;
contrib/libtests/pngvalid.c:      0 /*no scale16*/, 0 /*no expand16*/, 0 /*no background*/, 0 /*hence*/,
contrib/libtests/pngvalid.c:    * fact this test is somewhat excessive since libpng doesn't make this
contrib/libtests/pngvalid.c:   while (next_format(&colour_type, &bit_depth, &palette_number, 1/*gamma*/))
contrib/libtests/pngvalid.c:      scale16, pm->test_gamma_expand16, 0 , 0, 0);
contrib/libtests/pngvalid.c:   while (next_format(&colour_type, &bit_depth, &palette_number, 1/*gamma*/))
contrib/libtests/pngvalid.c:      while (next_format(&colour_type, &bit_depth, &npalette, 1/*gamma*/))
contrib/libtests/pngvalid.c:    * internal sbit style approximation.
contrib/libtests/pngvalid.c:    * by much) - this could be fixed, it only appears with the -g option.
contrib/libtests/pngvalid.c:   PNG_CONST int expand_16)
contrib/libtests/pngvalid.c:   if (expand_16 || bit_depth == 16)
contrib/libtests/pngvalid.c:       * gamma correction in the expand16 case was done using 8-bit gamma
contrib/libtests/pngvalid.c:         if (expand_16 && (do_background == PNG_BACKGROUND_GAMMA_UNIQUE ||
contrib/libtests/pngvalid.c:             * the gamma correction, so only select values which are an exact
contrib/libtests/pngvalid.c:   background.index = 193; /* rgb(193,193,193) to detect errors */
contrib/libtests/pngvalid.c:      /* This assumes no expand gray->rgb - the current code won't handle that!
contrib/libtests/pngvalid.c:      0/*strip 16*/, expand_16, do_background, &background, bg);
contrib/libtests/pngvalid.c:   int expand_16)
contrib/libtests/pngvalid.c:   while (next_format(&colour_type, &bit_depth, &palette_number, 1/*gamma*/))
contrib/libtests/pngvalid.c:            pm->use_input_precision, do_background, expand_16);
contrib/libtests/pngvalid.c:   pm->error_indexed = -1.;
contrib/libtests/pngvalid.c:   int indexed)
contrib/libtests/pngvalid.c:      if (indexed)
contrib/libtests/pngvalid.c:         print_one(" indexed:    ", pm->error_indexed);
contrib/libtests/pngvalid.c:      double maxout8 = pm->maxout8;
contrib/libtests/pngvalid.c:         printf("The printed value is the maximum error in the pixel values\n");
contrib/libtests/pngvalid.c:         printf("is calculated as the difference between the output pixel\n");
contrib/libtests/pngvalid.c:         printf("Expect this value to be less than .5 for 8 bit formats,\n");
contrib/libtests/pngvalid.c:      if (pm->test_gamma_expand16)
contrib/libtests/pngvalid.c:         summarize_gamma_errors(pm, 0/*who*/, 1/*low bit depth*/, 1/*indexed*/);
contrib/libtests/pngvalid.c:         summarize_gamma_errors(pm, "sBIT", pm->sbitlow < 8U, 1/*indexed*/);
contrib/libtests/pngvalid.c:      if (pm->test_gamma_expand16)
contrib/libtests/pngvalid.c:         pm->maxout8 = .499; /* because the 16 bit background is smashed */
contrib/libtests/pngvalid.c:         pm->test_gamma_expand16);
contrib/libtests/pngvalid.c:      pm->maxout8 = maxout8;
contrib/libtests/pngvalid.c:         summarize_gamma_errors(pm, "background", 1, 0/*indexed*/);
contrib/libtests/pngvalid.c:      if (pm->test_gamma_expand16)
contrib/libtests/pngvalid.c:            pm->test_gamma_expand16);
contrib/libtests/pngvalid.c:         summarize_gamma_errors(pm, "alpha mode", 1, 0/*indexed*/);
contrib/libtests/pngvalid.c: * number in which each pixel in each 8x8 tile appears.  The array must
contrib/libtests/pngvalid.c: * be indexed adam7[y][x] and notice that the pass numbers are based at
contrib/libtests/pngvalid.c:   int x, y;
contrib/libtests/pngvalid.c:   for (y=0; y<8; ++y) for (x=0; x<8; ++x) if (adam7[y][x] == pass)
contrib/libtests/pngvalid.c:   return 0xf;
contrib/libtests/pngvalid.c:   int x, y;
contrib/libtests/pngvalid.c:   for (x=0; x<8; ++x) for (y=0; y<8; ++y) if (adam7[y][x] == pass)
contrib/libtests/pngvalid.c:      return x;
contrib/libtests/pngvalid.c:   return 0xf;
contrib/libtests/pngvalid.c:   int x, y, base=(-1), inc=8;
contrib/libtests/pngvalid.c:   for (y=0; y<8; ++y) for (x=0; x<8; ++x) if (adam7[y][x] == pass)
contrib/libtests/pngvalid.c:         return 0xff; /* error - more than one 'inc' value! */
contrib/libtests/pngvalid.c:   if (base == (-1)) return 0xfe; /* error - no row in pass! */
contrib/libtests/pngvalid.c:   return (inc << 8) + 0xfd;
contrib/libtests/pngvalid.c:   int x, y, base=(-1), inc=8;
contrib/libtests/pngvalid.c:   for (x=0; x<8; ++x) for (y=0; y<8; ++y) if (adam7[y][x] == pass)
contrib/libtests/pngvalid.c:         base = x;
contrib/libtests/pngvalid.c:      else if (base == x)
contrib/libtests/pngvalid.c:      else if (inc == x-base)
contrib/libtests/pngvalid.c:         base=x;
contrib/libtests/pngvalid.c:         inc = x-base, base=x;
contrib/libtests/pngvalid.c:      else if (inc != x-base)
contrib/libtests/pngvalid.c:         return 0xff; /* error - more than one 'inc' value! */
contrib/libtests/pngvalid.c:   if (base == (-1)) return 0xfe; /* error - no row in pass! */
contrib/libtests/pngvalid.c:   return (inc << 8) + 0xfd;
contrib/libtests/pngvalid.c:   /* By examination of the array: */
contrib/libtests/pngvalid.c:   return 0xff; /* bad pass number */
contrib/libtests/pngvalid.c:png_col_from_pass_col(png_uint_32 xIn, int pass)
contrib/libtests/pngvalid.c:   /* By examination of the array: */
contrib/libtests/pngvalid.c:case 0: return xIn * 8;
contrib/libtests/pngvalid.c:case 1: return xIn * 8 + 4;
contrib/libtests/pngvalid.c:case 2: return xIn * 4;
contrib/libtests/pngvalid.c:case 3: return xIn * 4 + 2;
contrib/libtests/pngvalid.c:case 4: return xIn * 2;
contrib/libtests/pngvalid.c:case 5: return xIn * 2 + 1;
contrib/libtests/pngvalid.c:case 6: return xIn;
contrib/libtests/pngvalid.c:   return 0xff; /* bad pass number */
contrib/libtests/pngvalid.c:   int x;
contrib/libtests/pngvalid.c:   for (x=0; x<8; ++x) if (adam7[y][x] == pass)
contrib/libtests/pngvalid.c:png_col_in_interlace_pass(png_uint_32 x, int pass)
contrib/libtests/pngvalid.c:   /* Is column 'x' in pass 'pass'? */
contrib/libtests/pngvalid.c:   x &= 7;
contrib/libtests/pngvalid.c:   for (y=0; y<8; ++y) if (adam7[y][x] == pass)
contrib/libtests/pngvalid.c:   unsigned int x, y;
contrib/libtests/pngvalid.c:   for (y=0; y<8; ++y) for (x=0; x<8; ++x) if (adam7[y][x] == pass)
contrib/libtests/pngvalid.c:      break; /* i.e. break the 'x', column, loop. */
contrib/libtests/pngvalid.c:   unsigned int x, y;
contrib/libtests/pngvalid.c:   for (x=0; x<8; ++x) for (y=0; y<8; ++y) if (adam7[y][x] == pass)
contrib/libtests/pngvalid.c:      if (x < width) ++cols;
contrib/libtests/pngvalid.c:         fprintf(stderr, "PNG_PASS_START_ROW(%d) = %u != %x\n", pass, m, f);
contrib/libtests/pngvalid.c:         exit(99);
contrib/libtests/pngvalid.c:         fprintf(stderr, "PNG_PASS_START_COL(%d) = %u != %x\n", pass, m, f);
contrib/libtests/pngvalid.c:         exit(99);
contrib/libtests/pngvalid.c:         fprintf(stderr, "PNG_PASS_ROW_SHIFT(%d) = %u != %x\n", pass, m, f);
contrib/libtests/pngvalid.c:         exit(99);
contrib/libtests/pngvalid.c:         fprintf(stderr, "PNG_PASS_COL_SHIFT(%d) = %u != %x\n", pass, m, f);
contrib/libtests/pngvalid.c:         exit(99);
contrib/libtests/pngvalid.c:       * PNG_COL_FROM_PASS_COL(xIn, pass)
contrib/libtests/pngvalid.c:       * PNG_COL_IN_INTERLACE_PASS(x, pass)
contrib/libtests/pngvalid.c:            fprintf(stderr, "PNG_ROW_FROM_PASS_ROW(%u, %d) = %u != %x\n",
contrib/libtests/pngvalid.c:            exit(99);
contrib/libtests/pngvalid.c:            fprintf(stderr, "PNG_COL_FROM_PASS_COL(%u, %d) = %u != %x\n",
contrib/libtests/pngvalid.c:            exit(99);
contrib/libtests/pngvalid.c:            fprintf(stderr, "PNG_ROW_IN_INTERLACE_PASS(%u, %d) = %u != %x\n",
contrib/libtests/pngvalid.c:            exit(99);
contrib/libtests/pngvalid.c:            fprintf(stderr, "PNG_COL_IN_INTERLACE_PASS(%u, %d) = %u != %x\n",
contrib/libtests/pngvalid.c:            exit(99);
contrib/libtests/pngvalid.c:            fprintf(stderr, "PNG_PASS_ROWS(%u, %d) = %u != %x\n",
contrib/libtests/pngvalid.c:            exit(99);
contrib/libtests/pngvalid.c:            fprintf(stderr, "PNG_PASS_COLS(%u, %d) = %u != %x\n",
contrib/libtests/pngvalid.c:            exit(99);
contrib/libtests/pngvalid.c:         /* Move to the next v - the stepping algorithm starts skipping
contrib/libtests/pngvalid.c: * which typically don't exceed 4 decimal places.  This allows testing of the
contrib/libtests/pngvalid.c:/*gamma:*/ { 1/1.6 /*approximate: uses 1.8 power law compared to sRGB 2.4*/,
contrib/libtests/pngvalid.c: * context pointer so that it can throw an exception (call longjmp) to recover
contrib/libtests/pngvalid.c:         pos = safecat(msg, sizeof msg, pos, "floating point exception");
contrib/libtests/pngvalid.c:   /* And finally throw an exception so we can keep going, unless this is
contrib/libtests/pngvalid.c:      struct exception_context *the_exception_context =
contrib/libtests/pngvalid.c:         &pm.this.exception_context;
contrib/libtests/pngvalid.c:      exit(1);
contrib/libtests/pngvalid.c:   anon_context(&pm.this);
contrib/libtests/pngvalid.c:   /* Only required to enable FP exceptions on platforms where they start off
contrib/libtests/pngvalid.c:   feenableexcept(FE_DIVBYZERO | FE_INVALID | FE_OVERFLOW);
contrib/libtests/pngvalid.c:   /* Currently 16 bit expansion happens at the end of the pipeline, so the
contrib/libtests/pngvalid.c:    * TODO: fix this
contrib/libtests/pngvalid.c:    * These values simply control the maximum error permitted in the gamma
contrib/libtests/pngvalid.c:    * below (the setting for maxpc16), however for 8 bit encodings it isn't
contrib/libtests/pngvalid.c:   pm.maxout8 = .1;     /* Arithmetic error in *encoded* value */
contrib/libtests/pngvalid.c:   pm.maxabs8 = .00005; /* 1/20000 */
contrib/libtests/pngvalid.c:   pm.maxcalc8 = 1./255;  /* +/-1 in 8 bits for compose errors */
contrib/libtests/pngvalid.c:   pm.maxpc8 = .499;    /* I.e., .499% fractional error */
contrib/libtests/pngvalid.c:   pm.maxout16 = .499;  /* Error in *encoded* value */
contrib/libtests/pngvalid.c:   pm.maxabs16 = .00005;/* 1/20000 */
contrib/libtests/pngvalid.c:   pm.maxcalc16 =1./65535;/* +/-1 in 16 bits for compose errors */
contrib/libtests/pngvalid.c:   pm.maxcalcG = 1./((1<<PNG_MAX_GAMMA_8)-1);
contrib/libtests/pngvalid.c:    * maximum 16 bit error is about +/-1.9 in the fixed point implementation but
contrib/libtests/pngvalid.c:   pm.maxpc16 = .005;   /* I.e., 1/200% - 1/20000 */
contrib/libtests/pngvalid.c:      else if (strcmp(*argv, "--expand16") == 0)
contrib/libtests/pngvalid.c:         pm.test_gamma_expand16 = 1;
contrib/libtests/pngvalid.c:      else if (strcmp(*argv, "--noexpand16") == 0)
contrib/libtests/pngvalid.c:         pm.test_gamma_expand16 = 0;
contrib/libtests/pngvalid.c:      else if (strcmp(*argv, "--exhaustive") == 0)
contrib/libtests/pngvalid.c:         pm.test_exhaustive = 1;
contrib/libtests/pngvalid.c:      else if (argc > 1 && strncmp(*argv, "--max", 5) == 0)
contrib/libtests/pngvalid.c:            pm.maxabs8 = atof(*++argv);
contrib/libtests/pngvalid.c:            pm.maxabs16 = atof(*++argv);
contrib/libtests/pngvalid.c:            pm.maxcalc8 = atof(*++argv);
contrib/libtests/pngvalid.c:            pm.maxcalc16 = atof(*++argv);
contrib/libtests/pngvalid.c:            pm.maxout8 = atof(*++argv);
contrib/libtests/pngvalid.c:            pm.maxout16 = atof(*++argv);
contrib/libtests/pngvalid.c:            pm.maxpc8 = atof(*++argv);
contrib/libtests/pngvalid.c:            pm.maxpc16 = atof(*++argv);
contrib/libtests/pngvalid.c:            fprintf(stderr, "pngvalid: %s: unknown 'max' option\n", *argv);
contrib/libtests/pngvalid.c:            exit(99);
contrib/libtests/pngvalid.c:         /* Syntax of the argument is <option>:{on|off} */
contrib/libtests/pngvalid.c:         if (strncmp(arg, "max-inflate-window:", 19) == 0)
contrib/libtests/pngvalid.c:            exit(99);
contrib/libtests/pngvalid.c:            exit(99);
contrib/libtests/pngvalid.c:         exit(99);
contrib/libtests/pngvalid.c:      if (catmore) /* consumed an extra *argv */
contrib/libtests/pngvalid.c:      exit(1);
contrib/libtests/pngvalid.c:         "fixed"
contrib/libtests/pngvalid.c:         "\tread  %lu maximum single, %lu peak, %lu total\n"
contrib/libtests/pngvalid.c:         "\twrite %lu maximum single, %lu peak, %lu total\n",
contrib/libtests/pngvalid.c:         (unsigned long)pm.this.read_memory_pool.max_max,
contrib/libtests/pngvalid.c:         (unsigned long)pm.this.read_memory_pool.max_limit,
contrib/libtests/pngvalid.c:         (unsigned long)pm.this.read_memory_pool.max_total,
contrib/libtests/pngvalid.c:         (unsigned long)pm.this.write_memory_pool.max_max,
contrib/libtests/pngvalid.c:         (unsigned long)pm.this.write_memory_pool.max_limit,
contrib/libtests/pngvalid.c:         (unsigned long)pm.this.write_memory_pool.max_total);
contrib/libtests/pngvalid.c:   /* Error exit if there are any errors, and maybe if there are any
contrib/libtests/pngvalid.c:      exit(1);
contrib/libtests/pngvalid.c:            exit(1);
contrib/libtests/pngvalid.c:         exit(1);
contrib/libtests/pngstest.c:   /* If true include unused static GPC functions and declare an external array
contrib/libtests/pngstest.c:   /* There are thirty three bits, the next bit in the sequence is bit-33 XOR
contrib/libtests/pngstest.c:      png_uint_32 u = ((u0 >> (20-8)) ^ ((u1 << 7) | (u0 >> (32-7)))) & 0xff;
contrib/libtests/pngstest.c:   static png_uint_32 color_seed[2] = { 0x12345678, 0x9abcdef };
contrib/libtests/pngstest.c:closestinteger(double x)
contrib/libtests/pngstest.c:   return floor(x + .5);
contrib/libtests/pngstest.c:/* sRGB support: use exact calculations rounded to the nearest int, see the
contrib/libtests/pngstest.c:isRGB(int fixed_linear)
contrib/libtests/pngstest.c:   return sRGB(fixed_linear / 65535.);
contrib/libtests/pngstest.c:ilinear(int fixed_srgb)
contrib/libtests/pngstest.c:   return u16d(65535 * sRGB_to_d[fixed_srgb]);
contrib/libtests/pngstest.c:ilineara(int fixed_srgb, int alpha)
contrib/libtests/pngstest.c:   return u16d((257 * alpha) * sRGB_to_d[fixed_srgb]);
contrib/libtests/pngstest.c:ilinear_g22(int fixed_srgb)
contrib/libtests/pngstest.c:   return u16d(65535 * g22_to_d[fixed_srgb]);
contrib/libtests/pngstest.c:ilineara_g22(int fixed_srgb, int alpha)
contrib/libtests/pngstest.c:   return u16d((257 * alpha) * g22_to_d[fixed_srgb]);
contrib/libtests/pngstest.c:      /* Always allow an extra 1 here for rounding errors */
contrib/libtests/pngstest.c:static int error_in_sRGB_roundtrip = 56; /* by experiment */
contrib/libtests/pngstest.c:      /* Always allow an extra 1 here for rounding errors */
contrib/libtests/pngstest.c:#define FORMAT_NO_CHANGE 0x80000000 /* additional flag */
contrib/libtests/pngstest.c:#define FORMAT_MASK 0x3f
contrib/libtests/pngstest.c:            if ((f & 0x10U/*HACK: fixed value*/) != 0)
contrib/libtests/pngstest.c:            if ((f & 0x20U/*HACK: fixed value*/) != 0)
contrib/libtests/pngstest.c:   int         stride_extra;
contrib/libtests/pngstest.c:   int stride_extra)
contrib/libtests/pngstest.c:   image->stride_extra = stride_extra;
contrib/libtests/pngstest.c:         exit(1);
contrib/libtests/pngstest.c:      exit(1);
contrib/libtests/pngstest.c:      exit(1);
contrib/libtests/pngstest.c:/* Compare the pixels of two images, which should be the same but aren't.  The
contrib/libtests/pngstest.c:} Pixel;
contrib/libtests/pngstest.c:    * for with partially transparent pixels.
contrib/libtests/pngstest.c:/* Read a Pixel from a buffer.  The code below stores the correct routine for
contrib/libtests/pngstest.c:gp_g8(Pixel *p, png_const_voidp pb)
contrib/libtests/pngstest.c:gp_ga8(Pixel *p, png_const_voidp pb)
contrib/libtests/pngstest.c:gp_ag8(Pixel *p, png_const_voidp pb)
contrib/libtests/pngstest.c:gp_rgb8(Pixel *p, png_const_voidp pb)
contrib/libtests/pngstest.c:gp_bgr8(Pixel *p, png_const_voidp pb)
contrib/libtests/pngstest.c:gp_rgba8(Pixel *p, png_const_voidp pb)
contrib/libtests/pngstest.c:gp_bgra8(Pixel *p, png_const_voidp pb)
contrib/libtests/pngstest.c:gp_argb8(Pixel *p, png_const_voidp pb)
contrib/libtests/pngstest.c:gp_abgr8(Pixel *p, png_const_voidp pb)
contrib/libtests/pngstest.c:gp_g16(Pixel *p, png_const_voidp pb)
contrib/libtests/pngstest.c:gp_ga16(Pixel *p, png_const_voidp pb)
contrib/libtests/pngstest.c:gp_ag16(Pixel *p, png_const_voidp pb)
contrib/libtests/pngstest.c:gp_rgb16(Pixel *p, png_const_voidp pb)
contrib/libtests/pngstest.c:gp_bgr16(Pixel *p, png_const_voidp pb)
contrib/libtests/pngstest.c:gp_rgba16(Pixel *p, png_const_voidp pb)
contrib/libtests/pngstest.c:gp_bgra16(Pixel *p, png_const_voidp pb)
contrib/libtests/pngstest.c:gp_argb16(Pixel *p, png_const_voidp pb)
contrib/libtests/pngstest.c:gp_abgr16(Pixel *p, png_const_voidp pb)
contrib/libtests/pngstest.c:get_pixel(png_uint_32 format))(Pixel *p, png_const_voidp pb)
contrib/libtests/pngstest.c:/* Convertion between pixel formats.  The code above effectively eliminates the
contrib/libtests/pngstest.c: * This gives the following base format conversion matrix:
contrib/libtests/pngstest.c:gpc_noop(Pixel *out, const Pixel *in, const Background *back)
contrib/libtests/pngstest.c:gpc_nop8(Pixel *out, const Pixel *in, const Background *back)
contrib/libtests/pngstest.c:gpc_nop6(Pixel *out, const Pixel *in, const Background *back)
contrib/libtests/pngstest.c:gpc_bckg(Pixel *out, const Pixel *in, const Background *back)
contrib/libtests/pngstest.c:gpc_bckc(Pixel *out, const Pixel *in, const Background *back)
contrib/libtests/pngstest.c:gpc_g8(Pixel *out, const Pixel *in, const Background *back)
contrib/libtests/pngstest.c:gpc_g8b(Pixel *out, const Pixel *in, const Background *back)
contrib/libtests/pngstest.c:gpc_lin(Pixel *out, const Pixel *in, const Background *back)
contrib/libtests/pngstest.c:gpc_pre(Pixel *out, const Pixel *in, const Background *back)
contrib/libtests/pngstest.c:gpc_preq(Pixel *out, const Pixel *in, const Background *back)
contrib/libtests/pngstest.c:gpc_glin(Pixel *out, const Pixel *in, const Background *back)
contrib/libtests/pngstest.c:gpc_gpre(Pixel *out, const Pixel *in, const Background *back)
contrib/libtests/pngstest.c:gpc_gprq(Pixel *out, const Pixel *in, const Background *back)
contrib/libtests/pngstest.c:gpc_Lin(Pixel *out, const Pixel *in, const Background *back)
contrib/libtests/pngstest.c:gpc_Pre(Pixel *out, const Pixel *in, const Background *back)
contrib/libtests/pngstest.c:gpc_Preq(Pixel *out, const Pixel *in, const Background *back)
contrib/libtests/pngstest.c:gpc_Glin(Pixel *out, const Pixel *in, const Background *back)
contrib/libtests/pngstest.c:gpc_Gpre(Pixel *out, const Pixel *in, const Background *back)
contrib/libtests/pngstest.c:gpc_Gprq(Pixel *out, const Pixel *in, const Background *back)
contrib/libtests/pngstest.c:gpc_sRGB(Pixel *out, const Pixel *in, const Background *back)
contrib/libtests/pngstest.c:gpc_unpg(Pixel *out, const Pixel *in, const Background *back)
contrib/libtests/pngstest.c:gpc_unpc(Pixel *out, const Pixel *in, const Background *back)
contrib/libtests/pngstest.c:gpc_b16g(Pixel *out, const Pixel *in, const Background *back)
contrib/libtests/pngstest.c:gpc_b16c(Pixel *out, const Pixel *in, const Background *back)
contrib/libtests/pngstest.c:gpc_sG(Pixel *out, const Pixel *in, const Background *back)
contrib/libtests/pngstest.c:gpc_sGp(Pixel *out, const Pixel *in, const Background *back)
contrib/libtests/pngstest.c:gpc_sCp(Pixel *out, const Pixel *in, const Background *back)
contrib/libtests/pngstest.c:gpc_gb16(Pixel *out, const Pixel *in, const Background *back)
contrib/libtests/pngstest.c:gpc_cb16(Pixel *out, const Pixel *in, const Background *back)
contrib/libtests/pngstest.c:gpc_A(Pixel *out, const Pixel *in, const Background *back)
contrib/libtests/pngstest.c:gpc_g16(Pixel *out, const Pixel *in, const Background *back)
contrib/libtests/pngstest.c:gpc_g16q(Pixel *out, const Pixel *in, const Background *back)
contrib/libtests/pngstest.c:   (Pixel *out, const Pixel *in, const Background *back) =
contrib/libtests/pngstest.c: * The matrix is held in an array indexed thus:
contrib/libtests/pngstest.c: * match the above matrix!
contrib/libtests/pngstest.c:   (Pixel *out, const Pixel *in, const Background *back) =
contrib/libtests/pngstest.c:   (Pixel *out, const Pixel *in, const Background *back) =
contrib/libtests/pngstest.c:/* The error arrays record the error in the same matrix; 64 entries, however
contrib/libtests/pngstest.c: * opaque input pixel values.  Notice that alpha should be exact in each case.
contrib/libtests/pngstest.c:#if PNG_FORMAT_FLAG_COLORMAP == 8 /* extra check also required */
contrib/libtests/pngstest.c:   /* Basic pixel information: */
contrib/libtests/pngstest.c:   void (*in_gp)(Pixel*, png_const_voidp);
contrib/libtests/pngstest.c:   void (*out_gp)(Pixel*, png_const_voidp);
contrib/libtests/pngstest.c:   void (*transform)(Pixel *out, const Pixel *in, const Background *back);
contrib/libtests/pngstest.c:   void (*from_linear)(Pixel *out, const Pixel *in, const Background *back);
contrib/libtests/pngstest.c:       * input pixels (in turn).
contrib/libtests/pngstest.c:   result->in_gp = get_pixel(in_format);
contrib/libtests/pngstest.c:   result->out_gp = get_pixel(out_format);
contrib/libtests/pngstest.c:         fprintf(stderr, "internal transform via linear error 0x%x->0x%x\n",
contrib/libtests/pngstest.c:         exit(1);
contrib/libtests/pngstest.c:      /* The caller handles the colormap->pixel value conversion, so the
contrib/libtests/pngstest.c:       * transform function just gets a pixel value, however because libpng
contrib/libtests/pngstest.c:       * background color (to use a solid color).  The code above uses a fixed
contrib/libtests/pngstest.c:       * composition is always on the background (so BUFFER_INIT8 * 257), except
contrib/libtests/pngstest.c:/* Compare two pixels.
contrib/libtests/pngstest.c:static int error_to_linear = 811; * by experiment *
contrib/libtests/pngstest.c:static int error_to_linear_grayscale = 424; * by experiment *
contrib/libtests/pngstest.c:static int error_to_sRGB = 6; * by experiment *
contrib/libtests/pngstest.c:                                            2 by experiment *
contrib/libtests/pngstest.c:static int error_in_compose = 2; * by experiment *
contrib/libtests/pngstest.c: * The general 'error_via_linear' is more complex because of pre-multiplication,
contrib/libtests/pngstest.c: * this compounds the 8-bit errors according to the alpha value of the pixel.
contrib/libtests/pngstest.c:static int error_via_linear[256]; /* Indexed by 8-bit alpha */
contrib/libtests/pngstest.c:   error_via_linear[0] = 255; /* transparent pixel */
contrib/libtests/pngstest.c:print_pixel(char string[64], const Pixel *pixel, png_uint_32 format)
contrib/libtests/pngstest.c:         sprintf(string, "%s(%d)", format_names[format], pixel->g);
contrib/libtests/pngstest.c:         sprintf(string, "%s(%d,%d)", format_names[format], pixel->g,
contrib/libtests/pngstest.c:            pixel->a);
contrib/libtests/pngstest.c:            pixel->r, pixel->g, pixel->b);
contrib/libtests/pngstest.c:            pixel->r, pixel->g, pixel->b, pixel->a);
contrib/libtests/pngstest.c:logpixel(const Transform *transform, png_uint_32 x, png_uint_32 y,
contrib/libtests/pngstest.c:   const Pixel *in, const Pixel *calc, const Pixel *out, const char *reason)
contrib/libtests/pngstest.c:   char pixel_in[64], pixel_calc[64], pixel_out[64], pixel_loc[64];
contrib/libtests/pngstest.c:   print_pixel(pixel_in, in, in_format);
contrib/libtests/pngstest.c:   print_pixel(pixel_calc, calc, out_format);
contrib/libtests/pngstest.c:   print_pixel(pixel_out, out, out_format);
contrib/libtests/pngstest.c:      sprintf(pixel_loc, "palette: %lu", (unsigned long)y);
contrib/libtests/pngstest.c:      sprintf(pixel_loc, "%lu,%lu", (unsigned long)x, (unsigned long)y);
contrib/libtests/pngstest.c:      Pixel back;
contrib/libtests/pngstest.c:      char pixel_back[64];
contrib/libtests/pngstest.c:      print_pixel(pixel_back, &back, back_format);
contrib/libtests/pngstest.c:      sprintf(background_info, " on background %s", pixel_back);
contrib/libtests/pngstest.c:         "Use --preserve and examine: ", pixel_loc, reason, via_linear,
contrib/libtests/pngstest.c:         pixel_in, background_info, pixel_out, pixel_calc);
contrib/libtests/pngstest.c:         pixel_loc, reason, via_linear, pixel_in, background_info, pixel_out,
contrib/libtests/pngstest.c:         pixel_calc);
contrib/libtests/pngstest.c:cmppixel(Transform *transform, png_const_voidp in, png_const_voidp out,
contrib/libtests/pngstest.c:   png_uint_32 x, png_uint_32 y/*or palette index*/)
contrib/libtests/pngstest.c:   int maxerr;
contrib/libtests/pngstest.c:   Pixel pixel_in, pixel_calc, pixel_out;
contrib/libtests/pngstest.c:   transform->in_gp(&pixel_in, in);
contrib/libtests/pngstest.c:      transform->transform(&pixel_calc, &pixel_in, transform->background);
contrib/libtests/pngstest.c:      transform->transform(&pixel_out, &pixel_in, transform->background);
contrib/libtests/pngstest.c:      transform->from_linear(&pixel_calc, &pixel_out, NULL);
contrib/libtests/pngstest.c:   transform->out_gp(&pixel_out, out);
contrib/libtests/pngstest.c:   /* Eliminate the case where the input and output values match exactly. */
contrib/libtests/pngstest.c:   if (pixel_calc.a == pixel_out.a && pixel_calc.r == pixel_out.r &&
contrib/libtests/pngstest.c:      pixel_calc.g == pixel_out.g && pixel_calc.b == pixel_out.b)
contrib/libtests/pngstest.c:   /* Eliminate the case where the output pixel is transparent and the output
contrib/libtests/pngstest.c:   if (transform->output_8bit && pixel_calc.a == 0 && pixel_out.a == 0)
contrib/libtests/pngstest.c:      int err_a = abs(pixel_calc.a-pixel_out.a);
contrib/libtests/pngstest.c:      (pixel_calc.a == 0 || pixel_out.a == 0))
contrib/libtests/pngstest.c:      int err_r = abs(pixel_calc.r - pixel_out.r);
contrib/libtests/pngstest.c:      int err_g = abs(pixel_calc.g - pixel_out.g);
contrib/libtests/pngstest.c:      int err_b = abs(pixel_calc.b - pixel_out.b);
contrib/libtests/pngstest.c:         return 1; /* exact match */
contrib/libtests/pngstest.c:      if (pixel_in.a >= transform->in_opaque)
contrib/libtests/pngstest.c:      else if (pixel_in.a > 0)
contrib/libtests/pngstest.c:      maxerr = err_r;
contrib/libtests/pngstest.c:      if (maxerr < err_g) maxerr = err_g;
contrib/libtests/pngstest.c:      if (maxerr < err_b) maxerr = err_b;
contrib/libtests/pngstest.c:      if (maxerr <= transform->error[limit])
contrib/libtests/pngstest.c:         transform->error[limit] = (png_uint_16)maxerr;
contrib/libtests/pngstest.c:   return logpixel(transform, x, y, &pixel_in, &pixel_calc, &pixel_out, errmsg);
contrib/libtests/pngstest.c:      return logerror(a, a->file_name, ": width x height changed: ",
contrib/libtests/pngstest.c:    * matches then we expect the colormaps to match, although this is not
contrib/libtests/pngstest.c:      /* Only check colormap entries that actually exist; */
contrib/libtests/pngstest.c:      png_byte in_use[256], amax = 0, bmax = 0;
contrib/libtests/pngstest.c:       * ensure all pixels are valid color-map indexes.
contrib/libtests/pngstest.c:         png_uint_32 x;
contrib/libtests/pngstest.c:         for (x=0; x<width; ++x)
contrib/libtests/pngstest.c:            png_byte bval = ppb[x];
contrib/libtests/pngstest.c:            png_byte aval = ppa[x];
contrib/libtests/pngstest.c:            if (bval > bmax)
contrib/libtests/pngstest.c:               bmax = bval;
contrib/libtests/pngstest.c:            if (aval > amax)
contrib/libtests/pngstest.c:               amax = aval;
contrib/libtests/pngstest.c:         /* This is used in logpixel to get the error message correct. */
contrib/libtests/pngstest.c:             * pixel values.  These cause an error here (at present) unless
contrib/libtests/pngstest.c:                  char pindex[9];
contrib/libtests/pngstest.c:                  sprintf(pindex, "%lu[%lu]", (unsigned long)y,
contrib/libtests/pngstest.c:                  logerror(a, a->file_name, ": bad pixel index: ", pindex);
contrib/libtests/pngstest.c:                  char pindex[9];
contrib/libtests/pngstest.c:                  sprintf(pindex, "%lu[%lu]", (unsigned long)y,
contrib/libtests/pngstest.c:                  logerror(b, b->file_name, ": bad pixel index: ", pindex);
contrib/libtests/pngstest.c:            else if (!cmppixel(&tr, a_cmap, b_cmap, 0, y))
contrib/libtests/pngstest.c:      /* else the image buffers don't match pixel-wise so compare sample values
contrib/libtests/pngstest.c:       * instead, but first validate that the pixel indexes are in range (but
contrib/libtests/pngstest.c:          * TODO: deal with input images with bad pixel values?
contrib/libtests/pngstest.c:         if (amax >= a->image.colormap_entries)
contrib/libtests/pngstest.c:            char pindex[9];
contrib/libtests/pngstest.c:            sprintf(pindex, "%d[%lu]", amax,
contrib/libtests/pngstest.c:            return logerror(a, a->file_name, ": bad pixel index: ", pindex);
contrib/libtests/pngstest.c:         else if (bmax >= b->image.colormap_entries)
contrib/libtests/pngstest.c:            char pindex[9];
contrib/libtests/pngstest.c:            sprintf(pindex, "%d[%lu]", bmax,
contrib/libtests/pngstest.c:            return logerror(b, b->file_name, ": bad pixel index: ", pindex);
contrib/libtests/pngstest.c:   /* We can directly compare pixel values without the need to use the read
contrib/libtests/pngstest.c:    *    8-bit alpha value of the pixel was 255 (opaque).
contrib/libtests/pngstest.c:         /* The following are used only if the formats match, except that
contrib/libtests/pngstest.c:          * 'bchannels' is a flag for matching formats.  btoa[x] says, for each
contrib/libtests/pngstest.c:      png_uint_32 x;
contrib/libtests/pngstest.c:      for (x=0, ppa=rowa, ppb=rowb; x<width; ++x)
contrib/libtests/pngstest.c:                     continue; /* x loop */
contrib/libtests/pngstest.c:                     continue; /* x loop */
contrib/libtests/pngstest.c:          * pixel.
contrib/libtests/pngstest.c:         if (!cmppixel(&tr, psa, psb, x, y) && (a->opts & KEEP_GOING) == 0)
contrib/libtests/pngstest.c:         printf("%s %lu x %lu %s -> %s", image->file_name,
contrib/libtests/pngstest.c:      image->stride = PNG_IMAGE_ROW_STRIDE(image->image) + image->stride_extra;
contrib/libtests/pngstest.c:                      * this is greater than the maximum amount of
contrib/libtests/pngstest.c:               initimage(output, image->opts, "tmpfile", image->stride_extra);
contrib/libtests/pngstest.c:            image->stride_extra);
contrib/libtests/pngstest.c:   int stride_extra, int log_pass)
contrib/libtests/pngstest.c:   initimage(&image, opts, file_name, stride_extra);
contrib/libtests/pngstest.c:      exit(1);
contrib/libtests/pngstest.c:   int stride_extra = 0;
contrib/libtests/pngstest.c:               fprintf(stderr, "%s: %s is too long for a temp file prefix\n",
contrib/libtests/pngstest.c:               exit(99);
contrib/libtests/pngstest.c:            fprintf(stderr, "%s: %s requires a temporary file prefix\n",
contrib/libtests/pngstest.c:            exit(99);
contrib/libtests/pngstest.c:            exit(99);
contrib/libtests/pngstest.c:            exit(99);
contrib/libtests/pngstest.c:         exit(99);
contrib/libtests/pngstest.c:                     stride_extra, log_pass))
contrib/libtests/pngstest.c:               exit(99);
contrib/libtests/pngstest.c:         else if (!test_one_file(arg, &formats, opts, stride_extra, log_pass))
contrib/libtests/pngstest.c:            exit(99);
contrib/libtests/pngstest.c:         exit(99);
contrib/libtests/makepng.c: * component bit depth, or the pixel bit-depth for a color-mapped image.
contrib/libtests/makepng.c: * approximately value^(1/1.45) to the color values and so a gAMA chunk of 65909
contrib/libtests/makepng.c: * image is the 1-channel diamond, but using palette index, not luminosity.
contrib/libtests/makepng.c: * Image size is determined by the final pixel depth in bits, i.e. channels x
contrib/libtests/makepng.c: * 8 bits or less:    64x64
contrib/libtests/makepng.c: * 16 bits:           256x256
contrib/libtests/makepng.c: * More than 16 bits: 1024x1024
contrib/libtests/makepng.c: * will have exactly one palette entry and all image files with be 16x16 in
contrib/libtests/makepng.c: * default, it assumes text output; this program makes no attempt to change the
contrib/libtests/makepng.c: * text mode of stdout!
contrib/libtests/makepng.c:/* This structure is used for inserting extra chunks (the --insert argument, not
contrib/libtests/makepng.c:   struct chunk_insert *next;
contrib/libtests/makepng.c:pixel_depth_of_type(int color_type, int bit_depth)
contrib/libtests/makepng.c:      int pixel_depth = pixel_depth_of_type(color_type, bit_depth);
contrib/libtests/makepng.c:      if (pixel_depth < 8)
contrib/libtests/makepng.c:      else if (pixel_depth > 16)
contrib/libtests/makepng.c:         exit(1);
contrib/libtests/makepng.c:            unsigned int x, y, ip;
contrib/libtests/makepng.c:            for (x=0; x<size; ++x) for (y=0; y<size; ++y)
contrib/libtests/makepng.c:               ip = x + (size * y);
contrib/libtests/makepng.c:#              define xyinterp(x, y, c1, c2, c3, c4) (((size * size / 2) +\
contrib/libtests/makepng.c:                  (interp(x, c1, c2) * y + (size-y) * interp(x, c3, c4))) /\
contrib/libtests/makepng.c:                  xyinterp(x, y,   0, 255,   0, 255),
contrib/libtests/makepng.c:                  xyinterp(x, y, 255,   0,   0, 255),
contrib/libtests/makepng.c:                  xyinterp(x, y,   0,   0, 255, 255),
contrib/libtests/makepng.c:                  xyinterp(x, y,   0, 102, 204, 255),
contrib/libtests/makepng.c:set_value(png_bytep row, size_t rowbytes, png_uint_32 x, unsigned int bit_depth,
contrib/libtests/makepng.c:   x *= bit_depth;  /* Maximum x is 4*1024, maximum bit_depth is 16 */
contrib/libtests/makepng.c:      png_uint_32 offset = x >> 3;
contrib/libtests/makepng.c:                  unsigned int shift = (8 - bit_depth) - (x & 0x7U);
contrib/libtests/makepng.c:               exit(1);
contrib/libtests/makepng.c:         exit(1);
contrib/libtests/makepng.c:      exit(1);
contrib/libtests/makepng.c:   png_uint_32 size_max = image_size_of_type(color_type, bit_depth, colors)-1;
contrib/libtests/makepng.c:   png_uint_32 depth_max = (1U << bit_depth)-1; /* up to 65536 */
contrib/libtests/makepng.c:            png_uint_32 x;
contrib/libtests/makepng.c:            png_uint_32 base = 2*size_max - abs(2*y-size_max);
contrib/libtests/makepng.c:            for (x=0; x<=size_max; ++x)
contrib/libtests/makepng.c:               png_uint_32 luma = base - abs(2*x-size_max);
contrib/libtests/makepng.c:               /* 'luma' is now in the range 0..2*size_max, we need
contrib/libtests/makepng.c:                * 0..depth_max
contrib/libtests/makepng.c:               luma = (luma*depth_max + size_max) / (2*size_max);
contrib/libtests/makepng.c:               set_value(row, rowbytes, x, bit_depth, luma, gamma_table, conv);
contrib/libtests/makepng.c:            png_uint_32 alpha = (depth_max * y * 2 + size_max) / (2 * size_max);
contrib/libtests/makepng.c:            png_uint_32 x;
contrib/libtests/makepng.c:            for (x=0; x<=size_max; ++x)
contrib/libtests/makepng.c:               set_value(row, rowbytes, 2*x, bit_depth,
contrib/libtests/makepng.c:                  (depth_max * x * 2 + size_max) / (2 * size_max), gamma_table,
contrib/libtests/makepng.c:               set_value(row, rowbytes, 2*x+1, bit_depth, alpha, gamma_table,
contrib/libtests/makepng.c:            /* x0: the black->red scale (the value of the red component) at the
contrib/libtests/makepng.c:             * x1: the green->white scale (the value of the red and blue
contrib/libtests/makepng.c:             *     components at the end of the row; green is depth_max).
contrib/libtests/makepng.c:            png_uint_32 Y = (depth_max * y * 2 + size_max) / (2 * size_max);
contrib/libtests/makepng.c:            png_uint_32 x;
contrib/libtests/makepng.c:            /* Interpolate x/depth_max from start to end:
contrib/libtests/makepng.c:             * green:   0   depth_max   depth_max
contrib/libtests/makepng.c:            for (x=0; x<=size_max; ++x)
contrib/libtests/makepng.c:               set_value(row, rowbytes, 3*x+0, bit_depth, /* red */ Y,
contrib/libtests/makepng.c:               set_value(row, rowbytes, 3*x+1, bit_depth, /* green */
contrib/libtests/makepng.c:                  (depth_max * x * 2 + size_max) / (2 * size_max),
contrib/libtests/makepng.c:               set_value(row, rowbytes, 3*x+2, bit_depth, /* blue */
contrib/libtests/makepng.c:                  (Y * x * 2 + size_max) / (2 * size_max),
contrib/libtests/makepng.c:            /* x0: the transparent->blue scale (the value of the blue and alpha
contrib/libtests/makepng.c:             * x1: the red->green scale (the value of the red and green
contrib/libtests/makepng.c:             *     depth_max).
contrib/libtests/makepng.c:            png_uint_32 Y = (depth_max * y * 2 + size_max) / (2 * size_max);
contrib/libtests/makepng.c:            png_uint_32 x;
contrib/libtests/makepng.c:            /* Interpolate x/depth_max from start to end:
contrib/libtests/makepng.c:             * red:     0   depth_max-Y depth_max-Y
contrib/libtests/makepng.c:             * alpha:   Y    depth_max  depth_max-Y
contrib/libtests/makepng.c:            for (x=0; x<=size_max; ++x)
contrib/libtests/makepng.c:               set_value(row, rowbytes, 4*x+0, bit_depth, /* red */
contrib/libtests/makepng.c:                  ((depth_max-Y) * x * 2 + size_max) / (2 * size_max),
contrib/libtests/makepng.c:               set_value(row, rowbytes, 4*x+1, bit_depth, /* green */
contrib/libtests/makepng.c:                  (Y * x * 2 + size_max) / (2 * size_max),
contrib/libtests/makepng.c:               set_value(row, rowbytes, 4*x+2, bit_depth, /* blue */
contrib/libtests/makepng.c:                  Y - (Y * x * 2 + size_max) / (2 * size_max),
contrib/libtests/makepng.c:               set_value(row, rowbytes, 4*x+3, bit_depth, /* alpha */
contrib/libtests/makepng.c:                  Y + ((depth_max-Y) * x * 2 + size_max) / (2 * size_max),
contrib/libtests/makepng.c:         exit(2);
contrib/libtests/makepng.c:      /* Palette with fixed color: the image rows are all 0 and the image width
contrib/libtests/makepng.c:               png_uint_32 x;
contrib/libtests/makepng.c:               for (x=0; x<=size_max; ++x)
contrib/libtests/makepng.c:                  set_value(row, rowbytes, x, bit_depth, luma, gamma_table,
contrib/libtests/makepng.c:               png_uint_32 x;
contrib/libtests/makepng.c:               for (x=0; x<size_max; ++x)
contrib/libtests/makepng.c:                  set_value(row, rowbytes, 2*x, bit_depth, luma, gamma_table,
contrib/libtests/makepng.c:                  set_value(row, rowbytes, 2*x+1, bit_depth, alpha, gamma_table,
contrib/libtests/makepng.c:               png_uint_32 x;
contrib/libtests/makepng.c:               for (x=0; x<=size_max; ++x)
contrib/libtests/makepng.c:                  set_value(row, rowbytes, 3*x+0, bit_depth, red, gamma_table,
contrib/libtests/makepng.c:                  set_value(row, rowbytes, 3*x+1, bit_depth, green, gamma_table,
contrib/libtests/makepng.c:                  set_value(row, rowbytes, 3*x+2, bit_depth, blue, gamma_table,
contrib/libtests/makepng.c:               png_uint_32 x;
contrib/libtests/makepng.c:               for (x=0; x<=size_max; ++x)
contrib/libtests/makepng.c:                  set_value(row, rowbytes, 4*x+0, bit_depth, red, gamma_table,
contrib/libtests/makepng.c:                  set_value(row, rowbytes, 4*x+1, bit_depth, green, gamma_table,
contrib/libtests/makepng.c:                  set_value(row, rowbytes, 4*x+2, bit_depth, blue, gamma_table,
contrib/libtests/makepng.c:                  set_value(row, rowbytes, 4*x+3, bit_depth, alpha, gamma_table,
contrib/libtests/makepng.c:            exit(2);
contrib/libtests/makepng.c:      exit(1);
contrib/libtests/makepng.c:   volatile png_fixed_point gamma, chunk_insert * volatile insert,
contrib/libtests/makepng.c:      png_fixed_point real_gamma = 45455; /* For sRGB */
contrib/libtests/makepng.c:      /* This function uses the libpng values used on read to carry extra
contrib/libtests/makepng.c:         png_set_gAMA_fixed(png_ptr, info_ptr, real_gamma);
contrib/libtests/makepng.c:         png_set_cHRM_fixed(png_ptr, info_ptr,
contrib/libtests/makepng.c:            /* color      x       y */
contrib/libtests/makepng.c:      /* Insert extra information. */
contrib/libtests/makepng.c:         insert = insert->next;
contrib/libtests/makepng.c:                   * to be padded to a 4x boundary.
contrib/libtests/makepng.c:   exit(1);
contrib/libtests/makepng.c:         fprintf(stderr, "%s: size exceeds system limits\n", param);
contrib/libtests/makepng.c:         exit(1);
contrib/libtests/makepng.c:check_param_count(int nparams, int expect)
contrib/libtests/makepng.c:   if (nparams != expect)
contrib/libtests/makepng.c:      exit(1);
contrib/libtests/makepng.c:            if (filelen > 0xfffffffc) /* Maximum profile length */
contrib/libtests/makepng.c:               exit(1);
contrib/libtests/makepng.c:               if (fake_len > 0xffffffff) /* Maximum profile length */
contrib/libtests/makepng.c:                  exit(1);
contrib/libtests/makepng.c:               /* Always fix up the profile length. */
contrib/libtests/makepng.c:         exit(1);
contrib/libtests/makepng.c:      /* load_file allocates extra space for this padding, the ICC spec requires
contrib/libtests/makepng.c:      exit(1);
contrib/libtests/makepng.c:clear_text(png_text *text, png_charp keyword)
contrib/libtests/makepng.c:   text->compression = -1; /* none */
contrib/libtests/makepng.c:   text->key = keyword;
contrib/libtests/makepng.c:   text->text = NULL;
contrib/libtests/makepng.c:   text->text_length = 0; /* libpng calculates this */
contrib/libtests/makepng.c:   text->itxt_length = 0; /* libpng calculates this */
contrib/libtests/makepng.c:   text->lang = NULL;
contrib/libtests/makepng.c:   text->lang_key = NULL;
contrib/libtests/makepng.c:set_text(png_structp png_ptr, png_infop info_ptr, png_textp text,
contrib/libtests/makepng.c:            text->text_length = load_file(param+1, &file);
contrib/libtests/makepng.c:            text->text = (png_charp)file;
contrib/libtests/makepng.c:               text->text_length = fake_len;
contrib/libtests/makepng.c:               text->text = (png_charp)data;
contrib/libtests/makepng.c:         text->text = param;
contrib/libtests/makepng.c:   png_set_text(png_ptr, info_ptr, text, 1);
contrib/libtests/makepng.c:   if (text->text != param)
contrib/libtests/makepng.c:      free(text->text);
contrib/libtests/makepng.c:   png_text text;
contrib/libtests/makepng.c:   clear_text(&text, params[0]);
contrib/libtests/makepng.c:   set_text(png_ptr, info_ptr, &text, params[1]);
contrib/libtests/makepng.c:   png_text text;
contrib/libtests/makepng.c:   clear_text(&text, params[0]);
contrib/libtests/makepng.c:   text.compression = 0; /* deflate */
contrib/libtests/makepng.c:   set_text(png_ptr, info_ptr, &text, params[1]);
contrib/libtests/makepng.c:   png_text text;
contrib/libtests/makepng.c:   clear_text(&text, params[0]);
contrib/libtests/makepng.c:   text.compression = 2; /* iTXt + deflate */
contrib/libtests/makepng.c:   text.lang = params[1];/* language tag */
contrib/libtests/makepng.c:   text.lang_key = params[2]; /* translated keyword */
contrib/libtests/makepng.c:   set_text(png_ptr, info_ptr, &text, params[3]);
contrib/libtests/makepng.c:         exit(1);
contrib/libtests/makepng.c:      exit(1);
contrib/libtests/makepng.c:   exit(1);
contrib/libtests/makepng.c:      exit(1);
contrib/libtests/makepng.c:   cip->next = NULL;
contrib/libtests/makepng.c:      exit(1);
contrib/libtests/makepng.c:         exit(1);
contrib/libtests/makepng.c:         exit(1);
contrib/libtests/makepng.c:         exit(1);
contrib/libtests/makepng.c:      exit(1);
contrib/libtests/makepng.c:   png_fixed_point gamma = 0; /* not set */
contrib/libtests/makepng.c:            insert_ptr = &new_insert->next;
contrib/libtests/makepng.c:         exit(1);
contrib/libtests/makepng.c:            exit(1);
contrib/libtests/makepng.c:            exit(1);
contrib/libtests/makepng.c:            exit(1);
contrib/libtests/makepng.c:      exit(1);
contrib/libtests/makepng.c:      exit(1);
contrib/libtests/makepng.c:            exit(1);
contrib/libtests/readpng.c:   /* Exit code 0 on success. */
contrib/gregbook/Makefile.w32:# builds statically linked executables, but that can be changed by uncom-
contrib/gregbook/Makefile.w32:E = .exe
contrib/gregbook/readpng.h:      express or implied.  In no event shall the author or contributors
contrib/gregbook/readpng.h:#  define Trace(x)  {fprintf x ; fflush(stderr); fflush(stdout);}
contrib/gregbook/readpng.h:#  define Trace(x)  ;
contrib/gregbook/readpng.h:uch *readpng_get_image(double display_exponent, int *pChannels,
contrib/gregbook/wpng.c:   maxval = 255) to PNG.  Non-interlaced PNGs are written progressively;
contrib/gregbook/wpng.c:   interactive text from the keyboard while stdin is redirected.  Thanks
contrib/gregbook/wpng.c:   to Cosmin Truta for Cygwin fixes.
contrib/gregbook/wpng.c:    - process backspace with -text option under DOS/Win? (currently get ^H)
contrib/gregbook/wpng.c:    - 1.03:  removed extraneous character from usage screen; fixed bug in
contrib/gregbook/wpng.c:    - 1.04:  fixed DOS/OS2/Win32 detection, including partial Cygwin fix
contrib/gregbook/wpng.c:         Linux, the same wpng appears to work fine.  I don't know what is
contrib/gregbook/wpng.c:      express or implied.  In no event shall the author or contributors
contrib/gregbook/wpng.c:#  ifndef __GNUC__   /* treat Win32 native ports of gcc as Unix environments */
contrib/gregbook/wpng.c:#  include <fcntl.h>    /* O_BINARY for fdopen() without text translation */
contrib/gregbook/wpng.c:   text that includes control characters discouraged by the PNG spec; text
contrib/gregbook/wpng.c:    char *bgstr, *textbuf = NULL;
contrib/gregbook/wpng.c:    int text = FALSE;
contrib/gregbook/wpng.c:    int maxval;
contrib/gregbook/wpng.c:    double LUT_exponent;                /* just the lookup table */
contrib/gregbook/wpng.c:    double CRT_exponent = 2.2;          /* just the monitor */
contrib/gregbook/wpng.c:    double default_display_exponent;    /* whole display system */
contrib/gregbook/wpng.c:    wpng_info.have_text = 0;
contrib/gregbook/wpng.c:    /* First get the default value for our display-system exponent, i.e.,
contrib/gregbook/wpng.c:     * the product of the CRT exponent and the exponent corresponding to
contrib/gregbook/wpng.c:     * inverse of this value.  (Note that this is not an exhaustive list
contrib/gregbook/wpng.c:     * that default_display_exponent is positive.) */
contrib/gregbook/wpng.c:    /* third-party utilities can modify the default LUT exponent */
contrib/gregbook/wpng.c:    LUT_exponent = 1.0 / 2.2;
contrib/gregbook/wpng.c:    if (some_next_function_that_returns_gamma(&next_gamma))
contrib/gregbook/wpng.c:        LUT_exponent = 1.0 / next_gamma;
contrib/gregbook/wpng.c:    LUT_exponent = 1.0 / 1.7;
contrib/gregbook/wpng.c:            LUT_exponent = 1.0 / sgi_gamma;
contrib/gregbook/wpng.c:    LUT_exponent = 1.8 / 2.61;
contrib/gregbook/wpng.c:        LUT_exponent = mac_gamma / 2.61;
contrib/gregbook/wpng.c:    LUT_exponent = 1.0;   /* assume no LUT:  most PCs */
contrib/gregbook/wpng.c:    default_display_exponent = LUT_exponent * CRT_exponent;
contrib/gregbook/wpng.c:        double exponent = atof(p);
contrib/gregbook/wpng.c:        if (exponent > 0.0)
contrib/gregbook/wpng.c:            default_gamma = 1.0 / exponent;
contrib/gregbook/wpng.c:        default_gamma = 1.0 / default_display_exponent;
contrib/gregbook/wpng.c:        } else if (!strncmp(*argv, "-text", 3)) {
contrib/gregbook/wpng.c:            text = TRUE;
contrib/gregbook/wpng.c:                    sscanf(bgstr+1, "%2x%2x%2x", &r, &g, &b);
contrib/gregbook/wpng.c:                ++error;   /* not expecting any other options */
contrib/gregbook/wpng.c:            sscanf(pnmline, "%d", &maxval);
contrib/gregbook/wpng.c:                maxval != 255)
contrib/gregbook/wpng.c:                  ":  only positive width/height, maxval == 255 allowed \n");
contrib/gregbook/wpng.c:            wpng_info.sample_depth = 8;  /* <==> maxval 255 */
contrib/gregbook/wpng.c:                /* check if outname already exists; if not, open */
contrib/gregbook/wpng.c:                    fprintf(stderr, PROGNAME ":  output file exists [%s]\n",
contrib/gregbook/wpng.c:"Usage:  %s [-gamma exp] [-bgcolor bg] [-text] [-time] [-interlace] pnmfile\n"
contrib/gregbook/wpng.c:"or: ... | %s [-gamma exp] [-bgcolor bg] [-text] [-time] [-interlace] | ...\n"
contrib/gregbook/wpng.c:         "    exp \ttransfer-function exponent (``gamma'') of the image in\n"
contrib/gregbook/wpng.c:         "\t\t  inverse of display-system exponent, i.e., 1 / (LUT * CRT)\n"
contrib/gregbook/wpng.c:         "\t\t  (where LUT = lookup-table exponent and CRT = CRT exponent;\n"
contrib/gregbook/wpng.c:         "\t\t  7-character hex RGB format (e.g., ``#ff7700'' for orange:\n"
contrib/gregbook/wpng.c:         "    -text\tprompt interactively for text info (tEXt chunks)\n"
contrib/gregbook/wpng.c:"pnmfile or stdin must be a binary PGM (`P5'), PPM (`P6') or (extremely\n"
contrib/gregbook/wpng.c:"to have maxval == 255 (i.e., no scaling).  If pnmfile is specified, it\n"
contrib/gregbook/wpng.c:"``.png'' extension; files read from stdin are converted and sent to stdout.\n"
contrib/gregbook/wpng.c:        exit(1);
contrib/gregbook/wpng.c:    /* prepare the text buffers for libpng's use; note that even though
contrib/gregbook/wpng.c:     * PNG's png_text struct includes a length field, we don't have to fill
contrib/gregbook/wpng.c:    if (text &&
contrib/gregbook/wpng.c:        (textbuf = (char *)malloc((5 + 9)*75)) != NULL)
contrib/gregbook/wpng.c:          "Enter text info (no more than 72 characters per line);\n");
contrib/gregbook/wpng.c:            p = textbuf + TEXT_TITLE_OFFSET;
contrib/gregbook/wpng.c:                wpng_info.have_text |= TEXT_TITLE;
contrib/gregbook/wpng.c:                    wpng_info.have_text &= ~TEXT_TITLE;
contrib/gregbook/wpng.c:                        wpng_info.have_text &= ~TEXT_TITLE;
contrib/gregbook/wpng.c:            p = textbuf + TEXT_AUTHOR_OFFSET;
contrib/gregbook/wpng.c:                wpng_info.have_text |= TEXT_AUTHOR;
contrib/gregbook/wpng.c:                    wpng_info.have_text &= ~TEXT_AUTHOR;
contrib/gregbook/wpng.c:                        wpng_info.have_text &= ~TEXT_AUTHOR;
contrib/gregbook/wpng.c:            p = textbuf + TEXT_DESC_OFFSET;
contrib/gregbook/wpng.c:            if ((len = p - (textbuf + TEXT_DESC_OFFSET)) > 1) {
contrib/gregbook/wpng.c:                wpng_info.desc = textbuf + TEXT_DESC_OFFSET;
contrib/gregbook/wpng.c:                wpng_info.have_text |= TEXT_DESC;
contrib/gregbook/wpng.c:                p = textbuf + TEXT_DESC_OFFSET;
contrib/gregbook/wpng.c:                    wpng_info.have_text &= ~TEXT_DESC;
contrib/gregbook/wpng.c:                        wpng_info.have_text &= ~TEXT_DESC;
contrib/gregbook/wpng.c:            p = textbuf + TEXT_COPY_OFFSET;
contrib/gregbook/wpng.c:                wpng_info.have_text |= TEXT_COPY;
contrib/gregbook/wpng.c:                    wpng_info.have_text &= ~TEXT_COPY;
contrib/gregbook/wpng.c:                        wpng_info.have_text &= ~TEXT_COPY;
contrib/gregbook/wpng.c:            p = textbuf + TEXT_EMAIL_OFFSET;
contrib/gregbook/wpng.c:                wpng_info.have_text |= TEXT_EMAIL;
contrib/gregbook/wpng.c:                    wpng_info.have_text &= ~TEXT_EMAIL;
contrib/gregbook/wpng.c:                        wpng_info.have_text &= ~TEXT_EMAIL;
contrib/gregbook/wpng.c:            p = textbuf + TEXT_URL_OFFSET;
contrib/gregbook/wpng.c:                wpng_info.have_text |= TEXT_URL;
contrib/gregbook/wpng.c:                    wpng_info.have_text &= ~TEXT_URL;
contrib/gregbook/wpng.c:                        wpng_info.have_text &= ~TEXT_URL;
contrib/gregbook/wpng.c:    } else if (text) {
contrib/gregbook/wpng.c:        fprintf(stderr, PROGNAME ":  unable to allocate memory for text\n");
contrib/gregbook/wpng.c:        text = FALSE;
contrib/gregbook/wpng.c:        wpng_info.have_text = 0;
contrib/gregbook/wpng.c:                  ":  internal logic error (unexpected PNM type)\n");
contrib/gregbook/wpng.c:        exit(rc);
contrib/gregbook/wpng.c:    /* free textbuf, since it's a completely local variable and all text info
contrib/gregbook/wpng.c:    if (text && textbuf) {
contrib/gregbook/wpng.c:        free(textbuf);
contrib/gregbook/wpng.c:        textbuf = NULL;
contrib/gregbook/wpng.c:            exit(5);
contrib/gregbook/wpng.c:            fprintf(stderr, PROGNAME ":  expected %lu bytes, got %lu bytes\n",
contrib/gregbook/wpng.c:            exit(2);
contrib/gregbook/wpng.c:            exit(5);
contrib/gregbook/wpng.c:                  ":  expected %lu bytes, got %lu bytes (row %ld)\n", rowbytes,
contrib/gregbook/wpng.c:            exit(2);
contrib/gregbook/wpng.c:            exit(2);
contrib/gregbook/writepng.c:      express or implied.  In no event shall the author or contributors
contrib/gregbook/writepng.c:#include <stdlib.h>     /* for exit() prototype */
contrib/gregbook/writepng.c: *  unexpected pnmtype; note that outfile might be stdout */
contrib/gregbook/writepng.c:     * turned on (except for palette images) and allow all of the filters,
contrib/gregbook/writepng.c:     * is 16K or smaller (unknown here)--also the default; usually want max
contrib/gregbook/writepng.c:    if (mainprog_ptr->have_text) {
contrib/gregbook/writepng.c:        png_text  text[6];
contrib/gregbook/writepng.c:        int  num_text = 0;
contrib/gregbook/writepng.c:        if (mainprog_ptr->have_text & TEXT_TITLE) {
contrib/gregbook/writepng.c:            text[num_text].compression = PNG_TEXT_COMPRESSION_NONE;
contrib/gregbook/writepng.c:            text[num_text].key = "Title";
contrib/gregbook/writepng.c:            text[num_text].text = mainprog_ptr->title;
contrib/gregbook/writepng.c:            ++num_text;
contrib/gregbook/writepng.c:        if (mainprog_ptr->have_text & TEXT_AUTHOR) {
contrib/gregbook/writepng.c:            text[num_text].compression = PNG_TEXT_COMPRESSION_NONE;
contrib/gregbook/writepng.c:            text[num_text].key = "Author";
contrib/gregbook/writepng.c:            text[num_text].text = mainprog_ptr->author;
contrib/gregbook/writepng.c:            ++num_text;
contrib/gregbook/writepng.c:        if (mainprog_ptr->have_text & TEXT_DESC) {
contrib/gregbook/writepng.c:            text[num_text].compression = PNG_TEXT_COMPRESSION_NONE;
contrib/gregbook/writepng.c:            text[num_text].key = "Description";
contrib/gregbook/writepng.c:            text[num_text].text = mainprog_ptr->desc;
contrib/gregbook/writepng.c:            ++num_text;
contrib/gregbook/writepng.c:        if (mainprog_ptr->have_text & TEXT_COPY) {
contrib/gregbook/writepng.c:            text[num_text].compression = PNG_TEXT_COMPRESSION_NONE;
contrib/gregbook/writepng.c:            text[num_text].key = "Copyright";
contrib/gregbook/writepng.c:            text[num_text].text = mainprog_ptr->copyright;
contrib/gregbook/writepng.c:            ++num_text;
contrib/gregbook/writepng.c:        if (mainprog_ptr->have_text & TEXT_EMAIL) {
contrib/gregbook/writepng.c:            text[num_text].compression = PNG_TEXT_COMPRESSION_NONE;
contrib/gregbook/writepng.c:            text[num_text].key = "E-mail";
contrib/gregbook/writepng.c:            text[num_text].text = mainprog_ptr->email;
contrib/gregbook/writepng.c:            ++num_text;
contrib/gregbook/writepng.c:        if (mainprog_ptr->have_text & TEXT_URL) {
contrib/gregbook/writepng.c:            text[num_text].compression = PNG_TEXT_COMPRESSION_NONE;
contrib/gregbook/writepng.c:            text[num_text].key = "URL";
contrib/gregbook/writepng.c:            text[num_text].text = mainprog_ptr->url;
contrib/gregbook/writepng.c:            ++num_text;
contrib/gregbook/writepng.c:        png_set_text(png_ptr, info_ptr, text, num_text);
contrib/gregbook/writepng.c:    /* if we wanted to write any more text info *after* the image data, we
contrib/gregbook/writepng.c:     * would set up text struct(s) here and call png_set_text() again, with
contrib/gregbook/writepng.c:    /* set up the transformations:  for now, just pack low-bit-depth pixels
contrib/gregbook/writepng.c:     * into bytes (one, two or four pixels per byte) */
contrib/gregbook/writepng.c:     * had any text or time info to write after the IDATs, second argument
contrib/gregbook/writepng.c:    /* close out PNG file; if we had any text or time info to write after
contrib/gregbook/writepng.c:    /* This function, aside from the extra step of retrieving the "error
contrib/gregbook/writepng.c:     * pointer" (below) and the fact that it exists within the application
contrib/gregbook/writepng.c:        exit(99);
contrib/gregbook/README:a very simple example that that shows how a standard file-viewer might use
contrib/gregbook/README:Unix, OpenVMS, and 32-bit Windows.  (Special thanks to Martin Zinser,
contrib/gregbook/README:   Makefile.unx       Unix makefile
contrib/gregbook/README:   rpng-x.c           X Window System (Unix, OpenVMS) front end
contrib/gregbook/README:   rpng2-x.c          X front end for the progressive viewer
contrib/gregbook/README:   wpng.c             generic (text) front end for the converter
contrib/gregbook/README:http://pobox.com/~newt/greg_contact.html
contrib/gregbook/README:     The pngbook demo programs are explicitly designed to demonstrate proper
contrib/gregbook/README: - Unix:
contrib/gregbook/README:     Copy Makefile.unx to Makefile and edit the PNG* and Z* variables
contrib/gregbook/README:     There is no "install" target, so copy the three executables somewhere
contrib/gregbook/README:     This makefile therefore builds statically linked executables, but if
contrib/gregbook/README:     the DLL problems ever get fixed, uncommenting the appropriate PNGLIB
contrib/gregbook/README:     and ZLIB lines will build dynamically linked executables instead.
contrib/gregbook/README:     The result should be three executables:  rpng-win.exe, rpng2-win.exe,
contrib/gregbook/README:     and wpng.exe.  Copy them somewhere in your PATH or run them from the
contrib/gregbook/README:     current folder.  Like the Unix versions, the two windowed programs
contrib/gregbook/README:     the June 2001 release.  Note that the programs use the Unix-style "-"
contrib/gregbook/README:     "/" character.  (For example:  "rpng2-win -bgpat 4 foo.png", not
contrib/gregbook/README:     $ rpng  == "$disk:[dir]rpng-x.exe"
contrib/gregbook/README:     $ rpng2 == "$disk:[dir]rpng2-x.exe"
contrib/gregbook/README:     $ wpng  == "$disk:[dir]wpng.exe"
contrib/gregbook/README:     style is Unix-like, i.e., preceded by "-" rather than "/".
contrib/gregbook/README:     specified background color; for example,
contrib/gregbook/README:     background image.  For example:
contrib/gregbook/README:     format (.pgm or .ppm) to PNG; for example,
contrib/gregbook/README:     All options can be abbreviated to the shortest unique value; for example,
contrib/gregbook/makevms.com:$   write sys$output "zlib include not found. Exiting..."
contrib/gregbook/makevms.com:$   exit 2
contrib/gregbook/makevms.com:$   write sys$output "libpng include not found. Exiting..."
contrib/gregbook/makevms.com:$   exit 2
contrib/gregbook/makevms.com:$  ccopt = "/prefix=all"+ccopt
contrib/gregbook/makevms.com:$      comp = "__vaxc__=1"
contrib/gregbook/makevms.com:$    ccopt = "/decc/prefix=all"+ccopt
contrib/gregbook/makevms.com:$ open/write xopt x11.opt
contrib/gregbook/makevms.com:$ write xopt "sys$library:decw$xlibshr.exe/share"
contrib/gregbook/makevms.com:$ close xopt
contrib/gregbook/makevms.com:$   write sys$output "Building rpng-x..."
contrib/gregbook/makevms.com:$   CALL MAKE rpng-x.OBJ "cc ''CCOPT' rpng-x" -
contrib/gregbook/makevms.com:	rpng-x.c readpng.h
contrib/gregbook/makevms.com:$   call make rpng-x.exe -
contrib/gregbook/makevms.com:	"LINK rpng-x,readpng,lib.opt/opt,x11.opt/opt" -
contrib/gregbook/makevms.com:	rpng-x.obj readpng.obj
contrib/gregbook/makevms.com:$   write sys$output "Building rpng2-x..."
contrib/gregbook/makevms.com:$   CALL MAKE rpng2-x.OBJ "cc ''CCOPT' rpng2-x" -
contrib/gregbook/makevms.com:	rpng2-x.c readpng2.h
contrib/gregbook/makevms.com:$   call make rpng2-x.exe -
contrib/gregbook/makevms.com:	"LINK rpng2-x,readpng2,lib.opt/opt,x11.opt/opt" -
contrib/gregbook/makevms.com:	rpng2-x.obj readpng2.obj
contrib/gregbook/makevms.com:$   call make wpng.exe -
contrib/gregbook/makevms.com:$ exit
contrib/gregbook/makevms.com:$       If Argument .Eqs. "" Then Goto Exit
contrib/gregbook/makevms.com:$       If AFile .Eqs. "" .Or. AFile .Eqs. OFile Then Goto NextEl
contrib/gregbook/makevms.com:$NextEL:
contrib/gregbook/makevms.com:$ Goto Exit
contrib/gregbook/makevms.com:$Exit:
contrib/gregbook/readppm.c:      express or implied.  In no event shall the author or contributors
contrib/gregbook/readppm.c:    int maxval;
contrib/gregbook/readppm.c:    sscanf(ppmline, "%d", &maxval);
contrib/gregbook/readppm.c:    if (maxval != 255) {
contrib/gregbook/readppm.c:        fprintf(stderr, "ERROR:  maxval = %d\n", maxval);
contrib/gregbook/readppm.c:/* display_exponent == LUT_exponent * CRT_exponent */
contrib/gregbook/readppm.c:uch *readpng_get_image(double display_exponent, int *pChannels, ulg *pRowbytes)
contrib/gregbook/readppm.c:    /* expand palette images to RGB, low-bit-depth grayscale images to 8 bits,
contrib/gregbook/readppm.c:    /* GRR WARNING:  grayscale needs to be expanded and channels reset! */
contrib/gregbook/rpng-x.c:   rpng - simple PNG display program                               rpng-x.c
contrib/gregbook/rpng-x.c:   This version is for the X Window System (tested by author under Unix and
contrib/gregbook/rpng-x.c:    - 1.02:  modified to allow abbreviated options; fixed long/ulong mis-
contrib/gregbook/rpng-x.c:    - 1.10:  added support for non-default visuals; fixed X pixel-conversion
contrib/gregbook/rpng-x.c:    - 1.11:  added extra set of parentheses to png_jmpbuf() macro; fixed
contrib/gregbook/rpng-x.c:    - 1.12:  fixed some small X memory leaks (thanks to Franois Petitjean)
contrib/gregbook/rpng-x.c:    - 1.13:  fixed XFreeGC() crash bug (thanks to Patrick Welche)
contrib/gregbook/rpng-x.c:    - 2.01:  fixed improper display of usage screen on PNG error(s)
contrib/gregbook/rpng-x.c:      express or implied.  In no event shall the author or contributors
contrib/gregbook/rpng-x.c:#define PROGNAME  "rpng-x"
contrib/gregbook/rpng-x.c:static int  rpng_x_create_window(void);
contrib/gregbook/rpng-x.c:static int  rpng_x_display_image(void);
contrib/gregbook/rpng-x.c:static void rpng_x_cleanup(void);
contrib/gregbook/rpng-x.c:static int  rpng_x_msb(ulg u32val);
contrib/gregbook/rpng-x.c:static double display_exponent;
contrib/gregbook/rpng-x.c:static XImage *ximage;
contrib/gregbook/rpng-x.c:ulg numcolors=0, pixels[256];
contrib/gregbook/rpng-x.c:    double LUT_exponent;               /* just the lookup table */
contrib/gregbook/rpng-x.c:    double CRT_exponent = 2.2;         /* just the monitor */
contrib/gregbook/rpng-x.c:    double default_display_exponent;   /* whole display system */
contrib/gregbook/rpng-x.c:    /* First set the default value for our display-system exponent, i.e.,
contrib/gregbook/rpng-x.c:     * the product of the CRT exponent and the exponent corresponding to
contrib/gregbook/rpng-x.c:     * exhaustive list of LUT values (e.g., OpenStep has a lot of weird
contrib/gregbook/rpng-x.c:    LUT_exponent = 1.0 / 2.2;
contrib/gregbook/rpng-x.c:    if (some_next_function_that_returns_gamma(&next_gamma))
contrib/gregbook/rpng-x.c:        LUT_exponent = 1.0 / next_gamma;
contrib/gregbook/rpng-x.c:    LUT_exponent = 1.0 / 1.7;
contrib/gregbook/rpng-x.c:            LUT_exponent = 1.0 / sgi_gamma;
contrib/gregbook/rpng-x.c:    LUT_exponent = 1.8 / 2.61;
contrib/gregbook/rpng-x.c:        LUT_exponent = mac_gamma / 2.61;
contrib/gregbook/rpng-x.c:    LUT_exponent = 1.0;   /* assume no LUT:  most PCs */
contrib/gregbook/rpng-x.c:    default_display_exponent = LUT_exponent * CRT_exponent;
contrib/gregbook/rpng-x.c:        display_exponent = atof(p);
contrib/gregbook/rpng-x.c:        display_exponent = default_display_exponent;
contrib/gregbook/rpng-x.c:                display_exponent = atof(*argv);
contrib/gregbook/rpng-x.c:                if (display_exponent <= 0.0)
contrib/gregbook/rpng-x.c:                ++error;   /* not expecting any other options */
contrib/gregbook/rpng-x.c:          "Usage:  %s [-display xdpy] [-gamma exp] [-bgcolor bg] file.png\n"
contrib/gregbook/rpng-x.c:          "    xdpy\tname of the target X display (e.g., ``hostname:0'')\n"
contrib/gregbook/rpng-x.c:          "    exp \ttransfer-function exponent (``gamma'') of the display\n"
contrib/gregbook/rpng-x.c:          PROGNAME, default_display_exponent);
contrib/gregbook/rpng-x.c:          "\t\t  to the product of the lookup-table exponent (varies)\n"
contrib/gregbook/rpng-x.c:          "\t\t  and the CRT exponent (usually 2.2); must be positive\n"
contrib/gregbook/rpng-x.c:          "    bg  \tdesired background color in 7-character hex RGB format\n"
contrib/gregbook/rpng-x.c:        exit(1);
contrib/gregbook/rpng-x.c:        exit(2);
contrib/gregbook/rpng-x.c:        sscanf(bgstr+1, "%2x%2x%2x", &r, &g, &b);
contrib/gregbook/rpng-x.c:        exit(2);
contrib/gregbook/rpng-x.c:    if (rpng_x_create_window())
contrib/gregbook/rpng-x.c:        exit(2);
contrib/gregbook/rpng-x.c:    image_data = readpng_get_image(display_exponent, &image_channels,
contrib/gregbook/rpng-x.c:        exit(3);
contrib/gregbook/rpng-x.c:    Trace((stderr, "calling rpng_x_display_image()\n"))
contrib/gregbook/rpng-x.c:    if (rpng_x_display_image()) {
contrib/gregbook/rpng-x.c:        exit(4);
contrib/gregbook/rpng-x.c:    Trace((stderr, "done with rpng_x_display_image()\n"))
contrib/gregbook/rpng-x.c:        XNextEvent(display, &e);
contrib/gregbook/rpng-x.c:    while (!(e.type == ButtonPress && e.xbutton.button == Button1) &&
contrib/gregbook/rpng-x.c:             ((k = XLookupKeysym(&e.xkey, 0)) == XK_q || k == XK_Escape) ));
contrib/gregbook/rpng-x.c:    rpng_x_cleanup();
contrib/gregbook/rpng-x.c:static int rpng_x_create_window(void)
contrib/gregbook/rpng-x.c:    uch *xdata;
contrib/gregbook/rpng-x.c:    ulg bg_pixel = 0L;
contrib/gregbook/rpng-x.c:    XTextProperty windowName, *pWindowName = &windowName;
contrib/gregbook/rpng-x.c:    XTextProperty iconName, *pIconName = &iconName;
contrib/gregbook/rpng-x.c:        RShift = 15 - rpng_x_msb(RMask);    /* these are right-shifts */
contrib/gregbook/rpng-x.c:        GShift = 15 - rpng_x_msb(GMask);
contrib/gregbook/rpng-x.c:        BShift = 15 - rpng_x_msb(BMask);
contrib/gregbook/rpng-x.c:        RShift = rpng_x_msb(RMask) - 7;     /* these are left-shifts */
contrib/gregbook/rpng-x.c:        GShift = rpng_x_msb(GMask) - 7;
contrib/gregbook/rpng-x.c:        BShift = rpng_x_msb(BMask) - 7;
contrib/gregbook/rpng-x.c:        RShift = 7 - rpng_x_msb(RMask);     /* these are right-shifts, too */
contrib/gregbook/rpng-x.c:        GShift = 7 - rpng_x_msb(GMask);
contrib/gregbook/rpng-x.c:        BShift = 7 - rpng_x_msb(BMask);
contrib/gregbook/rpng-x.c:    attr.event_mask = ExposureMask | KeyPressMask | ButtonPressMask;
contrib/gregbook/rpng-x.c:        attr.background_pixel = 0;
contrib/gregbook/rpng-x.c:        attr.border_pixel = 1;
contrib/gregbook/rpng-x.c:        attrmask |= CWColormap | CWBackPixel | CWBorderPixel;
contrib/gregbook/rpng-x.c:    if (!XStringListToTextProperty(&window_name, 1, pWindowName))
contrib/gregbook/rpng-x.c:    if (!XStringListToTextProperty(&icon_name, 1, pIconName))
contrib/gregbook/rpng-x.c:        size_hints->flags = PMinSize | PMaxSize;
contrib/gregbook/rpng-x.c:        size_hints->min_width = size_hints->max_width = (int)image_width;
contrib/gregbook/rpng-x.c:        size_hints->min_height = size_hints->max_height = (int)image_height;
contrib/gregbook/rpng-x.c:     /* wm_hints->icon_pixmap = icon_pixmap; */
contrib/gregbook/rpng-x.c:        wm_hints->flags = StateHint | InputHint  /* | IconPixmapHint */ ;
contrib/gregbook/rpng-x.c:        bg_pixel = ((ulg)bg_red   << RShift) |
contrib/gregbook/rpng-x.c:        bg_pixel = ((((ulg)bg_red   << 8) >> RShift) & RMask) |
contrib/gregbook/rpng-x.c:    XSetForeground(display, gc, bg_pixel);
contrib/gregbook/rpng-x.c:    Wait for first Expose event to do any drawing, then flush.
contrib/gregbook/rpng-x.c:        XNextEvent(display, &e);
contrib/gregbook/rpng-x.c:    while (e.type != Expose || e.xexpose.count);
contrib/gregbook/rpng-x.c:        xdata = (uch *)malloc(4*image_width*image_height);
contrib/gregbook/rpng-x.c:        xdata = (uch *)malloc(2*image_width*image_height);
contrib/gregbook/rpng-x.c:        xdata = (uch *)malloc(image_width*image_height);
contrib/gregbook/rpng-x.c:    if (!xdata) {
contrib/gregbook/rpng-x.c:    ximage = XCreateImage(display, visual, depth, ZPixmap, 0,
contrib/gregbook/rpng-x.c:      (char *)xdata, image_width, image_height, pad, 0);
contrib/gregbook/rpng-x.c:    if (!ximage) {
contrib/gregbook/rpng-x.c:        free(xdata);
contrib/gregbook/rpng-x.c:    /* to avoid testing the byte order every pixel (or doubling the size of
contrib/gregbook/rpng-x.c:     * endian machines (like Linux/x86, old VAXen, etc.)--this is not the most
contrib/gregbook/rpng-x.c:    ximage->byte_order = MSBFirst;
contrib/gregbook/rpng-x.c:} /* end function rpng_x_create_window() */
contrib/gregbook/rpng-x.c:static int rpng_x_display_image(void)
contrib/gregbook/rpng-x.c:    ulg pixel;
contrib/gregbook/rpng-x.c:    int ximage_rowbytes = ximage->bytes_per_line;
contrib/gregbook/rpng-x.c:/*  int bpp = ximage->bits_per_pixel;  */
contrib/gregbook/rpng-x.c:    Trace((stderr, "   (width = %ld, rowbytes = %ld, ximage_rowbytes = %d)\n",
contrib/gregbook/rpng-x.c:      image_width, image_rowbytes, ximage_rowbytes))
contrib/gregbook/rpng-x.c:    Trace((stderr, "   (bpp = %d)\n", ximage->bits_per_pixel))
contrib/gregbook/rpng-x.c:    Trace((stderr, "   (byte_order = %s)\n", ximage->byte_order == MSBFirst?
contrib/gregbook/rpng-x.c:      "MSBFirst" : (ximage->byte_order == LSBFirst? "LSBFirst" : "unknown")))
contrib/gregbook/rpng-x.c:            dest = ximage->data + row*ximage_rowbytes;
contrib/gregbook/rpng-x.c:                    pixel = (red   << RShift) |
contrib/gregbook/rpng-x.c:                    /* recall that we set ximage->byte_order = MSBFirst above */
contrib/gregbook/rpng-x.c:                    *dest++ = (char)((pixel >> 24) & 0xff);
contrib/gregbook/rpng-x.c:                    *dest++ = (char)((pixel >> 16) & 0xff);
contrib/gregbook/rpng-x.c:                    *dest++ = (char)((pixel >>  8) & 0xff);
contrib/gregbook/rpng-x.c:                    *dest++ = (char)( pixel        & 0xff);
contrib/gregbook/rpng-x.c:                    pixel = (red & RMask) | (green & GMask) | (blue & BMask);
contrib/gregbook/rpng-x.c:                    /* recall that we set ximage->byte_order = MSBFirst above */
contrib/gregbook/rpng-x.c:                    *dest++ = (char)((pixel >> 24) & 0xff);
contrib/gregbook/rpng-x.c:                    *dest++ = (char)((pixel >> 16) & 0xff);
contrib/gregbook/rpng-x.c:                    *dest++ = (char)((pixel >>  8) & 0xff);
contrib/gregbook/rpng-x.c:                    *dest++ = (char)( pixel        & 0xff);
contrib/gregbook/rpng-x.c:                    pixel = (red   << RShift) |
contrib/gregbook/rpng-x.c:                    /* recall that we set ximage->byte_order = MSBFirst above */
contrib/gregbook/rpng-x.c:                    *dest++ = (char)((pixel >> 24) & 0xff);
contrib/gregbook/rpng-x.c:                    *dest++ = (char)((pixel >> 16) & 0xff);
contrib/gregbook/rpng-x.c:                    *dest++ = (char)((pixel >>  8) & 0xff);
contrib/gregbook/rpng-x.c:                    *dest++ = (char)( pixel        & 0xff);
contrib/gregbook/rpng-x.c:            if (((row+1) & 0xf) == 0) {
contrib/gregbook/rpng-x.c:                XPutImage(display, window, gc, ximage, 0, (int)lastrow, 0,
contrib/gregbook/rpng-x.c:            dest = ximage->data + row*ximage_rowbytes;
contrib/gregbook/rpng-x.c:                    pixel = ((red   >> RShift) & RMask) |
contrib/gregbook/rpng-x.c:                    /* recall that we set ximage->byte_order = MSBFirst above */
contrib/gregbook/rpng-x.c:                    *dest++ = (char)((pixel >>  8) & 0xff);
contrib/gregbook/rpng-x.c:                    *dest++ = (char)( pixel        & 0xff);
contrib/gregbook/rpng-x.c:                    pixel = ((red   >> RShift) & RMask) |
contrib/gregbook/rpng-x.c:                    /* recall that we set ximage->byte_order = MSBFirst above */
contrib/gregbook/rpng-x.c:                    *dest++ = (char)((pixel >>  8) & 0xff);
contrib/gregbook/rpng-x.c:                    *dest++ = (char)( pixel        & 0xff);
contrib/gregbook/rpng-x.c:            if (((row+1) & 0xf) == 0) {
contrib/gregbook/rpng-x.c:                XPutImage(display, window, gc, ximage, 0, (int)lastrow, 0,
contrib/gregbook/rpng-x.c:        XPutImage(display, window, gc, ximage, 0, (int)lastrow, 0,
contrib/gregbook/rpng-x.c:static void rpng_x_cleanup(void)
contrib/gregbook/rpng-x.c:    if (ximage) {
contrib/gregbook/rpng-x.c:        if (ximage->data) {
contrib/gregbook/rpng-x.c:            free(ximage->data);           /* we allocated it, so we free it */
contrib/gregbook/rpng-x.c:            ximage->data = (char *)NULL;  /*  instead of XDestroyImage() */
contrib/gregbook/rpng-x.c:        XDestroyImage(ximage);
contrib/gregbook/rpng-x.c:        ximage = NULL;
contrib/gregbook/rpng-x.c:static int rpng_x_msb(ulg u32val)
contrib/gregbook/rpng-x.c:        if (u32val & 0x80000000L)
contrib/gregbook/LICENSE:      express or implied.  In no event shall the author or contributors
Binary file contrib/gregbook/toucan.png matches
contrib/gregbook/readpng2.c:      express or implied.  In no event shall the author or contributors
contrib/gregbook/readpng2.c:#include <stdlib.h>     /* for exit() prototype */
contrib/gregbook/readpng2.c:     * (as in this program) or exit immediately, so here we are: */
contrib/gregbook/readpng2.c:     * used, i.e., all chunks recognized by libpng except for IHDR, PLTE, IDAT,
contrib/gregbook/readpng2.c:       /* Ignore all chunks except for IHDR, PLTE, tRNS, IDAT, and IEND */
contrib/gregbook/readpng2.c:    /* hand off the next chunk of input data to libpng for decoding */
contrib/gregbook/readpng2.c:    png_fixed_point gamma;
contrib/gregbook/readpng2.c:    /* setjmp() doesn't make sense here, because we'd either have to exit(),
contrib/gregbook/readpng2.c:     * decoding several PNG images at the same time, one needs to avoid mixing
contrib/gregbook/readpng2.c:    /* as before, let libpng expand palette images to RGB, low-bit-depth
contrib/gregbook/readpng2.c:        png_set_expand(png_ptr);
contrib/gregbook/readpng2.c:        png_set_expand(png_ptr);
contrib/gregbook/readpng2.c:        png_set_expand(png_ptr);
contrib/gregbook/readpng2.c:     * chunk) as existing in the sRGB color space.  That is, we assume that
contrib/gregbook/readpng2.c:     * the local platform.  Note that mainprog_ptr->display_exponent is the
contrib/gregbook/readpng2.c:     * LUT_exponent and CRT_exponent. */
contrib/gregbook/readpng2.c:        png_set_gamma(png_ptr, mainprog_ptr->display_exponent, gamma);
contrib/gregbook/readpng2.c:        png_set_gamma(png_ptr, mainprog_ptr->display_exponent, 0.45455);
contrib/gregbook/readpng2.c:    if (png_get_gAMA_fixed(png_ptr, info_ptr, &gamma))
contrib/gregbook/readpng2.c:        png_set_gamma_fixed(png_ptr,
contrib/gregbook/readpng2.c:            (png_fixed_point)(100000*mainprog_ptr->display_exponent+.5), gamma);
contrib/gregbook/readpng2.c:        png_set_gamma_fixed(png_ptr,
contrib/gregbook/readpng2.c:            (png_fixed_point)(100000*mainprog_ptr->display_exponent+.5), 45455);
contrib/gregbook/readpng2.c:    /* we'll let libpng expand interlaced images, too */
contrib/gregbook/readpng2.c:     * compilers that nevertheless barf on "fn_ptr()"-style syntax.) */
contrib/gregbook/readpng2.c:    /* have libpng either combine the new row data with the existing row data
contrib/gregbook/readpng2.c:    /* This function, aside from the extra step of retrieving the "error
contrib/gregbook/readpng2.c:     * pointer" (below) and the fact that it exists within the application
contrib/gregbook/readpng2.c:        exit(99);
contrib/gregbook/Makefile.sgi:# Sample makefile for rpng-x / rpng2-x / wpng for SGI using cc and make.
contrib/gregbook/Makefile.sgi:# Invoke this makefile from a shell prompt in the usual way; for example:
contrib/gregbook/Makefile.sgi:# This makefile builds dynamically linked executables (against libpng and zlib,
contrib/gregbook/Makefile.sgi:RPNG  = rpng-x
contrib/gregbook/Makefile.sgi:RPNG2 = rpng2-x
contrib/gregbook/COPYING:  For example, if you distribute copies of such a program, whether
contrib/gregbook/COPYING:you may at your option offer warranty protection in exchange for a fee.
contrib/gregbook/COPYING:    License.  (Exception: if the Program itself is interactive but
contrib/gregbook/COPYING:this License, whose permissions for other licensees extend to the
contrib/gregbook/COPYING:exercise the right to control the distribution of derivative or
contrib/gregbook/COPYING:under Section 2) in object code or executable form under the terms of
contrib/gregbook/COPYING:    received the program in object code or executable form with such
contrib/gregbook/COPYING:making modifications to it.  For an executable work, complete source
contrib/gregbook/COPYING:control compilation and installation of the executable.  However, as a
contrib/gregbook/COPYING:special exception, the source code distributed need not include
contrib/gregbook/COPYING:operating system on which the executable runs, unless that component
contrib/gregbook/COPYING:itself accompanies the executable.
contrib/gregbook/COPYING:If distribution of executable or object code is made by offering
contrib/gregbook/COPYING:except as expressly provided under this License.  Any attempt
contrib/gregbook/COPYING:restrictions on the recipients' exercise of the rights granted herein.
contrib/gregbook/COPYING:excuse you from the conditions of this License.  If you cannot
contrib/gregbook/COPYING:may not distribute the Program at all.  For example, if a patent
contrib/gregbook/COPYING:may add an explicit geographical distribution limitation excluding
contrib/gregbook/COPYING:countries not thus excluded.  In such case, this License incorporates
contrib/gregbook/COPYING:make exceptions for this.  Our decision will be guided by the two goals
contrib/gregbook/COPYING:convey the exclusion of warranty; and each file should have at least
contrib/gregbook/Makefile.mingw32:# builds both statically and dynamically linked executables by default.
contrib/gregbook/Makefile.mingw32:#PNGDIR = ../..#		for libpng-x.y.z/contrib/gregbook builds
contrib/gregbook/Makefile.mingw32:#ZDIR = ../../../zlib-win32#	for libpng-x.y.z/contrib/gregbook builds
contrib/gregbook/Makefile.mingw32:#CC = i386-mingw32msvc-gcc #	e.g., Linux -> Win32 cross-compilation
contrib/gregbook/Makefile.mingw32:E = .exe
contrib/gregbook/writepng.h:      express or implied.  In no event shall the author or contributors
contrib/gregbook/writepng.h:#  define Trace(x)  {fprintf x ; fflush(stderr); fflush(stdout);}
contrib/gregbook/writepng.h:#  define Trace(x)  ;
contrib/gregbook/writepng.h:#define TEXT_TITLE    0x01
contrib/gregbook/writepng.h:#define TEXT_AUTHOR   0x02
contrib/gregbook/writepng.h:#define TEXT_DESC     0x04
contrib/gregbook/writepng.h:#define TEXT_COPY     0x08
contrib/gregbook/writepng.h:#define TEXT_EMAIL    0x10
contrib/gregbook/writepng.h:#define TEXT_URL      0x20
contrib/gregbook/writepng.h:    int have_text;
contrib/gregbook/Makefile.unx:# Sample makefile for rpng-x / rpng2-x / wpng using gcc and make.
contrib/gregbook/Makefile.unx:# Invoke this makefile from a shell prompt in the usual way; for example:
contrib/gregbook/Makefile.unx:#	make -f Makefile.unx
contrib/gregbook/Makefile.unx:# This makefile builds both dynamically and statically linked executables
contrib/gregbook/Makefile.unx:PNGDIR = ../..#	this one is for libpng-x.y.z/contrib/gregbook builds
contrib/gregbook/Makefile.unx:#CFLAGS = -O -W -Wall -Wextra -pedantic -ansi
contrib/gregbook/Makefile.unx:# [-ansi, -pedantic, -Wextra, and -W can also be used]
contrib/gregbook/Makefile.unx:RPNG   = rpng-x
contrib/gregbook/Makefile.unx:RPNG2  = rpng2-x
contrib/gregbook/rpng2-x.c:   rpng2 - progressive-model PNG display program                  rpng2-x.c
contrib/gregbook/rpng2-x.c:   for the X Window System (tested by the author under Unix and by Martin
contrib/gregbook/rpng2-x.c:    - fix expose/redraw code:  don't draw entire row if only part exposed
contrib/gregbook/rpng2-x.c:    - 1.02:  modified to allow abbreviated options; fixed char/uchar mismatch
contrib/gregbook/rpng2-x.c:    - 1.10:  added support for non-default visuals; fixed X pixel-conversion
contrib/gregbook/rpng2-x.c:    - 1.11:  added -usleep option for demos; fixed command-line parsing bug
contrib/gregbook/rpng2-x.c:    - 1.20:  added runtime MMX-enabling/disabling and new -mmx* options
contrib/gregbook/rpng2-x.c:    - 1.21:  fixed some small X memory leaks (thanks to Franois Petitjean)
contrib/gregbook/rpng2-x.c:    - 1.22:  fixed XFreeGC() crash bug (thanks to Patrick Welche)
contrib/gregbook/rpng2-x.c:    - 1.23:  added -bgpat 0 mode (std white/gray checkerboard, 8x8 squares)
contrib/gregbook/rpng2-x.c:    - 1.30:  added -loop option for -bgpat (ifdef FEATURE_LOOP); fixed bpp =
contrib/gregbook/rpng2-x.c:    - 1.32:  added AMD64/EM64T support (__x86_64__); added basic expose/redraw
contrib/gregbook/rpng2-x.c:    - 2.01:  fixed 64-bit typo in readpng2.c; fixed -pause usage description
contrib/gregbook/rpng2-x.c:    - 2.02:  fixed improper display of usage screen on PNG error(s); fixed
contrib/gregbook/rpng2-x.c:              unexpected-EOF and file-read-error cases; fixed Trace() cut-and-
contrib/gregbook/rpng2-x.c:    - 2.03:  deleted runtime MMX-enabling/disabling and obsolete -mmx* options
contrib/gregbook/rpng2-x.c:      express or implied.  In no event shall the author or contributors
contrib/gregbook/rpng2-x.c:#define PROGNAME  "rpng2-x"
contrib/gregbook/rpng2-x.c:#  define usleep(x) sleep(((x)+499999)/1000000)
contrib/gregbook/rpng2-x.c:#define CLIP(a,min,max)  MAX(min,MIN((a),max))
contrib/gregbook/rpng2-x.c:#define QUIT(e,k) ((e.type == ButtonPress && e.xbutton.button == Button1) ||  \
contrib/gregbook/rpng2-x.c:                  ((k = XLookupKeysym(&e.xkey, 0)) == XK_q || k == XK_Escape)))
contrib/gregbook/rpng2-x.c:#define rgb1_max   bg_freq
contrib/gregbook/rpng2-x.c:#define rgb2_max   bg_bsat
contrib/gregbook/rpng2-x.c:                          *  speed 10% faster than theoretical 33.6K maximum
contrib/gregbook/rpng2-x.c:static void rpng2_x_init (void);
contrib/gregbook/rpng2-x.c:static int  rpng2_x_create_window (void);
contrib/gregbook/rpng2-x.c:static int  rpng2_x_load_bg_image (void);
contrib/gregbook/rpng2-x.c:static void rpng2_x_display_row (ulg row);
contrib/gregbook/rpng2-x.c:static void rpng2_x_finish_display (void);
contrib/gregbook/rpng2-x.c:static void rpng2_x_redisplay_image (ulg startcol, ulg startrow,
contrib/gregbook/rpng2-x.c:static void rpng2_x_reload_bg_image (void);
contrib/gregbook/rpng2-x.c:static void rpng2_x_cleanup (void);
contrib/gregbook/rpng2-x.c:static int  rpng2_x_msb (ulg u32val);
contrib/gregbook/rpng2-x.c:    struct...but a few macros and a little fixed-point math will do
contrib/gregbook/rpng2-x.c:    int rgb1_max, rgb1_min;     /* or bg_freq, bg_gray */
contrib/gregbook/rpng2-x.c:    int rgb2_max, rgb2_min;     /* or bg_bsat, bg_brot (both scaled by 10)*/
contrib/gregbook/rpng2-x.c:static XImage *ximage;
contrib/gregbook/rpng2-x.c:    long loop_interval = -1;            /* seconds (100,000 max) */
contrib/gregbook/rpng2-x.c:    double LUT_exponent;                /* just the lookup table */
contrib/gregbook/rpng2-x.c:    double CRT_exponent = 2.2;          /* just the monitor */
contrib/gregbook/rpng2-x.c:    double default_display_exponent;    /* whole display system */
contrib/gregbook/rpng2-x.c:    /* Set the default value for our display-system exponent, i.e., the
contrib/gregbook/rpng2-x.c:     * product of the CRT exponent and the exponent corresponding to
contrib/gregbook/rpng2-x.c:     * exhaustive list of LUT values (e.g., OpenStep has a lot of weird
contrib/gregbook/rpng2-x.c:    /* third-party utilities can modify the default LUT exponent */
contrib/gregbook/rpng2-x.c:    LUT_exponent = 1.0 / 2.2;
contrib/gregbook/rpng2-x.c:    if (some_next_function_that_returns_gamma(&next_gamma))
contrib/gregbook/rpng2-x.c:        LUT_exponent = 1.0 / next_gamma;
contrib/gregbook/rpng2-x.c:    LUT_exponent = 1.0 / 1.7;
contrib/gregbook/rpng2-x.c:            LUT_exponent = 1.0 / sgi_gamma;
contrib/gregbook/rpng2-x.c:    LUT_exponent = 1.8 / 2.61;
contrib/gregbook/rpng2-x.c:        LUT_exponent = mac_gamma / 2.61;
contrib/gregbook/rpng2-x.c:    LUT_exponent = 1.0;   /* assume no LUT:  most PCs */
contrib/gregbook/rpng2-x.c:    default_display_exponent = LUT_exponent * CRT_exponent;
contrib/gregbook/rpng2-x.c:        rpng2_info.display_exponent = atof(p);
contrib/gregbook/rpng2-x.c:        rpng2_info.display_exponent = default_display_exponent;
contrib/gregbook/rpng2-x.c:                rpng2_info.display_exponent = atof(*argv);
contrib/gregbook/rpng2-x.c:                if (rpng2_info.display_exponent <= 0.0)
contrib/gregbook/rpng2-x.c:                ++error;   /* not expecting any other options */
contrib/gregbook/rpng2-x.c:          "%s [-display xdpy] [-gamma exp] [-bgcolor bg | -bgpat pat]\n"
contrib/gregbook/rpng2-x.c:          "    xdpy\tname of the target X display (e.g., ``hostname:0'')\n"
contrib/gregbook/rpng2-x.c:          "    exp \ttransfer-function exponent (``gamma'') of the display\n"
contrib/gregbook/rpng2-x.c:          "\t\t  to the product of the lookup-table exponent (varies)\n",
contrib/gregbook/rpng2-x.c:          default_display_exponent);
contrib/gregbook/rpng2-x.c:          "\t\t  and the CRT exponent (usually 2.2); must be positive\n"
contrib/gregbook/rpng2-x.c:          "    bg  \tdesired background color in 7-character hex RGB format\n"
contrib/gregbook/rpng2-x.c:        exit(1);
contrib/gregbook/rpng2-x.c:        exit(2);
contrib/gregbook/rpng2-x.c:        sscanf(bgstr+1, "%2x%2x%2x", &r, &g, &b);
contrib/gregbook/rpng2-x.c:    rpng2_info.mainprog_init = rpng2_x_init;
contrib/gregbook/rpng2-x.c:    rpng2_info.mainprog_display_row = rpng2_x_display_row;
contrib/gregbook/rpng2-x.c:    rpng2_info.mainprog_finish_display = rpng2_x_finish_display;
contrib/gregbook/rpng2-x.c:                exit(3);
contrib/gregbook/rpng2-x.c:                  "(unexpectedly) while reading PNG image file\n");
contrib/gregbook/rpng2-x.c:                exit(3);
contrib/gregbook/rpng2-x.c:        exit(3);
contrib/gregbook/rpng2-x.c:            /* GRR BUG:  should also check for Expose events and redraw... */
contrib/gregbook/rpng2-x.c:            /* generate next background image */
contrib/gregbook/rpng2-x.c:            rpng2_x_reload_bg_image();
contrib/gregbook/rpng2-x.c:                    /* GRR BUG:  also need to check for Expose (and redraw!) */
contrib/gregbook/rpng2-x.c:                            /* GRR BUG:  need to check for Expose and redraw */
contrib/gregbook/rpng2-x.c:            rpng2_x_redisplay_image (0, 0, rpng2_info.width, rpng2_info.height);
contrib/gregbook/rpng2-x.c:            XNextEvent(display, &e);
contrib/gregbook/rpng2-x.c:            if (e.type == Expose) {
contrib/gregbook/rpng2-x.c:                XExposeEvent *ex = (XExposeEvent *)&e;
contrib/gregbook/rpng2-x.c:                rpng2_x_redisplay_image (ex->x, ex->y, ex->width, ex->height);
contrib/gregbook/rpng2-x.c:        exit(4);
contrib/gregbook/rpng2-x.c:    Trace((stderr, "about to call rpng2_x_cleanup()\n"))
contrib/gregbook/rpng2-x.c:    rpng2_x_cleanup();
contrib/gregbook/rpng2-x.c:static void rpng2_x_init(void)
contrib/gregbook/rpng2-x.c:    Trace((stderr, "beginning rpng2_x_init()\n"))
contrib/gregbook/rpng2-x.c:    if (rpng2_x_create_window()) {
contrib/gregbook/rpng2-x.c:        rpng2_x_cleanup();
contrib/gregbook/rpng2-x.c:        exit(2);
contrib/gregbook/rpng2-x.c:static int rpng2_x_create_window(void)
contrib/gregbook/rpng2-x.c:    ulg bg_pixel = 0L;
contrib/gregbook/rpng2-x.c:    uch *xdata;
contrib/gregbook/rpng2-x.c:    XTextProperty windowName, *pWindowName = &windowName;
contrib/gregbook/rpng2-x.c:    XTextProperty iconName, *pIconName = &iconName;
contrib/gregbook/rpng2-x.c:    Trace((stderr, "beginning rpng2_x_create_window()\n"))
contrib/gregbook/rpng2-x.c:        RShift = 15 - rpng2_x_msb(RMask);    /* these are right-shifts */
contrib/gregbook/rpng2-x.c:        GShift = 15 - rpng2_x_msb(GMask);
contrib/gregbook/rpng2-x.c:        BShift = 15 - rpng2_x_msb(BMask);
contrib/gregbook/rpng2-x.c:        RShift = rpng2_x_msb(RMask) - 7;     /* these are left-shifts */
contrib/gregbook/rpng2-x.c:        GShift = rpng2_x_msb(GMask) - 7;
contrib/gregbook/rpng2-x.c:        BShift = rpng2_x_msb(BMask) - 7;
contrib/gregbook/rpng2-x.c:    attr.event_mask = ExposureMask | KeyPressMask | ButtonPressMask;
contrib/gregbook/rpng2-x.c:        attr.background_pixel = 0;
contrib/gregbook/rpng2-x.c:        attr.border_pixel = 1;
contrib/gregbook/rpng2-x.c:        attrmask |= CWColormap | CWBackPixel | CWBorderPixel;
contrib/gregbook/rpng2-x.c:    if (!XStringListToTextProperty(&window_name, 1, pWindowName))
contrib/gregbook/rpng2-x.c:    if (!XStringListToTextProperty(&icon_name, 1, pIconName))
contrib/gregbook/rpng2-x.c:        size_hints->flags = PMinSize | PMaxSize;
contrib/gregbook/rpng2-x.c:        size_hints->min_width = size_hints->max_width = (int)rpng2_info.width;
contrib/gregbook/rpng2-x.c:        size_hints->min_height = size_hints->max_height =
contrib/gregbook/rpng2-x.c:     /* wm_hints->icon_pixmap = icon_pixmap; */
contrib/gregbook/rpng2-x.c:        wm_hints->flags = StateHint | InputHint  /* | IconPixmapHint */ ;
contrib/gregbook/rpng2-x.c:        xdata = (uch *)malloc(4*rpng2_info.width*rpng2_info.height);
contrib/gregbook/rpng2-x.c:        xdata = (uch *)malloc(2*rpng2_info.width*rpng2_info.height);
contrib/gregbook/rpng2-x.c:        xdata = (uch *)malloc(rpng2_info.width*rpng2_info.height);
contrib/gregbook/rpng2-x.c:    if (!xdata) {
contrib/gregbook/rpng2-x.c:    ximage = XCreateImage(display, visual, depth, ZPixmap, 0,
contrib/gregbook/rpng2-x.c:      (char *)xdata, rpng2_info.width, rpng2_info.height, pad, 0);
contrib/gregbook/rpng2-x.c:    if (!ximage) {
contrib/gregbook/rpng2-x.c:        free(xdata);
contrib/gregbook/rpng2-x.c:    /* to avoid testing the byte order every pixel (or doubling the size of
contrib/gregbook/rpng2-x.c:     * endian machines (e.g., Linux/x86, old VAXen, etc.)--this is not the
contrib/gregbook/rpng2-x.c:    ximage->byte_order = MSBFirst;
contrib/gregbook/rpng2-x.c:        rpng2_x_load_bg_image();    /* resets bg_image if fails */
contrib/gregbook/rpng2-x.c:            bg_pixel = (bg_red   << RShift) |
contrib/gregbook/rpng2-x.c:            bg_pixel = (((bg_red   << 8) >> RShift) & RMask) |
contrib/gregbook/rpng2-x.c:        XSetForeground(display, gc, bg_pixel);
contrib/gregbook/rpng2-x.c:    Wait for first Expose event to do any drawing, then flush and return.
contrib/gregbook/rpng2-x.c:        XNextEvent(display, &e);
contrib/gregbook/rpng2-x.c:    while (e.type != Expose || e.xexpose.count);
contrib/gregbook/rpng2-x.c:} /* end function rpng2_x_create_window() */
contrib/gregbook/rpng2-x.c:static int rpng2_x_load_bg_image(void)
contrib/gregbook/rpng2-x.c:    int k, hmax, max;
contrib/gregbook/rpng2-x.c:    int xidx, yidx, yidx_max;
contrib/gregbook/rpng2-x.c:    int invert_gradient2 = (bg[pat].type & 0x08);
contrib/gregbook/rpng2-x.c:    int ximage_rowbytes = ximage->bytes_per_line;
contrib/gregbook/rpng2-x.c:    ulg pixel;
contrib/gregbook/rpng2-x.c:    yidx_max = bgscale - 1;
contrib/gregbook/rpng2-x.c:    Vertical gradients (ramps) in NxN squares, alternating direction and
contrib/gregbook/rpng2-x.c:    if ((bg[pat].type & 0x07) == 0) {
contrib/gregbook/rpng2-x.c:        int r1_diff = rgb[bg[pat].rgb1_max].r - r1_min;
contrib/gregbook/rpng2-x.c:        int g1_diff = rgb[bg[pat].rgb1_max].g - g1_min;
contrib/gregbook/rpng2-x.c:        int b1_diff = rgb[bg[pat].rgb1_max].b - b1_min;
contrib/gregbook/rpng2-x.c:        int r2_diff = rgb[bg[pat].rgb2_max].r - r2_min;
contrib/gregbook/rpng2-x.c:        int g2_diff = rgb[bg[pat].rgb2_max].g - g2_min;
contrib/gregbook/rpng2-x.c:        int b2_diff = rgb[bg[pat].rgb2_max].b - b2_min;
contrib/gregbook/rpng2-x.c:            yidx = (int)(row % bgscale);
contrib/gregbook/rpng2-x.c:            r1 = r1_min + (r1_diff * yidx) / yidx_max;
contrib/gregbook/rpng2-x.c:            g1 = g1_min + (g1_diff * yidx) / yidx_max;
contrib/gregbook/rpng2-x.c:            b1 = b1_min + (b1_diff * yidx) / yidx_max;
contrib/gregbook/rpng2-x.c:            r1_inv = r1_min + (r1_diff * (yidx_max-yidx)) / yidx_max;
contrib/gregbook/rpng2-x.c:            g1_inv = g1_min + (g1_diff * (yidx_max-yidx)) / yidx_max;
contrib/gregbook/rpng2-x.c:            b1_inv = b1_min + (b1_diff * (yidx_max-yidx)) / yidx_max;
contrib/gregbook/rpng2-x.c:            r2 = r2_min + (r2_diff * yidx) / yidx_max;
contrib/gregbook/rpng2-x.c:            g2 = g2_min + (g2_diff * yidx) / yidx_max;
contrib/gregbook/rpng2-x.c:            b2 = b2_min + (b2_diff * yidx) / yidx_max;
contrib/gregbook/rpng2-x.c:            r2_inv = r2_min + (r2_diff * (yidx_max-yidx)) / yidx_max;
contrib/gregbook/rpng2-x.c:            g2_inv = g2_min + (g2_diff * (yidx_max-yidx)) / yidx_max;
contrib/gregbook/rpng2-x.c:            b2_inv = b2_min + (b2_diff * (yidx_max-yidx)) / yidx_max;
contrib/gregbook/rpng2-x.c:                  (even_odd_horiz && (bg[pat].type & 0x10));
contrib/gregbook/rpng2-x.c:    } else if ((bg[pat].type & 0x07) == 1) {
contrib/gregbook/rpng2-x.c:        hmax = (bgscale-1)/2;   /* half the max weight of a color */
contrib/gregbook/rpng2-x.c:        max = 2*hmax;           /* the max weight of a color */
contrib/gregbook/rpng2-x.c:        r1 = rgb[bg[pat].rgb1_max].r;
contrib/gregbook/rpng2-x.c:        g1 = rgb[bg[pat].rgb1_max].g;
contrib/gregbook/rpng2-x.c:        b1 = rgb[bg[pat].rgb1_max].b;
contrib/gregbook/rpng2-x.c:        r2 = rgb[bg[pat].rgb2_max].r;
contrib/gregbook/rpng2-x.c:        g2 = rgb[bg[pat].rgb2_max].g;
contrib/gregbook/rpng2-x.c:        b2 = rgb[bg[pat].rgb2_max].b;
contrib/gregbook/rpng2-x.c:            yidx = (int)(row % bgscale);
contrib/gregbook/rpng2-x.c:            if (yidx > hmax)
contrib/gregbook/rpng2-x.c:                yidx = bgscale-1 - yidx;
contrib/gregbook/rpng2-x.c:                xidx = (int)(i % bgscale);
contrib/gregbook/rpng2-x.c:                if (xidx > hmax)
contrib/gregbook/rpng2-x.c:                    xidx = bgscale-1 - xidx;
contrib/gregbook/rpng2-x.c:                k = xidx + yidx;
contrib/gregbook/rpng2-x.c:                *dest++ = (k*r1 + (max-k)*r2) / max;
contrib/gregbook/rpng2-x.c:                *dest++ = (k*g1 + (max-k)*g2) / max;
contrib/gregbook/rpng2-x.c:                *dest++ = (k*b1 + (max-k)*b2) / max;
contrib/gregbook/rpng2-x.c:    } else if ((bg[pat].type & 0x07) == 2) {
contrib/gregbook/rpng2-x.c:        int ii, x, y, hw, hh, grayspot;
contrib/gregbook/rpng2-x.c:        double angle=0.0, aoffset=0.0, maxDist, dist;
contrib/gregbook/rpng2-x.c:        maxDist = (double)((hw*hw) + (hh*hh));
contrib/gregbook/rpng2-x.c:                x = (int)(i - hw);
contrib/gregbook/rpng2-x.c:                angle = (x == 0)? PI_2 : atan((double)y / (double)x);
contrib/gregbook/rpng2-x.c:                gray = (double)MAX(ABS(y), ABS(x)) / grayspot;
contrib/gregbook/rpng2-x.c:                dist = (double)((x*x) + (y*y)) / maxDist;
contrib/gregbook/rpng2-x.c:                s = gray * ((double)(ABS(x)+ABS(y)) / (double)(hw + hh));
contrib/gregbook/rpng2-x.c:        int bpp = ximage->bits_per_pixel;
contrib/gregbook/rpng2-x.c:            dest = ximage->data + row*ximage_rowbytes;
contrib/gregbook/rpng2-x.c:                    pixel = (red   << RShift) |
contrib/gregbook/rpng2-x.c:                    /* recall that we set ximage->byte_order = MSBFirst above */
contrib/gregbook/rpng2-x.c:                    *dest++ = (char)((pixel >> 24) & 0xff);
contrib/gregbook/rpng2-x.c:                    *dest++ = (char)((pixel >> 16) & 0xff);
contrib/gregbook/rpng2-x.c:                    *dest++ = (char)((pixel >>  8) & 0xff);
contrib/gregbook/rpng2-x.c:                    *dest++ = (char)( pixel        & 0xff);
contrib/gregbook/rpng2-x.c:                    pixel = (red   << RShift) |
contrib/gregbook/rpng2-x.c:                    /* recall that we set ximage->byte_order = MSBFirst above */
contrib/gregbook/rpng2-x.c:                    *dest++ = (char)((pixel >> 16) & 0xff);
contrib/gregbook/rpng2-x.c:                    *dest++ = (char)((pixel >>  8) & 0xff);
contrib/gregbook/rpng2-x.c:                    *dest++ = (char)( pixel        & 0xff);
contrib/gregbook/rpng2-x.c:            dest = ximage->data + row*ximage_rowbytes;
contrib/gregbook/rpng2-x.c:                pixel = ((red   >> RShift) & RMask) |
contrib/gregbook/rpng2-x.c:                /* recall that we set ximage->byte_order = MSBFirst above */
contrib/gregbook/rpng2-x.c:                *dest++ = (char)((pixel >>  8) & 0xff);
contrib/gregbook/rpng2-x.c:                *dest++ = (char)( pixel        & 0xff);
contrib/gregbook/rpng2-x.c:    XPutImage(display, window, gc, ximage, 0, 0, 0, 0, rpng2_info.width,
contrib/gregbook/rpng2-x.c:} /* end function rpng2_x_load_bg_image() */
contrib/gregbook/rpng2-x.c:static void rpng2_x_display_row(ulg row)
contrib/gregbook/rpng2-x.c:    int ximage_rowbytes = ximage->bytes_per_line;
contrib/gregbook/rpng2-x.c:    ulg i, pixel;
contrib/gregbook/rpng2-x.c:    Trace((stderr, "beginning rpng2_x_display_row()\n"))
contrib/gregbook/rpng2-x.c:                XNextEvent(display, &e);
contrib/gregbook/rpng2-x.c:    tests, this routine is identical to rpng_x_display_image() in the non-
contrib/gregbook/rpng2-x.c:        int bpp = ximage->bits_per_pixel;
contrib/gregbook/rpng2-x.c:        dest = ximage->data + row*ximage_rowbytes;
contrib/gregbook/rpng2-x.c:                pixel = (red   << RShift) |
contrib/gregbook/rpng2-x.c:                /* recall that we set ximage->byte_order = MSBFirst above */
contrib/gregbook/rpng2-x.c:                    *dest++ = (char)((pixel >> 24) & 0xff);
contrib/gregbook/rpng2-x.c:                    *dest++ = (char)((pixel >> 16) & 0xff);
contrib/gregbook/rpng2-x.c:                    *dest++ = (char)((pixel >>  8) & 0xff);
contrib/gregbook/rpng2-x.c:                    *dest++ = (char)( pixel        & 0xff);
contrib/gregbook/rpng2-x.c:                    *dest++ = (char)((pixel >> 16) & 0xff);
contrib/gregbook/rpng2-x.c:                    *dest++ = (char)((pixel >>  8) & 0xff);
contrib/gregbook/rpng2-x.c:                    *dest++ = (char)( pixel        & 0xff);
contrib/gregbook/rpng2-x.c:                pixel = (red   << RShift) |
contrib/gregbook/rpng2-x.c:                /* recall that we set ximage->byte_order = MSBFirst above */
contrib/gregbook/rpng2-x.c:                    *dest++ = (char)((pixel >> 24) & 0xff);
contrib/gregbook/rpng2-x.c:                    *dest++ = (char)((pixel >> 16) & 0xff);
contrib/gregbook/rpng2-x.c:                    *dest++ = (char)((pixel >>  8) & 0xff);
contrib/gregbook/rpng2-x.c:                    *dest++ = (char)( pixel        & 0xff);
contrib/gregbook/rpng2-x.c:                    *dest++ = (char)((pixel >> 16) & 0xff);
contrib/gregbook/rpng2-x.c:                    *dest++ = (char)((pixel >>  8) & 0xff);
contrib/gregbook/rpng2-x.c:                    *dest++ = (char)( pixel        & 0xff);
contrib/gregbook/rpng2-x.c:        dest = ximage->data + row*ximage_rowbytes;
contrib/gregbook/rpng2-x.c:                pixel = ((red   >> RShift) & RMask) |
contrib/gregbook/rpng2-x.c:                /* recall that we set ximage->byte_order = MSBFirst above */
contrib/gregbook/rpng2-x.c:                *dest++ = (char)((pixel >>  8) & 0xff);
contrib/gregbook/rpng2-x.c:                *dest++ = (char)( pixel        & 0xff);
contrib/gregbook/rpng2-x.c:                pixel = ((red   >> RShift) & RMask) |
contrib/gregbook/rpng2-x.c:                /* recall that we set ximage->byte_order = MSBFirst above */
contrib/gregbook/rpng2-x.c:                *dest++ = (char)((pixel >>  8) & 0xff);
contrib/gregbook/rpng2-x.c:                *dest++ = (char)( pixel        & 0xff);
contrib/gregbook/rpng2-x.c:        XPutImage(display, window, gc, ximage, 0, (int)firstrow, 0,
contrib/gregbook/rpng2-x.c:    if (!demo_timing && ((rows & 0xf) == 0 || row >= rpng2_info.height-2)) {
contrib/gregbook/rpng2-x.c:        XPutImage(display, window, gc, ximage, 0, (int)firstrow, 0,
contrib/gregbook/rpng2-x.c:static void rpng2_x_finish_display(void)
contrib/gregbook/rpng2-x.c:    Trace((stderr, "beginning rpng2_x_finish_display()\n"))
contrib/gregbook/rpng2-x.c:    /* last row has already been displayed by rpng2_x_display_row(), so we
contrib/gregbook/rpng2-x.c:     * have nothing to do here except set a flag and let the user know that
contrib/gregbook/rpng2-x.c:static void rpng2_x_redisplay_image(ulg startcol, ulg startrow,
contrib/gregbook/rpng2-x.c:    ulg pixel;
contrib/gregbook/rpng2-x.c:    int ximage_rowbytes = ximage->bytes_per_line;
contrib/gregbook/rpng2-x.c:    Trace((stderr, "   (width = %ld, rowbytes = %d, ximage_rowbytes = %d)\n",
contrib/gregbook/rpng2-x.c:      rpng2_info.width, rpng2_info.rowbytes, ximage_rowbytes))
contrib/gregbook/rpng2-x.c:    Trace((stderr, "   (bpp = %d)\n", ximage->bits_per_pixel))
contrib/gregbook/rpng2-x.c:    Trace((stderr, "   (byte_order = %s)\n", ximage->byte_order == MSBFirst?
contrib/gregbook/rpng2-x.c:      "MSBFirst" : (ximage->byte_order == LSBFirst? "LSBFirst" : "unknown")))
contrib/gregbook/rpng2-x.c:    image), this routine is identical to rpng_x_display_image() in the non-
contrib/gregbook/rpng2-x.c:        int bpp = ximage->bits_per_pixel;
contrib/gregbook/rpng2-x.c:            dest = ximage->data + row*ximage_rowbytes;
contrib/gregbook/rpng2-x.c:                    pixel = (red   << RShift) |
contrib/gregbook/rpng2-x.c:                    /* recall that we set ximage->byte_order = MSBFirst above */
contrib/gregbook/rpng2-x.c:                        *dest++ = (char)((pixel >> 24) & 0xff);
contrib/gregbook/rpng2-x.c:                        *dest++ = (char)((pixel >> 16) & 0xff);
contrib/gregbook/rpng2-x.c:                        *dest++ = (char)((pixel >>  8) & 0xff);
contrib/gregbook/rpng2-x.c:                        *dest++ = (char)( pixel        & 0xff);
contrib/gregbook/rpng2-x.c:                        *dest++ = (char)((pixel >> 16) & 0xff);
contrib/gregbook/rpng2-x.c:                        *dest++ = (char)((pixel >>  8) & 0xff);
contrib/gregbook/rpng2-x.c:                        *dest++ = (char)( pixel        & 0xff);
contrib/gregbook/rpng2-x.c:                    pixel = (red & RMask) | (green & GMask) | (blue & BMask);
contrib/gregbook/rpng2-x.c:                    /* recall that we set ximage->byte_order = MSBFirst above */
contrib/gregbook/rpng2-x.c:                        *dest++ = (char)((pixel >> 24) & 0xff);
contrib/gregbook/rpng2-x.c:                        *dest++ = (char)((pixel >> 16) & 0xff);
contrib/gregbook/rpng2-x.c:                        *dest++ = (char)((pixel >>  8) & 0xff);
contrib/gregbook/rpng2-x.c:                        *dest++ = (char)( pixel        & 0xff);
contrib/gregbook/rpng2-x.c:                        *dest++ = (char)((pixel >> 16) & 0xff);
contrib/gregbook/rpng2-x.c:                        *dest++ = (char)((pixel >>  8) & 0xff);
contrib/gregbook/rpng2-x.c:                        *dest++ = (char)( pixel        & 0xff);
contrib/gregbook/rpng2-x.c:                    pixel = (red   << RShift) |
contrib/gregbook/rpng2-x.c:                    /* recall that we set ximage->byte_order = MSBFirst above */
contrib/gregbook/rpng2-x.c:                        *dest++ = (char)((pixel >> 24) & 0xff);
contrib/gregbook/rpng2-x.c:                        *dest++ = (char)((pixel >> 16) & 0xff);
contrib/gregbook/rpng2-x.c:                        *dest++ = (char)((pixel >>  8) & 0xff);
contrib/gregbook/rpng2-x.c:                        *dest++ = (char)( pixel        & 0xff);
contrib/gregbook/rpng2-x.c:                        *dest++ = (char)((pixel >> 16) & 0xff);
contrib/gregbook/rpng2-x.c:                        *dest++ = (char)((pixel >>  8) & 0xff);
contrib/gregbook/rpng2-x.c:                        *dest++ = (char)( pixel        & 0xff);
contrib/gregbook/rpng2-x.c:                    pixel = (red & RMask) | (green & GMask) | (blue & BMask);
contrib/gregbook/rpng2-x.c:                    /* recall that we set ximage->byte_order = MSBFirst above */
contrib/gregbook/rpng2-x.c:                        *dest++ = (char)((pixel >> 24) & 0xff);
contrib/gregbook/rpng2-x.c:                        *dest++ = (char)((pixel >> 16) & 0xff);
contrib/gregbook/rpng2-x.c:                        *dest++ = (char)((pixel >>  8) & 0xff);
contrib/gregbook/rpng2-x.c:                        *dest++ = (char)( pixel        & 0xff);
contrib/gregbook/rpng2-x.c:                        *dest++ = (char)((pixel >> 16) & 0xff);
contrib/gregbook/rpng2-x.c:                        *dest++ = (char)((pixel >>  8) & 0xff);
contrib/gregbook/rpng2-x.c:                        *dest++ = (char)( pixel        & 0xff);
contrib/gregbook/rpng2-x.c:            if (((row+1) & 0xf) == 0) {
contrib/gregbook/rpng2-x.c:                XPutImage(display, window, gc, ximage, 0, (int)lastrow, 0,
contrib/gregbook/rpng2-x.c:            dest = ximage->data + row*ximage_rowbytes;
contrib/gregbook/rpng2-x.c:                    pixel = ((red   >> RShift) & RMask) |
contrib/gregbook/rpng2-x.c:                    /* recall that we set ximage->byte_order = MSBFirst above */
contrib/gregbook/rpng2-x.c:                    *dest++ = (char)((pixel >>  8) & 0xff);
contrib/gregbook/rpng2-x.c:                    *dest++ = (char)( pixel        & 0xff);
contrib/gregbook/rpng2-x.c:                    pixel = ((red   >> RShift) & RMask) |
contrib/gregbook/rpng2-x.c:                    /* recall that we set ximage->byte_order = MSBFirst above */
contrib/gregbook/rpng2-x.c:                    *dest++ = (char)((pixel >>  8) & 0xff);
contrib/gregbook/rpng2-x.c:                    *dest++ = (char)( pixel        & 0xff);
contrib/gregbook/rpng2-x.c:            if (((row+1) & 0xf) == 0) {
contrib/gregbook/rpng2-x.c:                XPutImage(display, window, gc, ximage, 0, (int)lastrow, 0,
contrib/gregbook/rpng2-x.c:        XPutImage(display, window, gc, ximage, 0, (int)lastrow, 0,
contrib/gregbook/rpng2-x.c:} /* end function rpng2_x_redisplay_image() */
contrib/gregbook/rpng2-x.c:static void rpng2_x_reload_bg_image(void)
contrib/gregbook/rpng2-x.c:    int k, hmax, max;
contrib/gregbook/rpng2-x.c:    int xidx, yidx, yidx_max;
contrib/gregbook/rpng2-x.c:    int invert_gradient2 = (bg[pat].type & 0x08);
contrib/gregbook/rpng2-x.c:    yidx_max = bgscale - 1;
contrib/gregbook/rpng2-x.c:    Vertical gradients (ramps) in NxN squares, alternating direction and
contrib/gregbook/rpng2-x.c:    if ((bg[pat].type & 0x07) == 0) {
contrib/gregbook/rpng2-x.c:        int r1_diff = rgb[bg[pat].rgb1_max].r - r1_min;
contrib/gregbook/rpng2-x.c:        int g1_diff = rgb[bg[pat].rgb1_max].g - g1_min;
contrib/gregbook/rpng2-x.c:        int b1_diff = rgb[bg[pat].rgb1_max].b - b1_min;
contrib/gregbook/rpng2-x.c:        int r2_diff = rgb[bg[pat].rgb2_max].r - r2_min;
contrib/gregbook/rpng2-x.c:        int g2_diff = rgb[bg[pat].rgb2_max].g - g2_min;
contrib/gregbook/rpng2-x.c:        int b2_diff = rgb[bg[pat].rgb2_max].b - b2_min;
contrib/gregbook/rpng2-x.c:            yidx = (int)(row % bgscale);
contrib/gregbook/rpng2-x.c:            r1 = r1_min + (r1_diff * yidx) / yidx_max;
contrib/gregbook/rpng2-x.c:            g1 = g1_min + (g1_diff * yidx) / yidx_max;
contrib/gregbook/rpng2-x.c:            b1 = b1_min + (b1_diff * yidx) / yidx_max;
contrib/gregbook/rpng2-x.c:            r1_inv = r1_min + (r1_diff * (yidx_max-yidx)) / yidx_max;
contrib/gregbook/rpng2-x.c:            g1_inv = g1_min + (g1_diff * (yidx_max-yidx)) / yidx_max;
contrib/gregbook/rpng2-x.c:            b1_inv = b1_min + (b1_diff * (yidx_max-yidx)) / yidx_max;
contrib/gregbook/rpng2-x.c:            r2 = r2_min + (r2_diff * yidx) / yidx_max;
contrib/gregbook/rpng2-x.c:            g2 = g2_min + (g2_diff * yidx) / yidx_max;
contrib/gregbook/rpng2-x.c:            b2 = b2_min + (b2_diff * yidx) / yidx_max;
contrib/gregbook/rpng2-x.c:            r2_inv = r2_min + (r2_diff * (yidx_max-yidx)) / yidx_max;
contrib/gregbook/rpng2-x.c:            g2_inv = g2_min + (g2_diff * (yidx_max-yidx)) / yidx_max;
contrib/gregbook/rpng2-x.c:            b2_inv = b2_min + (b2_diff * (yidx_max-yidx)) / yidx_max;
contrib/gregbook/rpng2-x.c:                  (even_odd_horiz && (bg[pat].type & 0x10));
contrib/gregbook/rpng2-x.c:    } else if ((bg[pat].type & 0x07) == 1) {
contrib/gregbook/rpng2-x.c:        hmax = (bgscale-1)/2;   /* half the max weight of a color */
contrib/gregbook/rpng2-x.c:        max = 2*hmax;           /* the max weight of a color */
contrib/gregbook/rpng2-x.c:        r1 = rgb[bg[pat].rgb1_max].r;
contrib/gregbook/rpng2-x.c:        g1 = rgb[bg[pat].rgb1_max].g;
contrib/gregbook/rpng2-x.c:        b1 = rgb[bg[pat].rgb1_max].b;
contrib/gregbook/rpng2-x.c:        r2 = rgb[bg[pat].rgb2_max].r;
contrib/gregbook/rpng2-x.c:        g2 = rgb[bg[pat].rgb2_max].g;
contrib/gregbook/rpng2-x.c:        b2 = rgb[bg[pat].rgb2_max].b;
contrib/gregbook/rpng2-x.c:            yidx = (int)(row % bgscale);
contrib/gregbook/rpng2-x.c:            if (yidx > hmax)
contrib/gregbook/rpng2-x.c:                yidx = bgscale-1 - yidx;
contrib/gregbook/rpng2-x.c:                xidx = (int)(i % bgscale);
contrib/gregbook/rpng2-x.c:                if (xidx > hmax)
contrib/gregbook/rpng2-x.c:                    xidx = bgscale-1 - xidx;
contrib/gregbook/rpng2-x.c:                k = xidx + yidx;
contrib/gregbook/rpng2-x.c:                *dest++ = (k*r1 + (max-k)*r2) / max;
contrib/gregbook/rpng2-x.c:                *dest++ = (k*g1 + (max-k)*g2) / max;
contrib/gregbook/rpng2-x.c:                *dest++ = (k*b1 + (max-k)*b2) / max;
contrib/gregbook/rpng2-x.c:    } else if ((bg[pat].type & 0x07) == 2) {
contrib/gregbook/rpng2-x.c:        int ii, x, y, hw, hh, grayspot;
contrib/gregbook/rpng2-x.c:        double angle=0.0, aoffset=0.0, maxDist, dist;
contrib/gregbook/rpng2-x.c:        maxDist = (double)((hw*hw) + (hh*hh));
contrib/gregbook/rpng2-x.c:                x = (int)(i - hw);
contrib/gregbook/rpng2-x.c:                angle = (x == 0)? PI_2 : atan((double)y / (double)x);
contrib/gregbook/rpng2-x.c:                gray = (double)MAX(ABS(y), ABS(x)) / grayspot;
contrib/gregbook/rpng2-x.c:                dist = (double)((x*x) + (y*y)) / maxDist;
contrib/gregbook/rpng2-x.c:                s = gray * ((double)(ABS(x)+ABS(y)) / (double)(hw + hh));
contrib/gregbook/rpng2-x.c:} /* end function rpng2_x_reload_bg_image() */
contrib/gregbook/rpng2-x.c:static void rpng2_x_cleanup(void)
contrib/gregbook/rpng2-x.c:    if (ximage) {
contrib/gregbook/rpng2-x.c:        if (ximage->data) {
contrib/gregbook/rpng2-x.c:            free(ximage->data);           /* we allocated it, so we free it */
contrib/gregbook/rpng2-x.c:            ximage->data = (char *)NULL;  /*  instead of XDestroyImage() */
contrib/gregbook/rpng2-x.c:        XDestroyImage(ximage);
contrib/gregbook/rpng2-x.c:        ximage = NULL;
contrib/gregbook/rpng2-x.c:static int rpng2_x_msb(ulg u32val)
contrib/gregbook/rpng2-x.c:        if (u32val & 0x80000000L)
contrib/gregbook/rpng2-win.c:    - 1.02:  fixed cut-and-paste error in usage screen (oops...)
contrib/gregbook/rpng2-win.c:    - 1.04:  removed bogus extra argument from usage fprintf() [Glenn R-P?];
contrib/gregbook/rpng2-win.c:              fixed command-line parsing bug
contrib/gregbook/rpng2-win.c:    - 1.20:  added runtime MMX-enabling/disabling and new -mmx* options
contrib/gregbook/rpng2-win.c:    - 1.22:  added AMD64/EM64T support (__x86_64__)
contrib/gregbook/rpng2-win.c:    - 2.01:  fixed 64-bit typo in readpng2.c
contrib/gregbook/rpng2-win.c:    - 2.02:  fixed improper display of usage screen on PNG error(s); fixed
contrib/gregbook/rpng2-win.c:              unexpected-EOF and file-read-error cases
contrib/gregbook/rpng2-win.c:    - 2.03:  removed runtime MMX-enabling/disabling and obsolete -mmx* options
contrib/gregbook/rpng2-win.c:      express or implied.  In no event shall the author or contributors
contrib/gregbook/rpng2-win.c:#define CLIP(a,min,max)  MAX(min,MIN((a),max))
contrib/gregbook/rpng2-win.c:#define rgb1_max   bg_freq
contrib/gregbook/rpng2-win.c:#define rgb2_max   bg_bsat
contrib/gregbook/rpng2-win.c:                          *  speed 10% faster than theoretical 33.6K maximum
contrib/gregbook/rpng2-win.c:    struct...but a few macros and a little fixed-point math will do
contrib/gregbook/rpng2-win.c:    int rgb1_max, rgb1_min;     /* or bg_freq, bg_gray */
contrib/gregbook/rpng2-win.c:    int rgb2_max, rgb2_min;     /* or bg_bsat, bg_brot (both scaled by 10)*/
contrib/gregbook/rpng2-win.c:    double LUT_exponent;              /* just the lookup table */
contrib/gregbook/rpng2-win.c:    double CRT_exponent = 2.2;        /* just the monitor */
contrib/gregbook/rpng2-win.c:    double default_display_exponent;  /* whole display system */
contrib/gregbook/rpng2-win.c:    /* Next reenable console output, which normally goes to the bit bucket
contrib/gregbook/rpng2-win.c:    /* Set the default value for our display-system exponent, i.e., the
contrib/gregbook/rpng2-win.c:     * product of the CRT exponent and the exponent corresponding to
contrib/gregbook/rpng2-win.c:     * exhaustive list of LUT values (e.g., OpenStep has a lot of weird
contrib/gregbook/rpng2-win.c:    /* third-party utilities can modify the default LUT exponent */
contrib/gregbook/rpng2-win.c:    LUT_exponent = 1.0 / 2.2;
contrib/gregbook/rpng2-win.c:    if (some_next_function_that_returns_gamma(&next_gamma))
contrib/gregbook/rpng2-win.c:        LUT_exponent = 1.0 / next_gamma;
contrib/gregbook/rpng2-win.c:    LUT_exponent = 1.0 / 1.7;
contrib/gregbook/rpng2-win.c:            LUT_exponent = 1.0 / sgi_gamma;
contrib/gregbook/rpng2-win.c:    LUT_exponent = 1.8 / 2.61;
contrib/gregbook/rpng2-win.c:        LUT_exponent = mac_gamma / 2.61;
contrib/gregbook/rpng2-win.c:    LUT_exponent = 1.0;   /* assume no LUT:  most PCs */
contrib/gregbook/rpng2-win.c:    default_display_exponent = LUT_exponent * CRT_exponent;
contrib/gregbook/rpng2-win.c:        rpng2_info.display_exponent = atof(p);
contrib/gregbook/rpng2-win.c:        rpng2_info.display_exponent = default_display_exponent;
contrib/gregbook/rpng2-win.c:                rpng2_info.display_exponent = atof(*argv);
contrib/gregbook/rpng2-win.c:                if (rpng2_info.display_exponent <= 0.0)
contrib/gregbook/rpng2-win.c:                ++error;   /* not expecting any other options */
contrib/gregbook/rpng2-win.c:          "Usage:  %s [-gamma exp] [-bgcolor bg | -bgpat pat] [-timing]\n"
contrib/gregbook/rpng2-win.c:          "    exp \ttransfer-function exponent (``gamma'') of the display\n"
contrib/gregbook/rpng2-win.c:          "\t\t  to the product of the lookup-table exponent (varies)\n"
contrib/gregbook/rpng2-win.c:          "\t\t  and the CRT exponent (usually 2.2); must be positive\n"
contrib/gregbook/rpng2-win.c:          "    bg  \tdesired background color in 7-character hex RGB format\n"
contrib/gregbook/rpng2-win.c:#if (defined(__i386__) || defined(_M_IX86) || defined(__x86_64__)) && \
contrib/gregbook/rpng2-win.c:          (int)strlen(PROGNAME), " ", default_display_exponent, num_bgpat);
contrib/gregbook/rpng2-win.c:        while (ch != 'q' && ch != 'Q' && ch != 0x1B);
contrib/gregbook/rpng2-win.c:        exit(1);
contrib/gregbook/rpng2-win.c:        while (ch != 'q' && ch != 'Q' && ch != 0x1B);
contrib/gregbook/rpng2-win.c:        exit(2);
contrib/gregbook/rpng2-win.c:        sscanf(bgstr+1, "%2x%2x%2x", &r, &g, &b);
contrib/gregbook/rpng2-win.c:                exit(3);
contrib/gregbook/rpng2-win.c:                  "(unexpectedly) while reading PNG image file\n");
contrib/gregbook/rpng2-win.c:                exit(3);
contrib/gregbook/rpng2-win.c:        exit(3);
contrib/gregbook/rpng2-win.c:    int extra_width, extra_height;
contrib/gregbook/rpng2-win.c:    RegisterClassEx(&wndclass);
contrib/gregbook/rpng2-win.c:    extra_width  = 2*(GetSystemMetrics(SM_CXBORDER) +
contrib/gregbook/rpng2-win.c:    extra_height = 2*(GetSystemMetrics(SM_CYBORDER) +
contrib/gregbook/rpng2-win.c:      CW_USEDEFAULT, CW_USEDEFAULT, rpng2_info.width+extra_width,
contrib/gregbook/rpng2-win.c:      rpng2_info.height+extra_height, NULL, NULL, global_hInst, NULL);
contrib/gregbook/rpng2-win.c:        int x, y, len = strlen(msg);
contrib/gregbook/rpng2-win.c:        GetTextMetrics(hdc, &tm);
contrib/gregbook/rpng2-win.c:        x = (rpng2_info.width - len*tm.tmAveCharWidth)/2;
contrib/gregbook/rpng2-win.c:        SetTextColor(hdc, GetSysColor(COLOR_HIGHLIGHTTEXT));
contrib/gregbook/rpng2-win.c:        /* this can still begin out of bounds even if x is positive (???): */
contrib/gregbook/rpng2-win.c:        TextOut(hdc, ((x < 0)? 0 : x), ((y < 0)? 0 : y), msg, len);
contrib/gregbook/rpng2-win.c:    int k, hmax, max;
contrib/gregbook/rpng2-win.c:    int xidx, yidx, yidx_max = (bgscale-1);
contrib/gregbook/rpng2-win.c:    int invert_gradient2 = (bg[pat].type & 0x08);
contrib/gregbook/rpng2-win.c:    Vertical gradients (ramps) in NxN squares, alternating direction and
contrib/gregbook/rpng2-win.c:    if ((bg[pat].type & 0x07) == 0) {
contrib/gregbook/rpng2-win.c:        int r1_diff = rgb[bg[pat].rgb1_max].r - r1_min;
contrib/gregbook/rpng2-win.c:        int g1_diff = rgb[bg[pat].rgb1_max].g - g1_min;
contrib/gregbook/rpng2-win.c:        int b1_diff = rgb[bg[pat].rgb1_max].b - b1_min;
contrib/gregbook/rpng2-win.c:        int r2_diff = rgb[bg[pat].rgb2_max].r - r2_min;
contrib/gregbook/rpng2-win.c:        int g2_diff = rgb[bg[pat].rgb2_max].g - g2_min;
contrib/gregbook/rpng2-win.c:        int b2_diff = rgb[bg[pat].rgb2_max].b - b2_min;
contrib/gregbook/rpng2-win.c:            yidx = row % bgscale;
contrib/gregbook/rpng2-win.c:            r1 = r1_min + (r1_diff * yidx) / yidx_max;
contrib/gregbook/rpng2-win.c:            g1 = g1_min + (g1_diff * yidx) / yidx_max;
contrib/gregbook/rpng2-win.c:            b1 = b1_min + (b1_diff * yidx) / yidx_max;
contrib/gregbook/rpng2-win.c:            r1_inv = r1_min + (r1_diff * (yidx_max-yidx)) / yidx_max;
contrib/gregbook/rpng2-win.c:            g1_inv = g1_min + (g1_diff * (yidx_max-yidx)) / yidx_max;
contrib/gregbook/rpng2-win.c:            b1_inv = b1_min + (b1_diff * (yidx_max-yidx)) / yidx_max;
contrib/gregbook/rpng2-win.c:            r2 = r2_min + (r2_diff * yidx) / yidx_max;
contrib/gregbook/rpng2-win.c:            g2 = g2_min + (g2_diff * yidx) / yidx_max;
contrib/gregbook/rpng2-win.c:            b2 = b2_min + (b2_diff * yidx) / yidx_max;
contrib/gregbook/rpng2-win.c:            r2_inv = r2_min + (r2_diff * (yidx_max-yidx)) / yidx_max;
contrib/gregbook/rpng2-win.c:            g2_inv = g2_min + (g2_diff * (yidx_max-yidx)) / yidx_max;
contrib/gregbook/rpng2-win.c:            b2_inv = b2_min + (b2_diff * (yidx_max-yidx)) / yidx_max;
contrib/gregbook/rpng2-win.c:                  (even_odd_horiz && (bg[pat].type & 0x10));
contrib/gregbook/rpng2-win.c:    } else if ((bg[pat].type & 0x07) == 1) {
contrib/gregbook/rpng2-win.c:        hmax = (bgscale-1)/2;   /* half the max weight of a color */
contrib/gregbook/rpng2-win.c:        max = 2*hmax;           /* the max weight of a color */
contrib/gregbook/rpng2-win.c:        r1 = rgb[bg[pat].rgb1_max].r;
contrib/gregbook/rpng2-win.c:        g1 = rgb[bg[pat].rgb1_max].g;
contrib/gregbook/rpng2-win.c:        b1 = rgb[bg[pat].rgb1_max].b;
contrib/gregbook/rpng2-win.c:        r2 = rgb[bg[pat].rgb2_max].r;
contrib/gregbook/rpng2-win.c:        g2 = rgb[bg[pat].rgb2_max].g;
contrib/gregbook/rpng2-win.c:        b2 = rgb[bg[pat].rgb2_max].b;
contrib/gregbook/rpng2-win.c:            yidx = row % bgscale;
contrib/gregbook/rpng2-win.c:            if (yidx > hmax)
contrib/gregbook/rpng2-win.c:                yidx = bgscale-1 - yidx;
contrib/gregbook/rpng2-win.c:                xidx = i % bgscale;
contrib/gregbook/rpng2-win.c:                if (xidx > hmax)
contrib/gregbook/rpng2-win.c:                    xidx = bgscale-1 - xidx;
contrib/gregbook/rpng2-win.c:                k = xidx + yidx;
contrib/gregbook/rpng2-win.c:                *dest++ = (k*r1 + (max-k)*r2) / max;
contrib/gregbook/rpng2-win.c:                *dest++ = (k*g1 + (max-k)*g2) / max;
contrib/gregbook/rpng2-win.c:                *dest++ = (k*b1 + (max-k)*b2) / max;
contrib/gregbook/rpng2-win.c:    } else if ((bg[pat].type & 0x07) == 2) {
contrib/gregbook/rpng2-win.c:        int ii, x, y, hw, hh, grayspot;
contrib/gregbook/rpng2-win.c:        double angle=0.0, aoffset=0.0, maxDist, dist;
contrib/gregbook/rpng2-win.c:        maxDist = (double)((hw*hw) + (hh*hh));
contrib/gregbook/rpng2-win.c:                x = i - hw;
contrib/gregbook/rpng2-win.c:                angle = (x == 0)? PI_2 : atan((double)y / (double)x);
contrib/gregbook/rpng2-win.c:                gray = (double)MAX(ABS(y), ABS(x)) / grayspot;
contrib/gregbook/rpng2-win.c:                dist = (double)((x*x) + (y*y)) / maxDist;
contrib/gregbook/rpng2-win.c:                s = gray * ((double)(ABS(x)+ABS(y)) / (double)(hw + hh));
contrib/gregbook/rpng2-win.c:    if ((rows & 0xf) == 0 || row == rpng2_info.height-1) {
contrib/gregbook/rpng2-win.c:     * we have nothing to do here except set a flag and let the user know
contrib/gregbook/rpng2-win.c:                case 0x1B:      /* Esc key */
contrib/gregbook/rpng-win.c:    - 1.01:  modified to allow abbreviated options; fixed long/ulong mis-
contrib/gregbook/rpng-win.c:    - 1.02:  added extra set of parentheses to png_jmpbuf() macro; fixed
contrib/gregbook/rpng-win.c:    - 2.01:  fixed improper display of usage screen on PNG error(s)
contrib/gregbook/rpng-win.c:      express or implied.  In no event shall the author or contributors
contrib/gregbook/rpng-win.c:static double display_exponent;
contrib/gregbook/rpng-win.c:    double LUT_exponent;              /* just the lookup table */
contrib/gregbook/rpng-win.c:    double CRT_exponent = 2.2;        /* just the monitor */
contrib/gregbook/rpng-win.c:    double default_display_exponent;  /* whole display system */
contrib/gregbook/rpng-win.c:    /* Next set the default value for our display-system exponent, i.e.,
contrib/gregbook/rpng-win.c:     * the product of the CRT exponent and the exponent corresponding to
contrib/gregbook/rpng-win.c:     * exhaustive list of LUT values (e.g., OpenStep has a lot of weird
contrib/gregbook/rpng-win.c:    LUT_exponent = 1.0 / 2.2;
contrib/gregbook/rpng-win.c:    if (some_next_function_that_returns_gamma(&next_gamma))
contrib/gregbook/rpng-win.c:        LUT_exponent = 1.0 / next_gamma;
contrib/gregbook/rpng-win.c:    LUT_exponent = 1.0 / 1.7;
contrib/gregbook/rpng-win.c:            LUT_exponent = 1.0 / sgi_gamma;
contrib/gregbook/rpng-win.c:    LUT_exponent = 1.8 / 2.61;
contrib/gregbook/rpng-win.c:        LUT_exponent = mac_gamma / 2.61;
contrib/gregbook/rpng-win.c:    LUT_exponent = 1.0;   /* assume no LUT:  most PCs */
contrib/gregbook/rpng-win.c:    default_display_exponent = LUT_exponent * CRT_exponent;
contrib/gregbook/rpng-win.c:        display_exponent = atof(p);
contrib/gregbook/rpng-win.c:        display_exponent = default_display_exponent;
contrib/gregbook/rpng-win.c:                display_exponent = atof(*argv);
contrib/gregbook/rpng-win.c:                if (display_exponent <= 0.0)
contrib/gregbook/rpng-win.c:                ++error;   /* not expecting any other options */
contrib/gregbook/rpng-win.c:          "Usage:  %s [-gamma exp] [-bgcolor bg] file.png\n"
contrib/gregbook/rpng-win.c:          "    exp \ttransfer-function exponent (``gamma'') of the display\n"
contrib/gregbook/rpng-win.c:          "\t\t  to the product of the lookup-table exponent (varies)\n"
contrib/gregbook/rpng-win.c:          "\t\t  and the CRT exponent (usually 2.2); must be positive\n"
contrib/gregbook/rpng-win.c:          "    bg  \tdesired background color in 7-character hex RGB format\n"
contrib/gregbook/rpng-win.c:          "\n", PROGNAME, default_display_exponent);
contrib/gregbook/rpng-win.c:        while (ch != 'q' && ch != 'Q' && ch != 0x1B);
contrib/gregbook/rpng-win.c:        exit(1);
contrib/gregbook/rpng-win.c:        while (ch != 'q' && ch != 'Q' && ch != 0x1B);
contrib/gregbook/rpng-win.c:        exit(2);
contrib/gregbook/rpng-win.c:        sscanf(bgstr+1, "%2x%2x%2x", &r, &g, &b);
contrib/gregbook/rpng-win.c:        exit(2);
contrib/gregbook/rpng-win.c:        exit(2);
contrib/gregbook/rpng-win.c:    image_data = readpng_get_image(display_exponent, &image_channels,
contrib/gregbook/rpng-win.c:        exit(3);
contrib/gregbook/rpng-win.c:        exit(4);
contrib/gregbook/rpng-win.c:    int extra_width, extra_height;
contrib/gregbook/rpng-win.c:    RegisterClassEx(&wndclass);
contrib/gregbook/rpng-win.c:    extra_width  = 2*(GetSystemMetrics(SM_CXBORDER) +
contrib/gregbook/rpng-win.c:    extra_height = 2*(GetSystemMetrics(SM_CYBORDER) +
contrib/gregbook/rpng-win.c:      CW_USEDEFAULT, CW_USEDEFAULT, image_width+extra_width,
contrib/gregbook/rpng-win.c:      image_height+extra_height, NULL, NULL, hInst, NULL);
contrib/gregbook/rpng-win.c:        if (((row+1) & 0xf) == 0) {
contrib/gregbook/rpng-win.c:                case 0x1B:     /* Esc key */
contrib/gregbook/readpng.c:      express or implied.  In no event shall the author or contributors
contrib/gregbook/readpng.c:/* display_exponent == LUT_exponent * CRT_exponent */
contrib/gregbook/readpng.c:uch *readpng_get_image(double display_exponent, int *pChannels, ulg *pRowbytes)
contrib/gregbook/readpng.c:    /* expand palette images to RGB, low-bit-depth grayscale images to 8 bits,
contrib/gregbook/readpng.c:        png_set_expand(png_ptr);
contrib/gregbook/readpng.c:        png_set_expand(png_ptr);
contrib/gregbook/readpng.c:        png_set_expand(png_ptr);
contrib/gregbook/readpng.c:    /* unlike the example in the libpng documentation, we have *no* idea where
contrib/gregbook/readpng.c:        png_set_gamma(png_ptr, display_exponent, gamma);
contrib/gregbook/readpng.c:     * post-IDAT text/time/etc. is desired) */
contrib/gregbook/readpng2.h:      express or implied.  In no event shall the author or contributors
contrib/gregbook/readpng2.h:#  define Trace(x)  {fprintf x ; fflush(stderr); fflush(stdout);}
contrib/gregbook/readpng2.h:#  define Trace(x)  ;
contrib/gregbook/readpng2.h:    double display_exponent;
contrib/pngminus/README:express or implied warranty.
contrib/pngminus/README:pnmtopng / pngtopnm utilities. Independantly Alexander Lehmann and I
contrib/pngminus/README:features of PNG, like gamma, alpha, sbit, text-chunks, etc. This makes
contrib/pngminus/README:the utilities quite complex and by now not anymore very maintainable.
contrib/pngminus/README:To experiment a bit with the new interface of libpng, I started off with
contrib/pngminus/README:avoided the use the netpbm library, which requires DOS extenders. Again,
contrib/pngminus/README:MS-DOS with Turbo-C 3.0 and under RedHat Linux 4.2 with gcc. In both
contrib/pngminus/README:that you have built the libraries in ../libpng and ../zlib. Using Linux,
contrib/pngminus/README:makefile.linux (also called .lnx in earlier versions of libpng). The
contrib/pngminus/README:Please, remember that this was just a small experiment to learn a few
contrib/pngminus/README:          hptr = (png_byte huge *)((long)(hptr) & 0xfffffff0L);
contrib/pngminus/README:          hptr = (png_byte huge *)((long)(hptr) & 0xfffffff0L);
contrib/pngminus/makevms.com:$  ccopt = "/prefix=all"+ccopt
contrib/pngminus/makevms.com:$      comp = "__vaxc__=1"
contrib/pngminus/makevms.com:$    ccopt = "/decc/prefix=all"+ccopt
contrib/pngminus/makevms.com:$ open/write xopt x11.opt
contrib/pngminus/makevms.com:$ write xopt "sys$library:decw$xlibshr.exe/share"
contrib/pngminus/makevms.com:$ close xopt
contrib/pngminus/makevms.com:$   call make pnm2png.exe -
contrib/pngminus/makevms.com:$   call make png2pnm.exe -
contrib/pngminus/makevms.com:$ exit
contrib/pngminus/makevms.com:$       If Argument .Eqs. "" Then Goto Exit
contrib/pngminus/makevms.com:$       If AFile .Eqs. "" .Or. AFile .Eqs. OFile Then Goto NextEl
contrib/pngminus/makevms.com:$NextEL:
contrib/pngminus/makevms.com:$ Goto Exit
contrib/pngminus/makevms.com:$Exit:
contrib/pngminus/makefile.tc3:E=.exe
contrib/pngminus/pnm2png.c: *  express or implied warranty.
contrib/pngminus/pnm2png.c:            fprintf (stderr, "Error:  alpha-channel file %s does not exist\n",
contrib/pngminus/pnm2png.c:            exit (1);
contrib/pngminus/pnm2png.c:          exit(0);
contrib/pngminus/pnm2png.c:          exit(1);
contrib/pngminus/pnm2png.c:        fprintf (stderr, "Error:  file %s does not exist\n", argv[argi]);
contrib/pngminus/pnm2png.c:        exit (1);
contrib/pngminus/pnm2png.c:        exit (1);
contrib/pngminus/pnm2png.c:      exit (1);
contrib/pngminus/pnm2png.c:    exit (1);
contrib/pngminus/pnm2png.c:  fprintf (stderr, "   for Linux (and Unix) compilers\n");
contrib/pngminus/pnm2png.c:  png_byte      *png_pixels = NULL;
contrib/pngminus/pnm2png.c:  png_byte      *pix_ptr = NULL;
contrib/pngminus/pnm2png.c:  char          maxval_token[16];
contrib/pngminus/pnm2png.c:  unsigned long   ul_maxval=0;
contrib/pngminus/pnm2png.c:  png_uint_32   maxval;
contrib/pngminus/pnm2png.c:    get_token(pnm_file, maxval_token);
contrib/pngminus/pnm2png.c:    sscanf (maxval_token, "%lu", &ul_maxval);
contrib/pngminus/pnm2png.c:    maxval = (png_uint_32) ul_maxval;
contrib/pngminus/pnm2png.c:    if (maxval <= 1)
contrib/pngminus/pnm2png.c:    else if (maxval <= 3)
contrib/pngminus/pnm2png.c:    else if (maxval <= 15)
contrib/pngminus/pnm2png.c:    else if (maxval <= 255)
contrib/pngminus/pnm2png.c:    else /* if (maxval <= 65535) */
contrib/pngminus/pnm2png.c:    get_token(pnm_file, maxval_token);
contrib/pngminus/pnm2png.c:    sscanf (maxval_token, "%lu", &ul_maxval);
contrib/pngminus/pnm2png.c:    maxval = (png_uint_32) ul_maxval;
contrib/pngminus/pnm2png.c:    if (maxval <= 1)
contrib/pngminus/pnm2png.c:    else if (maxval <= 3)
contrib/pngminus/pnm2png.c:    else if (maxval <= 15)
contrib/pngminus/pnm2png.c:    else if (maxval <= 255)
contrib/pngminus/pnm2png.c:    else /* if (maxval <= 65535) */
contrib/pngminus/pnm2png.c:      get_token(alpha_file, maxval_token);
contrib/pngminus/pnm2png.c:      sscanf (maxval_token, "%lu", &ul_maxval);
contrib/pngminus/pnm2png.c:      maxval = (png_uint_32) ul_maxval;
contrib/pngminus/pnm2png.c:      if (maxval <= 1)
contrib/pngminus/pnm2png.c:      else if (maxval <= 3)
contrib/pngminus/pnm2png.c:      else if (maxval <= 15)
contrib/pngminus/pnm2png.c:      else if (maxval <= 255)
contrib/pngminus/pnm2png.c:      else /* if (maxval <= 65535) */
contrib/pngminus/pnm2png.c:    /* row data is as many bytes as can fit width x channels x bit_depth */
contrib/pngminus/pnm2png.c:    /* row_bytes is the width x number of channels x (bit-depth / 8) */
contrib/pngminus/pnm2png.c:  if ((png_pixels = (png_byte *)
contrib/pngminus/pnm2png.c:  pix_ptr = png_pixels;
contrib/pngminus/pnm2png.c:        *pix_ptr++ = get_data (pnm_file, 8);
contrib/pngminus/pnm2png.c:            *pix_ptr++ = get_data (pnm_file, bit_depth);
contrib/pngminus/pnm2png.c:              *pix_ptr++ = get_value (pnm_file, bit_depth);
contrib/pngminus/pnm2png.c:              *pix_ptr = (png_byte) ((tmp16 >> 8) & 0xFF);
contrib/pngminus/pnm2png.c:              pix_ptr++;
contrib/pngminus/pnm2png.c:              *pix_ptr = (png_byte) (tmp16 & 0xFF);
contrib/pngminus/pnm2png.c:              pix_ptr++;
contrib/pngminus/pnm2png.c:            *pix_ptr++ = get_data (alpha_file, alpha_depth);
contrib/pngminus/pnm2png.c:              *pix_ptr++ = get_value (alpha_file, bit_depth);
contrib/pngminus/pnm2png.c:              *pix_ptr++ = (png_byte) ((tmp16 >> 8) & 0xFF);
contrib/pngminus/pnm2png.c:              *pix_ptr++ = (png_byte) (tmp16 & 0xFF);
contrib/pngminus/pnm2png.c:    row_pointers[i] = png_pixels + i * row_bytes;
contrib/pngminus/pnm2png.c:  if (png_pixels != (unsigned char*) NULL)
contrib/pngminus/pnm2png.c:    free (png_pixels);
contrib/pngminus/pnm2png.c: * get_data() - takes first byte and converts into next pixel value,
contrib/pngminus/pnm2png.c:      mask = (mask >> 1) | 0x80;
contrib/pngminus/pnm2png.c:  old_value = (old_value << depth) & 0xFF;
contrib/pngminus/pnm2png.c:      mask = (mask << 1) | 0x01;
contrib/pngminus/pnm2png.bat:pnm2png.exe basn0g01.pgm basn0g01.png
contrib/pngminus/pnm2png.bat:pnm2png.exe basn0g02.pgm basn0g02.png
contrib/pngminus/pnm2png.bat:pnm2png.exe basn0g04.pgm basn0g04.png
contrib/pngminus/pnm2png.bat:pnm2png.exe basn0g08.pgm basn0g08.png
contrib/pngminus/pnm2png.bat:pnm2png.exe basn0g16.pgm basn0g16.png
contrib/pngminus/pnm2png.bat:pnm2png.exe basn2c08.ppm basn2c08.png
contrib/pngminus/pnm2png.bat:pnm2png.exe basn2c16.ppm basn2c16.png
contrib/pngminus/pnm2png.bat:pnm2png.exe basn3p01.ppm basn3p01.png
contrib/pngminus/pnm2png.bat:pnm2png.exe basn3p02.ppm basn3p02.png
contrib/pngminus/pnm2png.bat:pnm2png.exe basn3p04.ppm basn3p04.png
contrib/pngminus/pnm2png.bat:pnm2png.exe basn3p08.ppm basn3p08.png
contrib/pngminus/pnm2png.bat:pnm2png.exe -alpha basn6a08.pgm basn4a08.pgm basn4a08.png
contrib/pngminus/pnm2png.bat:pnm2png.exe -alpha basn6a16.pgm basn4a16.pgm basn4a16.png
contrib/pngminus/pnm2png.bat:pnm2png.exe -alpha basn6a08.pgm basn6a08.ppm basn6a08.png
contrib/pngminus/pnm2png.bat:pnm2png.exe -alpha basn6a16.pgm basn6a16.ppm basn6a16.png
contrib/pngminus/pnm2png.bat:pnm2png.exe rawn0g01.pgm rawn0g01.png
contrib/pngminus/pnm2png.bat:pnm2png.exe rawn0g02.pgm rawn0g02.png
contrib/pngminus/pnm2png.bat:pnm2png.exe rawn0g04.pgm rawn0g04.png
contrib/pngminus/pnm2png.bat:pnm2png.exe rawn0g08.pgm rawn0g08.png
contrib/pngminus/pnm2png.bat:pnm2png.exe rawn0g16.pgm rawn0g16.png
contrib/pngminus/pnm2png.bat:pnm2png.exe rawn2c08.ppm rawn2c08.png
contrib/pngminus/pnm2png.bat:pnm2png.exe rawn2c16.ppm rawn2c16.png
contrib/pngminus/pnm2png.bat:pnm2png.exe rawn3p01.ppm rawn3p01.png
contrib/pngminus/pnm2png.bat:pnm2png.exe rawn3p02.ppm rawn3p02.png
contrib/pngminus/pnm2png.bat:pnm2png.exe rawn3p04.ppm rawn3p04.png
contrib/pngminus/pnm2png.bat:pnm2png.exe rawn3p08.ppm rawn3p08.png
contrib/pngminus/pnm2png.bat:pnm2png.exe -alpha rawn6a08.pgm rawn4a08.pgm rawn4a08.png
contrib/pngminus/pnm2png.bat:pnm2png.exe -alpha rawn6a16.pgm rawn4a16.pgm rawn4a16.png
contrib/pngminus/pnm2png.bat:pnm2png.exe -alpha rawn6a08.pgm rawn6a08.ppm rawn6a08.png
contrib/pngminus/pnm2png.bat:pnm2png.exe -alpha rawn6a16.pgm rawn6a16.ppm rawn6a16.png
contrib/pngminus/makefile.std:# Linux / Unix
contrib/pngminus/png2pnm.bat:png2pnm.exe -noraw ..\pngsuite\basn0g01.png basn0g01.pgm
contrib/pngminus/png2pnm.bat:png2pnm.exe -noraw ..\pngsuite\basn0g02.png basn0g02.pgm
contrib/pngminus/png2pnm.bat:png2pnm.exe -noraw ..\pngsuite\basn0g04.png basn0g04.pgm
contrib/pngminus/png2pnm.bat:png2pnm.exe -noraw ..\pngsuite\basn0g08.png basn0g08.pgm
contrib/pngminus/png2pnm.bat:png2pnm.exe -noraw ..\pngsuite\basn0g16.png basn0g16.pgm
contrib/pngminus/png2pnm.bat:png2pnm.exe -noraw ..\pngsuite\basn2c08.png basn2c08.ppm
contrib/pngminus/png2pnm.bat:png2pnm.exe -noraw ..\pngsuite\basn2c16.png basn2c16.ppm
contrib/pngminus/png2pnm.bat:png2pnm.exe -noraw ..\pngsuite\basn3p01.png basn3p01.ppm
contrib/pngminus/png2pnm.bat:png2pnm.exe -noraw ..\pngsuite\basn3p02.png basn3p02.ppm
contrib/pngminus/png2pnm.bat:png2pnm.exe -noraw ..\pngsuite\basn3p04.png basn3p04.ppm
contrib/pngminus/png2pnm.bat:png2pnm.exe -noraw ..\pngsuite\basn3p08.png basn3p08.ppm
contrib/pngminus/png2pnm.bat:png2pnm.exe -noraw ..\pngsuite\basn4a08.png basn4a08.pgm
contrib/pngminus/png2pnm.bat:png2pnm.exe -noraw ..\pngsuite\basn4a16.png basn4a16.pgm
contrib/pngminus/png2pnm.bat:png2pnm.exe -noraw -alpha basn6a08.pgm ..\pngsuite\basn6a08.png basn6a08.ppm
contrib/pngminus/png2pnm.bat:png2pnm.exe -noraw -alpha basn6a16.pgm ..\pngsuite\basn6a16.png basn6a16.ppm
contrib/pngminus/png2pnm.bat:png2pnm.exe -raw ..\pngsuite\basn0g01.png rawn0g01.pgm
contrib/pngminus/png2pnm.bat:png2pnm.exe -raw ..\pngsuite\basn0g02.png rawn0g02.pgm
contrib/pngminus/png2pnm.bat:png2pnm.exe -raw ..\pngsuite\basn0g04.png rawn0g04.pgm
contrib/pngminus/png2pnm.bat:png2pnm.exe -raw ..\pngsuite\basn0g08.png rawn0g08.pgm
contrib/pngminus/png2pnm.bat:png2pnm.exe -raw ..\pngsuite\basn0g16.png rawn0g16.pgm
contrib/pngminus/png2pnm.bat:png2pnm.exe -raw ..\pngsuite\basn2c08.png rawn2c08.ppm
contrib/pngminus/png2pnm.bat:png2pnm.exe -raw ..\pngsuite\basn2c16.png rawn2c16.ppm
contrib/pngminus/png2pnm.bat:png2pnm.exe -raw ..\pngsuite\basn3p01.png rawn3p01.ppm
contrib/pngminus/png2pnm.bat:png2pnm.exe -raw ..\pngsuite\basn3p02.png rawn3p02.ppm
contrib/pngminus/png2pnm.bat:png2pnm.exe -raw ..\pngsuite\basn3p04.png rawn3p04.ppm
contrib/pngminus/png2pnm.bat:png2pnm.exe -raw ..\pngsuite\basn3p08.png rawn3p08.ppm
contrib/pngminus/png2pnm.bat:png2pnm.exe -raw ..\pngsuite\basn4a08.png rawn4a08.pgm
contrib/pngminus/png2pnm.bat:png2pnm.exe -raw ..\pngsuite\basn4a16.png rawn4a16.pgm
contrib/pngminus/png2pnm.bat:png2pnm.exe -noraw -alpha rawn6a08.pgm ..\pngsuite\basn6a08.png rawn6a08.ppm
contrib/pngminus/png2pnm.bat:png2pnm.exe -noraw -alpha rawn6a16.pgm ..\pngsuite\basn6a16.png rawn6a16.ppm
contrib/pngminus/png2pnm.c: *  express or implied warranty.
contrib/pngminus/png2pnm.c:            exit (1);
contrib/pngminus/png2pnm.c:          exit(0);
contrib/pngminus/png2pnm.c:          exit(1);
contrib/pngminus/png2pnm.c:            fprintf (stderr, "Error:  file %s does not exist\n", argv[argi]);
contrib/pngminus/png2pnm.c:            exit (1);
contrib/pngminus/png2pnm.c:        exit (1);
contrib/pngminus/png2pnm.c:      exit(1);
contrib/pngminus/png2pnm.c:    exit(1);
contrib/pngminus/png2pnm.c:  fprintf (stderr, "   for Linux (and Unix) compilers\n");
contrib/pngminus/png2pnm.c:  png_byte      *png_pixels = NULL;
contrib/pngminus/png2pnm.c:  png_byte      *pix_ptr = NULL;
contrib/pngminus/png2pnm.c:    png_set_expand (png_ptr);
contrib/pngminus/png2pnm.c:  /* expand images to bit-depth 8 (only applicable for grayscale images) */
contrib/pngminus/png2pnm.c:    png_set_expand (png_ptr);
contrib/pngminus/png2pnm.c:    png_set_expand (png_ptr);
contrib/pngminus/png2pnm.c:  /* get the new color-type and bit-depth (after expansion/stripping) */
contrib/pngminus/png2pnm.c:  /* check if alpha is expected to be present in file */
contrib/pngminus/png2pnm.c:    exit (1);
contrib/pngminus/png2pnm.c:  /* row_bytes is the width x number of channels x (bit-depth / 8) */
contrib/pngminus/png2pnm.c:  if ((png_pixels = (png_byte *)
contrib/pngminus/png2pnm.c:    free (png_pixels);
contrib/pngminus/png2pnm.c:    png_pixels = NULL;
contrib/pngminus/png2pnm.c:    row_pointers[i] = png_pixels + i * row_bytes;
contrib/pngminus/png2pnm.c:  pix_ptr = png_pixels;
contrib/pngminus/png2pnm.c:          fputc ((int) *pix_ptr++ , pnm_file);
contrib/pngminus/png2pnm.c:            dep_16 = (long) *pix_ptr++;
contrib/pngminus/png2pnm.c:            fprintf (pnm_file, "%ld ", (dep_16 << 8) + ((long) *pix_ptr++));
contrib/pngminus/png2pnm.c:            fprintf (pnm_file, "%ld ", (long) *pix_ptr++);
contrib/pngminus/png2pnm.c:          pix_ptr++; /* alpha */
contrib/pngminus/png2pnm.c:            pix_ptr++;
contrib/pngminus/png2pnm.c:            fputc ((int) *pix_ptr++ , alpha_file);
contrib/pngminus/png2pnm.c:              dep_16 = (long) *pix_ptr++;
contrib/pngminus/png2pnm.c:              fprintf (alpha_file, "%ld ", (dep_16 << 8) + (long) *pix_ptr++);
contrib/pngminus/png2pnm.c:              fprintf (alpha_file, "%ld ", (long) *pix_ptr++);
contrib/pngminus/png2pnm.c:  if (png_pixels != (unsigned char*) NULL)
contrib/pngminus/png2pnm.c:    free (png_pixels);
contrib/tools/intgamma.sh:# To the extent possible under law, the author has waived all copyright and
contrib/tools/intgamma.sh:# fixed point values of logarithms appropriate to finding the log of an 8-bit
contrib/tools/intgamma.sh:# (0..255) value and a similar table for the exponent calculation.
contrib/tools/intgamma.sh:# "bc" must be on the path when the script is executed, and the math library
contrib/tools/intgamma.sh:# The exponent table.
contrib/tools/intgamma.sh:/* The 'exp()' case must invert the above, taking a 20-bit fixed point
contrib/tools/intgamma.sh: * To deal with this the following exp() function works out the exponent of the
contrib/tools/intgamma.sh:png_32bit_exp[16] =
contrib/tools/intgamma.sh:   x = .5 + e(-i*f)*2^32;
contrib/tools/intgamma.sh:   if (x >= 2^32) x = 2^32-1;
contrib/tools/intgamma.sh:   x;
contrib/tools/intgamma.sh:/* Adjustment table; provided to explain the numbers in the code below. */
contrib/tools/pngfix.c:/* pngfix.c
contrib/tools/pngfix.c: * Tool to check and fix the zlib inflate 'too far back' problem.
contrib/tools/pngfix.c:#define implies(x,y) assert(!(x) || (y))
contrib/tools/pngfix.c:   /* This is used to fix the error:
contrib/tools/pngfix.c:    * pngfix.c:
contrib/tools/pngfix.c:    * pngfix.c:181:13: error: assuming signed overflow does not
contrib/tools/pngfix.c:#define PROGRAM_NAME "pngfix"
contrib/tools/pngfix.c:#  error "pngfix will not work with libpng prior to 1.6.3"
contrib/tools/pngfix.c:#if ZLIB_VERNUM < 0x1260
contrib/tools/pngfix.c:#  error "pngfix not supported in this libpng version"
contrib/tools/pngfix.c:#if ZLIB_VERNUM >= 0x1240
contrib/tools/pngfix.c:#define png_gIFx PNG_U32(103,  73,  70, 120)
contrib/tools/pngfix.c:/* Fix ups for builds with limited read support */
contrib/tools/pngfix.c:/* 80-bit number handling - a PNG image can be up to (2^31-1)x(2^31-1) 8 byte
contrib/tools/pngfix.c: * (16-bit RGBA) pixels in size; that's less than 2^65 bytes or 2^68 bits, so
contrib/tools/pngfix.c:    * be determined by the caller from a knowledge of the maximum for 'val'.
contrib/tools/pngfix.c:      result[ndigits++] = (png_uint_16)(val & 0xffff);
contrib/tools/pngfix.c:   /* This is a signed 32-bit add, except that to avoid overflow the value added
contrib/tools/pngfix.c:    * 'num' should be max(in_digits+1,2) for arbitrary 'add' but can be just
contrib/tools/pngfix.c:      num[out_digits++] = (png_uint_16)(add & 0xffff);
contrib/tools/pngfix.c:      num[out_digits++] = (png_uint_16)(add & 0xffff);
contrib/tools/pngfix.c:      while (out_digits > 1 && num[out_digits-1] == 0xffff)
contrib/tools/pngfix.c:      in_digits = uarb_inc(num, in_digits, add & 0xffff);
contrib/tools/pngfix.c:    * exactly 0xffffffff.
contrib/tools/pngfix.c:         acc[out_digits++] = (png_uint_16)(carry & 0xffff);
contrib/tools/pngfix.c:         (png_uint_16)(val & 0xffff));
contrib/tools/pngfix.c:      carry = (png_uint_16)((inout[i] << (16-right_shift)) & 0xffff);
contrib/tools/pngfix.c:      case 2:  return (val & 0xffff) == num[0] && (val >> 16) == num[1];
contrib/tools/pngfix.c:uarb_printx(uarb num, int digits, FILE *out)
contrib/tools/pngfix.c:   /* Print 'num' as a hexadecimal number (easier than decimal!) */
contrib/tools/pngfix.c:         fprintf(out, "0x%x", num[digits]);
contrib/tools/pngfix.c:            fprintf(out, "%.4x", num[--digits]);
contrib/tools/pngfix.c:         fputs("0x0", out);
contrib/tools/pngfix.c:    * hexadecimal number.  Notice that the results vary for images over 4GByte
contrib/tools/pngfix.c:    * in a system dependent way, and the hexadecimal form doesn't work very well
contrib/tools/pngfix.c:      uarb_printx(num, digits, out);
contrib/tools/pngfix.c:   /* There are thirty-three bits; the next bit in the sequence is bit-33 XOR
contrib/tools/pngfix.c:      png_uint_32 u = ((u0 >> (20-8)) ^ ((u1 << 7) | (u0 >> (32-7)))) & 0xff;
contrib/tools/pngfix.c:   static png_uint_32 clear_seed[2] = { 0x12345678, 0x9abcdef0 };
contrib/tools/pngfix.c:   0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419,
contrib/tools/pngfix.c:   0x706af48f, 0xe963a535, 0x9e6495a3, 0x0edb8832, 0x79dcb8a4,
contrib/tools/pngfix.c:   0xe0d5e91e, 0x97d2d988, 0x09b64c2b, 0x7eb17cbd, 0xe7b82d07,
contrib/tools/pngfix.c:   0x90bf1d91, 0x1db71064, 0x6ab020f2, 0xf3b97148, 0x84be41de,
contrib/tools/pngfix.c:   0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7, 0x136c9856,
contrib/tools/pngfix.c:   0x646ba8c0, 0xfd62f97a, 0x8a65c9ec, 0x14015c4f, 0x63066cd9,
contrib/tools/pngfix.c:   0xfa0f3d63, 0x8d080df5, 0x3b6e20c8, 0x4c69105e, 0xd56041e4,
contrib/tools/pngfix.c:   0xa2677172, 0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b,
contrib/tools/pngfix.c:   0x35b5a8fa, 0x42b2986c, 0xdbbbc9d6, 0xacbcf940, 0x32d86ce3,
contrib/tools/pngfix.c:   0x45df5c75, 0xdcd60dcf, 0xabd13d59, 0x26d930ac, 0x51de003a,
contrib/tools/pngfix.c:   0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423, 0xcfba9599,
contrib/tools/pngfix.c:   0xb8bda50f, 0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924,
contrib/tools/pngfix.c:   0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d, 0x76dc4190,
contrib/tools/pngfix.c:   0x01db7106, 0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f,
contrib/tools/pngfix.c:   0x9fbfe4a5, 0xe8b8d433, 0x7807c9a2, 0x0f00f934, 0x9609a88e,
contrib/tools/pngfix.c:   0xe10e9818, 0x7f6a0dbb, 0x086d3d2d, 0x91646c97, 0xe6635c01,
contrib/tools/pngfix.c:   0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e, 0x6c0695ed,
contrib/tools/pngfix.c:   0x1b01a57b, 0x8208f4c1, 0xf50fc457, 0x65b0d9c6, 0x12b7e950,
contrib/tools/pngfix.c:   0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3,
contrib/tools/pngfix.c:   0xfbd44c65, 0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2,
contrib/tools/pngfix.c:   0x4adfa541, 0x3dd895d7, 0xa4d1c46d, 0xd3d6f4fb, 0x4369e96a,
contrib/tools/pngfix.c:   0x346ed9fc, 0xad678846, 0xda60b8d0, 0x44042d73, 0x33031de5,
contrib/tools/pngfix.c:   0xaa0a4c5f, 0xdd0d7cc9, 0x5005713c, 0x270241aa, 0xbe0b1010,
contrib/tools/pngfix.c:   0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f,
contrib/tools/pngfix.c:   0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17,
contrib/tools/pngfix.c:   0x2eb40d81, 0xb7bd5c3b, 0xc0ba6cad, 0xedb88320, 0x9abfb3b6,
contrib/tools/pngfix.c:   0x03b6e20c, 0x74b1d29a, 0xead54739, 0x9dd277af, 0x04db2615,
contrib/tools/pngfix.c:   0x73dc1683, 0xe3630b12, 0x94643b84, 0x0d6d6a3e, 0x7a6a5aa8,
contrib/tools/pngfix.c:   0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1, 0xf00f9344,
contrib/tools/pngfix.c:   0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb,
contrib/tools/pngfix.c:   0x196c3671, 0x6e6b06e7, 0xfed41b76, 0x89d32be0, 0x10da7a5a,
contrib/tools/pngfix.c:   0x67dd4acc, 0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5,
contrib/tools/pngfix.c:   0xd6d6a3e8, 0xa1d1937e, 0x38d8c2c4, 0x4fdff252, 0xd1bb67f1,
contrib/tools/pngfix.c:   0xa6bc5767, 0x3fb506dd, 0x48b2364b, 0xd80d2bda, 0xaf0a1b4c,
contrib/tools/pngfix.c:   0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55, 0x316e8eef,
contrib/tools/pngfix.c:   0x4669be79, 0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236,
contrib/tools/pngfix.c:   0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f, 0xc5ba3bbe,
contrib/tools/pngfix.c:   0xb2bd0b28, 0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31,
contrib/tools/pngfix.c:   0x2cd99e8b, 0x5bdeae1d, 0x9b64c2b0, 0xec63f226, 0x756aa39c,
contrib/tools/pngfix.c:   0x026d930a, 0x9c0906a9, 0xeb0e363f, 0x72076785, 0x05005713,
contrib/tools/pngfix.c:   0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38, 0x92d28e9b,
contrib/tools/pngfix.c:   0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21, 0x86d3d2d4, 0xf1d4e242,
contrib/tools/pngfix.c:   0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1,
contrib/tools/pngfix.c:   0x18b74777, 0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c,
contrib/tools/pngfix.c:   0x8f659eff, 0xf862ae69, 0x616bffd3, 0x166ccf45, 0xa00ae278,
contrib/tools/pngfix.c:   0xd70dd2ee, 0x4e048354, 0x3903b3c2, 0xa7672661, 0xd06016f7,
contrib/tools/pngfix.c:   0x4969474d, 0x3e6e77db, 0xaed16a4a, 0xd9d65adc, 0x40df0b66,
contrib/tools/pngfix.c:   0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9,
contrib/tools/pngfix.c:   0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605,
contrib/tools/pngfix.c:   0xcdd70693, 0x54de5729, 0x23d967bf, 0xb3667a2e, 0xc4614ab8,
contrib/tools/pngfix.c:   0x5d681b02, 0x2a6f2b94, 0xb40bbe37, 0xc30c8ea1, 0x5a05df1b,
contrib/tools/pngfix.c:   0x2d02ef8d
contrib/tools/pngfix.c:#define CRC_INIT 0xffffffff
contrib/tools/pngfix.c:   return crc_table[(crc ^ b) & 0xff] ^ (crc >> 8);
contrib/tools/pngfix.c:    * conditioning (xor with 0xffffffff) by storing the conditioned value.
contrib/tools/pngfix.c:   png_uint_32 crc = crc_table[(~value >> 24)] ^ 0xffffff;
contrib/tools/pngfix.c:   crc = crc_table[(crc ^ (value >> 16)) & 0xff] ^ (crc >> 8);
contrib/tools/pngfix.c:   crc = crc_table[(crc ^ (value >> 8)) & 0xff] ^ (crc >> 8);
contrib/tools/pngfix.c:   return crc_table[(crc ^ value) & 0xff] ^ (crc >> 8);
contrib/tools/pngfix.c:   t = (c & ~0x1f1f1f1f) ^ 0x40404040;
contrib/tools/pngfix.c:   return (t & 0xe0e0e0e0) == 0;
contrib/tools/pngfix.c:   struct IDAT_list *next;     /* Linked list */
contrib/tools/pngfix.c:   list->next = NULL;
contrib/tools/pngfix.c:   struct IDAT_list *list = IDAT_list->next;
contrib/tools/pngfix.c:      struct IDAT_list *next = list->next;
contrib/tools/pngfix.c:      list = next;
contrib/tools/pngfix.c:IDAT_list_extend(struct IDAT_list *tail)
contrib/tools/pngfix.c:   struct IDAT_list *next = tail->next;
contrib/tools/pngfix.c:   if (next == NULL)
contrib/tools/pngfix.c:      next = png_voidcast(IDAT_list*, malloc(IDAT_list_size(NULL, length)));
contrib/tools/pngfix.c:      CLEAR(*next);
contrib/tools/pngfix.c:      if (next == NULL)
contrib/tools/pngfix.c:      next->next = NULL;
contrib/tools/pngfix.c:      next->length = length;
contrib/tools/pngfix.c:      tail->next = next;
contrib/tools/pngfix.c:   return next;
contrib/tools/pngfix.c:   png_uint_32    idat_max;         /* 0 to perform no re-chunking */
contrib/tools/pngfix.c:#     define TOO_FAR_BACK   0x01 /* found a too-far-back error */
contrib/tools/pngfix.c:#     define CRC_ERROR      0x02 /* fixed an invalid CRC */
contrib/tools/pngfix.c:#     define STREAM_ERROR   0x04 /* damaged PNG stream (may be fixable) */
contrib/tools/pngfix.c:#     define TRUNCATED      0x08 /* truncated but still readable */
contrib/tools/pngfix.c:#     define FILE_ERROR     0x10 /* could not read the file */
contrib/tools/pngfix.c:#     define WRITE_ERROR    0x20 /* write error (this terminates the read) */
contrib/tools/pngfix.c:#     define INTERNAL_ERROR 0x40 /* internal limits/errors encountered */
contrib/tools/pngfix.c:   global->idat_max      = 0;         /* no re-chunking of IDAT */
contrib/tools/pngfix.c:       * correct interpretation of the pixel values:
contrib/tools/pngfix.c:      case png_fRAc: case png_gIFg: case png_gIFt: case png_gIFx: case png_hIST:
contrib/tools/pngfix.c:    * and data position of the *next* chunk or, right at the start, the
contrib/tools/pngfix.c:    * into the structure and can then be overritten with the data for the next
contrib/tools/pngfix.c:#define UNEXPECTED_ERROR_CODE 7 /* unexpected (internal?) error */
contrib/tools/pngfix.c:      case UNEXPECTED_ERROR_CODE: return "unexpected";
contrib/tools/pngfix.c:      case UNEXPECTED_ERROR_CODE: reason = "unexpected error:";
contrib/tools/pngfix.c:      /* NOTE: this is bitwise |, all the following functions must execute and
contrib/tools/pngfix.c:    * function it will always return a-zA-Z, but the extra codes are just there
contrib/tools/pngfix.c:      return "!abcdefghijklmnopqrstuvwxyz56789"[(v-96)&31];
contrib/tools/pngfix.c:      printf(" ERR %.2x %s ", file->status_code, strcode(code));
contrib/tools/pngfix.c:      /* This is unexpected, so perror it */
contrib/tools/pngfix.c:      /* This is very unexpected; an error message is always output: */
contrib/tools/pngfix.c:      else /* unexpected */
contrib/tools/pngfix.c:    * expected to be there, so EOF should not occur.
contrib/tools/pngfix.c:   /* Read a byte when an error is not expected to happen because the byte has
contrib/tools/pngfix.c:   /* Skip exactly 12 bytes in the input stream - used to skip a CRC and chunk
contrib/tools/pngfix.c:   if (file->width < 1 || file->width > 0x7fffffff)
contrib/tools/pngfix.c:   else if (file->height < 1 || file->height > 0x7fffffff)
contrib/tools/pngfix.c: * This structure is instantiated for each chunk, except for the IDAT chunks
contrib/tools/pngfix.c:      /* This is probably wrong for the excess IDATs case, because then libpng
contrib/tools/pngfix.c:/* The next functions handle special processing for those chunks with LZ data,
contrib/tools/pngfix.c:   /* zTXt and iCCP have exactly the same form - keyword, null, compression
contrib/tools/pngfix.c:   png_uint_32 index = 0;
contrib/tools/pngfix.c:      ++index;
contrib/tools/pngfix.c:         ++index;
contrib/tools/pngfix.c:         return zlib_check(file, index);
contrib/tools/pngfix.c:   png_uint_32 index = 0;
contrib/tools/pngfix.c:      ++index;
contrib/tools/pngfix.c:         ++index;
contrib/tools/pngfix.c:         if (reread_byte(file) == 0) /* uncompressed text */
contrib/tools/pngfix.c:         ++index;
contrib/tools/pngfix.c:            ++index;
contrib/tools/pngfix.c:                  ++index;
contrib/tools/pngfix.c:                     return zlib_check(file, index);
contrib/tools/pngfix.c:   unsigned int      idat_count;     /* And the *current* index into the list */
contrib/tools/pngfix.c:   png_uint_32       idat_index;     /* Index of *next* input byte to write */
contrib/tools/pngfix.c:   /* Return the length for the next IDAT chunk, taking into account
contrib/tools/pngfix.c:   png_uint_32 len = idat->global->idat_max;
contrib/tools/pngfix.c:      if (idat->idat_index == 0) /* at the new chunk (first time) */
contrib/tools/pngfix.c:       * of the next one.
contrib/tools/pngfix.c:      assert(idat->idat_index == idat->idat_length &&
contrib/tools/pngfix.c:      /* Return length of the *next* chunk */
contrib/tools/pngfix.c:      cur = cur->next;
contrib/tools/pngfix.c:      /* The chunk size is the lesser of file->idat_max and the number
contrib/tools/pngfix.c:      png_uint_32 have = idat->idat_length - idat->idat_index;
contrib/tools/pngfix.c:         unsigned int j = idat->idat_count+1; /* the next IDAT in the list */
contrib/tools/pngfix.c:             * individual lengths are always <= 0x7fffffff, so when we add two
contrib/tools/pngfix.c:               cur = cur->next;
contrib/tools/pngfix.c:   /* Process the IDAT stream, this is the more complex than the preceding
contrib/tools/pngfix.c:    * have extent over the whole read of the IDAT stream.  For a PNG this means
contrib/tools/pngfix.c:    * the whole PNG read, for MNG it could have lesser extent.
contrib/tools/pngfix.c:    * recording the length of each because the length may have been fixed up by
contrib/tools/pngfix.c:    * At the end of the list of chunks, where the type of the next chunk is not
contrib/tools/pngfix.c:      list = IDAT_list_extend(list);
contrib/tools/pngfix.c:      /* Move to the next block */
contrib/tools/pngfix.c:   /* And fill in the next IDAT information buffer. */
contrib/tools/pngfix.c:   /* The type of the next chunk was recorded in the file control structure by
contrib/tools/pngfix.c:         type_message(file, png_IDAT, "extra uncompressed data");
contrib/tools/pngfix.c:      idat->idat_index = 0; /* Index into chunk data */
contrib/tools/pngfix.c:   png_uint_32    extra_bytes;   /* Count of extra compressed bytes */
contrib/tools/pngfix.c:      case 3:  return "maximum";
contrib/tools/pngfix.c:zlib_message(struct zlib *zlib, int unexpected)
contrib/tools/pngfix.c:         unexpected ? "unexpected " : "", zlib->rc, zlib_rc(zlib), reason);
contrib/tools/pngfix.c:    * output regardless of the manner of exit.
contrib/tools/pngfix.c:            reason = "TFB"; /* fixing a too-far-back error */
contrib/tools/pngfix.c:         zlib_message(zlib, 1/*unexpected*/);
contrib/tools/pngfix.c:   zlib->z.next_in = Z_NULL;
contrib/tools/pngfix.c:   zlib->z.next_out = Z_NULL;
contrib/tools/pngfix.c:      zlib_message(zlib, 1/*unexpected*/);
contrib/tools/pngfix.c:   zlib->z.next_in = Z_NULL;
contrib/tools/pngfix.c:      zlib_message(zlib, 1/*unexpected*/);
contrib/tools/pngfix.c:max_window_bits(uarbc size, int ndigits)
contrib/tools/pngfix.c:    *     1: saw Z_STREAM_END (zlib->extra_bytes indicates too much data)
contrib/tools/pngfix.c:               /* Check against the existing value - it may not need to be
contrib/tools/pngfix.c:                  bIn = (png_byte)((bIn & 0xf) + ((new_bits-8) << 4));
contrib/tools/pngfix.c:               int b2 = bIn & 0xe0; /* top 3 bits */
contrib/tools/pngfix.c:               b2 += 0x1f - ((zlib->header[0] << 8) + b2) % 0x1f;
contrib/tools/pngfix.c:       * immediately after all output has been flushed on the next input byte.
contrib/tools/pngfix.c:      zlib->z.next_in = &bIn;
contrib/tools/pngfix.c:      zlib->z.next_out = &bOut;
contrib/tools/pngfix.c:      /* NOTE: expression 3 is only evaluted on 'continue', because of the
contrib/tools/pngfix.c:         zlib->z.next_out = &bOut,
contrib/tools/pngfix.c:                * indicating no progress was possible.  This is unexpected.
contrib/tools/pngfix.c:               zlib_message(zlib, 1/*unexpected*/);
contrib/tools/pngfix.c:         chunk_message(chunk, "extra compressed data");
contrib/tools/pngfix.c:      zlib->extra_bytes = nbytes - in_bytes;
contrib/tools/pngfix.c:   /* The 'extra_bytes' field is set by zlib_advance if there is extra
contrib/tools/pngfix.c:   zlib->extra_bytes = 0;
contrib/tools/pngfix.c:            if (skip > 0) /* Skip CRC and next IDAT header */
contrib/tools/pngfix.c:            skip = 12; /* for the next time */
contrib/tools/pngfix.c:                  /* There may be extra chunks; if there are and one of them is
contrib/tools/pngfix.c:                   * not zero length output the 'extra data' message.  Only do
contrib/tools/pngfix.c:                  if (zlib->global->errors && zlib->extra_bytes == 0)
contrib/tools/pngfix.c:                                 "extra compressed data");
contrib/tools/pngfix.c:                        check = check->next;
contrib/tools/pngfix.c:                  list->lengths[i] -= zlib->extra_bytes;
contrib/tools/pngfix.c:         list = list->next;
contrib/tools/pngfix.c:      /* The extra bytes in the chunk are handled now by adjusting the chunk
contrib/tools/pngfix.c:       * length to exclude them; the zlib data is always stored at the end of
contrib/tools/pngfix.c:      chunk->chunk_length -= zlib->extra_bytes;
contrib/tools/pngfix.c:   /* First test the existing (file) window bits: */
contrib/tools/pngfix.c:      int min_bits, max_bits, rc;
contrib/tools/pngfix.c:      /* The first run using the existing window bits. */
contrib/tools/pngfix.c:            max_bits = 15;
contrib/tools/pngfix.c:            max_bits = max_window_bits(zlib.uncompressed_bytes,
contrib/tools/pngfix.c:            if (zlib.ok_bits < max_bits)
contrib/tools/pngfix.c:               max_bits = zlib.ok_bits;
contrib/tools/pngfix.c:            zlib_message(&zlib, 0/*expected*/);
contrib/tools/pngfix.c:      /* Optimize window bits or fix a too-far-back error.  min_bits and
contrib/tools/pngfix.c:       * max_bits have been set appropriately, ok_bits records the bit value
contrib/tools/pngfix.c:      while (min_bits < max_bits || max_bits < zlib.ok_bits/*if 16*/)
contrib/tools/pngfix.c:         int test_bits = (min_bits + max_bits) >> 1;
contrib/tools/pngfix.c:                  if (min_bits > max_bits)
contrib/tools/pngfix.c:                  max_bits = test_bits;
contrib/tools/pngfix.c:      assert(zlib.ok_bits == max_bits);
contrib/tools/pngfix.c:/* The strategy here is to run a regular libpng PNG file read but examine the
contrib/tools/pngfix.c: * the state we expect libpng to be in.  Warning and error callbacks are also
contrib/tools/pngfix.c: * hope that this can be fixed in the next version of libpng.
contrib/tools/pngfix.c: * which is pretty much everything except the 'zlib' control structure.
contrib/tools/pngfix.c: * called via a call to read_chunk and only exit at a return from process_chunk.
contrib/tools/pngfix.c:process_chunk(struct file *file, png_uint_32 file_crc, png_uint_32 next_length,
contrib/tools/pngfix.c:   png_uint_32 next_type)
contrib/tools/pngfix.c:   /* Called when the chunk data has been read, next_length and next_type
contrib/tools/pngfix.c:    * will be set for the next chunk (or 0 if this is IEND).
contrib/tools/pngfix.c:    * next chunk to write because if a chunk is skipped this return calls back
contrib/tools/pngfix.c:      fprintf(stderr, " %lu 0x%.8x 0x%.8x\n", (unsigned long)file->length,
contrib/tools/pngfix.c:         file->crc ^ 0xffffffff, file_crc);
contrib/tools/pngfix.c:   if ((file->crc ^ 0xffffffff) != file_crc)
contrib/tools/pngfix.c:   /* Record the 'next' information too, now that the original values for
contrib/tools/pngfix.c:   file->length = next_length;
contrib/tools/pngfix.c:   file->type = next_type;
contrib/tools/pngfix.c:         assert(next_type == png_IDAT);
contrib/tools/pngfix.c:    * the IDAT stream has not yet been reached and we must handle the next
contrib/tools/pngfix.c:    * next one.
contrib/tools/pngfix.c:   file->length = next_length;
contrib/tools/pngfix.c:   file->type = next_type;
contrib/tools/pngfix.c:    * header.  Executes stop on a fatal error, otherwise calls process_chunk.
contrib/tools/pngfix.c:       * bytes.  Each time a match is found check the next 8 bytes for a valid
contrib/tools/pngfix.c:      for (length=0; length <= 0x7fffffff; ++length)
contrib/tools/pngfix.c:         if ((crc ^ 0xffffffff) == file_crc)
contrib/tools/pngfix.c:             * else expect a following chunk header.
contrib/tools/pngfix.c:               /* Examine the 8 bytes for a valid chunk header. */
contrib/tools/pngfix.c:                  png_uint_32 next_length = get32(buffer, nused);
contrib/tools/pngfix.c:                  if (next_length < 0x7fffffff)
contrib/tools/pngfix.c:                     png_uint_32 next_type = get32(buffer, nused+4);
contrib/tools/pngfix.c:                     if (chunk_type_valid(next_type))
contrib/tools/pngfix.c:                        process_chunk(file, file_crc, next_length, next_type);
contrib/tools/pngfix.c:          * the code will always read ahead exactly 8 bytes and pass this on to
contrib/tools/pngfix.c:          * after the IEND CRC and other chunk leave it after the *next* chunk
contrib/tools/pngfix.c:      /* Control gets to here if when 0x7fffffff bytes (plus 8) have been read,
contrib/tools/pngfix.c:            png_uint_32 next_length;
contrib/tools/pngfix.c:            nread += read_4(file, &next_length);
contrib/tools/pngfix.c:            if (nread == 8 && next_length <= 0x7fffffff)
contrib/tools/pngfix.c:               png_uint_32 next_type;
contrib/tools/pngfix.c:               nread += read_4(file, &next_type);
contrib/tools/pngfix.c:               if (nread == 12 && chunk_type_valid(next_type))
contrib/tools/pngfix.c:                  process_chunk(file, file_crc, next_length, next_type);
contrib/tools/pngfix.c:    * way.  Either there was a problem reading all the expected data (this
contrib/tools/pngfix.c:    * chunk's data, its CRC and the length and type of the next chunk) or the
contrib/tools/pngfix.c:    * next chunk length/type are invalid.  Notice that the cases that end up
contrib/tools/pngfix.c:    * executed once for the signature and once for the first chunk right at the
contrib/tools/pngfix.c:         /* The first chunk must be a well formed IHDR (this could be relaxed to
contrib/tools/pngfix.c:       * next_ fields will refer to the chunk after the last IDAT.
contrib/tools/pngfix.c:                * the file.  The only exception is for that part of a
contrib/tools/pngfix.c:                     while (idat->idat_index >= idat->idat_length)
contrib/tools/pngfix.c:                        assert(idat->idat_index == idat->idat_length);
contrib/tools/pngfix.c:                           /* Move on to the next IDAT_list: */
contrib/tools/pngfix.c:                           cur = cur->next;
contrib/tools/pngfix.c:                        idat->idat_index = 0;
contrib/tools/pngfix.c:                        /* And skip 12 bytes to the next chunk data */
contrib/tools/pngfix.c:                     /* The index is always that of the next byte, the rest of
contrib/tools/pngfix.c:                     ++(idat->idat_index);
contrib/tools/pngfix.c:                     fprintf(stderr, " %lu 0x%.8x\n", (unsigned long)length,
contrib/tools/pngfix.c:                        chunk->write_crc ^ 0xffffffff);
contrib/tools/pngfix.c:                     (file->idat->idat_index < file->idat->idat_length ||
contrib/tools/pngfix.c:                     /* This is the last byte so reset chunk_read for the next
contrib/tools/pngfix.c:                      * *next* chunk header if required.
contrib/tools/pngfix.c:                  b ^= 0xff; /* conditioning */
contrib/tools/pngfix.c:      b &= 0xff;
contrib/tools/pngfix.c:    * don't always exist.
contrib/tools/pngfix.c:      /* This is not really expected. */
contrib/tools/pngfix.c:"  Tests, optimizes and optionally fixes the zlib header in PNG files.",
contrib/tools/pngfix.c:"  Optionally, when fixing, strips ancilliary chunks from the file.",
contrib/tools/pngfix.c:"                is modified.  This is set automatically if --max is given but",
contrib/tools/pngfix.c:"      chunks are never removed as they affect exact interpretation of the",
contrib/tools/pngfix.c:"      image pixel values.  The following known chunks are treated specially",
contrib/tools/pngfix.c:"        gAMA, sRGB [all]: These specify the gamma encoding used for the pixel",
contrib/tools/pngfix.c:"            specifies the exact encoding of a pixel value however in practice",
contrib/tools/pngfix.c:"    --max=<number>:",
contrib/tools/pngfix.c:"      chunks will be the maximum size permitted; 2^31-1 bytes.  If the option",
contrib/tools/pngfix.c:"      that have ever been formally proposed as PNG extensions.",
contrib/tools/pngfix.c:"      Do not output the summaries except for files which cannot be read. With",
contrib/tools/pngfix.c:"      Output errors from libpng and the program (except too-far-back).",
contrib/tools/pngfix.c:"      Write the optimized/corrected version of the next PNG to <file>.  This",
contrib/tools/pngfix.c:"    --suffix=<suffix>:",
contrib/tools/pngfix.c:"      Set --out=<name><suffix> for all following files unless overridden on",
contrib/tools/pngfix.c:"      a per-file basis by explicit --out.",
contrib/tools/pngfix.c:"    --prefix=<prefix>:",
contrib/tools/pngfix.c:"      Set --out=<prefix><name> for all the following files unless overridden",
contrib/tools/pngfix.c:"      on a per-file basis by explicit --out.",
contrib/tools/pngfix.c:"      These two options can be used together to produce a suffix and prefix.",
contrib/tools/pngfix.c:"  The program exit code is value in the range 0..127 holding a bit mask of",
contrib/tools/pngfix.c:"    0x01: The zlib too-far-back error existed in at least one chunk.",
contrib/tools/pngfix.c:"    0x02: At least once chunk had a CRC error.",
contrib/tools/pngfix.c:"    0x04: A chunk length was incorrect.",
contrib/tools/pngfix.c:"    0x08: The file was truncated.",
contrib/tools/pngfix.c:"  exit code is less than 16 the file could be read (with corrections if a",
contrib/tools/pngfix.c:"    0x10: The file could not be read, even with corrections.",
contrib/tools/pngfix.c:"    0x20: The output file could not be written.",
contrib/tools/pngfix.c:"    0x40: An unexpected, potentially internal, error occured.",
contrib/tools/pngfix.c:"  If the command line arguments are incorrect the program exits with exit",
contrib/tools/pngfix.c:"  255.  Some older operating systems only support 7-bit exit codes, on those",
contrib/tools/pngfix.c:"  not output and the program just returns an exit code and prints a summary.",
contrib/tools/pngfix.c:"  program only outputs unexpected errors (internal errors and file open",
contrib/tools/pngfix.c:"  Various known problems in PNG files are fixed while the file is being read",
contrib/tools/pngfix.c:"  The exit code says what problems were fixed.  In particular the zlib error:",
contrib/tools/pngfix.c:"  caused by an incorrect optimization of a zlib stream is fixed in any",
contrib/tools/pngfix.c:"  is also fixed.  Chunk CRC errors are automatically fixed up.",
contrib/tools/pngfix.c:"          CHK: A zlib header checksum was detected and fixed.",
contrib/tools/pngfix.c:"          TFB: The zlib too far back error was detected and fixed.",
contrib/tools/pngfix.c:"               explanation 'message'",
contrib/tools/pngfix.c:"          ERR: The read of the file was aborted.  The parameters explain why.",
contrib/tools/pngfix.c:"               This is printed as a 2 digit hexadecimal value",
contrib/tools/pngfix.c:"               expressed as a string {supfast,stdfast,default,maximum}",
contrib/tools/pngfix.c:"$4 code:       The file exit code; where stop was called, as a fairly terse",
contrib/tools/pngfix.c:"               string {warning,libpng,zlib,invalid,read,write,unexpected}.",
contrib/tools/pngfix.c:   exit(255);
contrib/tools/pngfix.c:   const char *  suffix = NULL;
contrib/tools/pngfix.c:   const char *  prefix = NULL;
contrib/tools/pngfix.c:      else if (strncmp(*argv, "--max=", 6) == 0)
contrib/tools/pngfix.c:         global.idat_max = (png_uint_32)atol(6+*argv);
contrib/tools/pngfix.c:      else if (strcmp(*argv, "--max") == 0)
contrib/tools/pngfix.c:         global.idat_max = 0x7fffffff;
contrib/tools/pngfix.c:      else if (strncmp(*argv, "--suffix=", 9) == 0)
contrib/tools/pngfix.c:         suffix = 9+*argv;
contrib/tools/pngfix.c:      else if (strncmp(*argv, "--prefix=", 9) == 0)
contrib/tools/pngfix.c:         prefix = 9+*argv;
contrib/tools/pngfix.c:            /* Consider the prefix/suffix options */
contrib/tools/pngfix.c:            if (prefix != NULL)
contrib/tools/pngfix.c:               size_t prefixlen = strlen(prefix);
contrib/tools/pngfix.c:               if (prefixlen+outlen > FILENAME_MAX)
contrib/tools/pngfix.c:                     prog, prefix, *argv, suffix ? suffix : "");
contrib/tools/pngfix.c:               memcpy(temp_name, prefix, prefixlen);
contrib/tools/pngfix.c:               memcpy(temp_name+prefixlen, *argv, outlen);
contrib/tools/pngfix.c:               outlen += prefixlen;
contrib/tools/pngfix.c:            else if (suffix != NULL)
contrib/tools/pngfix.c:            if (suffix != NULL)
contrib/tools/pngfix.c:               size_t suffixlen = strlen(suffix);
contrib/tools/pngfix.c:               if (outlen+suffixlen > FILENAME_MAX)
contrib/tools/pngfix.c:                     prog, *argv, suffix);
contrib/tools/pngfix.c:               memcpy(temp_name+outlen, suffix, suffixlen);
contrib/tools/pngfix.c:               outlen += suffixlen;
contrib/tools/pngfix.c:#else /* ZLIB_VERNUM < 0x1240 */
contrib/tools/pngfix.c:      "pngfix needs libpng with a zlib >=1.2.4 (not 0x%x)\n",
contrib/tools/pngfix.c:   fprintf(stderr, "pngfix does not work without read support\n");
contrib/tools/pngfix.c:   fprintf(stderr, "pngfix does not work without setjmp support\n");
contrib/tools/checksum-icc.c:   printf("PNG_ICC_CHECKSUM(0x%8.8lx, 0x%8.8lx,\n   PNG_MD5("
contrib/tools/checksum-icc.c:      "0x%2.2x%2.2x%2.2x%2.2x, 0x%2.2x%2.2x%2.2x%2.2x, 0x%2.2x%2.2x%2.2x%2.2x,"
contrib/tools/checksum-icc.c:      " 0x%2.2x%2.2x%2.2x%2.2x), %d,\n"
contrib/tools/checksum-icc.c:#     define u16(x) (header[x] * 256 + header[x+1])
contrib/tools/checksum-icc.c:#     define u32(x) (u16(x) * 65536 + u16(x+2))
Binary file contrib/tools/png-fix-itxt.o matches
contrib/tools/.deps/pngfix.Po:contrib/tools/pngfix.o: contrib/tools/pngfix.c \
contrib/tools/.deps/pngfix.Po:  /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/sys/_posix_availability.h \
contrib/tools/.deps/pngfix.Po:  /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/machine/_mcontext.h \
contrib/tools/.deps/pngfix.Po:  /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/i386/_mcontext.h \
contrib/tools/.deps/pngfix.Po:  /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/sys/_types/_ucontext.h \
contrib/tools/.deps/pngfix.Po:  /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/6.0/include/stdint.h \
contrib/tools/.deps/pngfix.Po:  /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/_types/_intmax_t.h \
contrib/tools/.deps/pngfix.Po:  /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/_types/_uintmax_t.h \
contrib/tools/.deps/pngfix.Po:  /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/6.0/include/limits.h \
contrib/tools/.deps/pngfix.Po:  /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/6.0/include/stddef.h \
contrib/tools/.deps/pngfix.Po:  /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/sys/_pthread/_pthread_mutex_t.h \
contrib/tools/.deps/pngfix.Po:  /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/sys/_pthread/_pthread_mutexattr_t.h \
contrib/tools/.deps/pngfix.Po:  /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/sys/_types/_posix_vdisable.h \
contrib/tools/.deps/pngfix.Po:/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/sys/_posix_availability.h:
contrib/tools/.deps/pngfix.Po:/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/machine/_mcontext.h:
contrib/tools/.deps/pngfix.Po:/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/i386/_mcontext.h:
contrib/tools/.deps/pngfix.Po:/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/sys/_types/_ucontext.h:
contrib/tools/.deps/pngfix.Po:/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/6.0/include/stdint.h:
contrib/tools/.deps/pngfix.Po:/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/_types/_intmax_t.h:
contrib/tools/.deps/pngfix.Po:/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/_types/_uintmax_t.h:
contrib/tools/.deps/pngfix.Po:/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/6.0/include/limits.h:
contrib/tools/.deps/pngfix.Po:/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../lib/clang/6.0/include/stddef.h:
contrib/tools/.deps/pngfix.Po:/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/sys/_pthread/_pthread_mutex_t.h:
contrib/tools/.deps/pngfix.Po:/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/sys/_pthread/_pthread_mutexattr_t.h:
contrib/tools/.deps/pngfix.Po:/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/sys/_types/_posix_vdisable.h:
contrib/tools/.deps/png-fix-itxt.Po:contrib/tools/png-fix-itxt.o: contrib/tools/png-fix-itxt.c \
contrib/tools/.deps/png-fix-itxt.Po:  /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/sys/_posix_availability.h \
contrib/tools/.deps/png-fix-itxt.Po:  /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/sys/_pthread/_pthread_mutex_t.h \
contrib/tools/.deps/png-fix-itxt.Po:  /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/sys/_pthread/_pthread_mutexattr_t.h \
contrib/tools/.deps/png-fix-itxt.Po:  /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/sys/_types/_posix_vdisable.h \
contrib/tools/.deps/png-fix-itxt.Po:/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/sys/_posix_availability.h:
contrib/tools/.deps/png-fix-itxt.Po:/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/sys/_pthread/_pthread_mutex_t.h:
contrib/tools/.deps/png-fix-itxt.Po:/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/sys/_pthread/_pthread_mutexattr_t.h:
contrib/tools/.deps/png-fix-itxt.Po:/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.10.sdk/usr/include/sys/_types/_posix_vdisable.h:
Binary file contrib/tools/pngfix.o matches
contrib/tools/README.txt:To the extent possible under law, the authors have waived all copyright and
contrib/tools/cvtcolor.c: * To the extent possible under law, the author has waived all copyright and
contrib/tools/cvtcolor.c:   exit(1);
contrib/tools/cvtcolor.c:    * everything rounds to the nearest value except that '.5' rounds to the
contrib/tools/sRGB.h: * To the extent possible under law, the author has waived all copyright and
contrib/tools/png-fix-itxt.c:/* png-fix-itxt version 1.0.0
contrib/tools/png-fix-itxt.c: *     png-fix-itxt.exe < bad.png > good.png
contrib/tools/png-fix-itxt.c: * Fixes a PNG file written with libpng-1.6.0 or 1.6.1 that has one or more
contrib/tools/png-fix-itxt.c: *     gcc -O -o png-fix-itxt png-fix-itxt.c -lz
contrib/tools/png-fix-itxt.c: * rebuild png-fix-itxt with a larger values of MAX_LENGTH (or a smaller value
contrib/tools/png-fix-itxt.c:   /* The iTXt chunk type expressed as integers is (105, 84, 88, 116) */
contrib/tools/png-fix-itxt.c:        if (((crc >> 24) & 0xff) == buf[length+8] &&
contrib/tools/png-fix-itxt.c:            ((crc >> 16) & 0xff) == buf[length+9] &&
contrib/tools/png-fix-itxt.c:            ((crc >>  8) & 0xff) == buf[length+10] &&
contrib/tools/png-fix-itxt.c:            ((crc      ) & 0xff) == buf[length+11])
contrib/tools/png-fix-itxt.c:      buf[0] = (unsigned char)((length << 24) & 0xff);
contrib/tools/png-fix-itxt.c:      buf[1] = (unsigned char)((length << 16) & 0xff);
contrib/tools/png-fix-itxt.c:      buf[2] = (unsigned char)((length <<  8) & 0xff);
contrib/tools/png-fix-itxt.c:      buf[3] = (unsigned char)((length      ) & 0xff);
contrib/tools/png-fix-itxt.c:      /* Write the fixed iTXt chunk (length, name, data, crc) */
contrib/tools/png-fix-itxt.c:   /* The IEND chunk type expressed as integers is (73, 69, 78, 68) */
contrib/tools/makesRGB.c: * To the extent possible under law, the author has waived all copyright and
contrib/tools/makesRGB.c: * approximation to the 8-bit sRGB encoded value.  Calculate the error in these
contrib/tools/makesRGB.c:static const unsigned int max_input = 255*65535;
contrib/tools/makesRGB.c:   return sRGB_from_linear(l/max_input);
contrib/tools/makesRGB.c:   unsigned int x = nearbyint(finvsRGB(i));
contrib/tools/makesRGB.c:   if (x > 65535)
contrib/tools/makesRGB.c:      fprintf(stderr, "invsRGB(%u) overflows to %u\n", i, x);
contrib/tools/makesRGB.c:      exit(1);
contrib/tools/makesRGB.c:   return (png_uint_16)x;
contrib/tools/makesRGB.c:   double max_error = 0;
contrib/tools/makesRGB.c:   double max_error16 = 0;
contrib/tools/makesRGB.c:         exit(1);
contrib/tools/makesRGB.c:            fprintf(stderr, "table[%d][0]: overflow %08x (%d)\n", i, calc,
contrib/tools/makesRGB.c:            exit(1);
contrib/tools/makesRGB.c:            fprintf(stderr, "table[%d][1]: overflow %08x (%d)\n", i, calc,
contrib/tools/makesRGB.c:            exit(1);
contrib/tools/makesRGB.c:         unsigned int iexact = nearbyint(255*sRGB(i));
contrib/tools/makesRGB.c:         if (icalc != iexact)
contrib/tools/makesRGB.c:            unsigned int iexact = nearbyint(255*sRGB(i));
contrib/tools/makesRGB.c:            if (icalc != iexact)
contrib/tools/makesRGB.c:               exit(1);
contrib/tools/makesRGB.c:   max_error = .4999;
contrib/tools/makesRGB.c:   for (i=0; i <= max_input; ++i)
contrib/tools/makesRGB.c:      unsigned int iexact = nearbyint(255*sRGB(i));
contrib/tools/makesRGB.c:      if (icalc != iexact)
contrib/tools/makesRGB.c:         if (err > (max_error+.001) || err < (min_error-.001))
contrib/tools/makesRGB.c:               "/* 0x%08x: exact: %3d, got: %3d [tables: %08x, %08x] (%f) */\n",
contrib/tools/makesRGB.c:               i, iexact, icalc, png_sRGB_base[i>>15],
contrib/tools/makesRGB.c:         if (err > max_error)
contrib/tools/makesRGB.c:            max_error = err;
contrib/tools/makesRGB.c:   max_error16 = 0;
contrib/tools/makesRGB.c:      unsigned int iexact = nearbyint(255*sRGB(i));
contrib/tools/makesRGB.c:      if (icalc != iexact)
contrib/tools/makesRGB.c:         if (err > max_error16)
contrib/tools/makesRGB.c:            max_error16 = err;
contrib/tools/makesRGB.c:         if (abs(icalc - iexact) > 1)
contrib/tools/makesRGB.c:               "/* 0x%04x: exact: %3d, got: %3d [tables: %08x, %08x] (%f) */\n",
contrib/tools/makesRGB.c:               i16, iexact, icalc, png_sRGB_base[i>>15],
contrib/tools/makesRGB.c:      unsigned int iexact = nearbyint(255*sRGB(i));
contrib/tools/makesRGB.c:      if (i16 != iexact)
contrib/tools/makesRGB.c:         fprintf(stderr, "8-bit rounding error: %d -> %d\n", i16, iexact);
contrib/tools/makesRGB.c:         exit(1);
contrib/tools/makesRGB.c:   printf("/* error: %g - %g, %u (%g%%) of readings inexact */\n",
contrib/tools/makesRGB.c:      min_error, max_error, error_count, (100.*error_count)/max_input);
contrib/tools/makesRGB.c:   printf("/* 16-bit error: %g - %g, %u (%g%%) of readings inexact */\n",
contrib/tools/makesRGB.c:      min_error16, max_error16, error_count16, (100.*error_count16)/65535);
contrib/tools/makesRGB.c:         while ((i & 0x7) != 0 && i<255);
contrib/tools/makesRGB.c:         while ((i & 0x7) != 0 && i<511);
contrib/tools/makesRGB.c:         while ((i & 0xf) != 0 && i<511);
contrib/tools/chkfmt:# line length of 80 characters max and no tab characters.
contrib/tools/chkfmt:# -v: output the long lines (makes fixing them easier)
contrib/tools/chkfmt:      exec 3>&0 4>&1 5>&2
contrib/tools/chkfmt:      exit 1
contrib/tools/chkfmt:   "$EDITOR" "$file" 0>&3 1>&4 2>&5 3>&- 4>&- 5>&- || exit 1
contrib/tools/chkfmt:   ! -name '*.jpg' ! -name '*.patch' ! -name '*.obj' ! -name '*.exe' \
contrib/tools/chkfmt:            doed "$file" || exit 1
contrib/tools/chkfmt:               doed "$file" || exit 1
contrib/tools/chkfmt:   exit $st
contrib/pngminim/encoder/pngusr.dfa:# You must choose fixed or floating point arithmetic:
contrib/pngminim/encoder/pngusr.dfa:# You must chose the internal fixed point implementation or to
contrib/pngminim/encoder/pngusr.dfa:# smaller (by about 1kbyte on an x86 system):
contrib/pngminim/encoder/pngusr.dfa:# Your program will probably need other options.  The example
contrib/pngminim/encoder/makefile:# Linux / Unix
contrib/pngminim/encoder/makefile:	    $(COPY) $(ZLIBSRC)/$$f $@ && exit 0;\
contrib/pngminim/encoder/makefile:	done; echo copy: $(ZLIBSRC)/zconf.h not found; exit 1
contrib/pngminim/README:See the individual README and pngusr.dfa files for more explanation.
contrib/pngminim/decoder/pngusr.dfa:# All that is required is some read code. This example switches
contrib/pngminim/decoder/pngusr.dfa:# read example).
contrib/pngminim/decoder/pngusr.dfa:# You must choose fixed or floating point arithmetic:
contrib/pngminim/decoder/pngusr.dfa:# You must chose the internal fixed point implementation or to
contrib/pngminim/decoder/pngusr.dfa:# smaller (by about 1kbyte on an x86 system):
contrib/pngminim/decoder/pngusr.dfa:# Your program will probably need other options.  The example
contrib/pngminim/decoder/makefile:# Linux / Unix
contrib/pngminim/decoder/makefile:ZH     = zlib.h crc32.h inffast.h inffixed.h \
contrib/pngminim/decoder/makefile:	    $(COPY) $(ZLIBSRC)/$$f $@ && exit 0;\
contrib/pngminim/decoder/makefile:	done; echo copy: $(ZLIBSRC)/zconf.h not found; exit 1
contrib/pngminim/preader/README:and build the rpng2-x application there.
contrib/pngminim/preader/pngusr.dfa:# You may choose fixed or floating point APIs:
contrib/pngminim/preader/pngusr.dfa:# You must chose the internal fixed point implementation or to
contrib/pngminim/preader/pngusr.dfa:# smaller (by about 1kbyte on an x86 system):
contrib/pngminim/preader/pngusr.dfa:# Your program will probably need other options.  The example
contrib/pngminim/preader/pngusr.dfa:# program here, rpng2-x, requires the following.  Take a look
contrib/pngminim/preader/makefile:# Linux / Unix
contrib/pngminim/preader/makefile:ZH     = zlib.h crc32.h inffast.h inffixed.h \
contrib/pngminim/preader/makefile:PROGSRCS= rpng2-x$(C) readpng2$(C)
contrib/pngminim/preader/makefile:PROGOBJS= rpng2-x$(O) readpng2$(O)
contrib/pngminim/preader/makefile:all: $(PROGDOCS) rpng2-x$(E)
contrib/pngminim/preader/makefile:rpng2-x$(E): $(OBJS)
contrib/pngminim/preader/makefile:	$(LD) -o rpng2-x$(E) $(OBJS) $(LIBS)
contrib/pngminim/preader/makefile:	$(RM) rpng2-x$(O)
contrib/pngminim/preader/makefile:	$(RM) rpng2-x$(E)
contrib/pngminim/preader/makefile:	    $(COPY) $(ZLIBSRC)/$$f $@ && exit 0;\
contrib/pngminim/preader/makefile:	done; echo copy: $(ZLIBSRC)/zconf.h not found; exit 1
contrib/pngminim/preader/makefile:# End of makefile for rpng2-x
contrib/examples/README.txt:This directory (contrib/examples) contains examples of libpng usage.
contrib/examples/README.txt:To the extent possible under law, the authors have waived all copyright and
contrib/examples/pngpixel.c:/*- pngpixel
contrib/examples/pngpixel.c: * To the extent possible under law, the author has waived all copyright and
contrib/examples/pngpixel.c: * Read a single pixel value from a PNG file.
contrib/examples/pngpixel.c: * Rows are read until a particular pixel is found; the value of this pixel is
contrib/examples/pngpixel.c: * interlace passes directly looking for the required pixel.
contrib/examples/pngpixel.c:/* Return component 'c' of pixel 'x' from the given row. */
contrib/examples/pngpixel.c:component(png_const_bytep row, png_uint_32 x, unsigned int c,
contrib/examples/pngpixel.c:   /* PNG images can be up to 2^31 pixels wide, but this means they can be up to
contrib/examples/pngpixel.c:    * 2^37 bits wide (for a 64-bit pixel - the largest possible) and hence 2^34
contrib/examples/pngpixel.c:   png_uint_32 bit_offset_hi = bit_depth * ((x >> 6) * channels);
contrib/examples/pngpixel.c:   png_uint_32 bit_offset_lo = bit_depth * ((x & 0x3f) * channels + c);
contrib/examples/pngpixel.c:   bit_offset_lo &= 0x07;
contrib/examples/pngpixel.c:   /* PNG pixels are packed into bytes to put the first pixel in the highest
contrib/examples/pngpixel.c:      case 1: return (row[0] >> (7-bit_offset_lo)) & 0x01;
contrib/examples/pngpixel.c:      case 2: return (row[0] >> (6-bit_offset_lo)) & 0x03;
contrib/examples/pngpixel.c:      case 4: return (row[0] >> (4-bit_offset_lo)) & 0x0f;
contrib/examples/pngpixel.c:         fprintf(stderr, "pngpixel: invalid bit depth %u\n", bit_depth);
contrib/examples/pngpixel.c:         exit(1);
contrib/examples/pngpixel.c:/* Print a pixel from a row returned by libpng; determine the row format, find
contrib/examples/pngpixel.c: * the pixel, and print the relevant information to stdout.
contrib/examples/pngpixel.c:print_pixel(png_structp png_ptr, png_infop info_ptr, png_const_bytep row,
contrib/examples/pngpixel.c:   png_uint_32 x)
contrib/examples/pngpixel.c:         printf("GRAY %u\n", component(row, x, 0, bit_depth, 1));
contrib/examples/pngpixel.c:            PNG_CONST unsigned int index = component(row, x, 0, bit_depth, 1);
contrib/examples/pngpixel.c:                  printf("INDEXED %u = %d %d %d %d\n", index,
contrib/examples/pngpixel.c:                     palette[index].red, palette[index].green,
contrib/examples/pngpixel.c:                     palette[index].blue,
contrib/examples/pngpixel.c:                     index < num_trans ? trans_alpha[index] : 255);
contrib/examples/pngpixel.c:                  printf("INDEXED %u = %d %d %d\n", index,
contrib/examples/pngpixel.c:                     palette[index].red, palette[index].green,
contrib/examples/pngpixel.c:                     palette[index].blue);
contrib/examples/pngpixel.c:               printf("INDEXED %u = invalid index\n", index);
contrib/examples/pngpixel.c:         printf("RGB %u %u %u\n", component(row, x, 0, bit_depth, 3),
contrib/examples/pngpixel.c:            component(row, x, 1, bit_depth, 3),
contrib/examples/pngpixel.c:            component(row, x, 2, bit_depth, 3));
contrib/examples/pngpixel.c:         printf("GRAY+ALPHA %u %u\n", component(row, x, 0, bit_depth, 2),
contrib/examples/pngpixel.c:            component(row, x, 1, bit_depth, 2));
contrib/examples/pngpixel.c:         printf("RGBA %u %u %u %u\n", component(row, x, 0, bit_depth, 4),
contrib/examples/pngpixel.c:            component(row, x, 1, bit_depth, 4),
contrib/examples/pngpixel.c:            component(row, x, 2, bit_depth, 4),
contrib/examples/pngpixel.c:            component(row, x, 3, bit_depth, 4));
contrib/examples/pngpixel.c:         png_error(png_ptr, "pngpixel: invalid color type");
contrib/examples/pngpixel.c:    * mechanism, therefore any local variable that exists before the call to
contrib/examples/pngpixel.c:      long x = atol(argv[1]);
contrib/examples/pngpixel.c:                   * all the information up to the first pixel.
contrib/examples/pngpixel.c:                           png_error(png_ptr, "pngpixel: unknown interlace");
contrib/examples/pngpixel.c:                     /* Now read the pixels, pass-by-pass, row-by-row: */
contrib/examples/pngpixel.c:                        png_uint_32 ystart, xstart, ystep, xstep;
contrib/examples/pngpixel.c:                            * expects to be called for each row that is
contrib/examples/pngpixel.c:                           /* We need the starting pixel and the offset
contrib/examples/pngpixel.c:                            * between each pixel in this pass; use the macros
contrib/examples/pngpixel.c:                           xstart = PNG_PASS_START_COL(pass);
contrib/examples/pngpixel.c:                           xstep = PNG_PASS_COL_OFFSET(pass);
contrib/examples/pngpixel.c:                           ystart = xstart = 0;
contrib/examples/pngpixel.c:                           ystep = xstep = 1;
contrib/examples/pngpixel.c:                        /* To find the pixel, loop over 'py' for each pass
contrib/examples/pngpixel.c:                         * contains the pixel.
contrib/examples/pngpixel.c:                           png_uint_32 px, ppx;
contrib/examples/pngpixel.c:                            * pixel-by-pixel, and the second receives the same
contrib/examples/pngpixel.c:                            * pixels but they are replicated across the
contrib/examples/pngpixel.c:                            * unwritten pixels so far for each pass.  When we
contrib/examples/pngpixel.c:                            * the pixels from the interlace pass - giving
contrib/examples/pngpixel.c:                           /* Now find the pixel if it is in this row; there
contrib/examples/pngpixel.c:                           if (y == py) for (px = xstart, ppx = 0;
contrib/examples/pngpixel.c:                              px < width; px += xstep, ++ppx) if (x == px)
contrib/examples/pngpixel.c:                              /* 'ppx' is the index of the pixel in the row
contrib/examples/pngpixel.c:                              print_pixel(png_ptr, info_ptr, row_tmp, ppx);
contrib/examples/pngpixel.c:                           } /* x loop */
contrib/examples/pngpixel.c:                     png_error(png_ptr, "pngpixel: png_get_IHDR failed");
contrib/examples/pngpixel.c:               fprintf(stderr, "pngpixel: out of memory allocating png_info\n");
contrib/examples/pngpixel.c:            fprintf(stderr, "pngpixel: out of memory allocating png_struct\n");
contrib/examples/pngpixel.c:         fprintf(stderr, "pngpixel: %s: could not open file\n", argv[3]);
contrib/examples/pngpixel.c:      fprintf(stderr, "pngpixel: usage: pngpixel x y png-file\n");
contrib/examples/iccfrompng.c: * To the extent possible under law, the author has waived all copyright and
contrib/examples/iccfrompng.c: * Extract any icc profiles found in the given PNG files.  This is a simple
contrib/examples/iccfrompng.c: * example of a program that extracts information from the header of a PNG file
contrib/examples/iccfrompng.c: * after the image data. Textual data and comments are an example; the approach
contrib/examples/iccfrompng.c: * extracted to a similarly named file with the extension replaced by 'icc',
contrib/examples/iccfrompng.c:extract(FILE *fp, png_uint_32 *proflen)
contrib/examples/iccfrompng.c:extract_one_file(const char *filename)
contrib/examples/iccfrompng.c:      png_bytep profile = extract(fp, &proflen);
contrib/examples/iccfrompng.c:   int extracted = 0;
contrib/examples/iccfrompng.c:      else if (extract_one_file(argv[i]))
contrib/examples/iccfrompng.c:         extracted = 1;
contrib/examples/iccfrompng.c:   /* Exit code is true if any extract succeeds */
contrib/examples/iccfrompng.c:   return extracted == 0;
contrib/examples/pngtopng.c: * To the extent possible under law, the author has waived all copyright and
contrib/examples/pngtopng.c: * Read a PNG and write it out in a fixed format, using the 'simplified API'
contrib/examples/pngtopng.c: * This sample code is just the code from the top of 'example.c' with some error
contrib/examples/pngtopng.c: * handling added.  See example.c for more comments.
Binary file contrib/pngsuite/ftp1n3p08.png matches
Binary file contrib/pngsuite/basn3p08.png matches
Binary file contrib/pngsuite/basn0g01.png matches
Binary file contrib/pngsuite/ftp0n2c08.png matches
Binary file contrib/pngsuite/ftbrn2c08.png matches
Binary file contrib/pngsuite/ftbgn3p08.png matches
Binary file contrib/pngsuite/ftbbn2c16.png matches
Binary file contrib/pngsuite/ftbbn3p08.png matches
Binary file contrib/pngsuite/ftbyn3p08.png matches
Binary file contrib/pngsuite/ftbbn0g04.png matches
Binary file contrib/pngsuite/ftp0n0g08.png matches
Binary file contrib/pngsuite/ftp0n3p08.png matches
Binary file contrib/pngsuite/ftbbn0g02.png matches
Binary file contrib/pngsuite/basn6a16.png matches
Binary file contrib/pngsuite/ftbwn3p08.png matches
Binary file contrib/pngsuite/ftbgn2c16.png matches
Binary file contrib/pngsuite/ftbwn0g16.png matches
Binary file contrib/pngsuite/basn4a16.png matches
Binary file contrib/pngsuite/basn6a08.png matches
Binary file contrib/pngsuite/basn2c08.png matches
contrib/arm-neon/linux-auxv.c:/* contrib/arm-neon/linux-auxv.c
contrib/arm-neon/linux-auxv.c: * png_have_neon implemented for Linux versions which allow access to
contrib/arm-neon/linux-auxv.c: * /proc/self/auxv.  This is probably faster, cleaner and safer than the code to
contrib/arm-neon/linux-auxv.c: * read /proc/cpuinfo in contrib/arm-neon/linux, however it is yet another piece
contrib/arm-neon/linux-auxv.c: * of potentially untested code and has more complex dependencies than the code
contrib/arm-neon/linux-auxv.c: * This generic __linux__ implementation requires reading /proc/self/auxv and
contrib/arm-neon/linux-auxv.c:   int fd = open("/proc/self/auxv", O_RDONLY);
contrib/arm-neon/linux-auxv.c:   Elf32_auxv_t aux;
contrib/arm-neon/linux-auxv.c:      png_warning(png_ptr, "/proc/self/auxv open failed");
contrib/arm-neon/linux-auxv.c:   while (safe_read(png_ptr, fd, &aux, sizeof aux) == sizeof aux)
contrib/arm-neon/linux-auxv.c:      if (aux.a_type == AT_HWCAP && (aux.a_un.a_val & HWCAP_NEON) != 0)
contrib/arm-neon/README:Detection of the ability to exexcute ARM NEON on an ARM processor requires
contrib/arm-neon/README:Apart from the basic Linux implementation in contrib/arm-neon/linux.c this code
contrib/arm-neon/README:         performed test builds and bugs are fixed when discovered.
contrib/arm-neon/README:         more detailed description for the extent to which the result was
contrib/arm-neon/README:The file is a fragment of C code. It should not define any 'extern' symbols;
contrib/arm-neon/README:It must not execute png_error unless it detects a bug.  A png_error will prevent
contrib/arm-neon/README:limited response.  Consider fixing it and sending a patch to fix the problem -
contrib/arm-neon/README:possible.  Obviously OS dependencies are to be expected.  If you submit code you
contrib/arm-neon/android-ndk.c: * only the header files exist in the NDK.
contrib/arm-neon/android-ndk.c:   /* This is a whole lot easier than the linux code, however it is probably
contrib/arm-neon/linux.c:/* contrib/arm-neon/linux.c
contrib/arm-neon/linux.c: * png_have_neon implemented for Linux by reading the widely available
contrib/arm-neon/linux.c:               if ((ch & ~0x20) == ch_feature[counter])
contrib/arm-neon/linux.c:               /* Either a bad line format or a 'feature' prefix followed by
contrib/arm-neon/linux.c:               if ((ch & ~0x20) == ch_neon[counter])
contrib/arm-neon/linux.c:               /* Have seen a 'neon' prefix, but there must be a space or new
depcomp:# As a special exception to the GNU General Public License, if you
depcomp:# Originally written by Alexandre Oliva <oliva@dcc.unicamp.br>.
depcomp:    exit 1;
depcomp:    exit $?
depcomp:    exit $?
depcomp:# Get the suffix-stripped basename of the given path, and save it the
depcomp:# Requires the auxiliary global variable '$tmpdepfile' to be set.
depcomp:aix_post_process_depfile ()
depcomp:lower=abcdefghijklmnopqrstuvwxyz
depcomp:  exit 1
depcomp:  # HP compiler uses -M and no extra arg.
depcomp:  dashmflag=-xM
depcomp:if test "$depmode" = xlc; then
depcomp:  # IBM C/C++ Compilers xlc/xlC can output gcc-like dependency information.
depcomp:## gcc 3 implements dependency tracking that does exactly what
depcomp:    exit $stat
depcomp:## Note that this doesn't just cater to obsosete pre-3.x GCC compilers.
depcomp:## but also to in-use compilers like IMB xlc/xlC and the HP C compiler.
depcomp:    exit $stat
depcomp:  # The second -e expression handles DOS-style file names with drive
depcomp:## This next piece of magic avoids the "deleted header file" problem.
depcomp:## well.  hp depmode also adds that space, but also prefixes the VPATH
depcomp:  # This case exists only to let depend.m4 do its work.  It works by
depcomp:  # looking at the text of this script.  This case will never be run,
depcomp:  exit 1
depcomp:    exit $stat
depcomp:    # lines with more than a fixed number of characters (4096 in
depcomp:xlc)
depcomp:  # This case exists only to let depend.m4 do its work.  It works by
depcomp:  # looking at the text of this script.  This case will never be run,
depcomp:  exit 1
depcomp:aix)
depcomp:    exit $stat
depcomp:  aix_post_process_depfile
depcomp:    exit $stat
depcomp:    exit 1
depcomp:        i=`expr $i - 1`
depcomp:    i=`expr $i - 1`
depcomp:    exit 1
depcomp:    exit $stat
depcomp:  # 'foo.d', which lands next to the object file, wherever that
depcomp:     exit $stat
depcomp:    exit $stat
depcomp:  aix_post_process_depfile
depcomp:    exit $stat
depcomp:  # The first sed program below extracts the file names and escapes
depcomp:  # This case exists only to let depend.m4 do its work.  It works by
depcomp:  # looking at the text of this script.  This case will never be run,
depcomp:  exit 1
depcomp:  "$@" || exit $?
depcomp:  # This case only exists to satisfy depend.m4.  It is never actually
depcomp:  exit 1
depcomp:  "$@" || exit $?
depcomp:  obj_suffix=`echo "$object" | sed 's/^.*\././'`
depcomp:  ${MAKEDEPEND-makedepend} -o"$obj_suffix" -f"$tmpdepfile" "$@"
depcomp:  # No need to regex-escape $object, excess matching of '.' is harmless.
depcomp:  "$@" || exit $?
depcomp:  "$@" || exit $?
depcomp:  # This case exists only to let depend.m4 do its work.  It works by
depcomp:  # looking at the text of this script.  This case will never be run,
depcomp:  exit 1
depcomp:  exec "$@"
depcomp:  exit 1
depcomp:exit 0
example.c:/* example.c - an example of using libpng
example.c: * To the extent possible under law, the authors have waived
example.c:/* This is an example of how to use libpng to read and write PNG files.
example.c: * The file libpng-manual.txt is much more verbose then this.  If you have not
example.c: * supply these parts to get it to compile.  For an example of a minimal
example.c: * contrib/examples/pngtopng.c
example.c:          * preserved; if it were to be removed, for example if we requested
example.c:          * colormaps have exactly the same format as a row of image pixels (so
example.c:          * all images into an index/color-mapped format then you can use:
example.c:          * to find the maximum size of the colormap in bytes.
example.c:               exit(0);
example.c:       * textual message in the 'png_image' structure:
example.c:      exit (1);
example.c:   exit(1);
example.c: *    pixel (red, green and blue), if not set the image will just have one
example.c: * PNG_FORMAT_FLAG_ALPHA: if set each pixel in the image will have an additional
example.c: *    alpha value; a linear value that describes the degree the image pixel
example.c: *    covers (overwrites) the contents of the existing pixel on the display.
example.c: * PNG_FORMAT_FLAG_LINEAR: if set the components of each pixel will be returned
example.c: * PNG_FORMAT_FLAG_BGR: if set the components of a color pixel will be returned
example.c: *    in the order blue, then green, then red.  If not set the pixel components
example.c: * significantly lossy.  The latter will be fixed in the future, but the former
example.c: * need to do more complex transformations, or minimize transformations, on the
example.c:    * with one of the PNG_TRANSFORM_* bits (this presently excludes
example.c:    * pixels) into the info structure with this call:
example.c:    * are mutually exclusive.
example.c:   /* Extract multiple pixels with bit depths of 1, 2, and 4 from a single
example.c:   /* Change the order of packed pixels to least significant bit first
example.c:   /* Expand paletted colors into true RGB triplets */
example.c:   /* Expand grayscale images to the full 8 bits from 1, 2, or 4 bits/pixel */
example.c:      png_set_expand_gray_1_2_4_to_8(png_ptr);
example.c:   /* Expand paletted or RGB images with transparency to full alpha channels
example.c:    * for paletted images instead of supplying a palette index.  Note that
example.c:    * Note that screen gamma is the display_exponent, which includes
example.c:    * the CRT_exponent and any correction for viewing conditions
example.c:                        max_screen_colors, histogram, 0);
example.c:   /* If you want to shift the pixel values from the range [0,255] or
example.c:   /* Flip the RGB pixels to BGR (or RGBA to BGRA) */
example.c:   png_set_filler(png_ptr, 0xff, PNG_FILLER_AFTER);
example.c:    * and update info structure.  REQUIRED if you are expecting libpng to
example.c:   /* Set the palette if there is one.  REQUIRED for indexed-color images */
example.c:      png_text text_ptr[3];
example.c:      char text0[]="Mona Lisa";
example.c:      text_ptr[0].key = key0;
example.c:      text_ptr[0].text = text0;
example.c:      text_ptr[0].compression = PNG_TEXT_COMPRESSION_NONE;
example.c:      text_ptr[0].itxt_length = 0;
example.c:      text_ptr[0].lang = NULL;
example.c:      text_ptr[0].lang_key = NULL;
example.c:      char text1[]="Leonardo DaVinci";
example.c:      text_ptr[1].key = key1;
example.c:      text_ptr[1].text = text1;
example.c:      text_ptr[1].compression = PNG_TEXT_COMPRESSION_NONE;
example.c:      text_ptr[1].itxt_length = 0;
example.c:      text_ptr[1].lang = NULL;
example.c:      text_ptr[1].lang_key = NULL;
example.c:      char text2[]="<long text>";
example.c:      text_ptr[2].key = key2;
example.c:      text_ptr[2].text = text2;
example.c:      text_ptr[2].compression = PNG_TEXT_COMPRESSION_zTXt;
example.c:      text_ptr[2].itxt_length = 0;
example.c:      text_ptr[2].lang = NULL;
example.c:      text_ptr[2].lang_key = NULL;
example.c:      png_set_text(write_ptr, write_info_ptr, text_ptr, 3);
example.c:   /* Once we write out the header, the compression type on the text
example.c:   /* Invert monochrome pixels */
example.c:   /* Shift the pixels up to a legal bit depth and fill in
example.c:   /* Pack pixels into bytes */
example.c:   /* Flip BGR pixels to RGB */
example.c:   /* Swap bits of 1, 2, 4 bit packed pixel formats */
example.c:   /* In this example, "image" is a one-dimensional array of bytes */
example.c:   png_byte image[height*width*bytes_per_pixel];
example.c:     row_pointers[k] = image + k*width*bytes_per_pixel;
example.c:    * as recommended in versions 1.0.5m and earlier of this example; if
include/libpng16/pnglibconf.h:#define PNG_ZLIB_VERNUM 0x1250
include/libpng16/png.h: *    1.0.2a-b                      10003  version, except as noted.
include/libpng16/png.h: *    1.0.6h                        10007  10.6h (testing xy.z so-numbering)
include/libpng16/png.h: *   for applications, is an unsigned integer of the form xyyzz corresponding
include/libpng16/png.h: *   to the source version x.y.z (leading zeros in y and z).  Beta versions
include/libpng16/png.h: *   Binary incompatibility exists only when applications make direct access
include/libpng16/png.h: * See libpng-manual.txt or libpng.3 for more information.  The PNG
include/libpng16/png.h: *    Simon-Pierre Cadieux
include/libpng16/png.h: * and Group 42, Inc. disclaim all warranties, expressed or implied,
include/libpng16/png.h: * assume no liability for direct, indirect, incidental, special, exemplary,
include/libpng16/png.h: * boxes and the like:
include/libpng16/png.h: * files "pngbar.png" and "pngbar.jpg (88x31) and "pngnow.png" (98x31).
include/libpng16/png.h: * with testing, bug fixes, and patience.  This wouldn't have been
include/libpng16/png.h: *    holds the date in text format, and will hold years up to 9999.
include/libpng16/png.h: *    in libpng-1.6.x and will be removed from libpng-1.7.0.
include/libpng16/png.h: *          (formerly png_convert_to_rfc_1123() prior to libpng-1.5.x and
include/libpng16/png.h:/* This is not the place to learn how to use libpng. The file libpng-manual.txt
include/libpng16/png.h: * describes how to use libpng, and the file example.c summarizes it
include/libpng16/png.h: * <http://www.libpng.org/pub/png/libpng-manual.txt>
include/libpng16/png.h: * version 1.0.1 it's    xxyyzz, where x=major, y=minor, z=release
include/libpng16/png.h:extern "C" {
include/libpng16/png.h: * 3. Exported library functions.
include/libpng16/png.h: * Use macros to read integers from PNG data or use the exported
include/libpng16/png.h:/* Basic control structions.  Read libpng-manual.txt or libpng.3 for more info.
include/libpng16/png.h: * or more of these must exist while reading or creating a PNG file.  The
include/libpng16/png.h: * applications.  Read libpng-manual.txt or libpng.3 for more info.
include/libpng16/png.h: * names ending 'rp' are identical pointer types except that the pointer is
include/libpng16/png.h: * consequentially, writing portable application code is extremely difficult if
include/libpng16/png.h: * exact size) is not important, although the size of the fields need to
include/libpng16/png.h:   png_byte index;    /* used for palette files */
include/libpng16/png.h:/* png_text holds the contents of a text/ztxt/itxt chunk in a PNG file,
include/libpng16/png.h: * points to a regular zero-terminated C string.  The "text" fields can be a
include/libpng16/png.h: * However, the structure returned by png_get_text() will always contain
include/libpng16/png.h: * the "text" field as a regular zero-terminated C string (possibly
include/libpng16/png.h: * other string-handling functions.  Note that the "itxt_length", "lang", and
include/libpng16/png.h: * "lang_key" members of the structure only exist when the library is built
include/libpng16/png.h:typedef struct png_text_struct
include/libpng16/png.h:   png_charp key;          /* keyword, 1-79 character description of "text" */
include/libpng16/png.h:   png_charp text;         /* comment, may be an empty string (ie "")
include/libpng16/png.h:   png_size_t text_length; /* length of the text string */
include/libpng16/png.h:   png_size_t itxt_length; /* length of the itxt string */
include/libpng16/png.h:} png_text;
include/libpng16/png.h:typedef png_text * png_textp;
include/libpng16/png.h:typedef const png_text * png_const_textp;
include/libpng16/png.h:typedef png_text * * png_textpp;
include/libpng16/png.h:/* Supported compression types for text in PNG files (tEXt, and zTXt).
include/libpng16/png.h:    png_byte name[5]; /* Textual chunk name with '\0' terminator */
include/libpng16/png.h:#define PNG_HAVE_IHDR  0x01
include/libpng16/png.h:#define PNG_HAVE_PLTE  0x02
include/libpng16/png.h:#define PNG_AFTER_IDAT 0x08
include/libpng16/png.h:/* Maximum positive integer used in PNG is (2^31)-1 */
include/libpng16/png.h:#define PNG_UINT_31_MAX ((png_uint_32)0x7fffffffL)
include/libpng16/png.h:/* These are constants for fixed point values encoded in the
include/libpng16/png.h: * PNG specification manner (x100000)
include/libpng16/png.h:#define PNG_FP_MAX  ((png_fixed_point)0x7fffffffL)
include/libpng16/png.h:#define PNG_OFFSET_PIXEL          0 /* Offset in pixels */
include/libpng16/png.h:#define PNG_EQUATION_BASE_E       1 /* Exponential base e transform */
include/libpng16/png.h:#define PNG_EQUATION_ARBITRARY    2 /* Arbitrary base exponential transform */
include/libpng16/png.h:#define PNG_SCALE_METER           1 /* meters per pixel */
include/libpng16/png.h:#define PNG_SCALE_RADIAN          2 /* radians per pixel */
include/libpng16/png.h:#define PNG_RESOLUTION_UNKNOWN    0 /* pixels/unknown unit (aspect ratio) */
include/libpng16/png.h:#define PNG_RESOLUTION_METER      1 /* pixels/meter */
include/libpng16/png.h:/* This is for text chunks */
include/libpng16/png.h:/* Maximum number of entries in PLTE/sPLT/tRNS arrays */
include/libpng16/png.h:#define PNG_INFO_gAMA 0x0001
include/libpng16/png.h:#define PNG_INFO_sBIT 0x0002
include/libpng16/png.h:#define PNG_INFO_cHRM 0x0004
include/libpng16/png.h:#define PNG_INFO_PLTE 0x0008
include/libpng16/png.h:#define PNG_INFO_tRNS 0x0010
include/libpng16/png.h:#define PNG_INFO_bKGD 0x0020
include/libpng16/png.h:#define PNG_INFO_hIST 0x0040
include/libpng16/png.h:#define PNG_INFO_pHYs 0x0080
include/libpng16/png.h:#define PNG_INFO_oFFs 0x0100
include/libpng16/png.h:#define PNG_INFO_tIME 0x0200
include/libpng16/png.h:#define PNG_INFO_pCAL 0x0400
include/libpng16/png.h:#define PNG_INFO_sRGB 0x0800   /* GR-P, 0.96a */
include/libpng16/png.h:#define PNG_INFO_iCCP 0x1000   /* ESR, 1.0.6 */
include/libpng16/png.h:#define PNG_INFO_sPLT 0x2000   /* ESR, 1.0.6 */
include/libpng16/png.h:#define PNG_INFO_sCAL 0x4000   /* ESR, 1.0.6 */
include/libpng16/png.h:#define PNG_INFO_IDAT 0x8000   /* ESR, 1.0.6 */
include/libpng16/png.h:   png_byte pixel_depth; /* bits per pixel (depth * channels) */
include/libpng16/png.h: * expected to return the read data in the buffer.
include/libpng16/png.h: * then reset to 0 for the next pass.
include/libpng16/png.h: * find the output pixel (x,y) given an interlaced sub-image pixel
include/libpng16/png.h:#define PNG_TRANSFORM_IDENTITY       0x0000    /* read and write */
include/libpng16/png.h:#define PNG_TRANSFORM_STRIP_16       0x0001    /* read only */
include/libpng16/png.h:#define PNG_TRANSFORM_STRIP_ALPHA    0x0002    /* read only */
include/libpng16/png.h:#define PNG_TRANSFORM_PACKING        0x0004    /* read and write */
include/libpng16/png.h:#define PNG_TRANSFORM_PACKSWAP       0x0008    /* read and write */
include/libpng16/png.h:#define PNG_TRANSFORM_EXPAND         0x0010    /* read only */
include/libpng16/png.h:#define PNG_TRANSFORM_INVERT_MONO    0x0020    /* read and write */
include/libpng16/png.h:#define PNG_TRANSFORM_SHIFT          0x0040    /* read and write */
include/libpng16/png.h:#define PNG_TRANSFORM_BGR            0x0080    /* read and write */
include/libpng16/png.h:#define PNG_TRANSFORM_SWAP_ALPHA     0x0100    /* read and write */
include/libpng16/png.h:#define PNG_TRANSFORM_SWAP_ENDIAN    0x0200    /* read and write */
include/libpng16/png.h:#define PNG_TRANSFORM_INVERT_ALPHA   0x0400    /* read and write */
include/libpng16/png.h:#define PNG_TRANSFORM_STRIP_FILLER   0x0800    /* write only */
include/libpng16/png.h:#define PNG_TRANSFORM_STRIP_FILLER_AFTER 0x1000 /* write only */
include/libpng16/png.h:#define PNG_TRANSFORM_GRAY_TO_RGB   0x2000      /* read only */
include/libpng16/png.h:#define PNG_TRANSFORM_EXPAND_16     0x4000      /* read only */
include/libpng16/png.h:#define PNG_TRANSFORM_SCALE_16      0x8000      /* read only */
include/libpng16/png.h:#define PNG_FLAG_MNG_EMPTY_PLTE     0x01
include/libpng16/png.h:#define PNG_FLAG_MNG_FILTER_64      0x04
include/libpng16/png.h:#define PNG_ALL_MNG_FEATURES        0x05
include/libpng16/png.h:/* Section 3: exported functions
include/libpng16/png.h: * the place to find out how to use libpng.  See libpng-manual.txt for the
include/libpng16/png.h: * full explanation, see example.c for the summary.  This just provides
include/libpng16/png.h:/* Expand data to 24-bit RGB, or 8-bit grayscale, with alpha if available. */
include/libpng16/png.h:PNG_EXPORT(26, void, png_set_expand, (png_structrp png_ptr));
include/libpng16/png.h:PNG_EXPORT(27, void, png_set_expand_gray_1_2_4_to_8, (png_structrp png_ptr));
include/libpng16/png.h:/* Expand to 16-bit channels, forces conversion of palette to RGB and expansion
include/libpng16/png.h:PNG_EXPORT(221, void, png_set_expand_16, (png_structrp png_ptr));
include/libpng16/png.h:/* Use blue, green, red order for pixels. */
include/libpng16/png.h:/* Expand the grayscale to 24-bit RGB if necessary. */
include/libpng16/png.h:PNG_FIXED_EXPORT(33, void, png_set_rgb_to_gray_fixed, (png_structrp png_ptr,
include/libpng16/png.h:    int error_action, png_fixed_point red, png_fixed_point green))
include/libpng16/png.h: * This has no effect on the way pixels are written into a PNG output
include/libpng16/png.h: * channel is a linear measure of the contribution of the pixel to the
include/libpng16/png.h: * corresponding composited pixel, and the color channels are unassociated
include/libpng16/png.h: * For the 'OPTIMIZED' mode, a pixel is treated as opaque only if the alpha
include/libpng16/png.h: * value is equal to the maximum value.
include/libpng16/png.h:#define PNG_ALPHA_OPTIMIZED     2 /* 'PNG' for opaque pixels, else 'STANDARD' */
include/libpng16/png.h:PNG_FIXED_EXPORT(228, void, png_set_alpha_mode_fixed, (png_structrp png_ptr,
include/libpng16/png.h:    int mode, png_fixed_point output_gamma))
include/libpng16/png.h:/* The output_gamma value is a screen gamma in libpng terminology: it expresses
include/libpng16/png.h:/* The following are examples of calls to png_set_alpha_mode to achieve the
include/libpng16/png.h: * png_set_expand_16(pp);
include/libpng16/png.h: *    If you just need to composite the PNG image onto an existing background
include/libpng16/png.h: *    setting.  In this case you just copy completely opaque pixels to the
include/libpng16/png.h: *    output.  For pixels that are not completely transparent (you just skip
include/libpng16/png.h: *    your hardware/software fixed!  (The OPTIMIZED approach is slightly
include/libpng16/png.h:/* Use 1 byte per pixel in 1, 2, or 4-bit depth files. */
include/libpng16/png.h:/* Swap packing order of pixels in bytes. */
include/libpng16/png.h: * read.  Doing so will result in unexpected behavior and possible warnings or
include/libpng16/png.h:    int need_expand, double background_gamma))
include/libpng16/png.h:PNG_FIXED_EXPORT(215, void, png_set_background_fixed, (png_structrp png_ptr,
include/libpng16/png.h:    int need_expand, png_fixed_point background_gamma))
include/libpng16/png.h:    png_colorp palette, int num_palette, int maximum_colors,
include/libpng16/png.h:/* Handle gamma correction. Screen_gamma=(display_exponent).
include/libpng16/png.h: * API (floating point or fixed.)  Notice, however, that the 'file_gamma' value
include/libpng16/png.h:PNG_FIXED_EXPORT(208, void, png_set_gamma_fixed, (png_structrp png_ptr,
include/libpng16/png.h:    png_fixed_point screen_gamma, png_fixed_point override_file_gamma))
include/libpng16/png.h: * expense of compression can modify them.  See the compression library
include/libpng16/png.h: * header file (zlib.h) for an explination of the compression functions.
include/libpng16/png.h:#define PNG_NO_FILTERS     0x00
include/libpng16/png.h:#define PNG_FILTER_NONE    0x08
include/libpng16/png.h:#define PNG_FILTER_SUB     0x10
include/libpng16/png.h:#define PNG_FILTER_UP      0x20
include/libpng16/png.h:#define PNG_FILTER_AVG     0x40
include/libpng16/png.h:#define PNG_FILTER_PAETH   0x80
include/libpng16/png.h: * the experimental method (weighted-minimum-sum-of-absolute-differences).
include/libpng16/png.h: * filter type.  Higher costs indicate more decoding expense, and are
include/libpng16/png.h:PNG_FIXED_EXPORT(209, void, png_set_filter_heuristics_fixed,
include/libpng16/png.h:    png_const_fixed_point_p filter_weights,
include/libpng16/png.h:    png_const_fixed_point_p filter_costs))
include/libpng16/png.h:#define PNG_FILTER_HEURISTIC_WEIGHTED   2  /* Experimental feature */
include/libpng16/png.h: * (0 - no compression, 9 - "maximal" compression).  Note that tests have
include/libpng16/png.h:PNG_EXPORT(222, void, png_set_text_compression_level, (png_structrp png_ptr,
include/libpng16/png.h:PNG_EXPORT(223, void, png_set_text_compression_mem_level, (png_structrp png_ptr,
include/libpng16/png.h:PNG_EXPORT(224, void, png_set_text_compression_strategy, (png_structrp png_ptr,
include/libpng16/png.h:PNG_EXPORT(225, void, png_set_text_compression_window_bits,
include/libpng16/png.h:PNG_EXPORT(226, void, png_set_text_compression_method, (png_structrp png_ptr,
include/libpng16/png.h:/* These next functions are called for input/output, memory, and error
include/libpng16/png.h: * different manner by calling png_set_???_fn().  See libpng-manual.txt for
include/libpng16/png.h: * APIs do not fail but will return unexpected results if called outside a user
include/libpng16/png.h: * then reset to 0 for the next pass.
include/libpng16/png.h: * find the output pixel (x,y) given an interlaced sub-image pixel
include/libpng16/png.h: * remaining, excluding any that libpng has cached internally.  A subsequent
include/libpng16/png.h: * following data to the next call to png_process_data.
include/libpng16/png.h:/* Reassign responsibility for freeing existing data, whether allocated
include/libpng16/png.h:#define PNG_FREE_HIST 0x0008
include/libpng16/png.h:#define PNG_FREE_ICCP 0x0010
include/libpng16/png.h:#define PNG_FREE_SPLT 0x0020
include/libpng16/png.h:#define PNG_FREE_ROWS 0x0040
include/libpng16/png.h:#define PNG_FREE_PCAL 0x0080
include/libpng16/png.h:#define PNG_FREE_SCAL 0x0100
include/libpng16/png.h:#  define PNG_FREE_UNKN 0x0200
include/libpng16/png.h:/*      PNG_FREE_LIST 0x0400    removed in 1.6.0 because it is ignored */
include/libpng16/png.h:#define PNG_FREE_PLTE 0x1000
include/libpng16/png.h:#define PNG_FREE_TRNS 0x2000
include/libpng16/png.h:#define PNG_FREE_TEXT 0x4000
include/libpng16/png.h:#define PNG_FREE_ALL  0x7fff
include/libpng16/png.h:#define PNG_FREE_MUL  0x4220 /* PNG_FREE_SPLT|PNG_FREE_TEXT|PNG_FREE_UNKN */
include/libpng16/png.h:/* Returns image width in pixels. */
include/libpng16/png.h:/* Returns image height in pixels. */
include/libpng16/png.h:/* Returns image resolution in pixels per meter, from pHYs chunk data. */
include/libpng16/png.h:PNG_EXPORT(122, png_uint_32, png_get_pixels_per_meter,
include/libpng16/png.h:PNG_EXPORT(123, png_uint_32, png_get_x_pixels_per_meter,
include/libpng16/png.h:PNG_EXPORT(124, png_uint_32, png_get_y_pixels_per_meter,
include/libpng16/png.h:/* Returns pixel aspect ratio, computed from pHYs chunk data.  */
include/libpng16/png.h:PNG_FP_EXPORT(125, float, png_get_pixel_aspect_ratio,
include/libpng16/png.h:PNG_FIXED_EXPORT(210, png_fixed_point, png_get_pixel_aspect_ratio_fixed,
include/libpng16/png.h:/* Returns image x, y offset in pixels or microns, from oFFs chunk data. */
include/libpng16/png.h:PNG_EXPORT(126, png_int_32, png_get_x_offset_pixels,
include/libpng16/png.h:PNG_EXPORT(127, png_int_32, png_get_y_offset_pixels,
include/libpng16/png.h:PNG_EXPORT(128, png_int_32, png_get_x_offset_microns,
include/libpng16/png.h:    png_const_inforp info_ptr, double *white_x, double *white_y, double *red_x,
include/libpng16/png.h:    double *red_y, double *green_x, double *green_y, double *blue_x,
include/libpng16/png.h:PNG_FIXED_EXPORT(134, png_uint_32, png_get_cHRM_fixed,
include/libpng16/png.h:    png_fixed_point *int_white_x, png_fixed_point *int_white_y,
include/libpng16/png.h:    png_fixed_point *int_red_x, png_fixed_point *int_red_y,
include/libpng16/png.h:    png_fixed_point *int_green_x, png_fixed_point *int_green_y,
include/libpng16/png.h:    png_fixed_point *int_blue_x, png_fixed_point *int_blue_y))
include/libpng16/png.h:PNG_FIXED_EXPORT(231, png_uint_32, png_get_cHRM_XYZ_fixed,
include/libpng16/png.h:    png_fixed_point *int_red_X, png_fixed_point *int_red_Y,
include/libpng16/png.h:    png_fixed_point *int_red_Z, png_fixed_point *int_green_X,
include/libpng16/png.h:    png_fixed_point *int_green_Y, png_fixed_point *int_green_Z,
include/libpng16/png.h:    png_fixed_point *int_blue_X, png_fixed_point *int_blue_Y,
include/libpng16/png.h:    png_fixed_point *int_blue_Z))
include/libpng16/png.h:    double white_x, double white_y, double red_x, double red_y, double green_x,
include/libpng16/png.h:    double green_y, double blue_x, double blue_y))
include/libpng16/png.h:PNG_FIXED_EXPORT(136, void, png_set_cHRM_fixed, (png_const_structrp png_ptr,
include/libpng16/png.h:    png_inforp info_ptr, png_fixed_point int_white_x,
include/libpng16/png.h:    png_fixed_point int_white_y, png_fixed_point int_red_x,
include/libpng16/png.h:    png_fixed_point int_red_y, png_fixed_point int_green_x,
include/libpng16/png.h:    png_fixed_point int_green_y, png_fixed_point int_blue_x,
include/libpng16/png.h:    png_fixed_point int_blue_y))
include/libpng16/png.h:PNG_FIXED_EXPORT(233, void, png_set_cHRM_XYZ_fixed, (png_const_structrp png_ptr,
include/libpng16/png.h:    png_inforp info_ptr, png_fixed_point int_red_X, png_fixed_point int_red_Y,
include/libpng16/png.h:    png_fixed_point int_red_Z, png_fixed_point int_green_X,
include/libpng16/png.h:    png_fixed_point int_green_Y, png_fixed_point int_green_Z,
include/libpng16/png.h:    png_fixed_point int_blue_X, png_fixed_point int_blue_Y,
include/libpng16/png.h:    png_fixed_point int_blue_Z))
include/libpng16/png.h:PNG_FIXED_EXPORT(138, png_uint_32, png_get_gAMA_fixed,
include/libpng16/png.h:    png_fixed_point *int_file_gamma))
include/libpng16/png.h:PNG_FIXED_EXPORT(140, void, png_set_gAMA_fixed, (png_const_structrp png_ptr,
include/libpng16/png.h:    png_inforp info_ptr, png_fixed_point int_file_gamma))
include/libpng16/png.h:   png_const_inforp info_ptr, png_int_32 *offset_x, png_int_32 *offset_y,
include/libpng16/png.h:    png_inforp info_ptr, png_int_32 offset_x, png_int_32 offset_y,
include/libpng16/png.h:    png_const_inforp info_ptr, png_uint_32 *res_x, png_uint_32 *res_y,
include/libpng16/png.h:    png_inforp info_ptr, png_uint_32 res_x, png_uint_32 res_y, int unit_type));
include/libpng16/png.h:/* png_get_text also returns the number of text chunks in *num_text */
include/libpng16/png.h:PNG_EXPORT(162, int, png_get_text, (png_const_structrp png_ptr,
include/libpng16/png.h:    png_inforp info_ptr, png_textp *text_ptr, int *num_text));
include/libpng16/png.h:/* Note while png_set_text() will accept a structure whose text,
include/libpng16/png.h: * returned by png_get_text will always contain regular
include/libpng16/png.h:PNG_EXPORT(163, void, png_set_text, (png_const_structrp png_ptr,
include/libpng16/png.h:    png_inforp info_ptr, png_const_textp text_ptr, int num_text));
include/libpng16/png.h: * In any case the range of values supported by png_fixed_point is small and it
include/libpng16/png.h:PNG_FIXED_EXPORT(214, png_uint_32, png_get_sCAL_fixed,
include/libpng16/png.h:    png_fixed_point *width, png_fixed_point *height))
include/libpng16/png.h:PNG_FIXED_EXPORT(213, void, png_set_sCAL_fixed, (png_const_structrp png_ptr,
include/libpng16/png.h:   png_inforp info_ptr, int unit, png_fixed_point width,
include/libpng16/png.h:   png_fixed_point height))
include/libpng16/png.h: *    except for the IHDR, PLTE, tRNS, IDAT, and IEND chunks (which continue to
include/libpng16/png.h:    * invariably the wrong value on write.  To fix this call the following API
include/libpng16/png.h:/* The "params" pointer is currently not used and is for future expansion. */
include/libpng16/png.h:    png_uint_32 user_width_max, png_uint_32 user_height_max));
include/libpng16/png.h:PNG_EXPORT(187, png_uint_32, png_get_user_width_max,
include/libpng16/png.h:PNG_EXPORT(188, png_uint_32, png_get_user_height_max,
include/libpng16/png.h:PNG_EXPORT(189, void, png_set_chunk_cache_max, (png_structrp png_ptr,
include/libpng16/png.h:    png_uint_32 user_chunk_cache_max));
include/libpng16/png.h:PNG_EXPORT(190, png_uint_32, png_get_chunk_cache_max,
include/libpng16/png.h:PNG_EXPORT(191, void, png_set_chunk_malloc_max, (png_structrp png_ptr,
include/libpng16/png.h:    png_alloc_size_t user_chunk_cache_max));
include/libpng16/png.h:PNG_EXPORT(192, png_alloc_size_t, png_get_chunk_malloc_max,
include/libpng16/png.h:PNG_EXPORT(193, png_uint_32, png_get_pixels_per_inch,
include/libpng16/png.h:PNG_EXPORT(194, png_uint_32, png_get_x_pixels_per_inch,
include/libpng16/png.h:PNG_EXPORT(195, png_uint_32, png_get_y_pixels_per_inch,
include/libpng16/png.h:PNG_FP_EXPORT(196, float, png_get_x_offset_inches,
include/libpng16/png.h:PNG_FIXED_EXPORT(211, png_fixed_point, png_get_x_offset_inches_fixed,
include/libpng16/png.h:PNG_FIXED_EXPORT(212, png_fixed_point, png_get_y_offset_inches_fixed,
include/libpng16/png.h:    png_const_inforp info_ptr, png_uint_32 *res_x, png_uint_32 *res_y,
include/libpng16/png.h:#  define PNG_IO_NONE        0x0000   /* no I/O at this moment */
include/libpng16/png.h:#  define PNG_IO_READING     0x0001   /* currently reading */
include/libpng16/png.h:#  define PNG_IO_WRITING     0x0002   /* currently writing */
include/libpng16/png.h:#  define PNG_IO_SIGNATURE   0x0010   /* currently at the file signature */
include/libpng16/png.h:#  define PNG_IO_CHUNK_HDR   0x0020   /* currently at the chunk header */
include/libpng16/png.h:#  define PNG_IO_CHUNK_DATA  0x0040   /* currently at the chunk data */
include/libpng16/png.h:#  define PNG_IO_CHUNK_CRC   0x0080   /* currently at the chunk crc */
include/libpng16/png.h:#  define PNG_IO_MASK_OP     0x000f   /* current operation: reading/writing */
include/libpng16/png.h:#  define PNG_IO_MASK_LOC    0x00f0   /* current location: sig/hdr/data/crc */
include/libpng16/png.h:/* A macro to return the offset between pixels in the output row for a pair of
include/libpng16/png.h: * pixels in the input - effectively the inverse of the 'COL_SHIFT' macro that
include/libpng16/png.h: * follows.  Note that ROW_OFFSET is the offset from one row to the next whereas
include/libpng16/png.h: * COL_OFFSET is from one column to the next, within a row.
include/libpng16/png.h: * pass.  This is expressed as a shift - effectively log2 of the number or
include/libpng16/png.h: * rows or columns in each 8x8 tile of the original image.
include/libpng16/png.h:#define PNG_COL_FROM_PASS_COL(x_in, pass) \
include/libpng16/png.h:   (((x_in)<<PNG_PASS_COL_SHIFT(pass))+PNG_PASS_START_COL(pass))
include/libpng16/png.h:   ((0x110145AF>>(((7-(off))-(pass))<<2)) & 0xF) | \
include/libpng16/png.h:   ((0x01145AF0>>(((7-(off))-(pass))<<2)) & 0xF0))
include/libpng16/png.h:#define PNG_COL_IN_INTERLACE_PASS(x, pass) \
include/libpng16/png.h:   ((PNG_PASS_MASK(pass,1) >> ((x)&7)) & 1)
include/libpng16/png.h:     ((png_int_32)((*(buf) & 0x80) \
include/libpng16/png.h:      ? -((png_int_32)((png_get_uint_32(buf) ^ 0xffffffffL) + 1)) \
include/libpng16/png.h:    * but defining a macro name prefixed with PNG_PREFIX.
include/libpng16/png.h: * Please read the documentation in libpng-manual.txt (TODO: write said
include/libpng16/png.h: * complex use of an alpha channel the transformation is extremely lossy and the
include/libpng16/png.h:   png_uint_32  width;     /* Image width in pixels (columns) */
include/libpng16/png.h:   png_uint_32  height;    /* Image height in pixels (rows) */
include/libpng16/png.h:#  define PNG_IMAGE_FAILED(png_cntrl) ((((png_cntrl).warning_or_error)&0x03)>1)
include/libpng16/png.h: * and matches the 8-bit format expected by typical display devices.
include/libpng16/png.h: * approximation used elsewhere in libpng.
include/libpng16/png.h: * When an alpha channel is present it is expected to denote pixel coverage
include/libpng16/png.h: * bytes per pixel according to the encoding, or are held in a color-map indexed
include/libpng16/png.h: * pixel to select the relevant sample from the color-map.
include/libpng16/png.h:#define PNG_FORMAT_FLAG_ALPHA    0x01U /* format with an alpha channel */
include/libpng16/png.h:#define PNG_FORMAT_FLAG_COLOR    0x02U /* color format: otherwise grayscale */
include/libpng16/png.h:#define PNG_FORMAT_FLAG_LINEAR   0x04U /* 2 byte channels else 1 byte */
include/libpng16/png.h:#define PNG_FORMAT_FLAG_COLORMAP 0x08U /* image data is color-mapped */
include/libpng16/png.h:#  define PNG_FORMAT_FLAG_BGR    0x10U /* BGR colors, else order is RGB */
include/libpng16/png.h:#  define PNG_FORMAT_FLAG_AFIRST 0x20U /* alpha channel comes first */
include/libpng16/png.h:/* With color-mapped formats the image data is one byte for each pixel, the byte
include/libpng16/png.h: * is an index into the color-map which is formatted as above.  To obtain a
include/libpng16/png.h: * pixels in the image.  The PNG_IMAGE_PIXEL_ macros return corresponding values
include/libpng16/png.h: * for the pixels and will always return 1 for color-mapped formats.  The
include/libpng16/png.h:   /* Return the size in bytes of a single component of a pixel or color-map
include/libpng16/png.h:    * color-mapped it is the size of one color-map entry (and image pixels are
include/libpng16/png.h:    * one byte in size), otherwise it is the size of one image pixel.
include/libpng16/png.h:   /* The maximum size of the color-map required by the format expressed in a
include/libpng16/png.h:/* Corresponding information about the pixels */
include/libpng16/png.h:   /* The number of separate channels (components) in a pixel; 1 for a
include/libpng16/png.h:   /* The size, in bytes, of each component in a pixel; 1 for a color-mapped
include/libpng16/png.h:   /* The size, in bytes, of a complete pixel; 1 for a color-mapped image. */
include/libpng16/png.h:#define PNG_IMAGE_FLAG_COLORSPACE_NOT_sRGB 0x01
include/libpng16/png.h:#define PNG_IMAGE_FLAG_FAST 0x02
include/libpng16/png.h:#define PNG_IMAGE_FLAG_16BIT_sRGB 0x04
include/libpng16/png.h:    * external source.  It is recommended that the application expose this flag
include/libpng16/png.h: * width: image width in pixels
include/libpng16/png.h: * from one row to the next in component sized units (1 or 2 bytes) and if
include/libpng16/png.h: * Note that the write API does not support interlacing or sub-8-bit pixels.
include/libpng16/png.h:PNG_EXPORT(242, void, png_set_check_for_invalid_index,
include/libpng16/png.h:PNG_EXPORT(243, int, png_get_palette_max, (png_const_structp png_ptr,
include/libpng16/png.h:#define PNG_MAXIMUM_INFLATE_WINDOW 2 /* SOFTWARE: force maximum window */
include/libpng16/png.h:#define PNG_OPTION_NEXT  6 /* Next option - numbers must be even */
include/libpng16/png.h:/* The last ordinal number (this is the *last* one already used; the next
include/libpng16/pngconf.h: * starting here down to where it starts to typedef png_color, png_text,
include/libpng16/pngconf.h: * expects conformant implementations, however, an ISOC90 conformant system need
include/libpng16/pngconf.h: * PNG_NO_CONST; this is no longer supported except for data declarations which
include/libpng16/pngconf.h: * can be used.  Some are fixed at build time (e.g. PNG_API_RULE
include/libpng16/pngconf.h: * a function - it just does it - however on x86 systems derived from
include/libpng16/pngconf.h: * libpng specifies the calling convention of every exported function and
include/libpng16/pngconf.h: * PNGAPI    Calling convention for exported functions.
include/libpng16/pngconf.h: *                please post an explanation of the problem to the
include/libpng16/pngconf.h: * (x86 DOS/Windows sytems) and, even then, this does not apply to
include/libpng16/pngconf.h:/* Symbol export
include/libpng16/pngconf.h: * the compiler which symbols to export.  The png.h macro 'PNG_EXPORT'
include/libpng16/pngconf.h: * extracted at link time and need no special processing by the compiler,
include/libpng16/pngconf.h: * PNG_IMPEXP The magic (if any) to cause a symbol to be exported from
include/libpng16/pngconf.h: *                make a symbol exported from the DLL.  Not used in the
include/libpng16/pngconf.h:      (defined(__BORLANDC__) && __BORLANDC__ < 0x500)
include/libpng16/pngconf.h:     * compilers used '__export' and required this to be after
include/libpng16/pngconf.h:#    define PNG_DLL_EXPORT __export
include/libpng16/pngconf.h:#    define PNG_DLL_EXPORT __declspec(dllexport)
include/libpng16/pngconf.h:#  else /* !Windows/x86 && !OS/2 */
include/libpng16/pngconf.h:#endif /* !Windows/x86 */
include/libpng16/pngconf.h:        extern attributes)
include/libpng16/pngconf.h:#      ifdef __has_extension
include/libpng16/pngconf.h:#        if __has_extension(attribute_unavailable_with_message)
include/libpng16/pngconf.h:             "This function is not exported by libpng.")))
include/libpng16/pngconf.h:            __attribute__((warning("This function is not exported by libpng.")))
include/libpng16/pngconf.h:#ifndef PNG_FIXED_EXPORT  /* A fixed point API. */
include/libpng16/pngconf.h:#  else                   /* No fixed point APIs */
include/libpng16/pngconf.h:/* libpng needs to know the maximum value of 'size_t' and this controls the
include/libpng16/pngconf.h: * definition of png_alloc_size_t, below.  This maximum value of size_t limits
include/libpng16/pngconf.h: * but does not control the maximum allocations the library makes - there is
include/libpng16/pngconf.h: * png_uint_32) should be explicitly applied; however, we do not expect to
include/libpng16/pngconf.h: * PNG_SMALL_SIZE_T must be defined if the maximum value of size_t is less than
include/libpng16/pngconf.h: * 4294967295 - i.e. less than the maximum value of png_uint_32.
include/libpng16/pngconf.h:/* Typedef for floating-point numbers that are converted to fixed-point with a
include/libpng16/pngconf.h:typedef png_int_32 png_fixed_point;
include/libpng16/pngconf.h:typedef png_fixed_point       * png_fixed_point_p;
include/libpng16/pngconf.h:typedef const png_fixed_point * png_const_fixed_point_p;
include/libpng16/pngconf.h:typedef png_fixed_point * * png_fixed_point_pp;
INSTALL:  XI. Prepending a prefix to exported symbols
INSTALL: XII. Configuring for compiler xxx:
INSTALL: XIV. Changes to the build and configuration of libpng in libpng-1.5.x
INSTALL:On Unix/Linux and similar systems, you can simply type
INSTALL:    ./configure [--prefix=/path]
INSTALL:running ./configure may fix the problem.  To be really sure that you
INSTALL:    ./configure [--prefix=/path] [other options]
INSTALL:are listed and described in scripts/README.txt.
INSTALL:ZLIBLIB=/path/to/lib export ZLIBLIB
INSTALL:ZLIBINC=/path/to/include export ZLIBINC
INSTALL:CPPFLAGS="-I$ZLIBINC" export CPPFLAGS
INSTALL:LDFLAGS="-L$ZLIBLIB" export LDFLAGS
INSTALL:LD_LIBRARY_PATH="$ZLIBLIB:$LD_LIBRARY_PATH" export LD_LIBRARY_PATH
INSTALL:might be called "libpng-x.y.z" or "libpngNN" and "zlib-1.2.8"
INSTALL:          CMakeLists.txt    =>  "cmake" script
INSTALL:             arm-neon, conftest, examples, gregbook, libtests, pngminim,
INSTALL:             cbuilder5, owatcom, visualc71, vstudio, xcode
INSTALL:in README.txt.
INSTALL:scripts directory into this directory, for example
INSTALL:   MSDOS example: copy scripts\makefile.msc makefile
INSTALL:   UNIX example:  cp scripts/makefile.std makefile
INSTALL:all set.  Everything in the library (except for zlib's structure) is
INSTALL:expecting far data.  You must use the typedefs with the p or pp on
INSTALL:XI. Prepending a prefix to exported symbols
INSTALL:"configure" script) to prefix all exported symbols by means of the
INSTALL:configuration option "--with-libpng-prefix=FOO_", where FOO_ can be any
INSTALL:XII. Configuring for compiler xxx:
INSTALL:extra transformations but still leave the library fully capable of reading
INSTALL:XIV. Changes to the build and configuration of libpng in libpng-1.5.x
INSTALL:builders will probably want to examine the changes to take advantage of
INSTALL:The exact mechanism used to control attributes of API functions has
INSTALL:to control the exported API functions; however, two new macros, PNGCBAPI
INSTALL:calling conventions seem to no longer exist.  Developers who find it
INSTALL:had either to modify the exported pngconf.h header file to add system
INSTALL:processed only once, at the time the exported header file pnglibconf.h is
INSTALL:names - nawk and gawk for example) are adequate to build pnglibconf.h.
INSTALL:Further information can be found in the README and libpng-manual.txt
INSTALL:explicitly, which previously was done semi-automatically (if you didn't edit
INSTALL:-malign-loops=2 -malign-functions=2" ./configure --prefix=/usr/include \
install-sh:# later released in X11R6 (xc/config/util/install.sh) with the
install-sh:# Except as contained in this notice, the name of the X Consortium shall not
install-sh:  doit_exec=exec
install-sh:  doit_exec=$doit
install-sh:posix_glob='?'
install-sh:initialize_posix_glob='
install-sh:  test "$posix_glob" != "?" || {
install-sh:      posix_glob=
install-sh:      posix_glob=:
install-sh:posix_mkdir=
install-sh:     --help     display this help and exit.
install-sh:     --version  display version info and exit.
install-sh:    --help) echo "$usage"; exit $?;;
install-sh:	    exit 1;;
install-sh:    --version) echo "$0 $scriptversion"; exit $?;;
install-sh:	exit 1;;
install-sh:    exit 1
install-sh:  exit 0
install-sh:  do_exit='(exit $ret); exit $ret'
install-sh:  trap "ret=129; $do_exit" 1
install-sh:  trap "ret=130; $do_exit" 2
install-sh:  trap "ret=141; $do_exit" 13
install-sh:  trap "ret=143; $do_exit" 15
install-sh:      cp_umask=`expr '(' 777 - $mode % 1000 ')' $u_plus_rw`;;
install-sh:      echo "$0: $src does not exist." >&2
install-sh:      exit 1
install-sh:      exit 1
install-sh:	exit 1
install-sh:	expr X"$dst" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
install-sh:    case $posix_mkdir in
install-sh:	    mkdir_umask=`expr $umask + 22 \
install-sh:	posix_mkdir=false
install-sh:	    # POSIX mkdir -p sets u+wx bits regardless of umask, which
install-sh:	    trap 'ret=$?; rmdir "$tmpdir/d" "$tmpdir" 2>/dev/null; exit $ret' 0
install-sh:		exec $mkdirprog $mkdir_mode -p -- "$tmpdir/d") >/dev/null 2>&1
install-sh:		   # FreeBSD 6.1 mkdir -m -p sets mode of existing directory.
install-sh:	      then posix_mkdir=:
install-sh:      $posix_mkdir && (
install-sh:	$doit_exec $mkdirprog $mkdir_mode -p -- "$dstdir"
install-sh:	/*) prefix='/';;
install-sh:	[-=\(\)!]*) prefix='./';;
install-sh:	*)  prefix='';;
install-sh:      eval "$initialize_posix_glob"
install-sh:      $posix_glob set -f
install-sh:      $posix_glob set +f
install-sh:      prefixes=
install-sh:	prefix=$prefix$d
install-sh:	if test -d "$prefix"; then
install-sh:	  prefixes=
install-sh:	  if $posix_mkdir; then
install-sh:	     $doit_exec $mkdirprog $mkdir_mode -p -- "$dstdir") && break
install-sh:	    test -d "$prefix" || exit 1
install-sh:	    case $prefix in
install-sh:	      *\'*) qprefix=`echo "$prefix" | sed "s/'/'\\\\\\\\''/g"`;;
install-sh:	      *) qprefix=$prefix;;
install-sh:	    prefixes="$prefixes '$qprefix'"
install-sh:	prefix=$prefix/
install-sh:      if test -n "$prefixes"; then
install-sh:	 eval "\$doit_exec \$mkdirprog $prefixes") ||
install-sh:	  test -d "$dstdir" || exit 1
install-sh:      test -z "$chmodcmd" || $doit $chmodcmd $mode "$dst"; } || exit 1
install-sh:    # Trap to clean up those temp files at exit.
install-sh:    trap 'ret=$?; rm -f "$dsttmp" "$rmtmp" && exit $ret' 0
install-sh:    (umask $cp_umask && $doit_exec $cpprog "$src" "$dsttmp") &&
install-sh:       eval "$initialize_posix_glob" &&
install-sh:       $posix_glob set -f &&
install-sh:       $posix_glob set +f &&
install-sh:	    (exit 1); exit 1
install-sh:    fi || exit 1
Binary file lib/libpng16.a matches
lib/pkgconfig/libpng16.pc:prefix=/Users/ananyu/csci3081/Photoshop/libpng-1.6.16
lib/pkgconfig/libpng16.pc:exec_prefix=${prefix}
lib/pkgconfig/libpng16.pc:libdir=${exec_prefix}/lib
lib/pkgconfig/libpng16.pc:includedir=${prefix}/include/libpng16
libpng16-config:# Modeled after libxml-config.
libpng16-config:prefix="/Users/ananyu/csci3081/Photoshop/libpng-1.6.16"
libpng16-config:exec_prefix="${prefix}"
libpng16-config:libdir="${exec_prefix}/lib"
libpng16-config:includedir="${prefix}/include/libpng16"
libpng16-config:  --prefix        print libpng prefix
libpng16-config:  --help          print this help and exit
libpng16-config:    exit $1
libpng16-config:    --prefix)
libpng16-config:        echo ${prefix}
libpng16-config:        exit 0
libpng16-config:        exit 1
libpng16-config:exit 0
libpng16.pc:prefix=/Users/ananyu/csci3081/Photoshop/libpng-1.6.16
libpng16.pc:exec_prefix=${prefix}
libpng16.pc:libdir=${exec_prefix}/lib
libpng16.pc:includedir=${prefix}/include/libpng16
libpng.3:\fBpng_uint_32 png_get_cHRM (png_const_structp \fP\fIpng_ptr\fP\fB, png_const_infop \fP\fIinfo_ptr\fP\fB, double \fP\fI*white_x\fP\fB, double \fP\fI*white_y\fP\fB, double \fP\fI*red_x\fP\fB, double \fP\fI*red_y\fP\fB, double \fP\fI*green_x\fP\fB, double \fP\fI*green_y\fP\fB, double \fP\fI*blue_x\fP\fB, double \fI*blue_y\fP\fB);\fP
libpng.3:\fBpng_uint_32 png_get_cHRM_fixed (png_const_structp \fP\fIpng_ptr\fP\fB, png_const_infop \fP\fIinfo_ptr\fP\fB, png_uint_32 \fP\fI*white_x\fP\fB, png_uint_32 \fP\fI*white_y\fP\fB, png_uint_32 \fP\fI*red_x\fP\fB, png_uint_32 \fP\fI*red_y\fP\fB, png_uint_32 \fP\fI*green_x\fP\fB, png_uint_32 \fP\fI*green_y\fP\fB, png_uint_32 \fP\fI*blue_x\fP\fB, png_uint_32 \fI*blue_y\fP\fB);\fP
libpng.3:\fBpng_uint_32 png_get_cHRM_XYZ_fixed (png_structp \fP\fIpng_ptr\fP\fB, png_const_infop \fP\fIinfo_ptr\fP\fB, png_fixed_point \fP\fI*int_red_X\fP\fB, png_fixed_point \fP\fI*int_red_Y\fP\fB, png_fixed_point \fP\fI*int_red_Z\fP\fB, png_fixed_point \fP\fI*int_green_X\fP\fB, png_fixed_point \fP\fI*int_green_Y\fP\fB, png_fixed_point \fP\fI*int_green_Z\fP\fB, png_fixed_point \fP\fI*int_blue_X\fP\fB, png_fixed_point \fP\fI*int_blue_Y\fP\fB, png_fixed_point \fI*int_blue_Z\fP\fB);\fP
libpng.3:\fBpng_uint_32 png_get_chunk_cache_max (png_const_structp \fIpng_ptr\fP\fB);\fP
libpng.3:\fBpng_alloc_size_t png_get_chunk_malloc_max (png_const_structp \fIpng_ptr\fP\fB);\fP
libpng.3:\fBpng_uint_32 png_get_gAMA_fixed (png_const_structp \fP\fIpng_ptr\fP\fB, png_const_infop \fP\fIinfo_ptr\fP\fB, png_uint_32 \fI*int_file_gamma\fP\fB);\fP
libpng.3:\fBpng_uint_32 png_get_oFFs (png_const_structp \fP\fIpng_ptr\fP\fB, png_const_infop \fP\fIinfo_ptr\fP\fB, png_uint_32 \fP\fI*offset_x\fP\fB, png_uint_32 \fP\fI*offset_y\fP\fB, int \fI*unit_type\fP\fB);\fP
libpng.3:\fBpng_uint_32 png_get_pHYs (png_const_structp \fP\fIpng_ptr\fP\fB, png_const_infop \fP\fIinfo_ptr\fP\fB, png_uint_32 \fP\fI*res_x\fP\fB, png_uint_32 \fP\fI*res_y\fP\fB, int \fI*unit_type\fP\fB);\fP
libpng.3:\fBfloat png_get_pixel_aspect_ratio (png_const_structp \fP\fIpng_ptr\fP\fB, png_const_infop \fIinfo_ptr\fP\fB);\fP
libpng.3:\fBpng_uint_32 png_get_pHYs_dpi (png_const_structp \fP\fIpng_ptr\fP\fB, png_const_infop \fP\fIinfo_ptr\fP\fB, png_uint_32 \fP\fI*res_x\fP\fB, png_uint_32 \fP\fI*res_y\fP\fB, int \fI*unit_type\fP\fB);\fP
libpng.3:\fBpng_fixed_point png_get_pixel_aspect_ratio_fixed (png_const_structp \fP\fIpng_ptr\fP\fB, png_const_infop \fIinfo_ptr\fP\fB);\fP
libpng.3:\fBpng_uint_32 png_get_pixels_per_inch (png_const_structp \fP\fIpng_ptr\fP\fB, png_const_infop \fIinfo_ptr\fP\fB);\fP
libpng.3:\fBpng_uint_32 png_get_pixels_per_meter (png_const_structp \fP\fIpng_ptr\fP\fB, png_const_infop \fIinfo_ptr\fP\fB);\fP
libpng.3:\fBvoid png_get_sCAL_fixed (png_const_structp \fP\fIpng_ptr\fP\fB, png_const_infop \fP\fIinfo_ptr\fP\fB, int* \fP\fIunit\fP\fB, png_fixed_pointp \fP\fIwidth\fP\fB, png_fixed_pointp \fIheight\fP\fB);\fP
libpng.3:\fBpng_uint_32 png_get_text (png_const_structp \fP\fIpng_ptr\fP\fB, png_const_infop \fP\fIinfo_ptr\fP\fB, png_textp \fP\fI*text_ptr\fP\fB, int \fI*num_text\fP\fB);\fP
libpng.3:\fBpng_uint_32 png_get_user_height_max (png_const_structp \fIpng_ptr\fP\fB);\fP
libpng.3:\fBpng_uint_32 png_get_user_width_max (png_const_structp \fIpng_ptr\fP\fB);\fP
libpng.3:\fBfloat png_get_x_offset_inches (png_const_structp \fP\fIpng_ptr\fP\fB, png_const_infop \fIinfo_ptr\fP\fB);\fP
libpng.3:\fBpng_fixed_point png_get_x_offset_inches_fixed (png_structp \fP\fIpng_ptr\fP\fB, png_const_infop \fIinfo_ptr\fP\fB);\fP
libpng.3:\fBpng_int_32 png_get_x_offset_microns (png_const_structp \fP\fIpng_ptr\fP\fB, png_const_infop \fIinfo_ptr\fP\fB);\fP
libpng.3:\fBpng_int_32 png_get_x_offset_pixels (png_const_structp \fP\fIpng_ptr\fP\fB, png_const_infop \fIinfo_ptr\fP\fB);\fP
libpng.3:\fBpng_uint_32 png_get_x_pixels_per_inch (png_const_structp \fP\fIpng_ptr\fP\fB, png_const_infop \fIinfo_ptr\fP\fB);\fP
libpng.3:\fBpng_uint_32 png_get_x_pixels_per_meter (png_const_structp \fP\fIpng_ptr\fP\fB, png_const_infop \fIinfo_ptr\fP\fB);\fP
libpng.3:\fBpng_fixed_point png_get_y_offset_inches_fixed (png_structp \fP\fIpng_ptr\fP\fB, png_const_infop \fIinfo_ptr\fP\fB);\fP
libpng.3:\fBpng_int_32 png_get_y_offset_pixels (png_const_structp \fP\fIpng_ptr\fP\fB, png_const_infop \fIinfo_ptr\fP\fB);\fP
libpng.3:\fBpng_uint_32 png_get_y_pixels_per_inch (png_const_structp \fP\fIpng_ptr\fP\fB, png_const_infop \fIinfo_ptr\fP\fB);\fP
libpng.3:\fBpng_uint_32 png_get_y_pixels_per_meter (png_const_structp \fP\fIpng_ptr\fP\fB, png_const_infop \fIinfo_ptr\fP\fB);\fP
libpng.3:\fBvoid png_set_alpha_mode_fixed (png_structp \fP\fIpng_ptr\fP\fB, int \fP\fImode\fP\fB, png_fixed_point \fIoutput_gamma\fP\fB);\fP
libpng.3:\fBvoid png_set_background (png_structp \fP\fIpng_ptr\fP\fB, png_color_16p \fP\fIbackground_color\fP\fB, int \fP\fIbackground_gamma_code\fP\fB, int \fP\fIneed_expand\fP\fB, double \fIbackground_gamma\fP\fB);\fP
libpng.3:\fBvoid png_set_background_fixed (png_structp \fP\fIpng_ptr\fP\fB, png_color_16p \fP\fIbackground_color\fP\fB, int \fP\fIbackground_gamma_code\fP\fB, int \fP\fIneed_expand\fP\fB, png_uint_32 \fIbackground_gamma\fP\fB);\fP
libpng.3:\fBvoid png_set_check_for_invalid_index(png_structrp \fP\fIpng_ptr\fP\fB, int \fIallowed\fP\fB);\fP
libpng.3:\fBvoid png_set_cHRM (png_structp \fP\fIpng_ptr\fP\fB, png_infop \fP\fIinfo_ptr\fP\fB, double \fP\fIwhite_x\fP\fB, double \fP\fIwhite_y\fP\fB, double \fP\fIred_x\fP\fB, double \fP\fIred_y\fP\fB, double \fP\fIgreen_x\fP\fB, double \fP\fIgreen_y\fP\fB, double \fP\fIblue_x\fP\fB, double \fIblue_y\fP\fB);\fP
libpng.3:\fBvoid png_set_cHRM_fixed (png_structp \fP\fIpng_ptr\fP\fB, png_infop \fP\fIinfo_ptr\fP\fB, png_uint_32 \fP\fIwhite_x\fP\fB, png_uint_32 \fP\fIwhite_y\fP\fB, png_uint_32 \fP\fIred_x\fP\fB, png_uint_32 \fP\fIred_y\fP\fB, png_uint_32 \fP\fIgreen_x\fP\fB, png_uint_32 \fP\fIgreen_y\fP\fB, png_uint_32 \fP\fIblue_x\fP\fB, png_uint_32 \fIblue_y\fP\fB);\fP
libpng.3:\fBvoid png_set_cHRM_XYZ_fixed (png_structp \fP\fIpng_ptr\fP\fB, png_infop \fP\fIinfo_ptr\fP\fB, png_fixed_point \fP\fIint_red_X\fP\fB, png_fixed_point \fP\fIint_red_Y\fP\fB, png_fixed_point \fP\fIint_red_Z\fP\fB, png_fixed_point \fP\fIint_green_X\fP\fB, png_fixed_point \fP\fIint_green_Y\fP\fB, png_fixed_point \fP\fIint_green_Z\fP\fB, png_fixed_point \fP\fIint_blue_X\fP\fB, png_fixed_point \fP\fIint_blue_Y\fP\fB, png_fixed_point \fIint_blue_Z\fP\fB);\fP
libpng.3:\fBvoid png_set_chunk_cache_max (png_structp \fP\fIpng_ptr\fP\fB, png_uint_32 \fIuser_chunk_cache_max\fP\fB);\fP
libpng.3:\fBvoid png_set_expand (png_structp \fIpng_ptr\fP\fB);\fP
libpng.3:\fBvoid png_set_expand_16 (png_structp \fIpng_ptr\fP\fB);\fP
libpng.3:\fBvoid png_set_expand_gray_1_2_4_to_8 (png_structp \fIpng_ptr\fP\fB);\fP
libpng.3:\fBvoid png_set_filter_heuristics_fixed (png_structp \fP\fIpng_ptr\fP\fB, int \fP\fIheuristic_method\fP\fB, int \fP\fInum_weights\fP\fB, png_fixed_point_p \fP\fIfilter_weights\fP\fB, png_fixed_point_p \fIfilter_costs\fP\fB);\fP
libpng.3:\fBvoid png_set_gamma_fixed (png_structp \fP\fIpng_ptr\fP\fB, png_uint_32 \fP\fIscreen_gamma\fP\fB, png_uint_32 \fIdefault_file_gamma\fP\fB);\fP
libpng.3:\fBvoid png_set_gAMA_fixed (png_structp \fP\fIpng_ptr\fP\fB, png_infop \fP\fIinfo_ptr\fP\fB, png_uint_32 \fIfile_gamma\fP\fB);\fP
libpng.3:\fBvoid png_set_chunk_malloc_max (png_structp \fP\fIpng_ptr\fP\fB, png_alloc_size_t \fIuser_chunk_cache_max\fP\fB);\fP
libpng.3:\fBvoid png_set_oFFs (png_structp \fP\fIpng_ptr\fP\fB, png_infop \fP\fIinfo_ptr\fP\fB, png_uint_32 \fP\fIoffset_x\fP\fB, png_uint_32 \fP\fIoffset_y\fP\fB, int \fIunit_type\fP\fB);\fP
libpng.3:\fBvoid png_set_pHYs (png_structp \fP\fIpng_ptr\fP\fB, png_infop \fP\fIinfo_ptr\fP\fB, png_uint_32 \fP\fIres_x\fP\fB, png_uint_32 \fP\fIres_y\fP\fB, int \fIunit_type\fP\fB);\fP
libpng.3:\fBvoid png_set_quantize (png_structp \fP\fIpng_ptr\fP\fB, png_colorp \fP\fIpalette\fP\fB, int \fP\fInum_palette\fP\fB, int \fP\fImaximum_colors\fP\fB, png_uint_16p \fP\fIhistogram\fP\fB, int \fIfull_quantize\fP\fB);\fP
libpng.3:\fBvoid png_set_rgb_to_gray_fixed (png_structp \fP\fIpng_ptr\fP\fB, int error_action png_uint_32 \fP\fIred\fP\fB, png_uint_32 \fIgreen\fP\fB);\fP
libpng.3:\fBvoid png_set_sCAL_fixed (png_structp \fP\fIpng_ptr\fP\fB, png_infop \fP\fIinfo_ptr\fP\fB, int \fP\fIunit\fP\fB, png_fixed_point \fP\fIwidth\fP\fB, png_fixed_point \fIheight\fP\fB);\fP
libpng.3:\fBvoid png_set_text (png_structp \fP\fIpng_ptr\fP\fB, png_infop \fP\fIinfo_ptr\fP\fB, png_textp \fP\fItext_ptr\fP\fB, int \fInum_text\fP\fB);\fP
libpng.3:\fBvoid png_set_text_compression_level (png_structp \fP\fIpng_ptr\fP\fB, int \fIlevel\fP\fB);\fP
libpng.3:\fBvoid png_set_text_compression_mem_level (png_structp \fP\fIpng_ptr\fP\fB, int \fImem_level\fP\fB);\fP
libpng.3:\fBvoid png_set_text_compression_strategy (png_structp \fP\fIpng_ptr\fP\fB, int \fIstrategy\fP\fB);\fP
libpng.3:\fBvoid png_set_text_compression_window_bits (png_structp \fP\fIpng_ptr\fP\fB, int \fIwindow_bits\fP\fB);\fP
libpng.3:\fBvoid \fP\fIpng_set_text_compression_method\fP\fB, (png_structp \fP\fIpng_ptr\fP\fB, int \fImethod)\fP\fB);\fP
libpng.3:\fBvoid png_set_user_limits (png_structp \fP\fIpng_ptr\fP\fB, png_uint_32 \fP\fIuser_width_max\fP\fB, png_uint_32 \fIuser_height_max\fP\fB);\fP
libpng.3:Following is a copy of the libpng-manual.txt file that accompanies libpng.
libpng.3:libpng-manual.txt - A description on how to use and modify libpng
libpng.3:   IX. Changes to Libpng from version 1.0.x to 1.2.x
libpng.3:    X. Changes to Libpng from version 1.0.x/1.2.x to 1.4.x
libpng.3:   XI. Changes to Libpng from version 1.4.x to 1.5.x
libpng.3:  XII. Changes to Libpng from version 1.5.x to 1.6.x
libpng.3:file, example.c is a good starting point for using the library, as
libpng.3:For examples of libpng usage, see the files "example.c", "pngtest.c",
libpng.3:and png_info.  Both are internal structures that are no longer exposed
libpng.3:single image.  As of 1.5.0 this structure is also not exposed.
libpng.3:APIs.  Most of these are fairly obvious; for example types corresponding
libpng.3:One exception is how non-integral numbers are handled.  For application
libpng.3:macro PNG_FP_1 is defined in png.h along with a type (png_fixed_point)
libpng.3:takes the corresponding fixed point integer arguments.  The fixed point
libpng.3:API has the same name as the floating point one with "_fixed" appended.
libpng.3:the full range of (png_fixed_point) (\-21474 to +21474).  When APIs require
libpng.3:the header file and the text below for more information.
libpng.3:should check the feature macros before using an API for maximum
libpng.3:the next section ("Reading").
libpng.3:using (typically) CPPFLAGS.  For example:
libpng.3:other arithmetic calculations to fixed point, avoiding the need for fast
libpng.3:If you need to make more extensive configuration changes - more than one or two
libpng.3:A variety of methods exist to build libpng.  Not all of these support
libpng.3:examine the intermediate file pnglibconf.dfn to find the full set of
libpng.3:in a PNG file sequentially, briefly explaining the syntax and purpose
libpng.3:of each one.  See example.c and png.h for more detail.  While
libpng.3:progressive reading is covered in the next section, you will still
libpng.3:Next, png_struct and png_info need to be allocated and initialized.  In
libpng.3:When libpng encounters an error, it expects to longjmp back
libpng.3:If you would rather avoid the complexity of setjmp/longjmp issues,
libpng.3:callback returns 0.  If you want the existing behavior you should set the global
libpng.3:the 'row' and 'pass' refer to the next row to be handled.  For the
libpng.3:                 all known chunks except for the IHDR,
libpng.3:Here is an example of the usage of png_set_keep_unknown_chunks(),
libpng.3:      /* except for vpAg: */
libpng.3:large as 2^(31\-1 (0x7fffffff), or about 2.147 billion rows and columns.
libpng.3:   png_set_user_limits(png_ptr, width_max, height_max);
libpng.3:   width_max = png_get_user_width_max(png_ptr);
libpng.3:   height_max = png_get_user_height_max(png_ptr);
libpng.3:   png_set_chunk_cache_max(png_ptr, user_chunk_cache_max);
libpng.3:where 0x7fffffffL means unlimited.  You can retrieve this limit with
libpng.3:   chunk_cache_max = png_get_chunk_cache_max(png_ptr);
libpng.3:   png_set_chunk_malloc_max(png_ptr, user_chunk_malloc_max);
libpng.3:   chunk_malloc_max = png_get_chunk_malloc_max(png_ptr);
libpng.3:Any chunks that would cause either of these limits to be exceeded will
libpng.3:header.  In earlier versions png_set_gamma() existed but behaved incorrectly if
libpng.3:exist.
libpng.3:You give libpng the encoding expected by your system expressed as a 'gamma'
libpng.3:or you can use the fixed point equivalent:
libpng.3:   png_set_gamma_fixed(png_ptr, PNG_FP_1*screen_gamma,
libpng.3:approximation to the IEC standard for display systems (sRGB).  If images are
libpng.3:   PNG_GAMMA_LINEAR: Just the fixed point value for 1.0 - indicates
libpng.3:                     that the system expects data with no gamma
libpng.3:You would use the linear (unencoded) value if you need to process the pixel
libpng.3:The output_gamma value expresses how to decode the output values, not how
libpng.3:describe the overall gamma of a computer display system; for example 2.2 for
libpng.3:an sRGB conformant system.  The values are scaled by 100000 in the _fixed
libpng.3:opaque pixels however pixels with lower alpha values are not encoded,
libpng.3:highly unexpected!
libpng.3:behind it.  sRGB is defined to be approximated by a PNG gAMA chunk value of
libpng.3:value expresses how to *decode* the image for display, not how the original
libpng.3:sRGB itself, and earlier TV standards, actually use a more complex transform
libpng.3:(a linear portion then a gamma 2.4 power law) than PNG can express.  (PNG is
libpng.3:extra viewing correction used in early Mac display systems was implemented as
libpng.3:difficult and most PNG gamma correction only requires an approximate value.
libpng.3:NOTE: the values can be passed to either the fixed or floating
libpng.3:contribution of the pixel to the corresponding final output pixel.
libpng.3:unnecessarily complex.
libpng.3:gamma encoding is used.  In addition all non-transparent pixel values,
libpng.3:convert the pixels to an associated form before returning them to your
libpng.3:possible to optimize the handling of alpha by storing the opaque pixels in
libpng.3:opaque pixels in the standard, linear, format.  The accuracy required for
libpng.3:standard alpha composition is relatively low, because the pixels are
libpng.3:this case!)  This is the 'OPTIMIZED' mode.  For this mode a pixel is
libpng.3:treated as opaque only if the alpha value is equal to the maximum value.
libpng.3:perform arithmetic on the pixels without decoding them,
libpng.3:pre-multiplied pixel values will be gamma encoded but
libpng.3:supports it, use png_set_expand_16() to force all
libpng.3:except that completely opaque pixels are gamma encoded according to
libpng.3:the screen_gamma value.  Pixels with alpha less than 1.0
libpng.3:compositing software can simply copy opaque pixels to
libpng.3:non-opaque pixels.
libpng.3:partial pixel coverage (as opposed to broad area
libpng.3:representation of non-opaque pixels are irrelevant.
libpng.3:If you don't have to deal with bugs in software or hardware, or if you can fix
libpng.3:   png_set_expand_16(png_ptr);
libpng.3:If you are using the high level interface, don't call png_set_expand_16();
libpng.3:You can avoid the expansion to 16-bit components with this mode, but you
libpng.3:The following are examples of calls to png_set_alpha_mode to achieve the
libpng.3:    png_set_expand_16(pp);
libpng.3:If you just need to composite the PNG image onto an existing background
libpng.3:setting.  In this case you just copy completely opaque pixels to the
libpng.3:output.  For pixels that are not completely transparent (you just skip
libpng.3:your hardware/software fixed!  (The OPTIMIZED approach is slightly
libpng.3:png_set_background() to remove it by compositing against a fixed color.  Don't
libpng.3:call png_set_strip_alpha() to do this - it will leave spurious pixel values in
libpng.3:   png_set_expand(png_ptr); png_set_scale_16(png_ptr);
libpng.3:   If you must get exactly the same inaccurate results
libpng.3:   png_set_expand_16(png_ptr);
libpng.3:In either case palette image data will be expanded to RGB.  If you just want
libpng.3:prior to libpng-1.5.4.  Because the failure may result in unexpected warnings or
libpng.3:    PNG_TRANSFORM_PACKING       Expand 1, 2 and 4-bit
libpng.3:                                pixels to LSB first
libpng.3:    PNG_TRANSFORM_EXPAND        Perform set_expand()
libpng.3:    PNG_TRANSFORM_SHIFT         Normalize pixels to the
libpng.3:    PNG_TRANSFORM_GRAY_TO_RGB   Expand grayscale samples
libpng.3:    PNG_TRANSFORM_EXPAND_16     Expand samples to 16 bits
libpng.3:(This excludes setting a background color, doing gamma transformation,
libpng.3:where row_pointers is an array of pointers to the pixel data for each row:
libpng.3:If you know your image size and pixel size ahead of time, you can allocate
libpng.3:   if (width > PNG_UINT_32_MAX/pixel_size)
libpng.3:          width*pixel_size);
libpng.3:resulting in unexpected behavior.  Libpng-1.5.4 no longer does this.
libpng.3:                     in pixels (up to 2^31).
libpng.3:                     in pixels (up to 2^31).
libpng.3:pointer into the info_ptr is returned for any complex types.
libpng.3:gamma when combining semitransparent pixels with the background color, and,
libpng.3:since libpng-1.6.0, when converting between 8-bit sRGB and 16-bit linear pixels
libpng.3:    png_get_gAMA_fixed(png_ptr, info_ptr, &int_file_gamma);
libpng.3:    png_get_cHRM(png_ptr, info_ptr,  &white_x, &white_y, &red_x,
libpng.3:                     &red_y, &green_x, &green_y, &blue_x, &blue_y)
libpng.3:    png_get_cHRM_fixed(png_ptr, info_ptr, &int_white_x,
libpng.3:                     &int_white_y, &int_red_x, &int_red_y,
libpng.3:                     &int_green_x, &int_green_y, &int_blue_x,
libpng.3:    png_get_cHRM_XYZ_fixed(png_ptr, info_ptr, &int_red_X, &int_red_Y,
libpng.3:    {white,red,green,blue}_{x,y}
libpng.3:                     means that the pixel data is in the
libpng.3:    num_comments   = png_get_text(png_ptr, info_ptr,
libpng.3:                     &text_ptr, &num_text);
libpng.3:    text_ptr       - array of png_text holding image
libpng.3:    text_ptr[i].compression - type of compression used
libpng.3:                 on "text" PNG_TEXT_COMPRESSION_NONE
libpng.3:    text_ptr[i].key   - keyword for comment.  Must contain
libpng.3:    text_ptr[i].text  - text comments for current
libpng.3:    text_ptr[i].text_length - length of text string,
libpng.3:    text_ptr[i].itxt_length - length of itxt string,
libpng.3:    text_ptr[i].lang  - language of comment (empty
libpng.3:    text_ptr[i].lang_key  - keyword in UTF-8
libpng.3:    Note that the itxt_length, lang, and lang_key
libpng.3:    members of the text_ptr structure only exist when the
libpng.3:    num_text       - number of comments (same as
libpng.3:    Note while png_set_text() will accept text, language,
libpng.3:    structure returned by png_get_text will always contain
libpng.3:    png_get_oFFs(png_ptr, info_ptr, &offset_x, &offset_y,
libpng.3:    offset_x       - positive offset from the left edge
libpng.3:    png_get_pHYs(png_ptr, info_ptr, &res_x, &res_y,
libpng.3:    res_x          - pixels/unit physical resolution in
libpng.3:                     x direction
libpng.3:    res_y          - pixels/unit physical resolution in
libpng.3:                     x direction
libpng.3:    width       - width of a pixel in physical scale units
libpng.3:    height      - height of a pixel in physical scale units
libpng.3:    width       - width of a pixel in physical scale units
libpng.3:                  (expressed as a string)
libpng.3:    height      - height of a pixel in physical scale units
libpng.3:         PNG_HAVE_IHDR  (0x01)
libpng.3:         PNG_HAVE_PLTE  (0x02)
libpng.3:         PNG_AFTER_IDAT (0x08)
libpng.3:    res_x = png_get_x_pixels_per_meter(png_ptr,
libpng.3:    res_y = png_get_y_pixels_per_meter(png_ptr,
libpng.3:    res_x_and_y = png_get_pixels_per_meter(png_ptr,
libpng.3:    res_x = png_get_x_pixels_per_inch(png_ptr,
libpng.3:    res_y = png_get_y_pixels_per_inch(png_ptr,
libpng.3:    res_x_and_y = png_get_pixels_per_inch(png_ptr,
libpng.3:    aspect_ratio = png_get_pixel_aspect_ratio(png_ptr,
libpng.3:       the data is not present or if res_x is 0;
libpng.3:       res_x_and_y is 0 if res_x != res_y
libpng.3:       come out to exactly even number.  For example,
libpng.3:       72 dpi is stored as 0.28346 pixels/meter, and
libpng.3:    x_offset = png_get_x_offset_microns(png_ptr, info_ptr);
libpng.3:    x_offset = png_get_x_offset_inches(png_ptr, info_ptr);
libpng.3:       x and y are 0] if the data is not present or if the
libpng.3:       chunk is present but the unit is the pixel.  The
libpng.3:       remark about inexact inch conversions applies here
libpng.3:needed to hold a row (expand, filler, gray_to_rgb, etc.).
libpng.3:A quick word about text_ptr and num_text.  PNG stores comments in
libpng.3:keyword/text pairs, one pair per chunk, with no limit on the number
libpng.3:of text chunks, and a 2^31 byte limit on their size.  While there are
libpng.3:strings.  It is strongly suggested that keywords and text be sensible
libpng.3:There is also no requirement to have text after the keyword.
libpng.3:The text_ptr is an array of png_text structures, each holding a
libpng.3:a text string.  The text string, language code, and translated
libpng.3:keyword may be empty or NULL pointers.  The keyword/text
libpng.3:However, some or all of the text chunks may be after the image, so, to
libpng.3:make sure you have read all the text chunks, don't mess with these
libpng.3:transformations, for example both adding and removing the alpha channel, you
libpng.3:as the image data in a tRNS chunk, so this is what libpng expects for this data.
libpng.3:The color used for the background value depends on the need_expand argument as
libpng.3:For example, 4 bit/pixel paletted or grayscale data will be returned
libpng.3:2 pixels/byte with the leftmost pixel in the high-order bits of the
libpng.3:        bit_depth < 8) png_set_expand_gray_1_2_4_to_8(png_ptr);
libpng.3:The first two functions are actually aliases for png_set_expand(), added
libpng.3:in libpng version 1.0.4, with the function names expanded to improve code
libpng.3:As of libpng version 1.2.9, png_set_expand_gray_1_2_4_to_8() was
libpng.3:added.  It expands the sample depth without changing tRNS to alpha.
libpng.3:As of libpng version 1.5.2, png_set_expand_16() was added.  It behaves as
libpng.3:png_set_expand(); however, the resultant channels have 16 bits rather than 8.
libpng.3:      png_set_expand_16(png_ptr);
libpng.3:8 bits per channel, this will strip the pixels down to 8-bit.
libpng.3:data (for example if you convert it to a bitmap mask) it is possible to have
libpng.3:As of libpng version 1.5.2, almost all useful expansions are supported, the
libpng.3:major ommissions are conversion of grayscale to indexed images (which can be
libpng.3:done trivially in the application) and conversion of indexed to grayscale (which
libpng.3:indexed with depth<8, other numerals represent the color type, "T" means
libpng.3:means tRNS or alpha is present but all pixels in the image are opaque.
libpng.3:Within the matrix,
libpng.3:     "X" means the transformation is obtained by png_set_expand().
libpng.3:         png_set_expand_gray_1_2_4_to_8() (and by png_set_expand()
libpng.3:         png_set_expand_palette_to_rgb().
libpng.3:PNG files pack pixels of bit depths 1, 2, and 4 into bytes as small as
libpng.3:they can, resulting in, for example, 8 pixels per byte for 1 bit
libpng.3:files.  This code expands to 1 pixel per byte without changing the
libpng.3:values of the pixels:
libpng.3:PNG files have possible bit depths of 1, 2, 4, 8, and 16.  All pixels
libpng.3:stored in a PNG image have been "scaled" or "shifted" up to the next
libpng.3:to convert the PNG pixel data back to the original bit depth of the
libpng.3:image.  This call reduces the pixels back down to the original bit depth:
libpng.3:PNG files store 3-color pixels in red, green, blue order.  This code
libpng.3:changes the storage of the pixels to blue, green, red:
libpng.3:PNG files store RGB pixels packed into 3 or 6 bytes. This code expands them
libpng.3:opaque alpha channel, use filler=0xff or 0xffff and PNG_FILLER_AFTER which
libpng.3:will generate RGBA pixels.
libpng.3:where "filler" contains the alpha value to assign to each pixel.
libpng.3:                      image has any pixel where
libpng.3:                      image has any pixel where
libpng.3:In the corresponding fixed point API the red_weight and green_weight values are
libpng.3:       png_fixed_point red_weight,
libpng.3:       png_fixed_point green_weight);
libpng.3:1 if there were any non-gray pixels.  Background and sBIT data
libpng.3:Libpng uses an integer approximation:
libpng.3:header, even if you don't want to use the color in a bKGD chunk, if one exists.
libpng.3:color.  The function takes two arguments, background_gamma_mode and need_expand
libpng.3:           PNG_BACKGROUND_GAMMA_FILE, 1/*needs to be expanded*/, 1);
libpng.3:           PNG_BACKGROUND_GAMMA_SCREEN, 0/*do not expand*/, 1);
libpng.3:index and for low bit greyscale images the color is a reduced bit value in
libpng.3:If you didn't call png_set_gamma() before reading the file header, for example
libpng.3:pass a palette that is larger than maximum_colors, the file will
libpng.3:maximum_colors.  If there is a histogram, libpng will use it to make
libpng.3:            max_screen_colors, histogram, 1);
libpng.3:PNG files store 16-bit pixels in network byte order (big-endian,
libpng.3:If you are using packed-pixel images (1, 2, or 4 bits/pixel), and you
libpng.3:need to change the order the pixels are packed into bytes, you can use:
libpng.3:the existing ones meets your needs.  This is done by setting a callback
libpng.3:See pngtest.c for a working example.  Your function will be called
libpng.3:unexpected results unless the row is actually being processed at the moment they
libpng.3:find the output pixel (x,y) given an interlaced sub-image pixel (row,col,pass).
libpng.3:png_get_user_transform_ptr().  For example:
libpng.3:but you must call the function here if you want libpng to handle expansion
libpng.3:varies among applications, no example will be given.  If you
libpng.3:You can point to void or char or whatever you use for pixels.
libpng.3:on an 8x8 grid.  This number is defined (from libpng 1.5) as
libpng.3:mentioned in the PNG specification is to expand each pixel to cover
libpng.3:those pixels that have not been read yet (the "rectangle" method).
libpng.3:smooths out as more pixels are read.  The other method is the "sparkle"
libpng.3:method, where pixels are drawn only in their final locations, with the
libpng.3:but tends to be slower, as there are more pixels to put in the rows.
libpng.3:If, as is likely, you want libpng to expand the images, call this before
libpng.3:will distribute the pixels from the current pass to the correct place in
libpng.3:is exactly the same.  If you are planning on displaying the image
libpng.3:not the data.  Each pass only writes the pixels appropriate for that
libpng.3:before except pass the row buffer in the third parameter, and leave
libpng.3:certainly need to distribute the pixels from each sub-image to the
libpng.3:not even exist because either their width or height ends up zero.
libpng.3:produce optimal code to make a pixel-by-pixel transformation of an
libpng.3:macros to help that tell you where to place the pixels in the output image.
libpng.3:Because the interlacing scheme is rectangular - sub-image pixels are always
libpng.3:starting column and row in the output image of the first pixel plus the
libpng.3:spacing between each pixel.  As of libpng 1.5 there are four macros to
libpng.3:   png_uint_32 x = PNG_PASS_START_COL(pass);
libpng.3:   png_uint_32 xStep = 1U << PNG_PASS_COL_SHIFT(pass);
libpng.3:      png_uint_32 input_x = 0;
libpng.3:      png_uint_32 output_x = PNG_PASS_START_COL(pass);
libpng.3:      while (output_x < output_image_width)
libpng.3:         image[output_y][output_x] =
libpng.3:             subimage[pass][input_y][input_x++];
libpng.3:         output_x += xStep;
libpng.3:returned as shifts.  This is possible because the pixels in the subimages
libpng.3:are always a power of 2 apart - 1, 2, 4 or 8 pixels - in the original
libpng.3:   png_uint_32 output_x = PNG_COL_FROM_PASS_COL(input_x, pass);
libpng.3:   int col_in_pass = PNG_COL_IN_INTERLACE_PASS(output_x, pass);
libpng.3:of the pass in addition to the above to be sure the pass even exists!
libpng.3:is if you are processing PNG files on a pixel-by-pixel basis and don't want
libpng.3:not what you want if you expect to read something beyond the end of
libpng.3:are allowed for the data type identified in the mask, such as text or
libpng.3:function is responsible for freeing any existing data that might be present,
libpng.3:If you allocated text_ptr.text, text_ptr.lang, and text_ptr.translated_keyword
libpng.3:separately, do not transfer responsibility for freeing text_ptr to libpng,
libpng.3:because when libpng fills a png_text structure it combines these members with
libpng.3:the key member, and png_free_data() will free only text_ptr.key.  Similarly,
libpng.3:if you transfer responsibility for free'ing text_ptr from libpng to your
libpng.3:For a more compact example of reading a PNG image, see the file example.c.
libpng.3: /*  An example code fragment of how you would
libpng.3:       libpng skipping that number of bytes on the next
libpng.3:       call - it is up to you to ensure that the next call
libpng.3:Next, png_struct and png_info need to be allocated and initialized.
libpng.3:"read_ptr" and "write_ptr".  Look at pngtest.c, for example.
libpng.3:error handling.  When libpng encounters an error, it expects to
libpng.3:If you would rather avoid the complexity of setjmp/longjmp issues,
libpng.3:Checking for invalid palette index on write was added at libpng
libpng.3:1.5.10.  If a pixel contains an invalid (out-of-range) index libpng issues
libpng.3:   png_set_check_for_invalid_index(png_ptr, 0);
libpng.3:any invalid pixels are written as-is by the encoder, resulting in an
libpng.3:responsible for ensuring that the pixel indexes are in range when it writes
libpng.3:it has also been written out.  The 'row' and 'pass' refer to the next row to be
libpng.3:in some cases, like if you need to write PNG files extremely fast and
libpng.3:maximum possible compression at the expense of slower writing.  If you
libpng.3:the previous row of pixels will be stored in case it's needed later),
libpng.3:data.  See the Compression Library (zlib.h and algorithm.txt, distributed
libpng.3:    /* Set zlib parameters for text compression
libpng.3:    png_set_text_compression_mem_level(png_ptr, 8);
libpng.3:    png_set_text_compression_strategy(png_ptr,
libpng.3:    png_set_text_compression_window_bits(png_ptr, 15);
libpng.3:    png_set_text_compression_method(png_ptr, 8);
libpng.3:are allowed to write after the image is the text chunks and the time
libpng.3:their data types, see png.h.  For explanations of what the fields
libpng.3:                     in pixels (up to 2^31).
libpng.3:                     in pixels (up to 2^31).
libpng.3:    png_set_gAMA_fixed(png_ptr, info_ptr, int_file_gamma);
libpng.3:    png_set_cHRM(png_ptr, info_ptr,  white_x, white_y, red_x, red_y,
libpng.3:                     green_x, green_y, blue_x, blue_y)
libpng.3:    png_set_cHRM_fixed(png_ptr, info_ptr, int_white_x, int_white_y,
libpng.3:                     int_red_x, int_red_y, int_green_x, int_green_y,
libpng.3:                     int_blue_x, int_blue_y)
libpng.3:    png_set_cHRM_XYZ_fixed(png_ptr, info_ptr, int_red_X, int_red_Y,
libpng.3:    {white,red,green,blue}_{x,y}
libpng.3:                     the sRGB chunk means that the pixel
libpng.3:                     sRGB chunk means that the pixel
libpng.3:    png_set_text(png_ptr, info_ptr, text_ptr, num_text);
libpng.3:    text_ptr       - array of png_text holding image
libpng.3:    text_ptr[i].compression - type of compression used
libpng.3:                 on "text" PNG_TEXT_COMPRESSION_NONE
libpng.3:    text_ptr[i].key   - keyword for comment.  Must contain
libpng.3:    text_ptr[i].text  - text comments for current
libpng.3:    text_ptr[i].text_length - length of text string,
libpng.3:    text_ptr[i].itxt_length - length of itxt string,
libpng.3:    text_ptr[i].lang  - language of comment (NULL or
libpng.3:    text_ptr[i].translated_keyword  - keyword in UTF-8 (NULL
libpng.3:    Note that the itxt_length, lang, and lang_key
libpng.3:    members of the text_ptr structure only exist when the
libpng.3:    num_text       - number of comments
libpng.3:    png_set_oFFs(png_ptr, info_ptr, offset_x, offset_y,
libpng.3:    offset_x  - positive offset from the left
libpng.3:    png_set_pHYs(png_ptr, info_ptr, res_x, res_y,
libpng.3:    res_x       - pixels/unit physical resolution
libpng.3:                  in x direction
libpng.3:    res_y       - pixels/unit physical resolution
libpng.3:    width       - width of a pixel in physical scale units
libpng.3:    height      - height of a pixel in physical scale units
libpng.3:    width       - width of a pixel in physical scale units
libpng.3:                  expressed as a string
libpng.3:    height      - height of a pixel in physical scale units
libpng.3:A quick word about text and num_text.  text is an array of png_text
libpng.3:structures.  num_text is the number of valid structures in the array.
libpng.3:Each png_text structure holds a language code, a keyword, a text value,
libpng.3:However, you can store text either compressed or uncompressed, unlike
libpng.3:text compressed, set the compression type to PNG_TEXT_COMPRESSION_NONE.
libpng.3:Until text gets around a few hundred bytes, it is not worth compressing it.
libpng.3:After the text has been written out to the file, the compression type
libpng.3:The keyword-text pairs work like this.  Keywords should be short
libpng.3:some text before the image and some after.  For example, you may want
libpng.3:words, not abbreviations.  Keywords and text are in the ISO 8859-1
libpng.3:with basic ASCII, and avoid machine specific character set extensions
libpng.3:you can leave off the text string on non-compressed pairs.
libpng.3:Compressed pairs must have a text string, as only the text string
libpng.3:"Creation Time" tEXt chunk is not expected to be automatically changed
libpng.3:next following png_write_info_before_PLTE, png_write_info, or png_write_end
libpng.3:Here is an example of writing two private chunks, prVt and miNE:
libpng.3:      /* Deal with unknown chunk location bug in 1.5.x and earlier */
libpng.3:                                pixels to LSB first
libpng.3:    PNG_TRANSFORM_SHIFT         Normalize pixels to the
libpng.3:data.  For example, don't swap red and blue on grayscale data.
libpng.3:PNG files store RGB pixels packed into 3 or 6 bytes.  This code tells
libpng.3:the library to strip input data that has 4 or 8 bytes per pixel down
libpng.3:bytes per pixel).
libpng.3:PNG_FILLER_AFTER, depending upon whether the filler byte in the pixel
libpng.3:PNG files pack pixels of bit depths 1, 2, and 4 into bytes as small as
libpng.3:they can, resulting in, for example, 8 pixels per byte for 1 bit files.
libpng.3:If the data is supplied at 1 pixel per byte, use this code, which will
libpng.3:correctly pack the pixels into a single byte:
libpng.3:PNG files store 16-bit pixels in network byte order (big-endian,
libpng.3:If you are using packed-pixel images (1, 2, or 4 bits/pixel), and you
libpng.3:need to change the order the pixels are packed into bytes, you can use:
libpng.3:PNG files store 3 color pixels in red, green, blue order.  This code
libpng.3:one. This code would be used if the pixels are supplied with this reversed
libpng.3:the existing ones meets your needs.  This is done by setting a callback
libpng.3:See pngtest.c for a working example.  Your function will be called
libpng.3:find the output pixel (x,y) given an interlaced sub-image pixel (row,col,pass).
libpng.3:For example:
libpng.3:output on the next scanline, and every 25 lines thereafter, unless
libpng.3:If nrows is too small (less than about 10 lines for a 640 pixel wide
libpng.3:You can point to void or char or whatever you use for pixels.
libpng.3:for details of which pixels to write when.
libpng.3:take advantage of the interlacing and even then the image has to be exactly
libpng.3:adjacent pixels and these are not available until all the passes have been
libpng.3:made some pixel-by-pixel transformation to it, as described in the read
libpng.3:are allowed for the data type identified in the mask, such as text or
libpng.3:For example, to transfer responsibility for some data from a read structure
libpng.3:If you allocated text_ptr.text, text_ptr.lang, and text_ptr.translated_keyword
libpng.3:separately, do not transfer responsibility for freeing text_ptr to libpng,
libpng.3:because when libpng fills a png_text structure it combines these members with
libpng.3:the key member, and png_free_data() will free only text_ptr.key.  Similarly,
libpng.3:if you transfer responsibility for free'ing text_ptr from libpng to your
libpng.3:For a more compact example of writing a PNG image, see the file example.c.
libpng.3:   png_uint_32  width   Image width in pixels (columns)
libpng.3:   png_uint_32  height  Image height in pixels (rows)
libpng.3:The pixels (samples) of the image have one to four channels whose components
libpng.3:and matches the 8-bit format expected by typical display devices.
libpng.3:When an alpha channel is present it is expected to denote pixel coverage
libpng.3:The image data is encoded as small integers, value 0..255, that index the
libpng.3:entries in the color-map.  One integer (one byte) is stored for each pixel.
libpng.3:   PNG_FORMAT_FLAG_ALPHA    0x01 format with an alpha channel
libpng.3:   PNG_FORMAT_FLAG_COLOR    0x02 color format: otherwise grayscale
libpng.3:   PNG_FORMAT_FLAG_LINEAR   0x04 png_uint_16 channels else png_byte
libpng.3:   PNG_FORMAT_FLAG_COLORMAP 0x08 libpng use only
libpng.3:   PNG_FORMAT_FLAG_BGR      0x10 BGR colors, else order is RGB
libpng.3:   PNG_FORMAT_FLAG_AFIRST   0x20 alpha channel comes first
libpng.3:of the components of the pixels of the image.
libpng.3:indicate a luminance (gray) channel.  The component order within the pixel
libpng.3:format of the color-map may be extracted using the following macro.
libpng.3:pixels in the image.  The PNG_IMAGE_PIXEL_ macros return corresponding values
libpng.3:for the pixels and will always return 1 after a call to
libpng.3:    Returns the size in bytes of a single component of a pixel or color-map
libpng.3:    color-mapped it is the size of one color-map entry (and image pixels are
libpng.3:    one byte in size), otherwise it is the size of one image pixel.
libpng.3:   a fixed number determined by the format so can easily be allocated on the
libpng.3:   /* The maximum size of the color-map required by the format expressed in a
libpng.3:Corresponding information about the pixels
libpng.3:   The number of separate channels (components) in a pixel; 1 for a
libpng.3:   The size, in bytes, of each component in a pixel; 1 for a color-mapped
libpng.3:   The size, in bytes, of a complete pixel; 1 for a color-mapped image.
libpng.3:   plus any padding bytes that your application might need, for example
libpng.3:   to start the next row on a 4-byte boundary.
libpng.3:  PNG_IMAGE_FLAG_COLORSPACE_NOT_sRGB == 0x01
libpng.3:  PNG_IMAGE_FLAG_COLORMAP == 0x02
libpng.3:approximation used elsewhere in libpng.
libpng.3:   width: image width in pixels
libpng.3:from one row to the next in component sized units (float) and if negative
libpng.3:Note that the write API does not support interlacing, sub-8-bit pixels,
libpng.3:and indexed (paletted) images.
libpng.3:png_get_io_ptr().  For example:
libpng.3:to using the default C stream functions, which expect the io_ptr to
libpng.3:but you could change this to do things like exit() if you should wish,
libpng.3:catch exception handling methods.  This makes the code much easier to write,
libpng.3:may wish to use the "cexcept" facility (see http://cexcept.sourceforge.net),
libpng.3:chunk and existing `intrinsic' chunks.
libpng.3:faster.  For online applications it may be desirable to have maximum speed
libpng.3:short on memory (running DOS, for example, where you only have 640K).
libpng.3:    png_set_text_compression_level(png_ptr, level);
libpng.3:    png_set_text_compression_mem_level(png_ptr, level);
libpng.3:    png_set_text_compression_strategy(png_ptr,
libpng.3:    png_set_text_compression_window_bits(png_ptr,
libpng.3:    png_set_text_compression_method(png_ptr, method);
libpng.3:for any images with bit depths less than 8 bits/pixel.
libpng.3:is that many times better than the previous filter.  In the above example,
libpng.3:"sum of absolute differences" 1.5 x 1.3 times higher than other filters
libpng.3:The costs do not necessarily reflect the exact computational speeds of
libpng.3:Note that the numbers above were invented purely for this example and
libpng.3:are given only to help explain the function usage.  Little testing has
libpng.3:according to printf-style formatting directives.  For example,
libpng.3:is expanded to
libpng.3:certain extensions to PNG for PNG images that are embedded in MNG datastreams.
libpng.3:Libpng can support some of these extensions.  To enable them, use the
libpng.3:.SH IX.  Changes to Libpng from version 1.0.x to 1.2.x
libpng.3:by default.  The functions png_set_user_limits(), png_get_user_width_max(),
libpng.3:and png_get_user_height_max() were added at libpng-1.2.6.
libpng.3:The function png_set_expand_gray_1_2_4_to_8() was added at libpng-1.2.9.
libpng.3:Unlike png_set_gray_1_2_4_to_8(), the new function does not expand the
libpng.3:    png_get_mmx_flagmask()
libpng.3:    png_set_mmx_thresholds()
libpng.3:    png_get_mmx_bitdepth_threshold()
libpng.3:    png_get_mmx_rowbytes_threshold()
libpng.3:which also expands tRNS to alpha was replaced with
libpng.3:    png_set_expand_gray_1_2_4_to_8()
libpng.3:.SH X.  Changes to Libpng from version 1.0.x/1.2.x to 1.4.x
libpng.3:Support for setting the maximum amount of memory that the application
libpng.3:The functions png_set_chunk_cache_max() and png_get_chunk_cache_max()
libpng.3:We removed the obsolete stub functions png_get_mmx_flagmask(),
libpng.3:png_set_mmx_thresholds(), png_get_asm_flags(),
libpng.3:png_get_mmx_bitdepth_threshold(), png_get_mmx_rowbytes_threshold(),
libpng.3:png_set_asm_flags(), and png_mmx_supported()
libpng.3:png_set_expand_gray_1_2_4_to_8() because the former function also
libpng.3:expanded any tRNS chunk to an alpha channel.
libpng.3:of "png_malloc(); memset();" except in the case in png_read_png()
libpng.3:The png_zalloc() and png_zfree() functions are no longer exported.
libpng.3:.SH XI.  Changes to Libpng from version 1.4.x to 1.5.x
libpng.3:Checking for invalid palette index on write was added at libpng
libpng.3:1.5.10.  If a pixel contains an invalid (out-of-range) index libpng issues
libpng.3:   png_set_check_for_invalid_index(png_ptr, allowed);
libpng.3:any invalid pixels are decoded as opaque black by the decoder and written
libpng.3:Retrieving the maximum palette index found was added at libpng-1.5.15.
libpng.3:   int max_palette = png_get_palette_max(png_ptr, info_ptr);
libpng.3:This will return the maximum palette index found in the image, or "\-1" if
libpng.3:does not account for any palette index used by ancillary chunks such as the
libpng.3:bKGD chunk; you must check those separately to determine the maximum
libpng.3:palette index actually used.
libpng.3:changed and some of this is visible in the exported header files, in
libpng.3:application code.  (It is extremely rare for an application to do this.)
libpng.3:against libpng 1.5, except for the change in the prototype for
libpng.3:libpng 1.5.0 includes a complete fixed point API.  By default this is
libpng.3:fixed point API is faster and smaller than the floating point one because
libpng.3:the PNG file format used fixed point, not floating point.  This applies
libpng.3:uses floating point arithmetic (the default) or fixed point arithmetic
libpng.3:composition (png_set_background for example). This applies even if the
libpng.3:Fixed point support for the sCAL chunk comes with an important caveat;
libpng.3:and the accuracy of PNG fixed point values is insufficient for
libpng.3:reset by pngusr.h or by explicit settings on the compiler command line.
libpng.3:when compressing the IDAT data and textual data such as zTXt and iCCP.
libpng.3:We added five png_set_text_*() functions for setting the parameters to
libpng.3:use with textual data.
libpng.3:application calls to png_set_user_limits(), png_set_user_chunk_cache_max(),
libpng.3:and/or png_set_user_malloc_max() that increase or decrease the limits.  Also,
libpng.3:from 1,000,000 to 0x7ffffff (i.e., made unlimited).  Therefore, the
libpng.3:   png_user_width_max        0x7fffffff    1,000,000
libpng.3:   png_user_height_max       0x7fffffff    1,000,000
libpng.3:   png_user_chunk_cache_max  0 (unlimited)   128
libpng.3:   png_user_chunk_malloc_max 0 (unlimited) 8,000,000
libpng.3:The library now supports a complete fixed point implementation and can
libpng.3:independent of the choice of fixed versus floating point APIs and all the
libpng.3:missing fixed point APIs have been implemented.
libpng.3:The exact mechanism used to control attributes of API functions has
libpng.3:3) Three feature macros now control the fixed/floating point decisions:
libpng.3:PNG_FIXED_POINT_SUPPORTED enables the fixed point APIs; however, in
libpng.3:file format is fixed point), therefore in most cases PNG_NO_FIXED_POINT
libpng.3:merely stops the function from being exported.
libpng.3:point implementation or the fixed point one.  Typically the fixed point
libpng.3:.SH XII.  Changes to Libpng from version 1.5.x to 1.6.x
libpng.3:example in contrib/examples/pngtopng.c).  The new publicly visible API
libpng.3:Starting with libpng-1.6.0, you can configure libpng to prefix all exported
libpng.3:The signatures of many exported functions were changed, such that
libpng.3:with color type 0 or 4 and that even if the image only contains gray pixels,
libpng.3:a pre-existing bug where the per-chunk 'keep' setting is ignored, and makes
libpng.3:provide a way to revert to the libpng-1.5.x behavior (ignoring the CMF bytes
libpng.3:and provide a tool (contrib/tools/pngfix) for rewriting a PNG file while
libpng.3:chunk.  This error was fixed in libpng-1.6.3, and a tool (called
libpng.3:contrib/tools/png-fix-itxt) has been added to the libpng distribution.
libpng.3:control.  The git repository was built from old libpng-x.y.z.tar.gz files
libpng.3:simple verbal discriptions of bug fixes, reported either to the
libpng.3:We use 3-space indentation, except for continued statements which
libpng.3:exported functions are marked with PNGAPI:
libpng.3: png_exported_function(png_ptr, png_info, foo)
libpng.3:The prototypes for all exported functions appear in png.h,
libpng.3:We mark all non-exported functions with "/* PRIVATE */"":
libpng.3: png_non_exported_function(png_ptr, png_info, foo)
libpng.3:The prototypes for non-exported functions (except for those in
libpng.3:To avoid polluting the global namespace, the names of all exported
libpng.3:is an expression, not a type name, and we always enclose the
libpng.3:"?".  We don't put a space between a typecast and the expression
libpng.3:       y[i] = a(x) + (int)b;
libpng.3:We prefer to express integers that are used as bit masks in hex format,
libpng.3:with an even number of lower-case hex digits (e.g., 0x00, 0xff, 0x0100).
libpng.3:We prefer to use underscores in variable names rather than camelCase, except
libpng.3:Lines do not exceed 80 characters.
libpng.3:holds the date in text format, and will hold years up to 9999.
libpng.3:in libpng-1.6.x and will be removed from libpng-1.7.0.
libpng.3: 1.0.1                     10001  code version except as
libpng.3:for applications, is an unsigned integer of the form xyyzz corresponding
libpng.3:to the source version x.y.z (leading zeros in y and z).  Beta versions
libpng.3:ftp://ds.internic.net/rfc/rfc2083.txt
libpng.3:with testing, bug fixes, and patience.  This wouldn't have been
libpng.3:   Simon-Pierre Cadieux
libpng.3:and Group 42, Inc. disclaim all warranties, expressed or implied,
libpng.3:assume no liability for direct, indirect, incidental, special, exemplary,
libpng.3:boxes and the like:
libpng.3:files "pngbar.png" and "pngbar.jpg (88x31) and "pngnow.png" (98x31).
libpng-config:# Modeled after libxml-config.
libpng-config:prefix="/Users/ananyu/csci3081/Photoshop/libpng-1.6.16"
libpng-config:exec_prefix="${prefix}"
libpng-config:libdir="${exec_prefix}/lib"
libpng-config:includedir="${prefix}/include/libpng16"
libpng-config:  --prefix        print libpng prefix
libpng-config:  --help          print this help and exit
libpng-config:    exit $1
libpng-config:    --prefix)
libpng-config:        echo ${prefix}
libpng-config:        exit 0
libpng-config:        exit 1
libpng-config:exit 0
libpng-config.in:# Modeled after libxml-config.
libpng-config.in:prefix="@prefix@"
libpng-config.in:exec_prefix="@exec_prefix@"
libpng-config.in:  --prefix        print libpng prefix
libpng-config.in:  --help          print this help and exit
libpng-config.in:    exit $1
libpng-config.in:    --prefix)
libpng-config.in:        echo ${prefix}
libpng-config.in:        exit 0
libpng-config.in:        exit 1
libpng-config.in:exit 0
libpng-manual.txt:libpng-manual.txt - A description on how to use and modify libpng
libpng-manual.txt:   IX. Changes to Libpng from version 1.0.x to 1.2.x
libpng-manual.txt:    X. Changes to Libpng from version 1.0.x/1.2.x to 1.4.x
libpng-manual.txt:   XI. Changes to Libpng from version 1.4.x to 1.5.x
libpng-manual.txt:  XII. Changes to Libpng from version 1.5.x to 1.6.x
libpng-manual.txt:file, example.c is a good starting point for using the library, as
libpng-manual.txt:For examples of libpng usage, see the files "example.c", "pngtest.c",
libpng-manual.txt:and png_info.  Both are internal structures that are no longer exposed
libpng-manual.txt:single image.  As of 1.5.0 this structure is also not exposed.
libpng-manual.txt:APIs.  Most of these are fairly obvious; for example types corresponding
libpng-manual.txt:One exception is how non-integral numbers are handled.  For application
libpng-manual.txt:macro PNG_FP_1 is defined in png.h along with a type (png_fixed_point)
libpng-manual.txt:takes the corresponding fixed point integer arguments.  The fixed point
libpng-manual.txt:API has the same name as the floating point one with "_fixed" appended.
libpng-manual.txt:the full range of (png_fixed_point) (-21474 to +21474).  When APIs require
libpng-manual.txt:the header file and the text below for more information.
libpng-manual.txt:should check the feature macros before using an API for maximum
libpng-manual.txt:the next section ("Reading").
libpng-manual.txt:using (typically) CPPFLAGS.  For example:
libpng-manual.txt:other arithmetic calculations to fixed point, avoiding the need for fast
libpng-manual.txt:If you need to make more extensive configuration changes - more than one or two
libpng-manual.txt:A variety of methods exist to build libpng.  Not all of these support
libpng-manual.txt:examine the intermediate file pnglibconf.dfn to find the full set of
libpng-manual.txt:in a PNG file sequentially, briefly explaining the syntax and purpose
libpng-manual.txt:of each one.  See example.c and png.h for more detail.  While
libpng-manual.txt:progressive reading is covered in the next section, you will still
libpng-manual.txt:Next, png_struct and png_info need to be allocated and initialized.  In
libpng-manual.txt:When libpng encounters an error, it expects to longjmp back
libpng-manual.txt:If you would rather avoid the complexity of setjmp/longjmp issues,
libpng-manual.txt:callback returns 0.  If you want the existing behavior you should set the global
libpng-manual.txt:the 'row' and 'pass' refer to the next row to be handled.  For the
libpng-manual.txt:                 all known chunks except for the IHDR,
libpng-manual.txt:Here is an example of the usage of png_set_keep_unknown_chunks(),
libpng-manual.txt:      /* except for vpAg: */
libpng-manual.txt:large as 2^31-1 (0x7fffffff), or about 2.147 billion rows and columns.
libpng-manual.txt:   png_set_user_limits(png_ptr, width_max, height_max);
libpng-manual.txt:   width_max = png_get_user_width_max(png_ptr);
libpng-manual.txt:   height_max = png_get_user_height_max(png_ptr);
libpng-manual.txt:   png_set_chunk_cache_max(png_ptr, user_chunk_cache_max);
libpng-manual.txt:where 0x7fffffffL means unlimited.  You can retrieve this limit with
libpng-manual.txt:   chunk_cache_max = png_get_chunk_cache_max(png_ptr);
libpng-manual.txt:   png_set_chunk_malloc_max(png_ptr, user_chunk_malloc_max);
libpng-manual.txt:   chunk_malloc_max = png_get_chunk_malloc_max(png_ptr);
libpng-manual.txt:Any chunks that would cause either of these limits to be exceeded will
libpng-manual.txt:header.  In earlier versions png_set_gamma() existed but behaved incorrectly if
libpng-manual.txt:exist.
libpng-manual.txt:You give libpng the encoding expected by your system expressed as a 'gamma'
libpng-manual.txt:or you can use the fixed point equivalent:
libpng-manual.txt:   png_set_gamma_fixed(png_ptr, PNG_FP_1*screen_gamma,
libpng-manual.txt:approximation to the IEC standard for display systems (sRGB).  If images are
libpng-manual.txt:   PNG_GAMMA_LINEAR: Just the fixed point value for 1.0 - indicates
libpng-manual.txt:                     that the system expects data with no gamma
libpng-manual.txt:You would use the linear (unencoded) value if you need to process the pixel
libpng-manual.txt:The output_gamma value expresses how to decode the output values, not how
libpng-manual.txt:describe the overall gamma of a computer display system; for example 2.2 for
libpng-manual.txt:an sRGB conformant system.  The values are scaled by 100000 in the _fixed
libpng-manual.txt:opaque pixels however pixels with lower alpha values are not encoded,
libpng-manual.txt:highly unexpected!
libpng-manual.txt:behind it.  sRGB is defined to be approximated by a PNG gAMA chunk value of
libpng-manual.txt:value expresses how to *decode* the image for display, not how the original
libpng-manual.txt:sRGB itself, and earlier TV standards, actually use a more complex transform
libpng-manual.txt:(a linear portion then a gamma 2.4 power law) than PNG can express.  (PNG is
libpng-manual.txt:extra viewing correction used in early Mac display systems was implemented as
libpng-manual.txt:difficult and most PNG gamma correction only requires an approximate value.
libpng-manual.txt:NOTE: the values can be passed to either the fixed or floating
libpng-manual.txt:contribution of the pixel to the corresponding final output pixel.
libpng-manual.txt:unnecessarily complex.
libpng-manual.txt:gamma encoding is used.  In addition all non-transparent pixel values,
libpng-manual.txt:convert the pixels to an associated form before returning them to your
libpng-manual.txt:possible to optimize the handling of alpha by storing the opaque pixels in
libpng-manual.txt:opaque pixels in the standard, linear, format.  The accuracy required for
libpng-manual.txt:standard alpha composition is relatively low, because the pixels are
libpng-manual.txt:this case!)  This is the 'OPTIMIZED' mode.  For this mode a pixel is
libpng-manual.txt:treated as opaque only if the alpha value is equal to the maximum value.
libpng-manual.txt:perform arithmetic on the pixels without decoding them,
libpng-manual.txt:pre-multiplied pixel values will be gamma encoded but
libpng-manual.txt:supports it, use png_set_expand_16() to force all
libpng-manual.txt:except that completely opaque pixels are gamma encoded according to
libpng-manual.txt:the screen_gamma value.  Pixels with alpha less than 1.0
libpng-manual.txt:compositing software can simply copy opaque pixels to
libpng-manual.txt:non-opaque pixels.
libpng-manual.txt:partial pixel coverage (as opposed to broad area
libpng-manual.txt:representation of non-opaque pixels are irrelevant.
libpng-manual.txt:If you don't have to deal with bugs in software or hardware, or if you can fix
libpng-manual.txt:   png_set_expand_16(png_ptr);
libpng-manual.txt:If you are using the high level interface, don't call png_set_expand_16();
libpng-manual.txt:You can avoid the expansion to 16-bit components with this mode, but you
libpng-manual.txt:The following are examples of calls to png_set_alpha_mode to achieve the
libpng-manual.txt:    png_set_expand_16(pp);
libpng-manual.txt:If you just need to composite the PNG image onto an existing background
libpng-manual.txt:setting.  In this case you just copy completely opaque pixels to the
libpng-manual.txt:output.  For pixels that are not completely transparent (you just skip
libpng-manual.txt:your hardware/software fixed!  (The OPTIMIZED approach is slightly
libpng-manual.txt:png_set_background() to remove it by compositing against a fixed color.  Don't
libpng-manual.txt:call png_set_strip_alpha() to do this - it will leave spurious pixel values in
libpng-manual.txt:   png_set_expand(png_ptr); png_set_scale_16(png_ptr);
libpng-manual.txt:   If you must get exactly the same inaccurate results
libpng-manual.txt:   png_set_expand_16(png_ptr);
libpng-manual.txt:In either case palette image data will be expanded to RGB.  If you just want
libpng-manual.txt:prior to libpng-1.5.4.  Because the failure may result in unexpected warnings or
libpng-manual.txt:    PNG_TRANSFORM_PACKING       Expand 1, 2 and 4-bit
libpng-manual.txt:                                pixels to LSB first
libpng-manual.txt:    PNG_TRANSFORM_EXPAND        Perform set_expand()
libpng-manual.txt:    PNG_TRANSFORM_SHIFT         Normalize pixels to the
libpng-manual.txt:    PNG_TRANSFORM_GRAY_TO_RGB   Expand grayscale samples
libpng-manual.txt:    PNG_TRANSFORM_EXPAND_16     Expand samples to 16 bits
libpng-manual.txt:(This excludes setting a background color, doing gamma transformation,
libpng-manual.txt:where row_pointers is an array of pointers to the pixel data for each row:
libpng-manual.txt:If you know your image size and pixel size ahead of time, you can allocate
libpng-manual.txt:   if (width > PNG_UINT_32_MAX/pixel_size)
libpng-manual.txt:          width*pixel_size);
libpng-manual.txt:resulting in unexpected behavior.  Libpng-1.5.4 no longer does this.
libpng-manual.txt:                     in pixels (up to 2^31).
libpng-manual.txt:                     in pixels (up to 2^31).
libpng-manual.txt:pointer into the info_ptr is returned for any complex types.
libpng-manual.txt:gamma when combining semitransparent pixels with the background color, and,
libpng-manual.txt:since libpng-1.6.0, when converting between 8-bit sRGB and 16-bit linear pixels
libpng-manual.txt:    png_get_gAMA_fixed(png_ptr, info_ptr, &int_file_gamma);
libpng-manual.txt:    png_get_cHRM(png_ptr, info_ptr,  &white_x, &white_y, &red_x,
libpng-manual.txt:                     &red_y, &green_x, &green_y, &blue_x, &blue_y)
libpng-manual.txt:    png_get_cHRM_fixed(png_ptr, info_ptr, &int_white_x,
libpng-manual.txt:                     &int_white_y, &int_red_x, &int_red_y,
libpng-manual.txt:                     &int_green_x, &int_green_y, &int_blue_x,
libpng-manual.txt:    png_get_cHRM_XYZ_fixed(png_ptr, info_ptr, &int_red_X, &int_red_Y,
libpng-manual.txt:    {white,red,green,blue}_{x,y}
libpng-manual.txt:                     means that the pixel data is in the
libpng-manual.txt:    num_comments   = png_get_text(png_ptr, info_ptr,
libpng-manual.txt:                     &text_ptr, &num_text);
libpng-manual.txt:    text_ptr       - array of png_text holding image
libpng-manual.txt:    text_ptr[i].compression - type of compression used
libpng-manual.txt:                 on "text" PNG_TEXT_COMPRESSION_NONE
libpng-manual.txt:    text_ptr[i].key   - keyword for comment.  Must contain
libpng-manual.txt:    text_ptr[i].text  - text comments for current
libpng-manual.txt:    text_ptr[i].text_length - length of text string,
libpng-manual.txt:    text_ptr[i].itxt_length - length of itxt string,
libpng-manual.txt:    text_ptr[i].lang  - language of comment (empty
libpng-manual.txt:    text_ptr[i].lang_key  - keyword in UTF-8
libpng-manual.txt:    Note that the itxt_length, lang, and lang_key
libpng-manual.txt:    members of the text_ptr structure only exist when the
libpng-manual.txt:    num_text       - number of comments (same as
libpng-manual.txt:    Note while png_set_text() will accept text, language,
libpng-manual.txt:    structure returned by png_get_text will always contain
libpng-manual.txt:    png_get_oFFs(png_ptr, info_ptr, &offset_x, &offset_y,
libpng-manual.txt:    offset_x       - positive offset from the left edge
libpng-manual.txt:    png_get_pHYs(png_ptr, info_ptr, &res_x, &res_y,
libpng-manual.txt:    res_x          - pixels/unit physical resolution in
libpng-manual.txt:                     x direction
libpng-manual.txt:    res_y          - pixels/unit physical resolution in
libpng-manual.txt:                     x direction
libpng-manual.txt:    width       - width of a pixel in physical scale units
libpng-manual.txt:    height      - height of a pixel in physical scale units
libpng-manual.txt:    width       - width of a pixel in physical scale units
libpng-manual.txt:                  (expressed as a string)
libpng-manual.txt:    height      - height of a pixel in physical scale units
libpng-manual.txt:         PNG_HAVE_IHDR  (0x01)
libpng-manual.txt:         PNG_HAVE_PLTE  (0x02)
libpng-manual.txt:         PNG_AFTER_IDAT (0x08)
libpng-manual.txt:    res_x = png_get_x_pixels_per_meter(png_ptr,
libpng-manual.txt:    res_y = png_get_y_pixels_per_meter(png_ptr,
libpng-manual.txt:    res_x_and_y = png_get_pixels_per_meter(png_ptr,
libpng-manual.txt:    res_x = png_get_x_pixels_per_inch(png_ptr,
libpng-manual.txt:    res_y = png_get_y_pixels_per_inch(png_ptr,
libpng-manual.txt:    res_x_and_y = png_get_pixels_per_inch(png_ptr,
libpng-manual.txt:    aspect_ratio = png_get_pixel_aspect_ratio(png_ptr,
libpng-manual.txt:       the data is not present or if res_x is 0;
libpng-manual.txt:       res_x_and_y is 0 if res_x != res_y
libpng-manual.txt:       come out to exactly even number.  For example,
libpng-manual.txt:       72 dpi is stored as 0.28346 pixels/meter, and
libpng-manual.txt:    x_offset = png_get_x_offset_microns(png_ptr, info_ptr);
libpng-manual.txt:    x_offset = png_get_x_offset_inches(png_ptr, info_ptr);
libpng-manual.txt:       x and y are 0] if the data is not present or if the
libpng-manual.txt:       chunk is present but the unit is the pixel.  The
libpng-manual.txt:       remark about inexact inch conversions applies here
libpng-manual.txt:needed to hold a row (expand, filler, gray_to_rgb, etc.).
libpng-manual.txt:A quick word about text_ptr and num_text.  PNG stores comments in
libpng-manual.txt:keyword/text pairs, one pair per chunk, with no limit on the number
libpng-manual.txt:of text chunks, and a 2^31 byte limit on their size.  While there are
libpng-manual.txt:strings.  It is strongly suggested that keywords and text be sensible
libpng-manual.txt:There is also no requirement to have text after the keyword.
libpng-manual.txt:The text_ptr is an array of png_text structures, each holding a
libpng-manual.txt:a text string.  The text string, language code, and translated
libpng-manual.txt:keyword may be empty or NULL pointers.  The keyword/text
libpng-manual.txt:However, some or all of the text chunks may be after the image, so, to
libpng-manual.txt:make sure you have read all the text chunks, don't mess with these
libpng-manual.txt:transformations, for example both adding and removing the alpha channel, you
libpng-manual.txt:as the image data in a tRNS chunk, so this is what libpng expects for this data.
libpng-manual.txt:The color used for the background value depends on the need_expand argument as
libpng-manual.txt:For example, 4 bit/pixel paletted or grayscale data will be returned
libpng-manual.txt:2 pixels/byte with the leftmost pixel in the high-order bits of the
libpng-manual.txt:        bit_depth < 8) png_set_expand_gray_1_2_4_to_8(png_ptr);
libpng-manual.txt:The first two functions are actually aliases for png_set_expand(), added
libpng-manual.txt:in libpng version 1.0.4, with the function names expanded to improve code
libpng-manual.txt:As of libpng version 1.2.9, png_set_expand_gray_1_2_4_to_8() was
libpng-manual.txt:added.  It expands the sample depth without changing tRNS to alpha.
libpng-manual.txt:As of libpng version 1.5.2, png_set_expand_16() was added.  It behaves as
libpng-manual.txt:png_set_expand(); however, the resultant channels have 16 bits rather than 8.
libpng-manual.txt:      png_set_expand_16(png_ptr);
libpng-manual.txt:8 bits per channel, this will strip the pixels down to 8-bit.
libpng-manual.txt:data (for example if you convert it to a bitmap mask) it is possible to have
libpng-manual.txt:As of libpng version 1.5.2, almost all useful expansions are supported, the
libpng-manual.txt:major ommissions are conversion of grayscale to indexed images (which can be
libpng-manual.txt:done trivially in the application) and conversion of indexed to grayscale (which
libpng-manual.txt:indexed with depth<8, other numerals represent the color type, "T" means
libpng-manual.txt:means tRNS or alpha is present but all pixels in the image are opaque.
libpng-manual.txt:Within the matrix,
libpng-manual.txt:     "X" means the transformation is obtained by png_set_expand().
libpng-manual.txt:         png_set_expand_gray_1_2_4_to_8() (and by png_set_expand()
libpng-manual.txt:         png_set_expand_palette_to_rgb().
libpng-manual.txt:PNG files pack pixels of bit depths 1, 2, and 4 into bytes as small as
libpng-manual.txt:they can, resulting in, for example, 8 pixels per byte for 1 bit
libpng-manual.txt:files.  This code expands to 1 pixel per byte without changing the
libpng-manual.txt:values of the pixels:
libpng-manual.txt:PNG files have possible bit depths of 1, 2, 4, 8, and 16.  All pixels
libpng-manual.txt:stored in a PNG image have been "scaled" or "shifted" up to the next
libpng-manual.txt:to convert the PNG pixel data back to the original bit depth of the
libpng-manual.txt:image.  This call reduces the pixels back down to the original bit depth:
libpng-manual.txt:PNG files store 3-color pixels in red, green, blue order.  This code
libpng-manual.txt:changes the storage of the pixels to blue, green, red:
libpng-manual.txt:PNG files store RGB pixels packed into 3 or 6 bytes. This code expands them
libpng-manual.txt:opaque alpha channel, use filler=0xff or 0xffff and PNG_FILLER_AFTER which
libpng-manual.txt:will generate RGBA pixels.
libpng-manual.txt:where "filler" contains the alpha value to assign to each pixel.
libpng-manual.txt:                      image has any pixel where
libpng-manual.txt:                      image has any pixel where
libpng-manual.txt:In the corresponding fixed point API the red_weight and green_weight values are
libpng-manual.txt:       png_fixed_point red_weight,
libpng-manual.txt:       png_fixed_point green_weight);
libpng-manual.txt:1 if there were any non-gray pixels.  Background and sBIT data
libpng-manual.txt:Libpng uses an integer approximation:
libpng-manual.txt:header, even if you don't want to use the color in a bKGD chunk, if one exists.
libpng-manual.txt:color.  The function takes two arguments, background_gamma_mode and need_expand
libpng-manual.txt:           PNG_BACKGROUND_GAMMA_FILE, 1/*needs to be expanded*/, 1);
libpng-manual.txt:           PNG_BACKGROUND_GAMMA_SCREEN, 0/*do not expand*/, 1);
libpng-manual.txt:index and for low bit greyscale images the color is a reduced bit value in
libpng-manual.txt:If you didn't call png_set_gamma() before reading the file header, for example
libpng-manual.txt:pass a palette that is larger than maximum_colors, the file will
libpng-manual.txt:maximum_colors.  If there is a histogram, libpng will use it to make
libpng-manual.txt:            max_screen_colors, histogram, 1);
libpng-manual.txt:PNG files store 16-bit pixels in network byte order (big-endian,
libpng-manual.txt:If you are using packed-pixel images (1, 2, or 4 bits/pixel), and you
libpng-manual.txt:need to change the order the pixels are packed into bytes, you can use:
libpng-manual.txt:the existing ones meets your needs.  This is done by setting a callback
libpng-manual.txt:See pngtest.c for a working example.  Your function will be called
libpng-manual.txt:unexpected results unless the row is actually being processed at the moment they
libpng-manual.txt:find the output pixel (x,y) given an interlaced sub-image pixel (row,col,pass).
libpng-manual.txt:png_get_user_transform_ptr().  For example:
libpng-manual.txt:but you must call the function here if you want libpng to handle expansion
libpng-manual.txt:varies among applications, no example will be given.  If you
libpng-manual.txt:You can point to void or char or whatever you use for pixels.
libpng-manual.txt:on an 8x8 grid.  This number is defined (from libpng 1.5) as
libpng-manual.txt:mentioned in the PNG specification is to expand each pixel to cover
libpng-manual.txt:those pixels that have not been read yet (the "rectangle" method).
libpng-manual.txt:smooths out as more pixels are read.  The other method is the "sparkle"
libpng-manual.txt:method, where pixels are drawn only in their final locations, with the
libpng-manual.txt:but tends to be slower, as there are more pixels to put in the rows.
libpng-manual.txt:If, as is likely, you want libpng to expand the images, call this before
libpng-manual.txt:will distribute the pixels from the current pass to the correct place in
libpng-manual.txt:is exactly the same.  If you are planning on displaying the image
libpng-manual.txt:not the data.  Each pass only writes the pixels appropriate for that
libpng-manual.txt:before except pass the row buffer in the third parameter, and leave
libpng-manual.txt:certainly need to distribute the pixels from each sub-image to the
libpng-manual.txt:not even exist because either their width or height ends up zero.
libpng-manual.txt:produce optimal code to make a pixel-by-pixel transformation of an
libpng-manual.txt:macros to help that tell you where to place the pixels in the output image.
libpng-manual.txt:Because the interlacing scheme is rectangular - sub-image pixels are always
libpng-manual.txt:starting column and row in the output image of the first pixel plus the
libpng-manual.txt:spacing between each pixel.  As of libpng 1.5 there are four macros to
libpng-manual.txt:   png_uint_32 x = PNG_PASS_START_COL(pass);
libpng-manual.txt:   png_uint_32 xStep = 1U << PNG_PASS_COL_SHIFT(pass);
libpng-manual.txt:      png_uint_32 input_x = 0;
libpng-manual.txt:      png_uint_32 output_x = PNG_PASS_START_COL(pass);
libpng-manual.txt:      while (output_x < output_image_width)
libpng-manual.txt:         image[output_y][output_x] =
libpng-manual.txt:             subimage[pass][input_y][input_x++];
libpng-manual.txt:         output_x += xStep;
libpng-manual.txt:returned as shifts.  This is possible because the pixels in the subimages
libpng-manual.txt:are always a power of 2 apart - 1, 2, 4 or 8 pixels - in the original
libpng-manual.txt:   png_uint_32 output_x = PNG_COL_FROM_PASS_COL(input_x, pass);
libpng-manual.txt:   int col_in_pass = PNG_COL_IN_INTERLACE_PASS(output_x, pass);
libpng-manual.txt:of the pass in addition to the above to be sure the pass even exists!
libpng-manual.txt:is if you are processing PNG files on a pixel-by-pixel basis and don't want
libpng-manual.txt:not what you want if you expect to read something beyond the end of
libpng-manual.txt:are allowed for the data type identified in the mask, such as text or
libpng-manual.txt:function is responsible for freeing any existing data that might be present,
libpng-manual.txt:If you allocated text_ptr.text, text_ptr.lang, and text_ptr.translated_keyword
libpng-manual.txt:separately, do not transfer responsibility for freeing text_ptr to libpng,
libpng-manual.txt:because when libpng fills a png_text structure it combines these members with
libpng-manual.txt:the key member, and png_free_data() will free only text_ptr.key.  Similarly,
libpng-manual.txt:if you transfer responsibility for free'ing text_ptr from libpng to your
libpng-manual.txt:For a more compact example of reading a PNG image, see the file example.c.
libpng-manual.txt: /*  An example code fragment of how you would
libpng-manual.txt:       libpng skipping that number of bytes on the next
libpng-manual.txt:       call - it is up to you to ensure that the next call
libpng-manual.txt:Next, png_struct and png_info need to be allocated and initialized.
libpng-manual.txt:"read_ptr" and "write_ptr".  Look at pngtest.c, for example.
libpng-manual.txt:error handling.  When libpng encounters an error, it expects to
libpng-manual.txt:If you would rather avoid the complexity of setjmp/longjmp issues,
libpng-manual.txt:Checking for invalid palette index on write was added at libpng
libpng-manual.txt:1.5.10.  If a pixel contains an invalid (out-of-range) index libpng issues
libpng-manual.txt:   png_set_check_for_invalid_index(png_ptr, 0);
libpng-manual.txt:any invalid pixels are written as-is by the encoder, resulting in an
libpng-manual.txt:responsible for ensuring that the pixel indexes are in range when it writes
libpng-manual.txt:it has also been written out.  The 'row' and 'pass' refer to the next row to be
libpng-manual.txt:in some cases, like if you need to write PNG files extremely fast and
libpng-manual.txt:maximum possible compression at the expense of slower writing.  If you
libpng-manual.txt:the previous row of pixels will be stored in case it's needed later),
libpng-manual.txt:data.  See the Compression Library (zlib.h and algorithm.txt, distributed
libpng-manual.txt:    /* Set zlib parameters for text compression
libpng-manual.txt:    png_set_text_compression_mem_level(png_ptr, 8);
libpng-manual.txt:    png_set_text_compression_strategy(png_ptr,
libpng-manual.txt:    png_set_text_compression_window_bits(png_ptr, 15);
libpng-manual.txt:    png_set_text_compression_method(png_ptr, 8);
libpng-manual.txt:are allowed to write after the image is the text chunks and the time
libpng-manual.txt:their data types, see png.h.  For explanations of what the fields
libpng-manual.txt:                     in pixels (up to 2^31).
libpng-manual.txt:                     in pixels (up to 2^31).
libpng-manual.txt:    png_set_gAMA_fixed(png_ptr, info_ptr, int_file_gamma);
libpng-manual.txt:    png_set_cHRM(png_ptr, info_ptr,  white_x, white_y, red_x, red_y,
libpng-manual.txt:                     green_x, green_y, blue_x, blue_y)
libpng-manual.txt:    png_set_cHRM_fixed(png_ptr, info_ptr, int_white_x, int_white_y,
libpng-manual.txt:                     int_red_x, int_red_y, int_green_x, int_green_y,
libpng-manual.txt:                     int_blue_x, int_blue_y)
libpng-manual.txt:    png_set_cHRM_XYZ_fixed(png_ptr, info_ptr, int_red_X, int_red_Y,
libpng-manual.txt:    {white,red,green,blue}_{x,y}
libpng-manual.txt:                     the sRGB chunk means that the pixel
libpng-manual.txt:                     sRGB chunk means that the pixel
libpng-manual.txt:    png_set_text(png_ptr, info_ptr, text_ptr, num_text);
libpng-manual.txt:    text_ptr       - array of png_text holding image
libpng-manual.txt:    text_ptr[i].compression - type of compression used
libpng-manual.txt:                 on "text" PNG_TEXT_COMPRESSION_NONE
libpng-manual.txt:    text_ptr[i].key   - keyword for comment.  Must contain
libpng-manual.txt:    text_ptr[i].text  - text comments for current
libpng-manual.txt:    text_ptr[i].text_length - length of text string,
libpng-manual.txt:    text_ptr[i].itxt_length - length of itxt string,
libpng-manual.txt:    text_ptr[i].lang  - language of comment (NULL or
libpng-manual.txt:    text_ptr[i].translated_keyword  - keyword in UTF-8 (NULL
libpng-manual.txt:    Note that the itxt_length, lang, and lang_key
libpng-manual.txt:    members of the text_ptr structure only exist when the
libpng-manual.txt:    num_text       - number of comments
libpng-manual.txt:    png_set_oFFs(png_ptr, info_ptr, offset_x, offset_y,
libpng-manual.txt:    offset_x  - positive offset from the left
libpng-manual.txt:    png_set_pHYs(png_ptr, info_ptr, res_x, res_y,
libpng-manual.txt:    res_x       - pixels/unit physical resolution
libpng-manual.txt:                  in x direction
libpng-manual.txt:    res_y       - pixels/unit physical resolution
libpng-manual.txt:    width       - width of a pixel in physical scale units
libpng-manual.txt:    height      - height of a pixel in physical scale units
libpng-manual.txt:    width       - width of a pixel in physical scale units
libpng-manual.txt:                  expressed as a string
libpng-manual.txt:    height      - height of a pixel in physical scale units
libpng-manual.txt:A quick word about text and num_text.  text is an array of png_text
libpng-manual.txt:structures.  num_text is the number of valid structures in the array.
libpng-manual.txt:Each png_text structure holds a language code, a keyword, a text value,
libpng-manual.txt:However, you can store text either compressed or uncompressed, unlike
libpng-manual.txt:text compressed, set the compression type to PNG_TEXT_COMPRESSION_NONE.
libpng-manual.txt:Until text gets around a few hundred bytes, it is not worth compressing it.
libpng-manual.txt:After the text has been written out to the file, the compression type
libpng-manual.txt:The keyword-text pairs work like this.  Keywords should be short
libpng-manual.txt:some text before the image and some after.  For example, you may want
libpng-manual.txt:words, not abbreviations.  Keywords and text are in the ISO 8859-1
libpng-manual.txt:with basic ASCII, and avoid machine specific character set extensions
libpng-manual.txt:you can leave off the text string on non-compressed pairs.
libpng-manual.txt:Compressed pairs must have a text string, as only the text string
libpng-manual.txt:"Creation Time" tEXt chunk is not expected to be automatically changed
libpng-manual.txt:next following png_write_info_before_PLTE, png_write_info, or png_write_end
libpng-manual.txt:Here is an example of writing two private chunks, prVt and miNE:
libpng-manual.txt:      /* Deal with unknown chunk location bug in 1.5.x and earlier */
libpng-manual.txt:                                pixels to LSB first
libpng-manual.txt:    PNG_TRANSFORM_SHIFT         Normalize pixels to the
libpng-manual.txt:data.  For example, don't swap red and blue on grayscale data.
libpng-manual.txt:PNG files store RGB pixels packed into 3 or 6 bytes.  This code tells
libpng-manual.txt:the library to strip input data that has 4 or 8 bytes per pixel down
libpng-manual.txt:bytes per pixel).
libpng-manual.txt:PNG_FILLER_AFTER, depending upon whether the filler byte in the pixel
libpng-manual.txt:PNG files pack pixels of bit depths 1, 2, and 4 into bytes as small as
libpng-manual.txt:they can, resulting in, for example, 8 pixels per byte for 1 bit files.
libpng-manual.txt:If the data is supplied at 1 pixel per byte, use this code, which will
libpng-manual.txt:correctly pack the pixels into a single byte:
libpng-manual.txt:PNG files store 16-bit pixels in network byte order (big-endian,
libpng-manual.txt:If you are using packed-pixel images (1, 2, or 4 bits/pixel), and you
libpng-manual.txt:need to change the order the pixels are packed into bytes, you can use:
libpng-manual.txt:PNG files store 3 color pixels in red, green, blue order.  This code
libpng-manual.txt:one. This code would be used if the pixels are supplied with this reversed
libpng-manual.txt:the existing ones meets your needs.  This is done by setting a callback
libpng-manual.txt:See pngtest.c for a working example.  Your function will be called
libpng-manual.txt:find the output pixel (x,y) given an interlaced sub-image pixel (row,col,pass).
libpng-manual.txt:For example:
libpng-manual.txt:output on the next scanline, and every 25 lines thereafter, unless
libpng-manual.txt:If nrows is too small (less than about 10 lines for a 640 pixel wide
libpng-manual.txt:You can point to void or char or whatever you use for pixels.
libpng-manual.txt:for details of which pixels to write when.
libpng-manual.txt:take advantage of the interlacing and even then the image has to be exactly
libpng-manual.txt:adjacent pixels and these are not available until all the passes have been
libpng-manual.txt:made some pixel-by-pixel transformation to it, as described in the read
libpng-manual.txt:are allowed for the data type identified in the mask, such as text or
libpng-manual.txt:For example, to transfer responsibility for some data from a read structure
libpng-manual.txt:If you allocated text_ptr.text, text_ptr.lang, and text_ptr.translated_keyword
libpng-manual.txt:separately, do not transfer responsibility for freeing text_ptr to libpng,
libpng-manual.txt:because when libpng fills a png_text structure it combines these members with
libpng-manual.txt:the key member, and png_free_data() will free only text_ptr.key.  Similarly,
libpng-manual.txt:if you transfer responsibility for free'ing text_ptr from libpng to your
libpng-manual.txt:For a more compact example of writing a PNG image, see the file example.c.
libpng-manual.txt:   png_uint_32  width   Image width in pixels (columns)
libpng-manual.txt:   png_uint_32  height  Image height in pixels (rows)
libpng-manual.txt:The pixels (samples) of the image have one to four channels whose components
libpng-manual.txt:and matches the 8-bit format expected by typical display devices.
libpng-manual.txt:When an alpha channel is present it is expected to denote pixel coverage
libpng-manual.txt:The image data is encoded as small integers, value 0..255, that index the
libpng-manual.txt:entries in the color-map.  One integer (one byte) is stored for each pixel.
libpng-manual.txt:   PNG_FORMAT_FLAG_ALPHA    0x01 format with an alpha channel
libpng-manual.txt:   PNG_FORMAT_FLAG_COLOR    0x02 color format: otherwise grayscale
libpng-manual.txt:   PNG_FORMAT_FLAG_LINEAR   0x04 png_uint_16 channels else png_byte
libpng-manual.txt:   PNG_FORMAT_FLAG_COLORMAP 0x08 libpng use only
libpng-manual.txt:   PNG_FORMAT_FLAG_BGR      0x10 BGR colors, else order is RGB
libpng-manual.txt:   PNG_FORMAT_FLAG_AFIRST   0x20 alpha channel comes first
libpng-manual.txt:of the components of the pixels of the image.
libpng-manual.txt:indicate a luminance (gray) channel.  The component order within the pixel
libpng-manual.txt:format of the color-map may be extracted using the following macro.
libpng-manual.txt:pixels in the image.  The PNG_IMAGE_PIXEL_ macros return corresponding values
libpng-manual.txt:for the pixels and will always return 1 after a call to
libpng-manual.txt:    Returns the size in bytes of a single component of a pixel or color-map
libpng-manual.txt:    color-mapped it is the size of one color-map entry (and image pixels are
libpng-manual.txt:    one byte in size), otherwise it is the size of one image pixel.
libpng-manual.txt:   a fixed number determined by the format so can easily be allocated on the
libpng-manual.txt:   /* The maximum size of the color-map required by the format expressed in a
libpng-manual.txt:Corresponding information about the pixels
libpng-manual.txt:   The number of separate channels (components) in a pixel; 1 for a
libpng-manual.txt:   The size, in bytes, of each component in a pixel; 1 for a color-mapped
libpng-manual.txt:   The size, in bytes, of a complete pixel; 1 for a color-mapped image.
libpng-manual.txt:   plus any padding bytes that your application might need, for example
libpng-manual.txt:   to start the next row on a 4-byte boundary.
libpng-manual.txt:  PNG_IMAGE_FLAG_COLORSPACE_NOT_sRGB == 0x01
libpng-manual.txt:  PNG_IMAGE_FLAG_COLORMAP == 0x02
libpng-manual.txt:approximation used elsewhere in libpng.
libpng-manual.txt:   width: image width in pixels
libpng-manual.txt:from one row to the next in component sized units (float) and if negative
libpng-manual.txt:Note that the write API does not support interlacing, sub-8-bit pixels,
libpng-manual.txt:and indexed (paletted) images.
libpng-manual.txt:png_get_io_ptr().  For example:
libpng-manual.txt:to using the default C stream functions, which expect the io_ptr to
libpng-manual.txt:but you could change this to do things like exit() if you should wish,
libpng-manual.txt:catch exception handling methods.  This makes the code much easier to write,
libpng-manual.txt:may wish to use the "cexcept" facility (see http://cexcept.sourceforge.net),
libpng-manual.txt:chunk and existing `intrinsic' chunks.
libpng-manual.txt:faster.  For online applications it may be desirable to have maximum speed
libpng-manual.txt:short on memory (running DOS, for example, where you only have 640K).
libpng-manual.txt:    png_set_text_compression_level(png_ptr, level);
libpng-manual.txt:    png_set_text_compression_mem_level(png_ptr, level);
libpng-manual.txt:    png_set_text_compression_strategy(png_ptr,
libpng-manual.txt:    png_set_text_compression_window_bits(png_ptr,
libpng-manual.txt:    png_set_text_compression_method(png_ptr, method);
libpng-manual.txt:for any images with bit depths less than 8 bits/pixel.
libpng-manual.txt:is that many times better than the previous filter.  In the above example,
libpng-manual.txt:"sum of absolute differences" 1.5 x 1.3 times higher than other filters
libpng-manual.txt:The costs do not necessarily reflect the exact computational speeds of
libpng-manual.txt:Note that the numbers above were invented purely for this example and
libpng-manual.txt:are given only to help explain the function usage.  Little testing has
libpng-manual.txt:according to printf-style formatting directives.  For example,
libpng-manual.txt:is expanded to
libpng-manual.txt:certain extensions to PNG for PNG images that are embedded in MNG datastreams.
libpng-manual.txt:Libpng can support some of these extensions.  To enable them, use the
libpng-manual.txt:IX.  Changes to Libpng from version 1.0.x to 1.2.x
libpng-manual.txt:by default.  The functions png_set_user_limits(), png_get_user_width_max(),
libpng-manual.txt:and png_get_user_height_max() were added at libpng-1.2.6.
libpng-manual.txt:The function png_set_expand_gray_1_2_4_to_8() was added at libpng-1.2.9.
libpng-manual.txt:Unlike png_set_gray_1_2_4_to_8(), the new function does not expand the
libpng-manual.txt:    png_get_mmx_flagmask()
libpng-manual.txt:    png_set_mmx_thresholds()
libpng-manual.txt:    png_get_mmx_bitdepth_threshold()
libpng-manual.txt:    png_get_mmx_rowbytes_threshold()
libpng-manual.txt:which also expands tRNS to alpha was replaced with
libpng-manual.txt:    png_set_expand_gray_1_2_4_to_8()
libpng-manual.txt:X.  Changes to Libpng from version 1.0.x/1.2.x to 1.4.x
libpng-manual.txt:Support for setting the maximum amount of memory that the application
libpng-manual.txt:The functions png_set_chunk_cache_max() and png_get_chunk_cache_max()
libpng-manual.txt:We removed the obsolete stub functions png_get_mmx_flagmask(),
libpng-manual.txt:png_set_mmx_thresholds(), png_get_asm_flags(),
libpng-manual.txt:png_get_mmx_bitdepth_threshold(), png_get_mmx_rowbytes_threshold(),
libpng-manual.txt:png_set_asm_flags(), and png_mmx_supported()
libpng-manual.txt:png_set_expand_gray_1_2_4_to_8() because the former function also
libpng-manual.txt:expanded any tRNS chunk to an alpha channel.
libpng-manual.txt:of "png_malloc(); memset();" except in the case in png_read_png()
libpng-manual.txt:The png_zalloc() and png_zfree() functions are no longer exported.
libpng-manual.txt:XI.  Changes to Libpng from version 1.4.x to 1.5.x
libpng-manual.txt:Checking for invalid palette index on write was added at libpng
libpng-manual.txt:1.5.10.  If a pixel contains an invalid (out-of-range) index libpng issues
libpng-manual.txt:   png_set_check_for_invalid_index(png_ptr, allowed);
libpng-manual.txt:any invalid pixels are decoded as opaque black by the decoder and written
libpng-manual.txt:Retrieving the maximum palette index found was added at libpng-1.5.15.
libpng-manual.txt:   int max_palette = png_get_palette_max(png_ptr, info_ptr);
libpng-manual.txt:This will return the maximum palette index found in the image, or "-1" if
libpng-manual.txt:does not account for any palette index used by ancillary chunks such as the
libpng-manual.txt:bKGD chunk; you must check those separately to determine the maximum
libpng-manual.txt:palette index actually used.
libpng-manual.txt:changed and some of this is visible in the exported header files, in
libpng-manual.txt:application code.  (It is extremely rare for an application to do this.)
libpng-manual.txt:against libpng 1.5, except for the change in the prototype for
libpng-manual.txt:libpng 1.5.0 includes a complete fixed point API.  By default this is
libpng-manual.txt:fixed point API is faster and smaller than the floating point one because
libpng-manual.txt:the PNG file format used fixed point, not floating point.  This applies
libpng-manual.txt:uses floating point arithmetic (the default) or fixed point arithmetic
libpng-manual.txt:composition (png_set_background for example). This applies even if the
libpng-manual.txt:Fixed point support for the sCAL chunk comes with an important caveat;
libpng-manual.txt:and the accuracy of PNG fixed point values is insufficient for
libpng-manual.txt:reset by pngusr.h or by explicit settings on the compiler command line.
libpng-manual.txt:when compressing the IDAT data and textual data such as zTXt and iCCP.
libpng-manual.txt:We added five png_set_text_*() functions for setting the parameters to
libpng-manual.txt:use with textual data.
libpng-manual.txt:application calls to png_set_user_limits(), png_set_user_chunk_cache_max(),
libpng-manual.txt:and/or png_set_user_malloc_max() that increase or decrease the limits.  Also,
libpng-manual.txt:from 1,000,000 to 0x7ffffff (i.e., made unlimited).  Therefore, the
libpng-manual.txt:   png_user_width_max        0x7fffffff    1,000,000
libpng-manual.txt:   png_user_height_max       0x7fffffff    1,000,000
libpng-manual.txt:   png_user_chunk_cache_max  0 (unlimited)   128
libpng-manual.txt:   png_user_chunk_malloc_max 0 (unlimited) 8,000,000
libpng-manual.txt:The library now supports a complete fixed point implementation and can
libpng-manual.txt:independent of the choice of fixed versus floating point APIs and all the
libpng-manual.txt:missing fixed point APIs have been implemented.
libpng-manual.txt:The exact mechanism used to control attributes of API functions has
libpng-manual.txt:3) Three feature macros now control the fixed/floating point decisions:
libpng-manual.txt:PNG_FIXED_POINT_SUPPORTED enables the fixed point APIs; however, in
libpng-manual.txt:file format is fixed point), therefore in most cases PNG_NO_FIXED_POINT
libpng-manual.txt:merely stops the function from being exported.
libpng-manual.txt:point implementation or the fixed point one.  Typically the fixed point
libpng-manual.txt:XII.  Changes to Libpng from version 1.5.x to 1.6.x
libpng-manual.txt:example in contrib/examples/pngtopng.c).  The new publicly visible API
libpng-manual.txt:Starting with libpng-1.6.0, you can configure libpng to prefix all exported
libpng-manual.txt:The signatures of many exported functions were changed, such that
libpng-manual.txt:with color type 0 or 4 and that even if the image only contains gray pixels,
libpng-manual.txt:a pre-existing bug where the per-chunk 'keep' setting is ignored, and makes
libpng-manual.txt:provide a way to revert to the libpng-1.5.x behavior (ignoring the CMF bytes
libpng-manual.txt:and provide a tool (contrib/tools/pngfix) for rewriting a PNG file while
libpng-manual.txt:chunk.  This error was fixed in libpng-1.6.3, and a tool (called
libpng-manual.txt:contrib/tools/png-fix-itxt) has been added to the libpng distribution.
libpng-manual.txt:control.  The git repository was built from old libpng-x.y.z.tar.gz files
libpng-manual.txt:simple verbal discriptions of bug fixes, reported either to the
libpng-manual.txt:We use 3-space indentation, except for continued statements which
libpng-manual.txt:exported functions are marked with PNGAPI:
libpng-manual.txt: png_exported_function(png_ptr, png_info, foo)
libpng-manual.txt:The prototypes for all exported functions appear in png.h,
libpng-manual.txt:We mark all non-exported functions with "/* PRIVATE */"":
libpng-manual.txt: png_non_exported_function(png_ptr, png_info, foo)
libpng-manual.txt:The prototypes for non-exported functions (except for those in
libpng-manual.txt:To avoid polluting the global namespace, the names of all exported
libpng-manual.txt:is an expression, not a type name, and we always enclose the
libpng-manual.txt:"?".  We don't put a space between a typecast and the expression
libpng-manual.txt:       y[i] = a(x) + (int)b;
libpng-manual.txt:We prefer to express integers that are used as bit masks in hex format,
libpng-manual.txt:with an even number of lower-case hex digits (e.g., 0x00, 0xff, 0x0100).
libpng-manual.txt:We prefer to use underscores in variable names rather than camelCase, except
libpng-manual.txt:Lines do not exceed 80 characters.
libpng-manual.txt:holds the date in text format, and will hold years up to 9999.
libpng-manual.txt:in libpng-1.6.x and will be removed from libpng-1.7.0.
libpng.pc:prefix=/Users/ananyu/csci3081/Photoshop/libpng-1.6.16
libpng.pc:exec_prefix=${prefix}
libpng.pc:libdir=${exec_prefix}/lib
libpng.pc:includedir=${prefix}/include/libpng16
libpng.pc.in:prefix=@prefix@
libpng.pc.in:exec_prefix=@exec_prefix@
libpngpf.3:available for use by applications.  They are not "exported" to applications
libpng.sym:png_set_expand
libpng.sym:png_set_expand_gray_1_2_4_to_8
libpng.sym:png_set_expand_16
libpng.sym:png_set_rgb_to_gray_fixed
libpng.sym:png_set_alpha_mode_fixed
libpng.sym:png_set_background_fixed
libpng.sym:png_set_gamma_fixed
libpng.sym:png_set_filter_heuristics_fixed
libpng.sym:png_set_text_compression_level
libpng.sym:png_set_text_compression_mem_level
libpng.sym:png_set_text_compression_strategy
libpng.sym:png_set_text_compression_window_bits
libpng.sym:png_set_text_compression_method
libpng.sym:png_get_pixels_per_meter
libpng.sym:png_get_x_pixels_per_meter
libpng.sym:png_get_y_pixels_per_meter
libpng.sym:png_get_pixel_aspect_ratio
libpng.sym:png_get_pixel_aspect_ratio_fixed
libpng.sym:png_get_x_offset_pixels
libpng.sym:png_get_y_offset_pixels
libpng.sym:png_get_x_offset_microns
libpng.sym:png_get_cHRM_fixed
libpng.sym:png_get_cHRM_XYZ_fixed
libpng.sym:png_set_cHRM_fixed
libpng.sym:png_set_cHRM_XYZ_fixed
libpng.sym:png_get_gAMA_fixed
libpng.sym:png_set_gAMA_fixed
libpng.sym:png_get_text
libpng.sym:png_set_text
libpng.sym:png_get_sCAL_fixed
libpng.sym:png_set_sCAL_fixed
libpng.sym:png_get_user_width_max
libpng.sym:png_get_user_height_max
libpng.sym:png_set_chunk_cache_max
libpng.sym:png_get_chunk_cache_max
libpng.sym:png_set_chunk_malloc_max
libpng.sym:png_get_chunk_malloc_max
libpng.sym:png_get_pixels_per_inch
libpng.sym:png_get_x_pixels_per_inch
libpng.sym:png_get_y_pixels_per_inch
libpng.sym:png_get_x_offset_inches
libpng.sym:png_get_x_offset_inches_fixed
libpng.sym:png_get_y_offset_inches_fixed
libpng.sym:png_set_check_for_invalid_index
libpng.sym:png_get_palette_max
libtool:# As a special exception to the GNU General Public License,
libtool:host=x86_64-apple-darwin13.4.0
libtool:build=x86_64-apple-darwin13.4.0
libtool:# What is the maximum length of a command?
libtool:max_cmd_len=196608
libtool:# Object file suffix (normally "o").
libtool:objext=o
libtool:# Executable file suffix (normally "").
libtool:exeext=
libtool:# Whether to use a lock for old archive extraction.
libtool:lock_old_archive_extraction=yes
libtool:global_symbol_to_cdecl="sed -n -e 's/^T .* \\(.*\\)\$/extern int \\1();/p' -e 's/^[BCDEGRST]* .* \\(.*\\)\$/extern char \\1;/p'"
libtool:# Transform the output of nm in a C name address pair when lib prefix is needed.
libtool:global_symbol_to_c_name_address_lib_prefix="sed -n -e 's/^: \\([^ ]*\\)[ ]*\$/  {\\\"\\1\\\", (void *) 0},/p' -e 's/^[BCDEGRST]* \\([^ ]*\\) \\(lib[^ ]*\\)\$/  {\"\\2\", (void *) \\&\\2},/p' -e 's/^[BCDEGRST]* \\([^ ]*\\) \\([^ ]*\\)\$/  {\"lib\\2\", (void *) \\&\\2},/p'"
libtool:# Used to examine libraries when file_magic_cmd begins with "file".
libtool:# Old archive suffix (normally "a").
libtool:libext=a
libtool:# Shared library suffix (normally ".so").
libtool:shrext_cmds="\`test .\$module = .yes && echo .so || echo .dylib\`"
libtool:# The commands to extract the exported symbol list from a shared archive.
libtool:extract_expsyms_cmds=""
libtool:# Do we need the "lib" prefix for modules?
libtool:need_lib_prefix=no
libtool:# Format of library name prefix.
libtool:library_names_spec="\${libname}\${release}\${major}\$shared_ext \${libname}\$shared_ext"
libtool:soname_spec="\${libname}\${release}\${major}\$shared_ext"
libtool:# As "finish_cmds", except a single script fragment to be evaled but
libtool:sys_lib_search_path_spec="/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/6.0  /usr/local/lib"
libtool:striplib="strip -x"
libtool:LD="/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/ld"
libtool:no_builtin_flag=" -fno-builtin -fno-rtti -fno-exceptions"
libtool:# Compiler flag to allow reflexive dlopens.
libtool:export_dynamic_flag_spec=""
libtool:old_archive_from_expsyms_cmds=""
libtool:archive_expsym_cmds="sed 's,^,_,' < \$export_symbols > \$output_objdir/\${libname}-symbols.expsym~\$CC -dynamiclib \$allow_undefined_flag -o \$lib \$libobjs \$deplibs \$compiler_flags -install_name \$rpath/\$soname \$verstring \$single_module \${wl}-exported_symbols_list,\$output_objdir/\${libname}-symbols.expsym"
libtool:module_expsym_cmds="sed -e 's,^,_,' < \$export_symbols > \$output_objdir/\${libname}-symbols.expsym~\$CC \$allow_undefined_flag -o \$lib -bundle \$libobjs \$deplibs \$compiler_flags \${wl}-exported_symbols_list,\$output_objdir/\${libname}-symbols.expsym"
libtool:# This must work even if $libdir does not exist
libtool:# Set to "yes" if using DIR/libNAME${shared_ext} during linking hardcodes
libtool:# Set to "yes" if using DIR/libNAME${shared_ext} during linking hardcodes
libtool:# into the library and all subsequent libraries and executables linked
libtool:# Set to "yes" if exported symbols are required.
libtool:always_export_symbols=no
libtool:# The commands to list exported symbols.
libtool:export_symbols_cmds="\$NM \$libobjs \$convenience | \$global_symbol_pipe | \$SED 's/.* //' | sort | uniq > \$export_symbols"
libtool:exclude_expsyms="_GLOBAL_OFFSET_TABLE_|_GLOBAL__F[ID]_.*"
libtool:# Symbols that must always be exported.
libtool:include_expsyms=""
libtool:# How to hardcode a shared library path into an executable.
libtool:# As a special exception to the GNU General Public License,
libtool:#       --features           display basic configuration information and exit
libtool:#       --no-verbose         don't print the extra informational messages
libtool:#         execute            automatically set library path, then run a program
libtool:#         install            install libraries or executables
libtool:#         link               create a library or an executable
libtool:  # Zsh 3.x and 4.x performs word splitting on ${1+"$@"}, which
libtool:  case `(set -o) 2>/dev/null` in *posix*) set -o posix;; esac
libtool:BIN_SH=xpg4; export BIN_SH # for Tru64
libtool:DUALCASE=1; export DUALCASE # for MKS sh
libtool:# NLS nuisances: We save the old values to restore during execute mode.
libtool:	  export $lt_var
libtool:export LANGUAGE LC_ALL
libtool:exit_status=$EXIT_SUCCESS
libtool:} # Extended-shell func_dirname implementation
libtool:} # Extended-shell func_basename implementation
libtool:} # Extended-shell func_dirname_and_basename implementation
libtool:# func_stripname prefix suffix name
libtool:# PREFIX and SUFFIX must not contain globbing or regex special
libtool:# func_strip_suffix prefix name
libtool:} # Extended-shell func_stripname implementation
libtool:    # The next three entries are used to spot a run of precisely
libtool:      # and for example Cygwin uses it to access remote file shares
libtool:    # check if we have found a prefix of bindir
libtool:        # found an exact match
libtool:        # found a matching prefix
libtool:        if test "x$func_relative_path_tlibdir" = x ; then
libtool:  if test "x$func_stripname_result" != x ; then
libtool:# Make sure we have an absolute path for reexecution:
libtool:       test -x "$progdir/$progname" && break
libtool:# Sed substitution that turns a string into a regex matching for the
libtool:sed_make_literal_regex='s,[].[^$\\*\/],\\&,g'
libtool:# Re-`\' parameter expansions in output of double_quote_subst that were
libtool:# in input to double_quote_subst, that '$' was protected from expansion.
libtool:# Echo program name prefixed message, along with the current mode
libtool:# Echo program name prefixed message in verbose mode only.
libtool:# Echo program name prefixed message to standard error.
libtool:# Echo program name prefixed warning message to standard error.
libtool:# Echo program name prefixed message to standard error, and exit.
libtool:    exit $EXIT_FAILURE
libtool:# Echo program name prefixed message to standard error, followed by
libtool:# a help hint, and exit.
libtool:# func_grep expression filename
libtool:      # While some portion of DIR does not yet exist...
libtool:        # mkdir can fail with a `File exist' error if two processes
libtool:      # expansion for a subsequent eval.
libtool:# func_quote_for_expand arg
libtool:func_quote_for_expand ()
libtool:    func_quote_for_expand_result="$my_arg"
libtool:# func_show_eval cmd [fail_exp]
libtool:    my_fail_exp="${2-:}"
libtool:      func_quote_for_expand "$my_cmd"
libtool:      eval "func_echo $func_quote_for_expand_result"
libtool:	eval "(exit $my_status); $my_fail_exp"
libtool:# func_show_eval_locale cmd [fail_exp]
libtool:    my_fail_exp="${2-:}"
libtool:      func_quote_for_expand "$my_cmd"
libtool:      eval "func_echo $func_quote_for_expand_result"
libtool:	eval "(exit $my_status); $my_fail_exp"
libtool:# Echo version message to standard output and exit.
libtool:     exit $?
libtool:# Echo short help message to standard output and exit.
libtool:    exit $?
libtool:# Echo long help message to standard output and exit,
libtool:# unless 'noexit' is passed as argument.
libtool:      exit $ret
libtool:# Echo program name prefixed message to standard error and set global
libtool:# exit_cmd.
libtool:    exit_cmd=exit
libtool:} # Extended-shell func_split_short_opt implementation
libtool:} # Extended-shell func_split_long_opt implementation
libtool:exit_cmd=:
libtool:magic_exe="%%%MAGIC EXE variable%%%"
libtool:lo2o="s/\\.lo\$/.${objext}/"
libtool:o2lo="s/\\.${objext}\$/.lo/"
libtool:extracted_archives=
libtool:extracted_serial=0
libtool:# will be execed at the end.  This prevents here-documents from being
libtool:exec_cmd=
libtool:} # Extended-shell func_append implementation
libtool:} # Extended-shell func_append_quoted implementation
libtool:} # Extended-shell func_arith implementation
libtool:} # Extended-shell func_len implementation
libtool:      *.lo) func_lo2o_result=${1%.lo}.${objext} ;;
libtool:} # Extended-shell func_lo2o implementation
libtool:# func_xform libobj-or-source
libtool:func_xform ()
libtool:func_xform_result=${1%.*}.lo
libtool:} # Extended-shell func_xform implementation
libtool:# Echo program name prefixed message to standard error, followed by
libtool:# a configuration failure hint, and exit.
libtool:    exit $?
libtool:    exit $?
libtool:# Verify that TAGNAME is valid, and either flag an error and exit, or
libtool:  sed_extractcf="/$re_begincf/,/$re_endcf/p"
libtool:	extractedcf=`$SED -n -e "$sed_extractcf" < "$progpath"`
libtool:	eval "$extractedcf"
libtool:    exit $EXIT_MISMATCH
libtool:execute|execut|execu|exec|exe|ex|e)
libtool:  shift; set dummy --mode execute ${1+"$@"}; shift
libtool:  # this just eases exit handling
libtool:      --debug|-x)	opt_debug='set -x'
libtool:  clean|compile|execute|finish|install|link|relink|uninstall) ;;
libtool:     exit_cmd=exit
libtool:    eval std_shrext=\"$shrext_cmds\"
libtool:    # Only execute mode is allowed to have -dlopen flags.
libtool:    if test -n "$opt_dlopen" && test "$opt_mode" != execute; then
libtool:      exit $EXIT_FAILURE
libtool:  $exit_cmd $EXIT_FAILURE
libtool:# resorting to external programs.  To this end, it redirects stdin and
libtool:# fatal anyway.  Works if `file' does not exist.
libtool:    if test -f "$1" && test -r "$1" && exec 5<&0 <"$1"; then
libtool:	exec 0<&5 5<&-
libtool:# func_ltwrapper_executable_p file
libtool:# True iff FILE is a libtool wrapper executable
libtool:func_ltwrapper_executable_p ()
libtool:    func_ltwrapper_exec_suffix=
libtool:    *.exe) ;;
libtool:    *) func_ltwrapper_exec_suffix=.exe ;;
libtool:    $GREP "$magic_exe" "$1$func_ltwrapper_exec_suffix" >/dev/null 2>&1
libtool:# Assumes file is an ltwrapper_executable
libtool:    func_stripname '' '.exe' "$func_basename_result"
libtool:# True iff FILE is a libtool wrapper script or wrapper executable
libtool:    func_ltwrapper_script_p "$1" || func_ltwrapper_executable_p "$1"
libtool:# func_execute_cmds commands fail_cmd
libtool:# Execute tilde-delimited COMMANDS.
libtool:func_execute_cmds ()
libtool:# FILE even if both FILE and FILE.exe exist: automatic-append-.exe
libtool:# behavior happens only for exec(3), not for open(2)!  Also, sourcing
libtool:      CC_expanded=`func_echo_all $CC`
libtool:      CC_quoted_expanded=`func_echo_all $CC_quoted`
libtool:      " $CC "* | "$CC "* | " $CC_expanded "* | "$CC_expanded "* | \
libtool:      " $CC_quoted"* | "$CC_quoted "* | " $CC_quoted_expanded "* | "$CC_quoted_expanded "*) ;;
libtool:	    CC_expanded=`func_echo_all $CC`
libtool:	    CC_quoted_expanded=`func_echo_all $CC_quoted`
libtool:	    " $CC "* | "$CC "* | " $CC_expanded "* | "$CC_expanded "* | \
libtool:	    " $CC_quoted"* | "$CC_quoted "* | " $CC_quoted_expanded "* | "$CC_quoted_expanded "*)
libtool:# Helper function used by file name conversion functions when $build is *nix,
libtool:    # Unfortunately, winepath does not exit with a non-zero error code, so we
libtool:    # command is not found, the shell will set an exit code of 127 and print
libtool:    # zero AND non-empty stdout, which explains the odd construction:
libtool:# Helper function used by path conversion functions when $build is *nix, and
libtool:# when (1) $build is *nix and Cygwin is hosted via a wine environment; or (2)
libtool:# from $build's *nix or MSYS format). In case (3), returns the w32 file name
libtool:# Specify the absolute *nix (or w32) name to cygpath in the LT_CYGPATH
libtool:    func_error "LT_CYGPATH is empty or specifies non-existent file: \`$LT_CYGPATH'"
libtool:    func_error "Continuing, but uninstalled executables may not work."
libtool:    func_error "Continuing, but uninstalled executables may not work."
libtool:    if test "x$1" != "x$2"; then
libtool:# func_convert_file_nix_to_w32 ARG
libtool:# Convert file name ARG from *nix to w32 format.  Requires a wine environment
libtool:func_convert_file_nix_to_w32 ()
libtool:# end func_convert_file_nix_to_w32
libtool:# func_convert_file_nix_to_cygwin ARG
libtool:# Convert file name ARG from *nix to Cygwin format.  Requires Cygwin installed
libtool:func_convert_file_nix_to_cygwin ()
libtool:    # convert from *nix to w32, then use cygpath to convert from w32 to cygwin.
libtool:# end func_convert_file_nix_to_cygwin
libtool:# func_convert_path_nix_to_w32 ARG
libtool:# Convert path ARG from *nix to w32 format.  Requires a wine environment and
libtool:func_convert_path_nix_to_w32 ()
libtool:# end func_convert_path_nix_to_w32
libtool:# func_convert_path_nix_to_cygwin ARG
libtool:# Convert path ARG from *nix to Cygwin format.  Requires Cygwin installed in a
libtool:func_convert_path_nix_to_cygwin ()
libtool:# end func_convert_path_nix_to_cygwin
libtool:	  arg_mode=arg  #  the next one goes into the "base_compile" arg list
libtool:    # Recognize several different file suffixes.
libtool:    *.c++ | *.cc | *.ii | *.class | *.cpp | *.cxx | \
libtool:    *.[fF][09]? | *.for | *.java | *.go | *.obj | *.sx | *.cu | *.cup)
libtool:      func_xform "$libobj"
libtool:      libobj=$func_xform_result
libtool:    xdir="$func_dirname_result"
libtool:    lobj=${xdir}$objdir/$objname
libtool:      output_obj=`$ECHO "$srcfile" | $SED 's%^.*/%%; s%\.[^.]*$%%'`.${objext}
libtool:*** ERROR, $lockfile exists and contains:
libtool:	exit $EXIT_FAILURE
libtool:    trap '$opt_dry_run || $RM $removelist; exit $EXIT_FAILURE' 1 2 15
libtool:      func_mkdir_p "$xdir$objdir"
libtool:          'test -n "$output_obj" && $RM $removelist; exit $EXIT_FAILURE'
libtool:	exit $EXIT_FAILURE
libtool:      # Just move the object if needed, then go on to compile the next one
libtool:	  'error=$?; $opt_dry_run || $RM $removelist; exit $error'
libtool:        '$opt_dry_run || $RM $removelist; exit $EXIT_FAILURE'
libtool:	exit $EXIT_FAILURE
libtool:	  'error=$?; $opt_dry_run || $RM $removelist; exit $error'
libtool:    exit $EXIT_SUCCESS
libtool:        # Generic help is extracted from the usage comments
libtool:SOURCEFILE, then substituting the C source code suffix \`.c' with the
libtool:library object suffix, \`.lo'."
libtool:      execute)
libtool:"Usage: $progname [OPTION]... --mode=execute COMMAND [ARGS]...
libtool:If any of the ARGS are libtool executable wrappers, then they are translated
libtool:Then, COMMAND is executed, with ARGS as arguments."
libtool:The commands that this mode executes may require superuser privileges.  Use
libtool:the \`--dry-run' option if you just want to see what would be executed."
libtool:Install executables or libraries.
libtool:  -inst-prefix-dir PREFIX-DIR  Use PREFIX-DIR as a staging area for installation
libtool:create an executable program.
libtool:  -avoid-version    do not add a version suffix if possible
libtool:  -export-dynamic   allow symbols from OUTPUT-FILE to be resolved with dlsym(3)
libtool:  -export-symbols SYMFILE
libtool:                    try to export only the symbols listed in SYMFILE
libtool:  -export-symbols-regex REGEX
libtool:                    try to export only the symbols matching REGEX
libtool:  -no-install       link a not-installable executable
libtool:  -no-undefined     declare that a library does not refer to external symbols
libtool:  -precious-files-regex REGEX
libtool:  -shrext SUFFIX    override the standard shared library file extension
libtool:required, except when creating a convenience library.
libtool:If OUTPUT-FILE ends in \`.lo' or \`.${objext}', then a reloadable object file
libtool:is created, otherwise an executable program is created."
libtool:      func_help noexit
libtool:      for opt_mode in compile link execute install finish uninstall clean; do
libtool:      func_help noexit
libtool:      for opt_mode in compile link execute install finish uninstall clean; do
libtool:      $x
libtool:  exit $?
libtool:# func_mode_execute arg...
libtool:func_mode_execute ()
libtool:	    func_warning "\`$file' was not linked with \`-export-dynamic'"
libtool:    libtool_execute_magic="$magic"
libtool:	elif func_ltwrapper_executable_p "$file"; then
libtool:	# Export the shlibpath_var.
libtool:	eval "export $shlibpath_var"
libtool:                $lt_var=\$save_$lt_var; export $lt_var
libtool:      # Now prepare to actually exec the command.
libtool:      exec_cmd="\$cmd$args"
libtool:	echo "export $shlibpath_var"
libtool:      exit $EXIT_SUCCESS
libtool:test "$opt_mode" = execute && func_mode_execute ${1+"$@"}
libtool:        sysroot_regex=`$ECHO "$lt_sysroot" | $SED "$sed_make_literal_regex"`
libtool:        sysroot_cmd="s/\([ ']\)$sysroot_regex/\1/g;"
libtool:          echo "removing references to $lt_sysroot and \`=' prefixes from $lib"
libtool:	  func_execute_cmds "$finish_cmds" 'admincmds="$admincmds
libtool:    # Exit here if they wanted silent mode.
libtool:    $opt_silent && exit $EXIT_SUCCESS
libtool:	echo "     during execution"
libtool:    exit $EXIT_SUCCESS
libtool:	  if test "x$prev" = x-m && test -n "$install_override_mode"; then
libtool:      *.$libext)
libtool:	  # Determine the prefix the user has applied to our future dir.
libtool:	  inst_prefix_dir=`$ECHO "$destdir" | $SED -e "s%$libdir\$%%"`
libtool:	  # Don't allow the user to place us outside of our expected
libtool:	  # are installed to the same prefix.
libtool:	  test "$inst_prefix_dir" = "$destdir" && \
libtool:	  if test -n "$inst_prefix_dir"; then
libtool:	    # Stick the inst_prefix_dir data into the link command.
libtool:	    relink_command=`$ECHO "$relink_command" | $SED "s%@inst_prefix_dir@%-inst-prefix-dir $inst_prefix_dir%"`
libtool:	    relink_command=`$ECHO "$relink_command" | $SED "s%@inst_prefix_dir@%%"`
libtool:	      'exit $?'
libtool:	    func_show_eval "$striplib $destdir/$realname" 'exit $?'
libtool:	  func_execute_cmds "$postinstall_cmds" 'exit $?'
libtool:	func_show_eval "$install_prog $instname $destdir/$name" 'exit $?'
libtool:	*.$objext)
libtool:	  func_show_eval "$install_prog $file $destfile" 'exit $?'
libtool:	  func_show_eval "$install_prog \$staticobj \$staticdest" 'exit $?'
libtool:	exit $EXIT_SUCCESS
libtool:	# If the file is missing, and there is a .exe on the end, strip it
libtool:	stripped_ext=""
libtool:	  *.exe)
libtool:	      func_stripname '' '.exe' "$file"
libtool:	      stripped_ext=".exe"
libtool:	    if func_ltwrapper_executable_p "$file"; then
libtool:	      func_stripname '' '.exe' "$file"
libtool:		func_basename "$file$stripped_ext"
libtool:	          func_quote_for_expand "$relink_command"
libtool:		  eval "func_echo $func_quote_for_expand_result"
libtool:	    file=`$ECHO "$file$stripped_ext" | $SED "s%\([^/]*\)$%$objdir/\1%"`
libtool:	# remove .exe since cygwin /usr/bin/install will append another
libtool:	  *.exe:*.exe)
libtool:	  *.exe:*)
libtool:	    destfile=$destfile.exe
libtool:	  *:*.exe)
libtool:	    func_stripname '' '.exe' "$destfile"
libtool:	func_show_eval "$install_prog\$stripme \$file \$destfile" 'exit $?'
libtool:      func_show_eval "$install_prog \$file \$oldlib" 'exit $?'
libtool:	func_show_eval "$old_striplib $tool_oldlib" 'exit $?'
libtool:      func_execute_cmds "$old_postinstall_cmds" 'exit $?'
libtool:      exec_cmd='$SHELL $progpath $preserve_args --finish$current_libdirs'
libtool:      exit $EXIT_SUCCESS
libtool:# Extract symbols from dlprefiles and create ${outputname}S.o with
libtool:    my_prefix=`$ECHO "$my_originator" | sed 's%[^a-zA-Z0-9]%_%g'`
libtool:	func_error "not configured to extract global symbols from dlpreopened files"
libtool:extern \"C\" {
libtool:/* External symbol declarations for the compiler. */\
libtool:	    func_verbose "extracting global C symbols from \`$func_to_tool_file_result'"
libtool:	  if test -n "$exclude_expsyms"; then
libtool:	      eval '$EGREP -v " ($exclude_expsyms)$" "$nlist" > "$nlist"T'
libtool:	  if test -n "$export_symbols_regex"; then
libtool:	      eval '$EGREP -e "$export_symbols_regex" "$nlist" > "$nlist"T'
libtool:	  # Prepare the list of exported symbols
libtool:	  if test -z "$export_symbols"; then
libtool:	    export_symbols="$output_objdir/$outputname.exp"
libtool:	      $RM $export_symbols
libtool:	      eval "${SED} -n -e '/^: @PROGRAM@ $/d' -e 's/^.* \(.*\)$/\1/p' "'< "$nlist" > "$export_symbols"'
libtool:                eval 'cat "$export_symbols" >> "$output_objdir/$outputname.def"'
libtool:	      eval "${SED} -e 's/\([].[*^$]\)/\\\\\1/g' -e 's/^/ /' -e 's/$/$/'"' < "$export_symbols" > "$output_objdir/$outputname.exp"'
libtool:	      eval '$GREP -f "$output_objdir/$outputname.exp" < "$nlist" > "$nlist"T'
libtool:	  func_verbose "extracting global C symbols from \`$dlprefile'"
libtool:	            # no lafile. user explicitly requested -dlpreopen <import library>.
libtool:	  if test -n "$exclude_expsyms"; then
libtool:	    $EGREP -v " ($exclude_expsyms)$" "$nlist" > "$nlist"T
libtool:extern LT_DLSYM_CONST lt_dlsymlist
libtool:lt_${my_prefix}_LTX_preloaded_symbols[];
libtool:lt_${my_prefix}_LTX_preloaded_symbols[] =
libtool:	  case $need_lib_prefix in
libtool:	    eval "$global_symbol_to_c_name_address_lib_prefix" < "$nlist" >> "$output_objdir/$my_dlsyms"
libtool:  return lt_${my_prefix}_LTX_preloaded_symbols;
libtool:	  # pic_flag when linking with -static.  The problem exists in
libtool:	  # FreeBSD 2.2.6 and is fixed in FreeBSD 3.1.
libtool:	  *-*-hpux*)
libtool:	func_show_eval '(cd $output_objdir && $LTCC$symtab_cflags -c$no_builtin_flag$pic_flag_for_symtable "$my_dlsyms")' 'exit $?'
libtool:	symfileobj="$output_objdir/${my_outputname}S.$objext"
libtool:	func_fatal_error "unknown suffix for \`$my_dlsyms'"
libtool:    win32_libid_type="x86 archive import"
libtool:       $EGREP 'file format (pei*-i386(.*architecture: i386)?|pe-arm-wince|pe-x86-64)' >/dev/null; then
libtool:      win32_nmres=`eval $NM -f posix -A \"$func_to_tool_file_result\" |
libtool:      import*)  win32_libid_type="x86 archive import";;
libtool:      *)        win32_libid_type="x86 archive static";;
libtool:    win32_libid_type="x86 DLL"
libtool:  *executable*) # but shell scripts are "executable" too...
libtool:      win32_libid_type="x86 DLL"
libtool:# Platform-specific function to extract the
libtool:# platform-specific function to extract the name of the
libtool:  match_literal=`$ECHO "$1" | $SED "$sed_make_literal_regex"`
libtool:      # Join marker and all lines until next marker into a single line
libtool:      x
libtool:    # 0x302f exports -- but will fail for DLLs whose name actually
libtool:# Platform-specific function to extract the
libtool:# func_extract_an_archive dir oldlib
libtool:func_extract_an_archive ()
libtool:    f_ex_an_ar_dir="$1"; shift
libtool:    f_ex_an_ar_oldlib="$1"
libtool:    if test "$lock_old_archive_extraction" = yes; then
libtool:      lockfile=$f_ex_an_ar_oldlib.lock
libtool:    func_show_eval "(cd \$f_ex_an_ar_dir && $AR x \"\$f_ex_an_ar_oldlib\")" \
libtool:		   'stat=$?; rm -f "$lockfile"; exit $stat'
libtool:    if test "$lock_old_archive_extraction" = yes; then
libtool:    if ($AR t "$f_ex_an_ar_oldlib" | sort | sort -uc >/dev/null 2>&1); then
libtool:      func_fatal_error "object name conflicts in archive: $f_ex_an_ar_dir/$f_ex_an_ar_oldlib"
libtool:# func_extract_archives gentop oldlib ...
libtool:func_extract_archives ()
libtool:    my_xlib=""
libtool:    my_xabs=""
libtool:    my_xdir=""
libtool:    for my_xlib in $my_oldlibs; do
libtool:      # Extract the objects.
libtool:      case $my_xlib in
libtool:	[\\/]* | [A-Za-z]:[\\/]*) my_xabs="$my_xlib" ;;
libtool:	*) my_xabs=`pwd`"/$my_xlib" ;;
libtool:      func_basename "$my_xlib"
libtool:      my_xlib="$func_basename_result"
libtool:      my_xlib_u=$my_xlib
libtool:        case " $extracted_archives " in
libtool:	*" $my_xlib_u "*)
libtool:	  func_arith $extracted_serial + 1
libtool:	  extracted_serial=$func_arith_result
libtool:	  my_xlib_u=lt$extracted_serial-$my_xlib ;;
libtool:      extracted_archives="$extracted_archives $my_xlib_u"
libtool:      my_xdir="$my_gentop/$my_xlib_u"
libtool:      func_mkdir_p "$my_xdir"
libtool:	func_verbose "Extracting $my_xabs"
libtool:	  cd $my_xdir || exit $?
libtool:	  darwin_archive=$my_xabs
libtool:	      func_extract_an_archive "`pwd`" "${darwin_base_archive}"
libtool:	    func_extract_an_archive "$my_xdir" "$my_xabs"
libtool:        func_extract_an_archive "$my_xdir" "$my_xabs"
libtool:      my_oldobjs="$my_oldobjs "`find $my_xdir -name \*.$objext -print -o -name \*.lo -print | sort | $NL2SP`
libtool:    func_extract_archives_result="$my_oldobjs"
libtool:# wrapper executable.  Must ONLY be called from within
libtool:# The $output program cannot be directly executed until all the libtool
libtool:  # Zsh 3.x and 4.x performs word splitting on \${1+\"\$@\"}, which
libtool:  case \`(set -o) 2>/dev/null\` in *posix*) set -o posix;; esac
libtool:BIN_SH=xpg4; export BIN_SH # for Tru64
libtool:DUALCASE=1; export DUALCASE # for MKS sh
libtool:  # When we are sourced in execute mode, \$file and \$ECHO are already set.
libtool:  if test \"\$libtool_execute_magic\" != \"$magic\"; then
libtool:# /script/ and the wrapper /executable/ which is used only on
libtool:        exit 0
libtool:        exit 1
libtool:    lt_dump_args_N=\`expr \$lt_dump_args_N + 1\`
libtool:func_exec_program_core ()
libtool:      exec \"\$progdir\\\\\$program\" \${1+\"\$@\"}
libtool:      exec \"\$progdir/\$program\" \${1+\"\$@\"}
libtool:      \$ECHO \"\$0: cannot exec \$program \$*\" 1>&2
libtool:      exit 1
libtool:func_exec_program ()
libtool:      *) set x \"\$@\" \"\$lt_wr_arg\"; shift;;
libtool:  func_exec_program_core \${1+\"\$@\"}
libtool:  test \"x\$thisdir\" = \"x\$file\" && thisdir=.
libtool:    if test \"x\$destdir\" != \"x\$file\"; then
libtool:  # Usually 'no', except on cygwin/mingw when embedded into
libtool:  program=lt-'$outputname'$exeext
libtool:    # relink executable if necessary
libtool:	exit 1
libtool:	# fixup the dll searchpath if we need to.
libtool:	# Fix the DLL searchpath if we need to.  Do this before prepending
libtool:    # Add the dll search path components to the executable PATH
libtool:	# Export our shlibpath_var if we have one.
libtool:    export $shlibpath_var
libtool:    if test \"\$libtool_execute_magic\" != \"$magic\"; then
libtool:      func_exec_program \${1+\"\$@\"}
libtool:    # The program doesn't exist.
libtool:    \$ECHO \"\$0: error: \\\`\$progdir/\$program' does not exist\" 1>&2
libtool:    exit 1
libtool:# func_emit_cwrapperexe_src
libtool:# emit the source code for a wrapper executable on stdout
libtool:func_emit_cwrapperexe_src ()
libtool:/* $cwrappersource - temporary wrapper executable for $objdir/$outputname
libtool:   The $output program cannot be directly executed until all the libtool
libtool:   This wrapper executable should never be moved out of the build directory.
libtool:/* portability defines, excluding path handling macros */
libtool:#define XMALLOC(type, num)      ((type *) xmalloc ((num) * sizeof(type)))
libtool:const char *program_name = "libtool-wrapper"; /* in case xstrdup fails */
libtool:void *xmalloc (size_t num);
libtool:char *xstrdup (const char *string);
libtool:char *find_executable (const char *wrapper);
libtool:int make_executable (const char *path);
libtool:int check_executable (const char *path);
libtool:char *lt_extend_str (const char *orig_value, const char *add, int to_end);
libtool:void lt_update_exe_path (const char *name, const char *value);
libtool:volatile const char * MAGIC_EXE = "$magic_exe";
libtool:const char * TARGET_PROGRAM_NAME = "lt-$outputname"; /* hopefully, no .exe */
libtool:const char * TARGET_PROGRAM_NAME = "$outputname"; /* hopefully, no .exe */
libtool:static const char *ltwrapper_option_prefix = LTWRAPPER_OPTION_PREFIX;
libtool:  program_name = (char *) xstrdup (base_name (argv[0]));
libtool:   * also, copy all non cwrapper options to newargz, except
libtool:		# make stdout use "unix" line endings
libtool:      if (strcmp (argv[i], ltwrapper_option_prefix) == 0)
libtool:                    ltwrapper_option_prefix, argv[i]);
libtool:      newargz[++newargc] = xstrdup (argv[i]);
libtool:  tmp_pathspec = find_executable (argv[0]);
libtool:                  "(main) found exe (before symlink chase) at: %s\n",
libtool:                  "(main) found exe (after symlink chase) at: %s\n",
libtool:  actual_cwrapper_name = xstrdup (base_name (actual_cwrapper_path));
libtool:  strendzap (actual_cwrapper_name, ".exe");
libtool:  tmp_pathspec = lt_extend_str (actual_cwrapper_name, ".exe", 1);
libtool:  /* target_name transforms -- use actual target program name; might have lt- prefix */
libtool:  target_name = xstrdup (base_name (TARGET_PROGRAM_NAME));
libtool:  strendzap (target_name, ".exe");
libtool:  tmp_pathspec = lt_extend_str (target_name, ".exe", 1);
libtool:  tmp_pathspec = xstrdup (newargz[0]);
libtool:  /* do NOT want the lt- prefix here, so use actual_cwrapper_name */
libtool:  /* DO want the lt- prefix here if it exists, so use target_name */
libtool:  lt_argv_zero = lt_extend_str (tmp_pathspec, target_name, 1);
libtool:  lt_setenv ("BIN_SH", "xpg4"); /* for Tru64 */
libtool:  lt_update_exe_path (EXE_PATH_VARNAME, EXE_PATH_VALUE);
libtool:  /* execv doesn't actually work on mingw as expected on unix */
libtool:  execv (lt_argv_zero, newargz);
libtool:xmalloc (size_t num)
libtool:    lt_fatal (__FILE__, __LINE__, "memory exhausted");
libtool:xstrdup (const char *string)
libtool:  return string ? strcpy ((char *) xmalloc (strlen (string) + 1),
libtool:check_executable (const char *path)
libtool:  lt_debugprintf (__FILE__, __LINE__, "(check_executable): %s\n",
libtool:make_executable (const char *path)
libtool:  lt_debugprintf (__FILE__, __LINE__, "(make_executable): %s\n",
libtool:find_executable (const char *wrapper)
libtool:  const char *p_next;
libtool:  lt_debugprintf (__FILE__, __LINE__, "(find_executable): %s\n",
libtool:      concat_name = xstrdup (wrapper);
libtool:      if (check_executable (concat_name))
libtool:	  concat_name = xstrdup (wrapper);
libtool:	  if (check_executable (concat_name))
libtool:	  for (p = path; *p; p = p_next)
libtool:	      p_next = (*q == '\0' ? q : q + 1);
libtool:	      if (check_executable (concat_name))
libtool:  if (check_executable (concat_name))
libtool:  return xstrdup (pathspec);
libtool:  char *tmp_pathspec = xstrdup (pathspec);
libtool:      return xstrdup (pathspec);
libtool:  return xstrdup (tmp_pathspec);
libtool:lt_error_core (int exit_status, const char *file,
libtool:  if (exit_status >= 0)
libtool:    exit (exit_status);
libtool:    char *str = xstrdup (value);
libtool:lt_extend_str (const char *orig_value, const char *add, int to_end)
libtool:      new_value = xstrdup (add);
libtool:lt_update_exe_path (const char *name, const char *value)
libtool:		  "(lt_update_exe_path) modifying '%s' by prepending '%s'\n",
libtool:      char *new_value = lt_extend_str (getenv (name), value, 0);
libtool:      char *new_value = lt_extend_str (getenv (name), value, 0);
libtool:         GetVersionEx(&v);
libtool:      }) ? "cmd.exe" : "command.com").
libtool:	new_argv[i] = xstrdup ("\"\"");
libtool:# end: func_emit_cwrapperexe_src
libtool:      # which system we are compiling for in order to pass an extra
libtool:    inst_prefix_dir=
libtool:    export_dynamic=no
libtool:    export_symbols=
libtool:    export_symbols_regex=
libtool:    precious_files_regex=
libtool:    xrpath=
libtool:	      export_dynamic=yes
libtool:	      export_dynamic=yes
libtool:	expsyms)
libtool:	  export_symbols="$arg"
libtool:	    || func_fatal_error "symbol file \`$arg' does not exist"
libtool:	expsyms_regex)
libtool:	  export_symbols_regex="$arg"
libtool:		*) deplibs+=" $qarg.ltframework" # this is fixed later
libtool:	inst_prefix)
libtool:	  inst_prefix_dir="$arg"
libtool:		# Extract subdirectory from the argument.
libtool:		xdir="$func_dirname_result"
libtool:		  pic_object="$xdir$pic_object"
libtool:		  non_pic_object="$xdir$non_pic_object"
libtool:		  # If the PIC object exists, use it instead.
libtool:		  # $xdir was prepended to $pic_object above.
libtool:		  # Extract subdirectory from the argument.
libtool:		  xdir="$func_dirname_result"
libtool:		  pic_object=$xdir$objdir/$func_lo2o_result
libtool:		  non_pic_object=$xdir$func_lo2o_result
libtool:	    func_fatal_error "link input file \`$arg' does not exist"
libtool:	precious_regex)
libtool:	  precious_files_regex="$arg"
libtool:	rpath | xrpath)
libtool:	    case "$xrpath " in
libtool:	    *) xrpath+=" $arg" ;;
libtool:	shrext)
libtool:	  shrext_cmds="$arg"
libtool:	xcclinker)
libtool:	xcompiler)
libtool:	xlinker)
libtool:      -export-dynamic)
libtool:	export_dynamic=yes
libtool:      -export-symbols | -export-symbols-regex)
libtool:	if test -n "$export_symbols" || test -n "$export_symbols_regex"; then
libtool:	  func_fatal_error "more than one -exported-symbols argument is not allowed"
libtool:	if test "X$arg" = "X-export-symbols"; then
libtool:	  prev=expsyms
libtool:	  prev=expsyms_regex
libtool:      -inst-prefix-dir)
libtool:	prev=inst_prefix
libtool:	no/*-*-irix* | /*-*-irix*)
libtool:	  *-*-sysv4.2uw2* | *-*-sysv5* | *-*-unixware* | *-*-OpenUNIX*)
libtool:      # classes, name mangling, and exception handling.
libtool:	prev=xcompiler
libtool:      |-threads|-fopenmp|-openmp|-mp|-xopenmp|-omp|-qsmp=*)
libtool:      -precious-files-regex)
libtool:	prev=precious_regex
libtool:	prev=xrpath
libtool:	case "$xrpath " in
libtool:	*) xrpath+=" $dir" ;;
libtool:      -shrext)
libtool:	prev=shrext
libtool:	# Digital Unix and AIX.
libtool:	prev=xcompiler
libtool:	prev=xlinker
libtool:	prev=xcclinker
libtool:      # -xarch=*, -xtarget=* enable 64-bit mode for the Sun compiler
libtool:      # -m*, -t[45]*, -txscale* architecture-specific flags for GCC
libtool:      -64|-mips[0-9]|-r[0-9][0-9]*|-xarch=*|-xtarget=*|+DA*|+DD*|-q*|-m*| \
libtool:      -t[45]*|-txscale*|-p|-pg|--coverage|-fprofile-*|-F*|@*|-tp=*|--sysroot=*| \
libtool:      *.$objext)
libtool:	  # Extract subdirectory from the argument.
libtool:	  xdir="$func_dirname_result"
libtool:	    pic_object="$xdir$pic_object"
libtool:	    non_pic_object="$xdir$non_pic_object"
libtool:	    # If the PIC object exists, use it instead.
libtool:	    # $xdir was prepended to $pic_object above.
libtool:	    # Extract subdirectory from the argument.
libtool:	    xdir="$func_dirname_result"
libtool:	    pic_object=$xdir$objdir/$func_lo2o_result
libtool:	    non_pic_object=$xdir$func_lo2o_result
libtool:      *.$libext)
libtool:    if test "$export_dynamic" = yes && test -n "$export_dynamic_flag_spec"; then
libtool:      eval arg=\"$export_dynamic_flag_spec\"
libtool:    *.$libext) linkmode=oldlib ;;
libtool:    *.lo | *.$objext) linkmode=obj ;;
libtool:	##        order, and fix it there properly
libtool:	  # Collect preopened libtool deplibs, except any this library
libtool:        |-threads|-fopenmp|-openmp|-mp|-xopenmp|-omp|-qsmp=*)
libtool:	    for search_ext in .la $std_shrext .so .a; do
libtool:	      lib="$searchdir/lib${name}${search_ext}"
libtool:		if test "$search_ext" = ".la"; then
libtool:	    # Make sure the xrpath contains only unique directories.
libtool:	    case "$xrpath " in
libtool:	    *) xrpath+=" $dir" ;;
libtool:	*.$libext)
libtool:		  match_pattern_regex=`expr "$deplibs_check_method" : "$1 \(.*\)"`
libtool:		    | $EGREP "$match_pattern_regex" > /dev/null; then
libtool:		echo "*** because the file extensions .$libext of this argument makes me believe"
libtool:	  ;; # *.$libext
libtool:	*.lo | *.$objext)
libtool:	      # static and shared are present.  Therefore, ensure we extract
libtool:	      # name in a special purpose variable, and (later) extracting the
libtool:	      $ECHO "*** Warning: Linking the executable $output against the loadable module"
libtool:	  if test -n "$old_archive_from_expsyms_cmds"; then
libtool:		versuffix="-$major"
libtool:	    # Make a new name for the extract_expsyms_cmds to use
libtool:	    # If the library has no export list, then create one now
libtool:	      func_verbose "extracting exported symbol list from \`$soname'"
libtool:	      func_execute_cmds "$extract_expsyms_cmds" 'exit $?'
libtool:	      func_execute_cmds "$old_archive_from_expsyms_cmds" 'exit $?'
libtool:	  fi # test -n "$old_archive_from_expsyms_cmds"
libtool:		  *-*-sysv5OpenUNIX* | *-*-sysv5UnixWare7.[01].[10]* | \
libtool:		    *-*-unixware7*) add_dir="-L$dir" ;;
libtool:		if test -n "$inst_prefix_dir"; then
libtool:		      add_dir+=" -L$inst_prefix_dir$libdir"
libtool:	      if test -n "$inst_prefix_dir" &&
libtool:		 test -f "$inst_prefix_dir$libdir/$linklib" ; then
libtool:		add="$inst_prefix_dir$libdir/$linklib"
libtool:	      if test -n "$inst_prefix_dir"; then
libtool:		    add_dir+=" -L$inst_prefix_dir$libdir"
libtool:		echo "*** However, this would only work if libtool was able to extract symbol"
libtool:	    # Extract -R from dependency_libs
libtool:	           temp_xrpath=$func_stripname_result
libtool:		   case " $xrpath " in
libtool:		   *" $temp_xrpath "*) ;;
libtool:		   *) xrpath+=" $temp_xrpath";;
libtool:		      darwin_install_name=`${OTOOL} -L $depdepl | awk '{if (NR == 2) {print $1;exit}}'`
libtool:                          darwin_install_name=`${OTOOL64} -L $depdepl  | awk '{if (NR == 2) {print $1;exit}}'`
libtool:	      # than once as an explicit dependence of a library, or
libtool:      test -n "$xrpath" && \
libtool:      test -n "$export_symbols$export_symbols_regex" && \
libtool:	func_warning "\`-export-symbols' is ignored for archives"
libtool:	eval shared_ext=\"$shrext_cmds\"
libtool:	if test "$need_lib_prefix" != no; then
libtool:	  # Add the "lib" prefix for modules if required
libtool:	  eval shared_ext=\"$shrext_cmds\"
libtool:	  # Some compilers have problems with a `.al' extension so
libtool:	  # convenience libraries should have the same extension an
libtool:	  oldlibs="$output_objdir/$libname.$libext $oldlibs"
libtool:	  # a minor version.  But, then there is irix
libtool:	  # which has an extra 1 added just for fun
libtool:	  # correct linux to gnu/linux during the next big refactor
libtool:	  darwin|linux|osf|windows|none)
libtool:	  freebsd-aout|freebsd-elf|qnx|sunos)
libtool:	  irix|nonstopux)
libtool:	    lt_irix_increment=no
libtool:	versuffix=
libtool:	  # Like Linux, but with the current version available in
libtool:	  versuffix="$major.$age.$revision"
libtool:	  xlcverstring="${wl}-compatibility_version ${wl}$minor_current ${wl}-current_version ${wl}$minor_current.$revision"
libtool:	  versuffix=".$current.$revision";
libtool:	  versuffix=".$current"
libtool:	irix | nonstopux)
libtool:	  if test "X$lt_irix_increment" = "Xno"; then
libtool:	    nonstopux) verstring_prefix=nonstopux ;;
libtool:	    *)         verstring_prefix=sgi ;;
libtool:	  verstring="$verstring_prefix$major.$revision"
libtool:	    verstring="$verstring_prefix$major.$iface:$verstring"
libtool:	  versuffix="$major.$revision"
libtool:	linux) # correct to gnu/linux during the next big refactor
libtool:	  versuffix="$major.$age.$revision"
libtool:	  versuffix=".$current.$age.$revision"
libtool:	  # Make executables depend on our current version.
libtool:	qnx)
libtool:	  versuffix=".$current"
libtool:	  versuffix=".$current.$revision"
libtool:	  # extension on DOS 8.3 filesystems.
libtool:	  versuffix="-$major"
libtool:	    versuffix=
libtool:	    versuffix=".0.0"
libtool:	  versuffix=
libtool:	    *.$objext | *.gcno)
libtool:	       if test "X$precious_files_regex" != "X"; then
libtool:		 if $ECHO "$p" | $EGREP -e "$precious_files_regex" >/dev/null 2>&1
libtool:	oldlibs+=" $output_objdir/$libname.$libext"
libtool:	oldobjs="$objs "`$ECHO "$libobjs" | $SP2NL | $SED "/\.${libext}$/d; $lo2o" | $NL2SP`
libtool:      if test -n "$xrpath"; then
libtool:	temp_xrpath=
libtool:	for libdir in $xrpath; do
libtool:	  temp_xrpath+=" -R$func_replace_sysroot_result"
libtool:	  dependency_libs="$temp_xrpath $dependency_libs"
libtool:	    # Don't link with libc until the a.out ld.so is fixed.
libtool:	  *-*-sysv4.2uw2* | *-*-sysv5* | *-*-unixware* | *-*-OpenUNIX*)
libtool:	versuffix_save=$versuffix
libtool:	versuffix=""
libtool:	  # whether the library exists or not.  But this is on
libtool:	  # against the deplibs as a proxy for the library.  Then we can check
libtool:		  if test `expr "$ldd_output" : ".*$deplib_match"` -ne 0 ; then
libtool:		    if test `expr "$ldd_output" : ".*$deplib_match"` -ne 0 ; then
libtool:	  file_magic_regex=`expr "$deplibs_check_method" : "$1 \(.*\)"`
libtool:			 $EGREP "$file_magic_regex" > /dev/null; then
libtool:	  match_pattern_regex=`expr "$deplibs_check_method" : "$1 \(.*\)"`
libtool:		       $EGREP "$match_pattern_regex" > /dev/null; then
libtool:		  $ECHO "*** with $libname but no candidates were found. (...for regex pattern test)"
libtool:		  $ECHO "*** using a regex pattern. Last file checked: $potlib"
libtool:	versuffix=$versuffix_save
libtool:	      echo "*** However, this would only work if libtool was able to extract symbol"
libtool:	      oldlibs="$output_objdir/$libname.$libext"
libtool:	      echo "*** it was explicitly requested with -no-undefined,"
libtool:		oldlibs="$output_objdir/$libname.$libext"
libtool:	    eval "$runpath_var='$rpath\$$runpath_var'; export $runpath_var"
libtool:	  eval "$shlibpath_var='$shlibpath\$$shlibpath_var'; export $shlibpath_var"
libtool:	eval shared_ext=\"$shrext_cmds\"
libtool:	if test -n "$export_symbols" && test -n "$include_expsyms"; then
libtool:	  $opt_dry_run || cp "$export_symbols" "$output_objdir/$libname.uexp"
libtool:	  export_symbols="$output_objdir/$libname.uexp"
libtool:	  delfiles+=" $export_symbols"
libtool:	orig_export_symbols=
libtool:	  if test -n "$export_symbols" && test -z "$export_symbols_regex"; then
libtool:	    # exporting using user supplied symfile
libtool:	    if test "x`$SED 1q $export_symbols`" != xEXPORTS; then
libtool:	      # them as such. So, trigger use of export_symbols_cmds.
libtool:	      # export_symbols gets reassigned inside the "prepare
libtool:	      # the list of exported symbols" if statement, so the
libtool:	      # include_expsyms logic still works.
libtool:	      orig_export_symbols="$export_symbols"
libtool:	      export_symbols=
libtool:	      always_export_symbols=yes
libtool:	# Prepare the list of exported symbols
libtool:	if test -z "$export_symbols"; then
libtool:	  if test "$always_export_symbols" = yes || test -n "$export_symbols_regex"; then
libtool:	    export_symbols="$output_objdir/$libname.exp"
libtool:	    $opt_dry_run || $RM $export_symbols
libtool:	    cmds=$export_symbols_cmds
libtool:		 && { test "$len" -lt "$max_cmd_len" \
libtool:		      || test "$max_cmd_len" -le -1; }
libtool:		func_show_eval "$cmd" 'exit $?'
libtool:		skipped_export=false
libtool:		func_show_eval "$cmd" 'exit $?'
libtool:		skipped_export=false
libtool:		# The command line is too long to execute in one step.
libtool:		func_verbose "using reloadable object file for export list..."
libtool:		skipped_export=:
libtool:		# Break out early, otherwise skipped_export may be
libtool:	    if test -n "$export_symbols_regex" && test "X$skipped_export" != "X:"; then
libtool:	      func_show_eval '$EGREP -e "$export_symbols_regex" "$export_symbols" > "${export_symbols}T"'
libtool:	      func_show_eval '$MV "${export_symbols}T" "$export_symbols"'
libtool:	if test -n "$export_symbols" && test -n "$include_expsyms"; then
libtool:	  tmp_export_symbols="$export_symbols"
libtool:	  test -n "$orig_export_symbols" && tmp_export_symbols="$orig_export_symbols"
libtool:	  $opt_dry_run || eval '$ECHO "$include_expsyms" | $SP2NL >> "$tmp_export_symbols"'
libtool:	if test "X$skipped_export" != "X:" && test -n "$orig_export_symbols"; then
libtool:	  # The given exports_symbols file has to be filtered, so filter it.
libtool:	  func_verbose "filter symbol list for \`$libname.la' to tag DATA exports"
libtool:	  $opt_dry_run || $SED -e '/[ ,]DATA/!d;s,\(.*\)\([ \,].*\),s|^\1$|\1\2|,' < $export_symbols > $output_objdir/$libname.filter
libtool:	  delfiles+=" $export_symbols $output_objdir/$libname.filter"
libtool:	  export_symbols=$output_objdir/$libname.def
libtool:	  $opt_dry_run || $SED -f $output_objdir/$libname.filter < $orig_export_symbols > $export_symbols
libtool:	    # extract the archives, so we have objects to list.
libtool:	    # TODO: could optimize this to just extract one archive.
libtool:	    gentop="$output_objdir/${outputname}x"
libtool:	    func_extract_archives $gentop $convenience
libtool:	    libobjs+=" $func_extract_archives_result"
libtool:	  $opt_dry_run || eval '(cd $output_objdir && $RM ${realname}U && $MV $realname ${realname}U)' || exit $?
libtool:	  if test -n "$export_symbols" && test -n "$module_expsym_cmds"; then
libtool:	    eval test_cmds=\"$module_expsym_cmds\"
libtool:	    cmds=$module_expsym_cmds
libtool:	  if test -n "$export_symbols" && test -n "$archive_expsym_cmds"; then
libtool:	    eval test_cmds=\"$archive_expsym_cmds\"
libtool:	    cmds=$archive_expsym_cmds
libtool:	if test "X$skipped_export" != "X:" &&
libtool:	   test "$len" -lt "$max_cmd_len" || test "$max_cmd_len" -le -1; then
libtool:	  # or, if using GNU ld and skipped_export is not :, use a linker
libtool:	  # whole_archive_flag_spec was expanded, because we can't
libtool:	  # convenience libraries get linked in and end up exceeding
libtool:	  if test -n "$save_libobjs" && test "X$skipped_export" != "X:" && test "$with_gnu_ld" = yes; then
libtool:	  elif test -n "$save_libobjs" && test "X$skipped_export" != "X:" && test "X$file_list_spec" != X; then
libtool:	    set x $save_libobjs
libtool:	      output=$output_objdir/$output_la-${k}.$objext
libtool:		   test "$len" -lt "$max_cmd_len"; then
libtool:		  last_robj=$output_objdir/$output_la-${k}.$objext
libtool:		  output=$output_objdir/$output_la-${k}.$objext
libtool:	    if ${skipped_export-false}; then
libtool:	      export_symbols="$output_objdir/$libname.exp"
libtool:	      $opt_dry_run || $RM $export_symbols
libtool:	      # Append the command to create the export file.
libtool:	      eval concat_cmds=\"\$concat_cmds$export_symbols_cmds\"
libtool:	    # Loop through the commands generated above and execute them.
libtool:		  func_quote_for_expand "$cmd"
libtool:		  eval "func_echo $func_quote_for_expand_result"
libtool:		lt_exit=$?
libtool:		# Restore the uninstalled library and exit
libtool:		exit $lt_exit
libtool:	    if test -n "$export_symbols_regex" && ${skipped_export-false}; then
libtool:	      func_show_eval '$EGREP -e "$export_symbols_regex" "$export_symbols" > "${export_symbols}T"'
libtool:	      func_show_eval '$MV "${export_symbols}T" "$export_symbols"'
libtool:          if ${skipped_export-false}; then
libtool:	    if test -n "$export_symbols" && test -n "$include_expsyms"; then
libtool:	      tmp_export_symbols="$export_symbols"
libtool:	      test -n "$orig_export_symbols" && tmp_export_symbols="$orig_export_symbols"
libtool:	      $opt_dry_run || eval '$ECHO "$include_expsyms" | $SP2NL >> "$tmp_export_symbols"'
libtool:	    if test -n "$orig_export_symbols"; then
libtool:	      # The given exports_symbols file has to be filtered, so filter it.
libtool:	      func_verbose "filter symbol list for \`$libname.la' to tag DATA exports"
libtool:	      $opt_dry_run || $SED -e '/[ ,]DATA/!d;s,\(.*\)\([ \,].*\),s|^\1$|\1\2|,' < $export_symbols > $output_objdir/$libname.filter
libtool:	      delfiles+=" $export_symbols $output_objdir/$libname.filter"
libtool:	      export_symbols=$output_objdir/$libname.def
libtool:	      $opt_dry_run || $SED -f $output_objdir/$libname.filter < $orig_export_symbols > $export_symbols
libtool:	  # Expand the library linking commands again to reset the
libtool:	    if test -n "$export_symbols" && test -n "$module_expsym_cmds"; then
libtool:	      cmds=$module_expsym_cmds
libtool:	    if test -n "$export_symbols" && test -n "$archive_expsym_cmds"; then
libtool:	      cmds=$archive_expsym_cmds
libtool:	  gentop="$output_objdir/${outputname}x"
libtool:	  func_extract_archives $gentop $dlprefiles
libtool:	  libobjs+=" $func_extract_archives_result"
libtool:	    func_quote_for_expand "$cmd"
libtool:	    eval "func_echo $func_quote_for_expand_result"
libtool:	    lt_exit=$?
libtool:	    # Restore the uninstalled library and exit
libtool:	    exit $lt_exit
libtool:	# Restore the uninstalled library and exit
libtool:	  $opt_dry_run || eval '(cd $output_objdir && $RM ${realname}T && $MV $realname ${realname}T && $MV ${realname}U $realname)' || exit $?
libtool:	  exit $EXIT_SUCCESS
libtool:	    func_show_eval '(cd "$output_objdir" && $RM "$linkname" && $LN_S "$realname" "$linkname")' 'exit $?'
libtool:	# If -module or -export-dynamic was specified, set the dlname.
libtool:	if test "$module" = yes || test "$export_dynamic" = yes; then
libtool:      test -n "$xrpath" && \
libtool:      # the extraction.
libtool:	  gentop="$output_objdir/${obj}x"
libtool:	  func_extract_archives $gentop $convenience
libtool:	  reload_conv_objs="$reload_objs $func_extract_archives_result"
libtool:      reload_objs="$objs$old_deplibs "`$ECHO "$libobjs" | $SP2NL | $SED "/\.${libext}$/d; /\.lib$/d; $lo2o" | $NL2SP`" $reload_conv_objs" ### testsuite: skip nested quoting test
libtool:      func_execute_cmds "$reload_cmds" 'exit $?'
libtool:      # Exit if we aren't doing a library object file.
libtool:	exit $EXIT_SUCCESS
libtool:	# $opt_dry_run || eval "echo timestamp > $libobj" || exit $?
libtool:	exit $EXIT_SUCCESS
libtool:	func_execute_cmds "$reload_cmds" 'exit $?'
libtool:      exit $EXIT_SUCCESS
libtool:	*cygwin*) func_stripname '' '.exe' "$output"
libtool:	          output=$func_stripname_result.exe;;
libtool:	# But is supposedly fixed on 10.4 or later (yay!).
libtool:      if test -n "$rpath$xrpath"; then
libtool:	for libdir in $rpath $xrpath; do
libtool:	func_execute_cmds "$prelink_cmds" 'exit $?'
libtool:	exit_status=0
libtool:	func_show_eval "$link_command" 'exit_status=$?'
libtool:	  func_execute_cmds "$postlink_cmds" 'exit $?'
libtool:	if test -f "$output_objdir/${outputname}S.${objext}"; then
libtool:	  func_show_eval '$RM "$output_objdir/${outputname}S.${objext}"'
libtool:	exit $exit_status
libtool:	# Link the executable and exit
libtool:	func_show_eval "$link_command" 'exit $?'
libtool:	  func_execute_cmds "$postlink_cmds" 'exit $?'
libtool:	exit $EXIT_SUCCESS
libtool:      func_show_eval "$link_command" 'exit $?'
libtool:	func_execute_cmds "$postlink_cmds" 'exit $?'
libtool:	    relink_command="{ test -z \"\${$var+set}\" || $lt_unset $var || { $var=; export $var; }; }; $relink_command"
libtool:	    relink_command="$var=; export $var; $relink_command"
libtool:	    relink_command="$var=$func_quote_for_eval_result; export $var; $relink_command"
libtool:	# a .exe suffix, so we strip it off here.
libtool:	  *.exe) func_stripname '' '.exe' "$output"
libtool:	# test for cygwin because mv fails w/o .exe extensions
libtool:	    exeext=.exe
libtool:	    func_stripname '' '.exe' "$outputname"
libtool:	  *) exeext= ;;
libtool:	    cwrapper="$output_path/$output_name.exe"
libtool:	    trap "$RM $cwrappersource $cwrapper; exit $EXIT_FAILURE" 1 2 15
libtool:	    func_emit_cwrapperexe_src > $cwrappersource
libtool:	    # The wrapper executable is built using the $host compiler,
libtool:	    # compiling, it, like the target executable, must be
libtool:	    # executed on the $host or under an emulation environment.
libtool:	    trap "$RM $func_ltwrapper_scriptname_result; exit $EXIT_FAILURE" 1 2 15
libtool:	      # note: this script will not be executed, so do not chmod.
libtool:	      if test "x$build" = "x$host" ; then
libtool:	    trap "$RM $output; exit $EXIT_FAILURE" 1 2 15
libtool:	    chmod +x $output
libtool:      exit $EXIT_SUCCESS
libtool:	gentop="$output_objdir/${outputname}x"
libtool:	func_extract_archives $gentop $addlibs
libtool:	oldobjs+=" $func_extract_archives_result"
libtool:	  gentop="$output_objdir/${outputname}x"
libtool:	  func_extract_archives $gentop $dlprefiles
libtool:	  oldobjs+=" $func_extract_archives_result"
libtool:	# might have to extract them afterwards, e.g., when creating a
libtool:	  gentop="$output_objdir/${outputname}x"
libtool:	if test "$len" -lt "$max_cmd_len" || test "$max_cmd_len" -le -1; then
libtool:	    if test "$len" -lt "$max_cmd_len"; then
libtool:      func_execute_cmds "$cmds" 'exit $?'
libtool:      test "$build_old_libs" = yes && old_library="$libname.$libext"
libtool:	  relink_command="{ test -z \"\${$var+set}\" || $lt_unset $var || { $var=; export $var; }; }; $relink_command"
libtool:	  relink_command="$var=; export $var; $relink_command"
libtool:	  relink_command="$var=$func_quote_for_eval_result; export $var; $relink_command"
libtool:      relink_command="(cd `pwd`; $SHELL $progpath $preserve_args --mode=relink $libtool_args @inst_prefix_dir@)"
libtool:	  # systems that can't hard-code library paths into their executables
libtool:	      if test "x$bindir" != x ;
libtool:      func_show_eval '( cd "$output_objdir" && $RM "$outputname" && $LN_S "../$outputname" "$outputname" )' 'exit $?'
libtool:    exit $EXIT_SUCCESS
libtool:    exit_status=0
libtool:      # Don't error if the file doesn't exist and rm -f was used.
libtool:	exit_status=1
libtool:	      func_execute_cmds "$postuninstall_cmds" 'test "$rmforce" = yes || exit_status=1'
libtool:	      func_execute_cmds "$old_postuninstall_cmds" 'test "$rmforce" = yes || exit_status=1'
libtool:	  noexename=$name
libtool:	  *.exe)
libtool:	    func_stripname '' '.exe' "$file"
libtool:	    func_stripname '' '.exe' "$name"
libtool:	    noexename=$func_stripname_result
libtool:	    # $file with .exe has already been added to rmfiles,
libtool:	    # add $file without .exe
libtool:	    if func_ltwrapper_executable_p "$file"; then
libtool:	      func_source $dir/$noexename
libtool:	    # note $name still contains .exe if it was in $file originally
libtool:	    rmfiles+=" $odir/$name $odir/${name}S.${objext}"
libtool:	    if test "X$noexename" != "X$name" ; then
libtool:	      rmfiles+=" $odir/lt-${noexename}.c"
libtool:      func_show_eval "$RM $rmfiles" 'exit_status=1'
libtool:    exit $exit_status
libtool:test -z "$exec_cmd" && \
libtool:if test -n "$exec_cmd"; then
libtool:  eval exec "$exec_cmd"
libtool:  exit $EXIT_FAILURE
libtool:exit $exit_status
LICENSE:   Simon-Pierre Cadieux
LICENSE:and Group 42, Inc. disclaim all warranties, expressed or implied,
LICENSE:assume no liability for direct, indirect, incidental, special, exemplary,
LICENSE:boxes and the like:
LICENSE:files "pngbar.png" and "pngbar.jpg (88x31) and "pngnow.png" (98x31).
ltmain.sh:# As a special exception to the GNU General Public License,
ltmain.sh:#       --features           display basic configuration information and exit
ltmain.sh:#       --no-verbose         don't print the extra informational messages
ltmain.sh:#         execute            automatically set library path, then run a program
ltmain.sh:#         install            install libraries or executables
ltmain.sh:#         link               create a library or an executable
ltmain.sh:  # Zsh 3.x and 4.x performs word splitting on ${1+"$@"}, which
ltmain.sh:  case `(set -o) 2>/dev/null` in *posix*) set -o posix;; esac
ltmain.sh:BIN_SH=xpg4; export BIN_SH # for Tru64
ltmain.sh:DUALCASE=1; export DUALCASE # for MKS sh
ltmain.sh:# NLS nuisances: We save the old values to restore during execute mode.
ltmain.sh:	  export $lt_var
ltmain.sh:export LANGUAGE LC_ALL
ltmain.sh:exit_status=$EXIT_SUCCESS
ltmain.sh:} # func_dirname may be replaced by extended shell implementation
ltmain.sh:} # func_basename may be replaced by extended shell implementation
ltmain.sh:    # Extract subdirectory from the argument.
ltmain.sh:} # func_dirname_and_basename may be replaced by extended shell implementation
ltmain.sh:# func_stripname prefix suffix name
ltmain.sh:# PREFIX and SUFFIX must not contain globbing or regex special
ltmain.sh:# func_strip_suffix prefix name
ltmain.sh:} # func_stripname may be replaced by extended shell implementation
ltmain.sh:    # The next three entries are used to spot a run of precisely
ltmain.sh:      # and for example Cygwin uses it to access remote file shares
ltmain.sh:    # check if we have found a prefix of bindir
ltmain.sh:        # found an exact match
ltmain.sh:        # found a matching prefix
ltmain.sh:        if test "x$func_relative_path_tlibdir" = x ; then
ltmain.sh:  if test "x$func_stripname_result" != x ; then
ltmain.sh:# Make sure we have an absolute path for reexecution:
ltmain.sh:       test -x "$progdir/$progname" && break
ltmain.sh:# Sed substitution that turns a string into a regex matching for the
ltmain.sh:sed_make_literal_regex='s,[].[^$\\*\/],\\&,g'
ltmain.sh:# Re-`\' parameter expansions in output of double_quote_subst that were
ltmain.sh:# in input to double_quote_subst, that '$' was protected from expansion.
ltmain.sh:# Echo program name prefixed message, along with the current mode
ltmain.sh:# Echo program name prefixed message in verbose mode only.
ltmain.sh:# Echo program name prefixed message to standard error.
ltmain.sh:# Echo program name prefixed warning message to standard error.
ltmain.sh:# Echo program name prefixed message to standard error, and exit.
ltmain.sh:    exit $EXIT_FAILURE
ltmain.sh:# Echo program name prefixed message to standard error, followed by
ltmain.sh:# a help hint, and exit.
ltmain.sh:# func_grep expression filename
ltmain.sh:      # While some portion of DIR does not yet exist...
ltmain.sh:        # mkdir can fail with a `File exist' error if two processes
ltmain.sh:      # expansion for a subsequent eval.
ltmain.sh:# func_quote_for_expand arg
ltmain.sh:func_quote_for_expand ()
ltmain.sh:    func_quote_for_expand_result="$my_arg"
ltmain.sh:# func_show_eval cmd [fail_exp]
ltmain.sh:    my_fail_exp="${2-:}"
ltmain.sh:      func_quote_for_expand "$my_cmd"
ltmain.sh:      eval "func_echo $func_quote_for_expand_result"
ltmain.sh:	eval "(exit $my_status); $my_fail_exp"
ltmain.sh:# func_show_eval_locale cmd [fail_exp]
ltmain.sh:    my_fail_exp="${2-:}"
ltmain.sh:      func_quote_for_expand "$my_cmd"
ltmain.sh:      eval "func_echo $func_quote_for_expand_result"
ltmain.sh:	eval "(exit $my_status); $my_fail_exp"
ltmain.sh:# Echo version message to standard output and exit.
ltmain.sh:     exit $?
ltmain.sh:# Echo short help message to standard output and exit.
ltmain.sh:    exit $?
ltmain.sh:# Echo long help message to standard output and exit,
ltmain.sh:# unless 'noexit' is passed as argument.
ltmain.sh:      exit $ret
ltmain.sh:# Echo program name prefixed message to standard error and set global
ltmain.sh:# exit_cmd.
ltmain.sh:    exit_cmd=exit
ltmain.sh:} # func_split_short_opt may be replaced by extended shell implementation
ltmain.sh:} # func_split_long_opt may be replaced by extended shell implementation
ltmain.sh:exit_cmd=:
ltmain.sh:magic_exe="%%%MAGIC EXE variable%%%"
ltmain.sh:lo2o="s/\\.lo\$/.${objext}/"
ltmain.sh:o2lo="s/\\.${objext}\$/.lo/"
ltmain.sh:extracted_archives=
ltmain.sh:extracted_serial=0
ltmain.sh:# will be execed at the end.  This prevents here-documents from being
ltmain.sh:exec_cmd=
ltmain.sh:} # func_append may be replaced by extended shell implementation
ltmain.sh:} # func_append_quoted may be replaced by extended shell implementation
ltmain.sh:    func_arith_result=`expr "${@}"`
ltmain.sh:} # func_arith may be replaced by extended shell implementation
ltmain.sh:    func_len_result=`expr "${1}" : ".*" 2>/dev/null || echo $max_cmd_len`
ltmain.sh:} # func_len may be replaced by extended shell implementation
ltmain.sh:} # func_lo2o may be replaced by extended shell implementation
ltmain.sh:# func_xform libobj-or-source
ltmain.sh:func_xform ()
ltmain.sh:    func_xform_result=`$ECHO "${1}" | $SED 's/\.[^.]*$/.lo/'`
ltmain.sh:} # func_xform may be replaced by extended shell implementation
ltmain.sh:# Echo program name prefixed message to standard error, followed by
ltmain.sh:# a configuration failure hint, and exit.
ltmain.sh:    exit $?
ltmain.sh:    exit $?
ltmain.sh:# Verify that TAGNAME is valid, and either flag an error and exit, or
ltmain.sh:  sed_extractcf="/$re_begincf/,/$re_endcf/p"
ltmain.sh:	extractedcf=`$SED -n -e "$sed_extractcf" < "$progpath"`
ltmain.sh:	eval "$extractedcf"
ltmain.sh:    exit $EXIT_MISMATCH
ltmain.sh:execute|execut|execu|exec|exe|ex|e)
ltmain.sh:  shift; set dummy --mode execute ${1+"$@"}; shift
ltmain.sh:  # this just eases exit handling
ltmain.sh:      --debug|-x)	opt_debug='set -x'
ltmain.sh:  clean|compile|execute|finish|install|link|relink|uninstall) ;;
ltmain.sh:     exit_cmd=exit
ltmain.sh:    eval std_shrext=\"$shrext_cmds\"
ltmain.sh:    # Only execute mode is allowed to have -dlopen flags.
ltmain.sh:    if test -n "$opt_dlopen" && test "$opt_mode" != execute; then
ltmain.sh:      exit $EXIT_FAILURE
ltmain.sh:  $exit_cmd $EXIT_FAILURE
ltmain.sh:# resorting to external programs.  To this end, it redirects stdin and
ltmain.sh:# fatal anyway.  Works if `file' does not exist.
ltmain.sh:    if test -f "$1" && test -r "$1" && exec 5<&0 <"$1"; then
ltmain.sh:	exec 0<&5 5<&-
ltmain.sh:# func_ltwrapper_executable_p file
ltmain.sh:# True iff FILE is a libtool wrapper executable
ltmain.sh:func_ltwrapper_executable_p ()
ltmain.sh:    func_ltwrapper_exec_suffix=
ltmain.sh:    *.exe) ;;
ltmain.sh:    *) func_ltwrapper_exec_suffix=.exe ;;
ltmain.sh:    $GREP "$magic_exe" "$1$func_ltwrapper_exec_suffix" >/dev/null 2>&1
ltmain.sh:# Assumes file is an ltwrapper_executable
ltmain.sh:    func_stripname '' '.exe' "$func_basename_result"
ltmain.sh:# True iff FILE is a libtool wrapper script or wrapper executable
ltmain.sh:    func_ltwrapper_script_p "$1" || func_ltwrapper_executable_p "$1"
ltmain.sh:# func_execute_cmds commands fail_cmd
ltmain.sh:# Execute tilde-delimited COMMANDS.
ltmain.sh:func_execute_cmds ()
ltmain.sh:# FILE even if both FILE and FILE.exe exist: automatic-append-.exe
ltmain.sh:# behavior happens only for exec(3), not for open(2)!  Also, sourcing
ltmain.sh:      CC_expanded=`func_echo_all $CC`
ltmain.sh:      CC_quoted_expanded=`func_echo_all $CC_quoted`
ltmain.sh:      " $CC "* | "$CC "* | " $CC_expanded "* | "$CC_expanded "* | \
ltmain.sh:      " $CC_quoted"* | "$CC_quoted "* | " $CC_quoted_expanded "* | "$CC_quoted_expanded "*) ;;
ltmain.sh:	    CC_expanded=`func_echo_all $CC`
ltmain.sh:	    CC_quoted_expanded=`func_echo_all $CC_quoted`
ltmain.sh:	    " $CC "* | "$CC "* | " $CC_expanded "* | "$CC_expanded "* | \
ltmain.sh:	    " $CC_quoted"* | "$CC_quoted "* | " $CC_quoted_expanded "* | "$CC_quoted_expanded "*)
ltmain.sh:# Helper function used by file name conversion functions when $build is *nix,
ltmain.sh:    # Unfortunately, winepath does not exit with a non-zero error code, so we
ltmain.sh:    # command is not found, the shell will set an exit code of 127 and print
ltmain.sh:    # zero AND non-empty stdout, which explains the odd construction:
ltmain.sh:# Helper function used by path conversion functions when $build is *nix, and
ltmain.sh:# when (1) $build is *nix and Cygwin is hosted via a wine environment; or (2)
ltmain.sh:# from $build's *nix or MSYS format). In case (3), returns the w32 file name
ltmain.sh:# Specify the absolute *nix (or w32) name to cygpath in the LT_CYGPATH
ltmain.sh:    func_error "LT_CYGPATH is empty or specifies non-existent file: \`$LT_CYGPATH'"
ltmain.sh:    func_error "Continuing, but uninstalled executables may not work."
ltmain.sh:    func_error "Continuing, but uninstalled executables may not work."
ltmain.sh:    if test "x$1" != "x$2"; then
ltmain.sh:# func_convert_file_nix_to_w32 ARG
ltmain.sh:# Convert file name ARG from *nix to w32 format.  Requires a wine environment
ltmain.sh:func_convert_file_nix_to_w32 ()
ltmain.sh:# end func_convert_file_nix_to_w32
ltmain.sh:# func_convert_file_nix_to_cygwin ARG
ltmain.sh:# Convert file name ARG from *nix to Cygwin format.  Requires Cygwin installed
ltmain.sh:func_convert_file_nix_to_cygwin ()
ltmain.sh:    # convert from *nix to w32, then use cygpath to convert from w32 to cygwin.
ltmain.sh:# end func_convert_file_nix_to_cygwin
ltmain.sh:# func_convert_path_nix_to_w32 ARG
ltmain.sh:# Convert path ARG from *nix to w32 format.  Requires a wine environment and
ltmain.sh:func_convert_path_nix_to_w32 ()
ltmain.sh:# end func_convert_path_nix_to_w32
ltmain.sh:# func_convert_path_nix_to_cygwin ARG
ltmain.sh:# Convert path ARG from *nix to Cygwin format.  Requires Cygwin installed in a
ltmain.sh:func_convert_path_nix_to_cygwin ()
ltmain.sh:# end func_convert_path_nix_to_cygwin
ltmain.sh:	  arg_mode=arg  #  the next one goes into the "base_compile" arg list
ltmain.sh:    # Recognize several different file suffixes.
ltmain.sh:    *.c++ | *.cc | *.ii | *.class | *.cpp | *.cxx | \
ltmain.sh:    *.[fF][09]? | *.for | *.java | *.go | *.obj | *.sx | *.cu | *.cup)
ltmain.sh:      func_xform "$libobj"
ltmain.sh:      libobj=$func_xform_result
ltmain.sh:    xdir="$func_dirname_result"
ltmain.sh:    lobj=${xdir}$objdir/$objname
ltmain.sh:      output_obj=`$ECHO "$srcfile" | $SED 's%^.*/%%; s%\.[^.]*$%%'`.${objext}
ltmain.sh:*** ERROR, $lockfile exists and contains:
ltmain.sh:	exit $EXIT_FAILURE
ltmain.sh:    trap '$opt_dry_run || $RM $removelist; exit $EXIT_FAILURE' 1 2 15
ltmain.sh:      func_mkdir_p "$xdir$objdir"
ltmain.sh:          'test -n "$output_obj" && $RM $removelist; exit $EXIT_FAILURE'
ltmain.sh:	exit $EXIT_FAILURE
ltmain.sh:      # Just move the object if needed, then go on to compile the next one
ltmain.sh:	  'error=$?; $opt_dry_run || $RM $removelist; exit $error'
ltmain.sh:        '$opt_dry_run || $RM $removelist; exit $EXIT_FAILURE'
ltmain.sh:	exit $EXIT_FAILURE
ltmain.sh:	  'error=$?; $opt_dry_run || $RM $removelist; exit $error'
ltmain.sh:    exit $EXIT_SUCCESS
ltmain.sh:        # Generic help is extracted from the usage comments
ltmain.sh:SOURCEFILE, then substituting the C source code suffix \`.c' with the
ltmain.sh:library object suffix, \`.lo'."
ltmain.sh:      execute)
ltmain.sh:"Usage: $progname [OPTION]... --mode=execute COMMAND [ARGS]...
ltmain.sh:If any of the ARGS are libtool executable wrappers, then they are translated
ltmain.sh:Then, COMMAND is executed, with ARGS as arguments."
ltmain.sh:The commands that this mode executes may require superuser privileges.  Use
ltmain.sh:the \`--dry-run' option if you just want to see what would be executed."
ltmain.sh:Install executables or libraries.
ltmain.sh:  -inst-prefix-dir PREFIX-DIR  Use PREFIX-DIR as a staging area for installation
ltmain.sh:create an executable program.
ltmain.sh:  -avoid-version    do not add a version suffix if possible
ltmain.sh:  -export-dynamic   allow symbols from OUTPUT-FILE to be resolved with dlsym(3)
ltmain.sh:  -export-symbols SYMFILE
ltmain.sh:                    try to export only the symbols listed in SYMFILE
ltmain.sh:  -export-symbols-regex REGEX
ltmain.sh:                    try to export only the symbols matching REGEX
ltmain.sh:  -no-install       link a not-installable executable
ltmain.sh:  -no-undefined     declare that a library does not refer to external symbols
ltmain.sh:  -precious-files-regex REGEX
ltmain.sh:  -shrext SUFFIX    override the standard shared library file extension
ltmain.sh:required, except when creating a convenience library.
ltmain.sh:If OUTPUT-FILE ends in \`.lo' or \`.${objext}', then a reloadable object file
ltmain.sh:is created, otherwise an executable program is created."
ltmain.sh:      func_help noexit
ltmain.sh:      for opt_mode in compile link execute install finish uninstall clean; do
ltmain.sh:      func_help noexit
ltmain.sh:      for opt_mode in compile link execute install finish uninstall clean; do
ltmain.sh:      $x
ltmain.sh:  exit $?
ltmain.sh:# func_mode_execute arg...
ltmain.sh:func_mode_execute ()
ltmain.sh:	    func_warning "\`$file' was not linked with \`-export-dynamic'"
ltmain.sh:    libtool_execute_magic="$magic"
ltmain.sh:	elif func_ltwrapper_executable_p "$file"; then
ltmain.sh:	# Export the shlibpath_var.
ltmain.sh:	eval "export $shlibpath_var"
ltmain.sh:                $lt_var=\$save_$lt_var; export $lt_var
ltmain.sh:      # Now prepare to actually exec the command.
ltmain.sh:      exec_cmd="\$cmd$args"
ltmain.sh:	echo "export $shlibpath_var"
ltmain.sh:      exit $EXIT_SUCCESS
ltmain.sh:test "$opt_mode" = execute && func_mode_execute ${1+"$@"}
ltmain.sh:        sysroot_regex=`$ECHO "$lt_sysroot" | $SED "$sed_make_literal_regex"`
ltmain.sh:        sysroot_cmd="s/\([ ']\)$sysroot_regex/\1/g;"
ltmain.sh:          echo "removing references to $lt_sysroot and \`=' prefixes from $lib"
ltmain.sh:	  func_execute_cmds "$finish_cmds" 'admincmds="$admincmds
ltmain.sh:    # Exit here if they wanted silent mode.
ltmain.sh:    $opt_silent && exit $EXIT_SUCCESS
ltmain.sh:	echo "     during execution"
ltmain.sh:    exit $EXIT_SUCCESS
ltmain.sh:	  if test "x$prev" = x-m && test -n "$install_override_mode"; then
ltmain.sh:      *.$libext)
ltmain.sh:	  # Determine the prefix the user has applied to our future dir.
ltmain.sh:	  inst_prefix_dir=`$ECHO "$destdir" | $SED -e "s%$libdir\$%%"`
ltmain.sh:	  # Don't allow the user to place us outside of our expected
ltmain.sh:	  # are installed to the same prefix.
ltmain.sh:	  test "$inst_prefix_dir" = "$destdir" && \
ltmain.sh:	  if test -n "$inst_prefix_dir"; then
ltmain.sh:	    # Stick the inst_prefix_dir data into the link command.
ltmain.sh:	    relink_command=`$ECHO "$relink_command" | $SED "s%@inst_prefix_dir@%-inst-prefix-dir $inst_prefix_dir%"`
ltmain.sh:	    relink_command=`$ECHO "$relink_command" | $SED "s%@inst_prefix_dir@%%"`
ltmain.sh:	      'exit $?'
ltmain.sh:	    func_show_eval "$striplib $destdir/$realname" 'exit $?'
ltmain.sh:	  func_execute_cmds "$postinstall_cmds" 'exit $?'
ltmain.sh:	func_show_eval "$install_prog $instname $destdir/$name" 'exit $?'
ltmain.sh:	*.$objext)
ltmain.sh:	  func_show_eval "$install_prog $file $destfile" 'exit $?'
ltmain.sh:	  func_show_eval "$install_prog \$staticobj \$staticdest" 'exit $?'
ltmain.sh:	exit $EXIT_SUCCESS
ltmain.sh:	# If the file is missing, and there is a .exe on the end, strip it
ltmain.sh:	stripped_ext=""
ltmain.sh:	  *.exe)
ltmain.sh:	      func_stripname '' '.exe' "$file"
ltmain.sh:	      stripped_ext=".exe"
ltmain.sh:	    if func_ltwrapper_executable_p "$file"; then
ltmain.sh:	      func_stripname '' '.exe' "$file"
ltmain.sh:		func_basename "$file$stripped_ext"
ltmain.sh:	          func_quote_for_expand "$relink_command"
ltmain.sh:		  eval "func_echo $func_quote_for_expand_result"
ltmain.sh:	    file=`$ECHO "$file$stripped_ext" | $SED "s%\([^/]*\)$%$objdir/\1%"`
ltmain.sh:	# remove .exe since cygwin /usr/bin/install will append another
ltmain.sh:	  *.exe:*.exe)
ltmain.sh:	  *.exe:*)
ltmain.sh:	    destfile=$destfile.exe
ltmain.sh:	  *:*.exe)
ltmain.sh:	    func_stripname '' '.exe' "$destfile"
ltmain.sh:	func_show_eval "$install_prog\$stripme \$file \$destfile" 'exit $?'
ltmain.sh:      func_show_eval "$install_prog \$file \$oldlib" 'exit $?'
ltmain.sh:	func_show_eval "$old_striplib $tool_oldlib" 'exit $?'
ltmain.sh:      func_execute_cmds "$old_postinstall_cmds" 'exit $?'
ltmain.sh:      exec_cmd='$SHELL $progpath $preserve_args --finish$current_libdirs'
ltmain.sh:      exit $EXIT_SUCCESS
ltmain.sh:# Extract symbols from dlprefiles and create ${outputname}S.o with
ltmain.sh:    my_prefix=`$ECHO "$my_originator" | sed 's%[^a-zA-Z0-9]%_%g'`
ltmain.sh:	func_error "not configured to extract global symbols from dlpreopened files"
ltmain.sh:extern \"C\" {
ltmain.sh:/* External symbol declarations for the compiler. */\
ltmain.sh:	    func_verbose "extracting global C symbols from \`$func_to_tool_file_result'"
ltmain.sh:	  if test -n "$exclude_expsyms"; then
ltmain.sh:	      eval '$EGREP -v " ($exclude_expsyms)$" "$nlist" > "$nlist"T'
ltmain.sh:	  if test -n "$export_symbols_regex"; then
ltmain.sh:	      eval '$EGREP -e "$export_symbols_regex" "$nlist" > "$nlist"T'
ltmain.sh:	  # Prepare the list of exported symbols
ltmain.sh:	  if test -z "$export_symbols"; then
ltmain.sh:	    export_symbols="$output_objdir/$outputname.exp"
ltmain.sh:	      $RM $export_symbols
ltmain.sh:	      eval "${SED} -n -e '/^: @PROGRAM@ $/d' -e 's/^.* \(.*\)$/\1/p' "'< "$nlist" > "$export_symbols"'
ltmain.sh:                eval 'cat "$export_symbols" >> "$output_objdir/$outputname.def"'
ltmain.sh:	      eval "${SED} -e 's/\([].[*^$]\)/\\\\\1/g' -e 's/^/ /' -e 's/$/$/'"' < "$export_symbols" > "$output_objdir/$outputname.exp"'
ltmain.sh:	      eval '$GREP -f "$output_objdir/$outputname.exp" < "$nlist" > "$nlist"T'
ltmain.sh:	  func_verbose "extracting global C symbols from \`$dlprefile'"
ltmain.sh:	            # no lafile. user explicitly requested -dlpreopen <import library>.
ltmain.sh:	  if test -n "$exclude_expsyms"; then
ltmain.sh:	    $EGREP -v " ($exclude_expsyms)$" "$nlist" > "$nlist"T
ltmain.sh:extern LT_DLSYM_CONST lt_dlsymlist
ltmain.sh:lt_${my_prefix}_LTX_preloaded_symbols[];
ltmain.sh:lt_${my_prefix}_LTX_preloaded_symbols[] =
ltmain.sh:	  case $need_lib_prefix in
ltmain.sh:	    eval "$global_symbol_to_c_name_address_lib_prefix" < "$nlist" >> "$output_objdir/$my_dlsyms"
ltmain.sh:  return lt_${my_prefix}_LTX_preloaded_symbols;
ltmain.sh:	  # pic_flag when linking with -static.  The problem exists in
ltmain.sh:	  # FreeBSD 2.2.6 and is fixed in FreeBSD 3.1.
ltmain.sh:	  *-*-hpux*)
ltmain.sh:	func_show_eval '(cd $output_objdir && $LTCC$symtab_cflags -c$no_builtin_flag$pic_flag_for_symtable "$my_dlsyms")' 'exit $?'
ltmain.sh:	symfileobj="$output_objdir/${my_outputname}S.$objext"
ltmain.sh:	func_fatal_error "unknown suffix for \`$my_dlsyms'"
ltmain.sh:    win32_libid_type="x86 archive import"
ltmain.sh:       $EGREP 'file format (pei*-i386(.*architecture: i386)?|pe-arm-wince|pe-x86-64)' >/dev/null; then
ltmain.sh:      win32_nmres=`eval $NM -f posix -A \"$func_to_tool_file_result\" |
ltmain.sh:      import*)  win32_libid_type="x86 archive import";;
ltmain.sh:      *)        win32_libid_type="x86 archive static";;
ltmain.sh:    win32_libid_type="x86 DLL"
ltmain.sh:  *executable*) # but shell scripts are "executable" too...
ltmain.sh:      win32_libid_type="x86 DLL"
ltmain.sh:# Platform-specific function to extract the
ltmain.sh:# platform-specific function to extract the name of the
ltmain.sh:  match_literal=`$ECHO "$1" | $SED "$sed_make_literal_regex"`
ltmain.sh:      # Join marker and all lines until next marker into a single line
ltmain.sh:      x
ltmain.sh:    # 0x302f exports -- but will fail for DLLs whose name actually
ltmain.sh:# Platform-specific function to extract the
ltmain.sh:# func_extract_an_archive dir oldlib
ltmain.sh:func_extract_an_archive ()
ltmain.sh:    f_ex_an_ar_dir="$1"; shift
ltmain.sh:    f_ex_an_ar_oldlib="$1"
ltmain.sh:    if test "$lock_old_archive_extraction" = yes; then
ltmain.sh:      lockfile=$f_ex_an_ar_oldlib.lock
ltmain.sh:    func_show_eval "(cd \$f_ex_an_ar_dir && $AR x \"\$f_ex_an_ar_oldlib\")" \
ltmain.sh:		   'stat=$?; rm -f "$lockfile"; exit $stat'
ltmain.sh:    if test "$lock_old_archive_extraction" = yes; then
ltmain.sh:    if ($AR t "$f_ex_an_ar_oldlib" | sort | sort -uc >/dev/null 2>&1); then
ltmain.sh:      func_fatal_error "object name conflicts in archive: $f_ex_an_ar_dir/$f_ex_an_ar_oldlib"
ltmain.sh:# func_extract_archives gentop oldlib ...
ltmain.sh:func_extract_archives ()
ltmain.sh:    my_xlib=""
ltmain.sh:    my_xabs=""
ltmain.sh:    my_xdir=""
ltmain.sh:    for my_xlib in $my_oldlibs; do
ltmain.sh:      # Extract the objects.
ltmain.sh:      case $my_xlib in
ltmain.sh:	[\\/]* | [A-Za-z]:[\\/]*) my_xabs="$my_xlib" ;;
ltmain.sh:	*) my_xabs=`pwd`"/$my_xlib" ;;
ltmain.sh:      func_basename "$my_xlib"
ltmain.sh:      my_xlib="$func_basename_result"
ltmain.sh:      my_xlib_u=$my_xlib
ltmain.sh:        case " $extracted_archives " in
ltmain.sh:	*" $my_xlib_u "*)
ltmain.sh:	  func_arith $extracted_serial + 1
ltmain.sh:	  extracted_serial=$func_arith_result
ltmain.sh:	  my_xlib_u=lt$extracted_serial-$my_xlib ;;
ltmain.sh:      extracted_archives="$extracted_archives $my_xlib_u"
ltmain.sh:      my_xdir="$my_gentop/$my_xlib_u"
ltmain.sh:      func_mkdir_p "$my_xdir"
ltmain.sh:	func_verbose "Extracting $my_xabs"
ltmain.sh:	  cd $my_xdir || exit $?
ltmain.sh:	  darwin_archive=$my_xabs
ltmain.sh:	      func_extract_an_archive "`pwd`" "${darwin_base_archive}"
ltmain.sh:	    func_extract_an_archive "$my_xdir" "$my_xabs"
ltmain.sh:        func_extract_an_archive "$my_xdir" "$my_xabs"
ltmain.sh:      my_oldobjs="$my_oldobjs "`find $my_xdir -name \*.$objext -print -o -name \*.lo -print | sort | $NL2SP`
ltmain.sh:    func_extract_archives_result="$my_oldobjs"
ltmain.sh:# wrapper executable.  Must ONLY be called from within
ltmain.sh:# The $output program cannot be directly executed until all the libtool
ltmain.sh:  # Zsh 3.x and 4.x performs word splitting on \${1+\"\$@\"}, which
ltmain.sh:  case \`(set -o) 2>/dev/null\` in *posix*) set -o posix;; esac
ltmain.sh:BIN_SH=xpg4; export BIN_SH # for Tru64
ltmain.sh:DUALCASE=1; export DUALCASE # for MKS sh
ltmain.sh:  # When we are sourced in execute mode, \$file and \$ECHO are already set.
ltmain.sh:  if test \"\$libtool_execute_magic\" != \"$magic\"; then
ltmain.sh:# /script/ and the wrapper /executable/ which is used only on
ltmain.sh:        exit 0
ltmain.sh:        exit 1
ltmain.sh:    lt_dump_args_N=\`expr \$lt_dump_args_N + 1\`
ltmain.sh:func_exec_program_core ()
ltmain.sh:      exec \"\$progdir\\\\\$program\" \${1+\"\$@\"}
ltmain.sh:      exec \"\$progdir/\$program\" \${1+\"\$@\"}
ltmain.sh:      \$ECHO \"\$0: cannot exec \$program \$*\" 1>&2
ltmain.sh:      exit 1
ltmain.sh:func_exec_program ()
ltmain.sh:      *) set x \"\$@\" \"\$lt_wr_arg\"; shift;;
ltmain.sh:  func_exec_program_core \${1+\"\$@\"}
ltmain.sh:  test \"x\$thisdir\" = \"x\$file\" && thisdir=.
ltmain.sh:    if test \"x\$destdir\" != \"x\$file\"; then
ltmain.sh:  # Usually 'no', except on cygwin/mingw when embedded into
ltmain.sh:  program=lt-'$outputname'$exeext
ltmain.sh:    # relink executable if necessary
ltmain.sh:	exit 1
ltmain.sh:	# fixup the dll searchpath if we need to.
ltmain.sh:	# Fix the DLL searchpath if we need to.  Do this before prepending
ltmain.sh:    # Add the dll search path components to the executable PATH
ltmain.sh:	# Export our shlibpath_var if we have one.
ltmain.sh:    export $shlibpath_var
ltmain.sh:    if test \"\$libtool_execute_magic\" != \"$magic\"; then
ltmain.sh:      func_exec_program \${1+\"\$@\"}
ltmain.sh:    # The program doesn't exist.
ltmain.sh:    \$ECHO \"\$0: error: \\\`\$progdir/\$program' does not exist\" 1>&2
ltmain.sh:    exit 1
ltmain.sh:# func_emit_cwrapperexe_src
ltmain.sh:# emit the source code for a wrapper executable on stdout
ltmain.sh:func_emit_cwrapperexe_src ()
ltmain.sh:/* $cwrappersource - temporary wrapper executable for $objdir/$outputname
ltmain.sh:   The $output program cannot be directly executed until all the libtool
ltmain.sh:   This wrapper executable should never be moved out of the build directory.
ltmain.sh:/* portability defines, excluding path handling macros */
ltmain.sh:#define XMALLOC(type, num)      ((type *) xmalloc ((num) * sizeof(type)))
ltmain.sh:const char *program_name = "libtool-wrapper"; /* in case xstrdup fails */
ltmain.sh:void *xmalloc (size_t num);
ltmain.sh:char *xstrdup (const char *string);
ltmain.sh:char *find_executable (const char *wrapper);
ltmain.sh:int make_executable (const char *path);
ltmain.sh:int check_executable (const char *path);
ltmain.sh:char *lt_extend_str (const char *orig_value, const char *add, int to_end);
ltmain.sh:void lt_update_exe_path (const char *name, const char *value);
ltmain.sh:volatile const char * MAGIC_EXE = "$magic_exe";
ltmain.sh:const char * TARGET_PROGRAM_NAME = "lt-$outputname"; /* hopefully, no .exe */
ltmain.sh:const char * TARGET_PROGRAM_NAME = "$outputname"; /* hopefully, no .exe */
ltmain.sh:static const char *ltwrapper_option_prefix = LTWRAPPER_OPTION_PREFIX;
ltmain.sh:  program_name = (char *) xstrdup (base_name (argv[0]));
ltmain.sh:   * also, copy all non cwrapper options to newargz, except
ltmain.sh:		# make stdout use "unix" line endings
ltmain.sh:      if (strcmp (argv[i], ltwrapper_option_prefix) == 0)
ltmain.sh:                    ltwrapper_option_prefix, argv[i]);
ltmain.sh:      newargz[++newargc] = xstrdup (argv[i]);
ltmain.sh:  tmp_pathspec = find_executable (argv[0]);
ltmain.sh:                  "(main) found exe (before symlink chase) at: %s\n",
ltmain.sh:                  "(main) found exe (after symlink chase) at: %s\n",
ltmain.sh:  actual_cwrapper_name = xstrdup (base_name (actual_cwrapper_path));
ltmain.sh:  strendzap (actual_cwrapper_name, ".exe");
ltmain.sh:  tmp_pathspec = lt_extend_str (actual_cwrapper_name, ".exe", 1);
ltmain.sh:  /* target_name transforms -- use actual target program name; might have lt- prefix */
ltmain.sh:  target_name = xstrdup (base_name (TARGET_PROGRAM_NAME));
ltmain.sh:  strendzap (target_name, ".exe");
ltmain.sh:  tmp_pathspec = lt_extend_str (target_name, ".exe", 1);
ltmain.sh:  tmp_pathspec = xstrdup (newargz[0]);
ltmain.sh:  /* do NOT want the lt- prefix here, so use actual_cwrapper_name */
ltmain.sh:  /* DO want the lt- prefix here if it exists, so use target_name */
ltmain.sh:  lt_argv_zero = lt_extend_str (tmp_pathspec, target_name, 1);
ltmain.sh:  lt_setenv ("BIN_SH", "xpg4"); /* for Tru64 */
ltmain.sh:  lt_update_exe_path (EXE_PATH_VARNAME, EXE_PATH_VALUE);
ltmain.sh:  /* execv doesn't actually work on mingw as expected on unix */
ltmain.sh:  execv (lt_argv_zero, newargz);
ltmain.sh:xmalloc (size_t num)
ltmain.sh:    lt_fatal (__FILE__, __LINE__, "memory exhausted");
ltmain.sh:xstrdup (const char *string)
ltmain.sh:  return string ? strcpy ((char *) xmalloc (strlen (string) + 1),
ltmain.sh:check_executable (const char *path)
ltmain.sh:  lt_debugprintf (__FILE__, __LINE__, "(check_executable): %s\n",
ltmain.sh:make_executable (const char *path)
ltmain.sh:  lt_debugprintf (__FILE__, __LINE__, "(make_executable): %s\n",
ltmain.sh:find_executable (const char *wrapper)
ltmain.sh:  const char *p_next;
ltmain.sh:  lt_debugprintf (__FILE__, __LINE__, "(find_executable): %s\n",
ltmain.sh:      concat_name = xstrdup (wrapper);
ltmain.sh:      if (check_executable (concat_name))
ltmain.sh:	  concat_name = xstrdup (wrapper);
ltmain.sh:	  if (check_executable (concat_name))
ltmain.sh:	  for (p = path; *p; p = p_next)
ltmain.sh:	      p_next = (*q == '\0' ? q : q + 1);
ltmain.sh:	      if (check_executable (concat_name))
ltmain.sh:  if (check_executable (concat_name))
ltmain.sh:  return xstrdup (pathspec);
ltmain.sh:  char *tmp_pathspec = xstrdup (pathspec);
ltmain.sh:      return xstrdup (pathspec);
ltmain.sh:  return xstrdup (tmp_pathspec);
ltmain.sh:lt_error_core (int exit_status, const char *file,
ltmain.sh:  if (exit_status >= 0)
ltmain.sh:    exit (exit_status);
ltmain.sh:    char *str = xstrdup (value);
ltmain.sh:lt_extend_str (const char *orig_value, const char *add, int to_end)
ltmain.sh:      new_value = xstrdup (add);
ltmain.sh:lt_update_exe_path (const char *name, const char *value)
ltmain.sh:		  "(lt_update_exe_path) modifying '%s' by prepending '%s'\n",
ltmain.sh:      char *new_value = lt_extend_str (getenv (name), value, 0);
ltmain.sh:      char *new_value = lt_extend_str (getenv (name), value, 0);
ltmain.sh:         GetVersionEx(&v);
ltmain.sh:      }) ? "cmd.exe" : "command.com").
ltmain.sh:	new_argv[i] = xstrdup ("\"\"");
ltmain.sh:# end: func_emit_cwrapperexe_src
ltmain.sh:      # which system we are compiling for in order to pass an extra
ltmain.sh:    inst_prefix_dir=
ltmain.sh:    export_dynamic=no
ltmain.sh:    export_symbols=
ltmain.sh:    export_symbols_regex=
ltmain.sh:    precious_files_regex=
ltmain.sh:    xrpath=
ltmain.sh:	      export_dynamic=yes
ltmain.sh:	      export_dynamic=yes
ltmain.sh:	expsyms)
ltmain.sh:	  export_symbols="$arg"
ltmain.sh:	    || func_fatal_error "symbol file \`$arg' does not exist"
ltmain.sh:	expsyms_regex)
ltmain.sh:	  export_symbols_regex="$arg"
ltmain.sh:		*) func_append deplibs " $qarg.ltframework" # this is fixed later
ltmain.sh:	inst_prefix)
ltmain.sh:	  inst_prefix_dir="$arg"
ltmain.sh:		# Extract subdirectory from the argument.
ltmain.sh:		xdir="$func_dirname_result"
ltmain.sh:		  pic_object="$xdir$pic_object"
ltmain.sh:		  non_pic_object="$xdir$non_pic_object"
ltmain.sh:		  # If the PIC object exists, use it instead.
ltmain.sh:		  # $xdir was prepended to $pic_object above.
ltmain.sh:		  # Extract subdirectory from the argument.
ltmain.sh:		  xdir="$func_dirname_result"
ltmain.sh:		  pic_object=$xdir$objdir/$func_lo2o_result
ltmain.sh:		  non_pic_object=$xdir$func_lo2o_result
ltmain.sh:	    func_fatal_error "link input file \`$arg' does not exist"
ltmain.sh:	precious_regex)
ltmain.sh:	  precious_files_regex="$arg"
ltmain.sh:	rpath | xrpath)
ltmain.sh:	    case "$xrpath " in
ltmain.sh:	    *) func_append xrpath " $arg" ;;
ltmain.sh:	shrext)
ltmain.sh:	  shrext_cmds="$arg"
ltmain.sh:	xcclinker)
ltmain.sh:	xcompiler)
ltmain.sh:	xlinker)
ltmain.sh:      -export-dynamic)
ltmain.sh:	export_dynamic=yes
ltmain.sh:      -export-symbols | -export-symbols-regex)
ltmain.sh:	if test -n "$export_symbols" || test -n "$export_symbols_regex"; then
ltmain.sh:	  func_fatal_error "more than one -exported-symbols argument is not allowed"
ltmain.sh:	if test "X$arg" = "X-export-symbols"; then
ltmain.sh:	  prev=expsyms
ltmain.sh:	  prev=expsyms_regex
ltmain.sh:      -inst-prefix-dir)
ltmain.sh:	prev=inst_prefix
ltmain.sh:	no/*-*-irix* | /*-*-irix*)
ltmain.sh:	  *-*-sysv4.2uw2* | *-*-sysv5* | *-*-unixware* | *-*-OpenUNIX*)
ltmain.sh:      # classes, name mangling, and exception handling.
ltmain.sh:	prev=xcompiler
ltmain.sh:      |-threads|-fopenmp|-openmp|-mp|-xopenmp|-omp|-qsmp=*)
ltmain.sh:      -precious-files-regex)
ltmain.sh:	prev=precious_regex
ltmain.sh:	prev=xrpath
ltmain.sh:	case "$xrpath " in
ltmain.sh:	*) func_append xrpath " $dir" ;;
ltmain.sh:      -shrext)
ltmain.sh:	prev=shrext
ltmain.sh:	# Digital Unix and AIX.
ltmain.sh:	prev=xcompiler
ltmain.sh:	prev=xlinker
ltmain.sh:	prev=xcclinker
ltmain.sh:      # -xarch=*, -xtarget=* enable 64-bit mode for the Sun compiler
ltmain.sh:      # -m*, -t[45]*, -txscale* architecture-specific flags for GCC
ltmain.sh:      -64|-mips[0-9]|-r[0-9][0-9]*|-xarch=*|-xtarget=*|+DA*|+DD*|-q*|-m*| \
ltmain.sh:      -t[45]*|-txscale*|-p|-pg|--coverage|-fprofile-*|-F*|@*|-tp=*|--sysroot=*| \
ltmain.sh:      *.$objext)
ltmain.sh:	  # Extract subdirectory from the argument.
ltmain.sh:	  xdir="$func_dirname_result"
ltmain.sh:	    pic_object="$xdir$pic_object"
ltmain.sh:	    non_pic_object="$xdir$non_pic_object"
ltmain.sh:	    # If the PIC object exists, use it instead.
ltmain.sh:	    # $xdir was prepended to $pic_object above.
ltmain.sh:	    # Extract subdirectory from the argument.
ltmain.sh:	    xdir="$func_dirname_result"
ltmain.sh:	    pic_object=$xdir$objdir/$func_lo2o_result
ltmain.sh:	    non_pic_object=$xdir$func_lo2o_result
ltmain.sh:      *.$libext)
ltmain.sh:    if test "$export_dynamic" = yes && test -n "$export_dynamic_flag_spec"; then
ltmain.sh:      eval arg=\"$export_dynamic_flag_spec\"
ltmain.sh:    *.$libext) linkmode=oldlib ;;
ltmain.sh:    *.lo | *.$objext) linkmode=obj ;;
ltmain.sh:	##        order, and fix it there properly
ltmain.sh:	  # Collect preopened libtool deplibs, except any this library
ltmain.sh:        |-threads|-fopenmp|-openmp|-mp|-xopenmp|-omp|-qsmp=*)
ltmain.sh:	    for search_ext in .la $std_shrext .so .a; do
ltmain.sh:	      lib="$searchdir/lib${name}${search_ext}"
ltmain.sh:		if test "$search_ext" = ".la"; then
ltmain.sh:	    # Make sure the xrpath contains only unique directories.
ltmain.sh:	    case "$xrpath " in
ltmain.sh:	    *) func_append xrpath " $dir" ;;
ltmain.sh:	*.$libext)
ltmain.sh:		  match_pattern_regex=`expr "$deplibs_check_method" : "$1 \(.*\)"`
ltmain.sh:		    | $EGREP "$match_pattern_regex" > /dev/null; then
ltmain.sh:		echo "*** because the file extensions .$libext of this argument makes me believe"
ltmain.sh:	  ;; # *.$libext
ltmain.sh:	*.lo | *.$objext)
ltmain.sh:	      # static and shared are present.  Therefore, ensure we extract
ltmain.sh:	      # name in a special purpose variable, and (later) extracting the
ltmain.sh:	      $ECHO "*** Warning: Linking the executable $output against the loadable module"
ltmain.sh:	  if test -n "$old_archive_from_expsyms_cmds"; then
ltmain.sh:		versuffix="-$major"
ltmain.sh:	    # Make a new name for the extract_expsyms_cmds to use
ltmain.sh:	    # If the library has no export list, then create one now
ltmain.sh:	      func_verbose "extracting exported symbol list from \`$soname'"
ltmain.sh:	      func_execute_cmds "$extract_expsyms_cmds" 'exit $?'
ltmain.sh:	      func_execute_cmds "$old_archive_from_expsyms_cmds" 'exit $?'
ltmain.sh:	  fi # test -n "$old_archive_from_expsyms_cmds"
ltmain.sh:		  *-*-sysv5OpenUNIX* | *-*-sysv5UnixWare7.[01].[10]* | \
ltmain.sh:		    *-*-unixware7*) add_dir="-L$dir" ;;
ltmain.sh:		if test -n "$inst_prefix_dir"; then
ltmain.sh:		      func_append add_dir " -L$inst_prefix_dir$libdir"
ltmain.sh:	      if test -n "$inst_prefix_dir" &&
ltmain.sh:		 test -f "$inst_prefix_dir$libdir/$linklib" ; then
ltmain.sh:		add="$inst_prefix_dir$libdir/$linklib"
ltmain.sh:	      if test -n "$inst_prefix_dir"; then
ltmain.sh:		    func_append add_dir " -L$inst_prefix_dir$libdir"
ltmain.sh:		echo "*** However, this would only work if libtool was able to extract symbol"
ltmain.sh:	    # Extract -R from dependency_libs
ltmain.sh:	           temp_xrpath=$func_stripname_result
ltmain.sh:		   case " $xrpath " in
ltmain.sh:		   *" $temp_xrpath "*) ;;
ltmain.sh:		   *) func_append xrpath " $temp_xrpath";;
ltmain.sh:		      darwin_install_name=`${OTOOL} -L $depdepl | awk '{if (NR == 2) {print $1;exit}}'`
ltmain.sh:                          darwin_install_name=`${OTOOL64} -L $depdepl  | awk '{if (NR == 2) {print $1;exit}}'`
ltmain.sh:	      # than once as an explicit dependence of a library, or
ltmain.sh:      test -n "$xrpath" && \
ltmain.sh:      test -n "$export_symbols$export_symbols_regex" && \
ltmain.sh:	func_warning "\`-export-symbols' is ignored for archives"
ltmain.sh:	eval shared_ext=\"$shrext_cmds\"
ltmain.sh:	if test "$need_lib_prefix" != no; then
ltmain.sh:	  # Add the "lib" prefix for modules if required
ltmain.sh:	  eval shared_ext=\"$shrext_cmds\"
ltmain.sh:	  # Some compilers have problems with a `.al' extension so
ltmain.sh:	  # convenience libraries should have the same extension an
ltmain.sh:	  oldlibs="$output_objdir/$libname.$libext $oldlibs"
ltmain.sh:	  # a minor version.  But, then there is irix
ltmain.sh:	  # which has an extra 1 added just for fun
ltmain.sh:	  # correct linux to gnu/linux during the next big refactor
ltmain.sh:	  darwin|linux|osf|windows|none)
ltmain.sh:	  freebsd-aout|freebsd-elf|qnx|sunos)
ltmain.sh:	  irix|nonstopux)
ltmain.sh:	    lt_irix_increment=no
ltmain.sh:	versuffix=
ltmain.sh:	  # Like Linux, but with the current version available in
ltmain.sh:	  versuffix="$major.$age.$revision"
ltmain.sh:	  xlcverstring="${wl}-compatibility_version ${wl}$minor_current ${wl}-current_version ${wl}$minor_current.$revision"
ltmain.sh:	  versuffix=".$current.$revision";
ltmain.sh:	  versuffix=".$current"
ltmain.sh:	irix | nonstopux)
ltmain.sh:	  if test "X$lt_irix_increment" = "Xno"; then
ltmain.sh:	    nonstopux) verstring_prefix=nonstopux ;;
ltmain.sh:	    *)         verstring_prefix=sgi ;;
ltmain.sh:	  verstring="$verstring_prefix$major.$revision"
ltmain.sh:	    verstring="$verstring_prefix$major.$iface:$verstring"
ltmain.sh:	  versuffix="$major.$revision"
ltmain.sh:	linux) # correct to gnu/linux during the next big refactor
ltmain.sh:	  versuffix="$major.$age.$revision"
ltmain.sh:	  versuffix=".$current.$age.$revision"
ltmain.sh:	  # Make executables depend on our current version.
ltmain.sh:	qnx)
ltmain.sh:	  versuffix=".$current"
ltmain.sh:	  versuffix=".$current.$revision"
ltmain.sh:	  # extension on DOS 8.3 filesystems.
ltmain.sh:	  versuffix="-$major"
ltmain.sh:	    versuffix=
ltmain.sh:	    versuffix=".0.0"
ltmain.sh:	  versuffix=
ltmain.sh:	    *.$objext | *.gcno)
ltmain.sh:	       if test "X$precious_files_regex" != "X"; then
ltmain.sh:		 if $ECHO "$p" | $EGREP -e "$precious_files_regex" >/dev/null 2>&1
ltmain.sh:	func_append oldlibs " $output_objdir/$libname.$libext"
ltmain.sh:	oldobjs="$objs "`$ECHO "$libobjs" | $SP2NL | $SED "/\.${libext}$/d; $lo2o" | $NL2SP`
ltmain.sh:      if test -n "$xrpath"; then
ltmain.sh:	temp_xrpath=
ltmain.sh:	for libdir in $xrpath; do
ltmain.sh:	  func_append temp_xrpath " -R$func_replace_sysroot_result"
ltmain.sh:	  dependency_libs="$temp_xrpath $dependency_libs"
ltmain.sh:	    # Don't link with libc until the a.out ld.so is fixed.
ltmain.sh:	  *-*-sysv4.2uw2* | *-*-sysv5* | *-*-unixware* | *-*-OpenUNIX*)
ltmain.sh:	versuffix_save=$versuffix
ltmain.sh:	versuffix=""
ltmain.sh:	  # whether the library exists or not.  But this is on
ltmain.sh:	  # against the deplibs as a proxy for the library.  Then we can check
ltmain.sh:		  if test `expr "$ldd_output" : ".*$deplib_match"` -ne 0 ; then
ltmain.sh:		    if test `expr "$ldd_output" : ".*$deplib_match"` -ne 0 ; then
ltmain.sh:	  file_magic_regex=`expr "$deplibs_check_method" : "$1 \(.*\)"`
ltmain.sh:			 $EGREP "$file_magic_regex" > /dev/null; then
ltmain.sh:	  match_pattern_regex=`expr "$deplibs_check_method" : "$1 \(.*\)"`
ltmain.sh:		       $EGREP "$match_pattern_regex" > /dev/null; then
ltmain.sh:		  $ECHO "*** with $libname but no candidates were found. (...for regex pattern test)"
ltmain.sh:		  $ECHO "*** using a regex pattern. Last file checked: $potlib"
ltmain.sh:	versuffix=$versuffix_save
ltmain.sh:	      echo "*** However, this would only work if libtool was able to extract symbol"
ltmain.sh:	      oldlibs="$output_objdir/$libname.$libext"
ltmain.sh:	      echo "*** it was explicitly requested with -no-undefined,"
ltmain.sh:		oldlibs="$output_objdir/$libname.$libext"
ltmain.sh:	    eval "$runpath_var='$rpath\$$runpath_var'; export $runpath_var"
ltmain.sh:	  eval "$shlibpath_var='$shlibpath\$$shlibpath_var'; export $shlibpath_var"
ltmain.sh:	eval shared_ext=\"$shrext_cmds\"
ltmain.sh:	if test -n "$export_symbols" && test -n "$include_expsyms"; then
ltmain.sh:	  $opt_dry_run || cp "$export_symbols" "$output_objdir/$libname.uexp"
ltmain.sh:	  export_symbols="$output_objdir/$libname.uexp"
ltmain.sh:	  func_append delfiles " $export_symbols"
ltmain.sh:	orig_export_symbols=
ltmain.sh:	  if test -n "$export_symbols" && test -z "$export_symbols_regex"; then
ltmain.sh:	    # exporting using user supplied symfile
ltmain.sh:	    if test "x`$SED 1q $export_symbols`" != xEXPORTS; then
ltmain.sh:	      # them as such. So, trigger use of export_symbols_cmds.
ltmain.sh:	      # export_symbols gets reassigned inside the "prepare
ltmain.sh:	      # the list of exported symbols" if statement, so the
ltmain.sh:	      # include_expsyms logic still works.
ltmain.sh:	      orig_export_symbols="$export_symbols"
ltmain.sh:	      export_symbols=
ltmain.sh:	      always_export_symbols=yes
ltmain.sh:	# Prepare the list of exported symbols
ltmain.sh:	if test -z "$export_symbols"; then
ltmain.sh:	  if test "$always_export_symbols" = yes || test -n "$export_symbols_regex"; then
ltmain.sh:	    export_symbols="$output_objdir/$libname.exp"
ltmain.sh:	    $opt_dry_run || $RM $export_symbols
ltmain.sh:	    cmds=$export_symbols_cmds
ltmain.sh:		 && { test "$len" -lt "$max_cmd_len" \
ltmain.sh:		      || test "$max_cmd_len" -le -1; }
ltmain.sh:		func_show_eval "$cmd" 'exit $?'
ltmain.sh:		skipped_export=false
ltmain.sh:		func_show_eval "$cmd" 'exit $?'
ltmain.sh:		skipped_export=false
ltmain.sh:		# The command line is too long to execute in one step.
ltmain.sh:		func_verbose "using reloadable object file for export list..."
ltmain.sh:		skipped_export=:
ltmain.sh:		# Break out early, otherwise skipped_export may be
ltmain.sh:	    if test -n "$export_symbols_regex" && test "X$skipped_export" != "X:"; then
ltmain.sh:	      func_show_eval '$EGREP -e "$export_symbols_regex" "$export_symbols" > "${export_symbols}T"'
ltmain.sh:	      func_show_eval '$MV "${export_symbols}T" "$export_symbols"'
ltmain.sh:	if test -n "$export_symbols" && test -n "$include_expsyms"; then
ltmain.sh:	  tmp_export_symbols="$export_symbols"
ltmain.sh:	  test -n "$orig_export_symbols" && tmp_export_symbols="$orig_export_symbols"
ltmain.sh:	  $opt_dry_run || eval '$ECHO "$include_expsyms" | $SP2NL >> "$tmp_export_symbols"'
ltmain.sh:	if test "X$skipped_export" != "X:" && test -n "$orig_export_symbols"; then
ltmain.sh:	  # The given exports_symbols file has to be filtered, so filter it.
ltmain.sh:	  func_verbose "filter symbol list for \`$libname.la' to tag DATA exports"
ltmain.sh:	  $opt_dry_run || $SED -e '/[ ,]DATA/!d;s,\(.*\)\([ \,].*\),s|^\1$|\1\2|,' < $export_symbols > $output_objdir/$libname.filter
ltmain.sh:	  func_append delfiles " $export_symbols $output_objdir/$libname.filter"
ltmain.sh:	  export_symbols=$output_objdir/$libname.def
ltmain.sh:	  $opt_dry_run || $SED -f $output_objdir/$libname.filter < $orig_export_symbols > $export_symbols
ltmain.sh:	    # extract the archives, so we have objects to list.
ltmain.sh:	    # TODO: could optimize this to just extract one archive.
ltmain.sh:	    gentop="$output_objdir/${outputname}x"
ltmain.sh:	    func_extract_archives $gentop $convenience
ltmain.sh:	    func_append libobjs " $func_extract_archives_result"
ltmain.sh:	  $opt_dry_run || eval '(cd $output_objdir && $RM ${realname}U && $MV $realname ${realname}U)' || exit $?
ltmain.sh:	  if test -n "$export_symbols" && test -n "$module_expsym_cmds"; then
ltmain.sh:	    eval test_cmds=\"$module_expsym_cmds\"
ltmain.sh:	    cmds=$module_expsym_cmds
ltmain.sh:	  if test -n "$export_symbols" && test -n "$archive_expsym_cmds"; then
ltmain.sh:	    eval test_cmds=\"$archive_expsym_cmds\"
ltmain.sh:	    cmds=$archive_expsym_cmds
ltmain.sh:	if test "X$skipped_export" != "X:" &&
ltmain.sh:	   test "$len" -lt "$max_cmd_len" || test "$max_cmd_len" -le -1; then
ltmain.sh:	  # or, if using GNU ld and skipped_export is not :, use a linker
ltmain.sh:	  # whole_archive_flag_spec was expanded, because we can't
ltmain.sh:	  # convenience libraries get linked in and end up exceeding
ltmain.sh:	  if test -n "$save_libobjs" && test "X$skipped_export" != "X:" && test "$with_gnu_ld" = yes; then
ltmain.sh:	  elif test -n "$save_libobjs" && test "X$skipped_export" != "X:" && test "X$file_list_spec" != X; then
ltmain.sh:	    set x $save_libobjs
ltmain.sh:	      output=$output_objdir/$output_la-${k}.$objext
ltmain.sh:		   test "$len" -lt "$max_cmd_len"; then
ltmain.sh:		  last_robj=$output_objdir/$output_la-${k}.$objext
ltmain.sh:		  output=$output_objdir/$output_la-${k}.$objext
ltmain.sh:	    if ${skipped_export-false}; then
ltmain.sh:	      export_symbols="$output_objdir/$libname.exp"
ltmain.sh:	      $opt_dry_run || $RM $export_symbols
ltmain.sh:	      # Append the command to create the export file.
ltmain.sh:	      eval concat_cmds=\"\$concat_cmds$export_symbols_cmds\"
ltmain.sh:	    # Loop through the commands generated above and execute them.
ltmain.sh:		  func_quote_for_expand "$cmd"
ltmain.sh:		  eval "func_echo $func_quote_for_expand_result"
ltmain.sh:		lt_exit=$?
ltmain.sh:		# Restore the uninstalled library and exit
ltmain.sh:		exit $lt_exit
ltmain.sh:	    if test -n "$export_symbols_regex" && ${skipped_export-false}; then
ltmain.sh:	      func_show_eval '$EGREP -e "$export_symbols_regex" "$export_symbols" > "${export_symbols}T"'
ltmain.sh:	      func_show_eval '$MV "${export_symbols}T" "$export_symbols"'
ltmain.sh:          if ${skipped_export-false}; then
ltmain.sh:	    if test -n "$export_symbols" && test -n "$include_expsyms"; then
ltmain.sh:	      tmp_export_symbols="$export_symbols"
ltmain.sh:	      test -n "$orig_export_symbols" && tmp_export_symbols="$orig_export_symbols"
ltmain.sh:	      $opt_dry_run || eval '$ECHO "$include_expsyms" | $SP2NL >> "$tmp_export_symbols"'
ltmain.sh:	    if test -n "$orig_export_symbols"; then
ltmain.sh:	      # The given exports_symbols file has to be filtered, so filter it.
ltmain.sh:	      func_verbose "filter symbol list for \`$libname.la' to tag DATA exports"
ltmain.sh:	      $opt_dry_run || $SED -e '/[ ,]DATA/!d;s,\(.*\)\([ \,].*\),s|^\1$|\1\2|,' < $export_symbols > $output_objdir/$libname.filter
ltmain.sh:	      func_append delfiles " $export_symbols $output_objdir/$libname.filter"
ltmain.sh:	      export_symbols=$output_objdir/$libname.def
ltmain.sh:	      $opt_dry_run || $SED -f $output_objdir/$libname.filter < $orig_export_symbols > $export_symbols
ltmain.sh:	  # Expand the library linking commands again to reset the
ltmain.sh:	    if test -n "$export_symbols" && test -n "$module_expsym_cmds"; then
ltmain.sh:	      cmds=$module_expsym_cmds
ltmain.sh:	    if test -n "$export_symbols" && test -n "$archive_expsym_cmds"; then
ltmain.sh:	      cmds=$archive_expsym_cmds
ltmain.sh:	  gentop="$output_objdir/${outputname}x"
ltmain.sh:	  func_extract_archives $gentop $dlprefiles
ltmain.sh:	  func_append libobjs " $func_extract_archives_result"
ltmain.sh:	    func_quote_for_expand "$cmd"
ltmain.sh:	    eval "func_echo $func_quote_for_expand_result"
ltmain.sh:	    lt_exit=$?
ltmain.sh:	    # Restore the uninstalled library and exit
ltmain.sh:	    exit $lt_exit
ltmain.sh:	# Restore the uninstalled library and exit
ltmain.sh:	  $opt_dry_run || eval '(cd $output_objdir && $RM ${realname}T && $MV $realname ${realname}T && $MV ${realname}U $realname)' || exit $?
ltmain.sh:	  exit $EXIT_SUCCESS
ltmain.sh:	    func_show_eval '(cd "$output_objdir" && $RM "$linkname" && $LN_S "$realname" "$linkname")' 'exit $?'
ltmain.sh:	# If -module or -export-dynamic was specified, set the dlname.
ltmain.sh:	if test "$module" = yes || test "$export_dynamic" = yes; then
ltmain.sh:      test -n "$xrpath" && \
ltmain.sh:      # the extraction.
ltmain.sh:	  gentop="$output_objdir/${obj}x"
ltmain.sh:	  func_extract_archives $gentop $convenience
ltmain.sh:	  reload_conv_objs="$reload_objs $func_extract_archives_result"
ltmain.sh:      reload_objs="$objs$old_deplibs "`$ECHO "$libobjs" | $SP2NL | $SED "/\.${libext}$/d; /\.lib$/d; $lo2o" | $NL2SP`" $reload_conv_objs" ### testsuite: skip nested quoting test
ltmain.sh:      func_execute_cmds "$reload_cmds" 'exit $?'
ltmain.sh:      # Exit if we aren't doing a library object file.
ltmain.sh:	exit $EXIT_SUCCESS
ltmain.sh:	# $opt_dry_run || eval "echo timestamp > $libobj" || exit $?
ltmain.sh:	exit $EXIT_SUCCESS
ltmain.sh:	func_execute_cmds "$reload_cmds" 'exit $?'
ltmain.sh:      exit $EXIT_SUCCESS
ltmain.sh:	*cygwin*) func_stripname '' '.exe' "$output"
ltmain.sh:	          output=$func_stripname_result.exe;;
ltmain.sh:	# But is supposedly fixed on 10.4 or later (yay!).
ltmain.sh:      if test -n "$rpath$xrpath"; then
ltmain.sh:	for libdir in $rpath $xrpath; do
ltmain.sh:	func_execute_cmds "$prelink_cmds" 'exit $?'
ltmain.sh:	exit_status=0
ltmain.sh:	func_show_eval "$link_command" 'exit_status=$?'
ltmain.sh:	  func_execute_cmds "$postlink_cmds" 'exit $?'
ltmain.sh:	if test -f "$output_objdir/${outputname}S.${objext}"; then
ltmain.sh:	  func_show_eval '$RM "$output_objdir/${outputname}S.${objext}"'
ltmain.sh:	exit $exit_status
ltmain.sh:	# Link the executable and exit
ltmain.sh:	func_show_eval "$link_command" 'exit $?'
ltmain.sh:	  func_execute_cmds "$postlink_cmds" 'exit $?'
ltmain.sh:	exit $EXIT_SUCCESS
ltmain.sh:      func_show_eval "$link_command" 'exit $?'
ltmain.sh:	func_execute_cmds "$postlink_cmds" 'exit $?'
ltmain.sh:	    relink_command="{ test -z \"\${$var+set}\" || $lt_unset $var || { $var=; export $var; }; }; $relink_command"
ltmain.sh:	    relink_command="$var=; export $var; $relink_command"
ltmain.sh:	    relink_command="$var=$func_quote_for_eval_result; export $var; $relink_command"
ltmain.sh:	# a .exe suffix, so we strip it off here.
ltmain.sh:	  *.exe) func_stripname '' '.exe' "$output"
ltmain.sh:	# test for cygwin because mv fails w/o .exe extensions
ltmain.sh:	    exeext=.exe
ltmain.sh:	    func_stripname '' '.exe' "$outputname"
ltmain.sh:	  *) exeext= ;;
ltmain.sh:	    cwrapper="$output_path/$output_name.exe"
ltmain.sh:	    trap "$RM $cwrappersource $cwrapper; exit $EXIT_FAILURE" 1 2 15
ltmain.sh:	    func_emit_cwrapperexe_src > $cwrappersource
ltmain.sh:	    # The wrapper executable is built using the $host compiler,
ltmain.sh:	    # compiling, it, like the target executable, must be
ltmain.sh:	    # executed on the $host or under an emulation environment.
ltmain.sh:	    trap "$RM $func_ltwrapper_scriptname_result; exit $EXIT_FAILURE" 1 2 15
ltmain.sh:	      # note: this script will not be executed, so do not chmod.
ltmain.sh:	      if test "x$build" = "x$host" ; then
ltmain.sh:	    trap "$RM $output; exit $EXIT_FAILURE" 1 2 15
ltmain.sh:	    chmod +x $output
ltmain.sh:      exit $EXIT_SUCCESS
ltmain.sh:	gentop="$output_objdir/${outputname}x"
ltmain.sh:	func_extract_archives $gentop $addlibs
ltmain.sh:	func_append oldobjs " $func_extract_archives_result"
ltmain.sh:	  gentop="$output_objdir/${outputname}x"
ltmain.sh:	  func_extract_archives $gentop $dlprefiles
ltmain.sh:	  func_append oldobjs " $func_extract_archives_result"
ltmain.sh:	# might have to extract them afterwards, e.g., when creating a
ltmain.sh:	  gentop="$output_objdir/${outputname}x"
ltmain.sh:	if test "$len" -lt "$max_cmd_len" || test "$max_cmd_len" -le -1; then
ltmain.sh:	    if test "$len" -lt "$max_cmd_len"; then
ltmain.sh:      func_execute_cmds "$cmds" 'exit $?'
ltmain.sh:      test "$build_old_libs" = yes && old_library="$libname.$libext"
ltmain.sh:	  relink_command="{ test -z \"\${$var+set}\" || $lt_unset $var || { $var=; export $var; }; }; $relink_command"
ltmain.sh:	  relink_command="$var=; export $var; $relink_command"
ltmain.sh:	  relink_command="$var=$func_quote_for_eval_result; export $var; $relink_command"
ltmain.sh:      relink_command="(cd `pwd`; $SHELL $progpath $preserve_args --mode=relink $libtool_args @inst_prefix_dir@)"
ltmain.sh:	  # systems that can't hard-code library paths into their executables
ltmain.sh:	      if test "x$bindir" != x ;
ltmain.sh:      func_show_eval '( cd "$output_objdir" && $RM "$outputname" && $LN_S "../$outputname" "$outputname" )' 'exit $?'
ltmain.sh:    exit $EXIT_SUCCESS
ltmain.sh:    exit_status=0
ltmain.sh:      # Don't error if the file doesn't exist and rm -f was used.
ltmain.sh:	exit_status=1
ltmain.sh:	      func_execute_cmds "$postuninstall_cmds" 'test "$rmforce" = yes || exit_status=1'
ltmain.sh:	      func_execute_cmds "$old_postuninstall_cmds" 'test "$rmforce" = yes || exit_status=1'
ltmain.sh:	  noexename=$name
ltmain.sh:	  *.exe)
ltmain.sh:	    func_stripname '' '.exe' "$file"
ltmain.sh:	    func_stripname '' '.exe' "$name"
ltmain.sh:	    noexename=$func_stripname_result
ltmain.sh:	    # $file with .exe has already been added to rmfiles,
ltmain.sh:	    # add $file without .exe
ltmain.sh:	    if func_ltwrapper_executable_p "$file"; then
ltmain.sh:	      func_source $dir/$noexename
ltmain.sh:	    # note $name still contains .exe if it was in $file originally
ltmain.sh:	    func_append rmfiles " $odir/$name $odir/${name}S.${objext}"
ltmain.sh:	    if test "X$noexename" != "X$name" ; then
ltmain.sh:	      func_append rmfiles " $odir/lt-${noexename}.c"
ltmain.sh:      func_show_eval "$RM $rmfiles" 'exit_status=1'
ltmain.sh:    exit $exit_status
ltmain.sh:test -z "$exec_cmd" && \
ltmain.sh:if test -n "$exec_cmd"; then
ltmain.sh:  eval exec "$exec_cmd"
ltmain.sh:  exit $EXIT_FAILURE
ltmain.sh:exit $exit_status
Makefile:# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
Makefile:         exit 1;; \
Makefile:  skip_next=no; \
Makefile:    test $$skip_next = yes && { skip_next=no; continue; }; \
Makefile:        -*I) strip_trailopt 'I'; skip_next=yes;; \
Makefile:        -*O) strip_trailopt 'O'; skip_next=yes;; \
Makefile:        -*l) strip_trailopt 'l'; skip_next=yes;; \
Makefile:      -[dEDm]) skip_next=yes;; \
Makefile:      -[JT]) skip_next=yes;; \
Makefile:pkglibexecdir = $(libexecdir)/libpng
Makefile:build_triplet = x86_64-apple-darwin13.4.0
Makefile:host_triplet = x86_64-apple-darwin13.4.0
Makefile:bin_PROGRAMS = pngfix$(EXEEXT) png-fix-itxt$(EXEEXT)
Makefile:#   Versioned symbols and restricted exports
Makefile:#   Only restricted exports when possible
Makefile:am__append_4 = -export-symbols libpng.sym
Makefile:am__install_max = 40
Makefile:    if (++n[$$2] == $(am__install_max)) \
Makefile:am_png_fix_itxt_OBJECTS = contrib/tools/png-fix-itxt.$(OBJEXT)
Makefile:png_fix_itxt_OBJECTS = $(am_png_fix_itxt_OBJECTS)
Makefile:png_fix_itxt_LDADD = $(LDADD)
Makefile:am_pngfix_OBJECTS = contrib/tools/pngfix.$(OBJEXT)
Makefile:pngfix_OBJECTS = $(am_pngfix_OBJECTS)
Makefile:pngfix_DEPENDENCIES = libpng16.la
Makefile:	$(png_fix_itxt_SOURCES) $(pngfix_SOURCES) $(pngimage_SOURCES) \
Makefile:	$(png_fix_itxt_SOURCES) $(pngfix_SOURCES) $(pngimage_SOURCES) \
Makefile:am__recheck_rx = ^[ 	]*:recheck:[ 	]*
Makefile:am__global_test_result_rx = ^[ 	]*:global-test-result:[ 	]*
Makefile:am__copy_in_global_log_rx = ^[ 	]*:copy-in-global-log:[ 	]*
Makefile:      else if (line ~ /$(am__recheck_rx)[nN][Oo]/) \
Makefile:      else if (line ~ /$(am__recheck_rx)[yY][eE][sS]/) \
Makefile:  exit 1; \
Makefile:      if (line ~ /$(am__global_test_result_rx)/) \
Makefile:          sub("$(am__global_test_result_rx)", "", line); \
Makefile:      else if (line ~ /$(am__copy_in_global_log_rx)[nN][oO]/) \
Makefile:# Restructured Text title.
Makefile:am__rst_title = { sed 's/.*/   &   /;h;s/./=/g;p;x;s/ *$$//;p;g' && echo; }
Makefile:# by disabling -e (using the XSI extension "set +e") if it's set.
Makefile:  --expect-failure "$$am__expect_failure"
Makefile:# containing $f, in $tst the test, in $log the log.  Executes the
Makefile:srcdir=$(srcdir); export srcdir;			\
Makefile:test "x$$am__odir" = x"." || test -d "$$am__odir" 	\
Makefile:  || $(MKDIR_P) "$$am__odir" || exit $$?;		\
Makefile:    am__expect_failure=yes;;				\
Makefile:    am__expect_failure=no;;				\
Makefile:# extension removed (i.e., equivalently, the names of the test logs, with
Makefile:# the '.log' extension removed).  The result is saved in the shell variable
Makefile:# since that might cause problem with VPATH rewrites for suffix-less tests.
Makefile:    find "$(distdir)" -type d ! -perm -200 -exec chmod u+w {} ';' \
Makefile:DIST_ARCHIVES = $(distdir).tar.gz $(distdir).tar.xz
Makefile:DIST_TARGETS = dist-xz dist-gzip
Makefile:  | sed 's|^\./|$(prefix)/|' | grep -v '$(infodir)/dir$$'
Makefile:LD = /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/ld
Makefile:# PNG_COPTS give extra options for the C compiler to be used on all compilation
Makefile:am__untar = $${TAR-tar} xf -
Makefile:bindir = ${exec_prefix}/bin
Makefile:build = x86_64-apple-darwin13.4.0
Makefile:build_cpu = x86_64
Makefile:datarootdir = ${prefix}/share
Makefile:exec_prefix = ${prefix}
Makefile:host = x86_64-apple-darwin13.4.0
Makefile:host_cpu = x86_64
Makefile:includedir = ${prefix}/include
Makefile:libdir = ${exec_prefix}/lib
Makefile:libexecdir = ${exec_prefix}/libexec
Makefile:localstatedir = ${prefix}/var
Makefile:prefix = /Users/ananyu/csci3081/Photoshop/libpng-1.6.16
Makefile:program_transform_name = s,x,x,
Makefile:sbindir = ${exec_prefix}/sbin
Makefile:sharedstatedir = ${prefix}/com
Makefile:sysconfdir = ${prefix}/etc
Makefile:top_build_prefix = 
Makefile:pngfix_SOURCES = contrib/tools/pngfix.c
Makefile:pngfix_LDADD = libpng16.la
Makefile:png_fix_itxt_SOURCES = contrib/tools/png-fix-itxt.c
Makefile:   tests/pngvalid-gamma-background tests/pngvalid-gamma-expand16-alpha-mode\
Makefile:   tests/pngvalid-gamma-expand16-background\
Makefile:   tests/pngvalid-gamma-expand16-transform tests/pngvalid-gamma-sbit\
Makefile:# These tests are expected, and required, to fail:
Makefile:	-export-dynamic -version-number \
Makefile:# Extra source distribution files, '${srcdir}' is used below to stop build files
Makefile:	CMakeLists.txt example.c libpng-manual.txt
Makefile:	check.new pnglibconf.* pngprefix.h symbols.new pngtest-log.txt \
Makefile:# EXT_LIST is a list of the possibly library directory extensions, this exists
Makefile:# because we can't find a good way of discovering the file extensions that are
Makefile:# actually installed on a given system, so instead we check for every extension
Makefile:		&& exit 0; \
Makefile:	      exit 1;; \
Makefile:	  $(MKDIR_P) "$(DESTDIR)$(libdir)" || exit 1; \
Makefile:	  $(MKDIR_P) "$(DESTDIR)$(bindir)" || exit 1; \
Makefile:	    -e 'p;x;s,.*/,,;s/$(EXEEXT)$$//;$(transform);s/$$/$(EXEEXT)/' | \
Makefile:	    $(INSTALL_PROGRAM_ENV) $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=install $(INSTALL_PROGRAM) $$files "$(DESTDIR)$(bindir)$$dir" || exit $$?; \
Makefile:	test -n "$$list" || exit 0; \
Makefile:	@list='$(bin_PROGRAMS)'; test -n "$$list" || exit 0; \
Makefile:	rm -f $$list || exit $$?; \
Makefile:	test -n "$(EXEEXT)" || exit 0; \
Makefile:	@list='$(check_PROGRAMS)'; test -n "$$list" || exit 0; \
Makefile:	rm -f $$list || exit $$?; \
Makefile:	test -n "$(EXEEXT)" || exit 0; \
Makefile:contrib/tools/png-fix-itxt.$(OBJEXT): contrib/tools/$(am__dirstamp) \
Makefile:png-fix-itxt$(EXEEXT): $(png_fix_itxt_OBJECTS) $(png_fix_itxt_DEPENDENCIES) $(EXTRA_png_fix_itxt_DEPENDENCIES) 
Makefile:	@rm -f png-fix-itxt$(EXEEXT)
Makefile:	$(AM_V_CCLD)$(LINK) $(png_fix_itxt_OBJECTS) $(png_fix_itxt_LDADD) $(LIBS)
Makefile:contrib/tools/pngfix.$(OBJEXT): contrib/tools/$(am__dirstamp) \
Makefile:pngfix$(EXEEXT): $(pngfix_OBJECTS) $(pngfix_DEPENDENCIES) $(EXTRA_pngfix_DEPENDENCIES) 
Makefile:	@rm -f pngfix$(EXEEXT)
Makefile:	$(AM_V_CCLD)$(LINK) $(pngfix_OBJECTS) $(pngfix_LDADD) $(LIBS)
Makefile:	  $(MKDIR_P) "$(DESTDIR)$(bindir)" || exit 1; \
Makefile:	    -e 'p;x;s,.*/,,;$(transform)' | sed 'N;N;N;s,\n, ,g' | \
Makefile:	      if (++n[d] == $(am__install_max)) { \
Makefile:	       $(INSTALL_SCRIPT) $$files "$(DESTDIR)$(bindir)$$dir" || exit $$?; \
Makefile:	@list='$(bin_SCRIPTS)'; test -n "$(bindir)" || exit 0; \
Makefile:include contrib/tools/$(DEPDIR)/png-fix-itxt.Po
Makefile:include contrib/tools/$(DEPDIR)/pngfix.Po
Makefile:	  || exit 0; \
Makefile:	$(MKDIR_P) "$(DESTDIR)$(man3dir)" || exit 1; \
Makefile:	sed -e 'n;s,.*/,,;p;h;s,.*\.,,;s,^[^3][0-9a-z]*$$,3,;x' \
Makefile:	    $(INSTALL_DATA) "$$file" "$(DESTDIR)$(man3dir)/$$inst" || exit $$?; \
Makefile:	    $(INSTALL_DATA) $$files "$(DESTDIR)$(man3dir)" || exit $$?; }; \
Makefile:	@list=''; test -n "$(man3dir)" || exit 0; \
Makefile:	} | sed -e 's,.*/,,;h;s,.*\.,,;s,^[^3][0-9a-z]*$$,3,;x' \
Makefile:	  || exit 0; \
Makefile:	$(MKDIR_P) "$(DESTDIR)$(man5dir)" || exit 1; \
Makefile:	sed -e 'n;s,.*/,,;p;h;s,.*\.,,;s,^[^5][0-9a-z]*$$,5,;x' \
Makefile:	    $(INSTALL_DATA) "$$file" "$(DESTDIR)$(man5dir)/$$inst" || exit $$?; \
Makefile:	    $(INSTALL_DATA) $$files "$(DESTDIR)$(man5dir)" || exit $$?; }; \
Makefile:	@list=''; test -n "$(man5dir)" || exit 0; \
Makefile:	} | sed -e 's,.*/,,;h;s,.*\.,,;s,^[^5][0-9a-z]*$$,5,;x' \
Makefile:	  $(MKDIR_P) "$(DESTDIR)$(pkgconfigdir)" || exit 1; \
Makefile:	  $(INSTALL_DATA) $$files "$(DESTDIR)$(pkgconfigdir)" || exit $$?; \
Makefile:	  $(MKDIR_P) "$(DESTDIR)$(pkgincludedir)" || exit 1; \
Makefile:	  $(INSTALL_HEADER) $$files "$(DESTDIR)$(pkgincludedir)" || exit $$?; \
Makefile:	  $(MKDIR_P) "$(DESTDIR)$(pkgincludedir)" || exit 1; \
Makefile:	  $(INSTALL_HEADER) $$files "$(DESTDIR)$(pkgincludedir)" || exit $$?; \
Makefile:	set x; \
Makefile:	  test -n "$$unique" || unique=$$empty_fix; \
Makefile:# expand to empty, as could happen e.g. with make check TESTS=''.
Makefile:	    rm -f $$redo_logs && rm -f $$redo_results || exit 1; \
Makefile:	  test $$st -eq 0 || exit 1; \
Makefile:	xfail=`grep "^$$ws*:test-result:$$ws*XFAIL" $$results | wc -l`; \
Makefile:	xpass=`grep "^$$ws*:test-result:$$ws*XPASS" $$results | wc -l`; \
Makefile:	if test `expr $$fail + $$xpass + $$error` -eq 0; then \
Makefile:	    if test x"$$1" = x"--maybe-color"; then \
Makefile:	    elif test x"$$1" = x"--no-color"; then \
Makefile:	      echo "$@: invalid 'result_count' usage" >&2; exit 4; \
Makefile:	  result_count $$1 "XFAIL:" $$xfail "$$lgn"; \
Makefile:	  result_count $$1 "XPASS:" $$xpass "$$red"; \
Makefile:	} >$(TEST_SUITE_LOG).tmp || exit 1;				\
Makefile:	  test x"$$VERBOSE" = x || cat $(TEST_SUITE_LOG);		\
Makefile:	$$success || exit 1
Makefile:	exit $$?;
Makefile:	         | $(am__list_recheck_tests)` || exit 1; \
Makefile:	exit $$?
Makefile:tests/pngvalid-gamma-expand16-alpha-mode.log: tests/pngvalid-gamma-expand16-alpha-mode
Makefile:	@p='tests/pngvalid-gamma-expand16-alpha-mode'; \
Makefile:	b='tests/pngvalid-gamma-expand16-alpha-mode'; \
Makefile:tests/pngvalid-gamma-expand16-background.log: tests/pngvalid-gamma-expand16-background
Makefile:	@p='tests/pngvalid-gamma-expand16-background'; \
Makefile:	b='tests/pngvalid-gamma-expand16-background'; \
Makefile:tests/pngvalid-gamma-expand16-transform.log: tests/pngvalid-gamma-expand16-transform
Makefile:	@p='tests/pngvalid-gamma-expand16-transform'; \
Makefile:	b='tests/pngvalid-gamma-expand16-transform'; \
Makefile:	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
Makefile:	      cp -fpR $(srcdir)/$$file "$(distdir)$$dir" || exit 1; \
Makefile:	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
Makefile:	    cp -fpR $$d/$$file "$(distdir)$$dir" || exit 1; \
Makefile:	    || exit 1; \
Makefile:	-test -n "$(am__skip_mode_fix)" \
Makefile:		-exec chmod u+rwx,go+rx {} \; -o \
Makefile:	  ! -type d ! -perm -444 -links 1 -exec chmod a+r {} \; -o \
Makefile:	  ! -type d ! -perm -400 -exec chmod a+r {} \; -o \
Makefile:	  ! -type d ! -perm -444 -exec $(install_sh) -c -m a+r {} {} \; \
Makefile:dist-xz: distdir
Makefile:	tardir=$(distdir) && $(am__tar) | XZ_OPT=$${XZ_OPT--e} xz -c >$(distdir).tar.xz
Makefile:	*.tar.xz*) \
Makefile:	  xz -dc $(distdir).tar.xz | $(am__untar) ;;\
Makefile:	test -d $(distdir)/_build || exit 0; \
Makefile:	    --srcdir=.. --prefix="$$dc_install_base" \
Makefile:	      } || { rm -rf "$$dc_destdir"; exit 1; }) \
Makefile:	  || exit 1
Makefile:	  sed -e 1h -e 1s/./=/g -e 1p -e 1x -e '$$p' -e '$$x'
Makefile:	  exit 1; \
Makefile:	  exit 1; \
Makefile:	        exit 1; } >&2
Makefile:	  exit 1 ; \
Makefile:	       exit 1; } >&2
Makefile:install-exec: install-exec-am
Makefile:	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
Makefile:##install-exec-hook:
Makefile:install-exec-am: install-binPROGRAMS install-binSCRIPTS \
Makefile:	$(MAKE) $(AM_MAKEFLAGS) install-exec-hook
Makefile:	install-exec-am install-strip uninstall-am
Makefile:	dist-gzip dist-hook dist-lzip dist-shar dist-tarZ dist-xz \
Makefile:	install-exec install-exec-am install-exec-hook install-html \
Makefile:scripts/prefix.out: png.h pngconf.h pnglibconf.out
Makefile:scripts/intprefix.out: pnglibconf.h
Makefile:# Rename functions in scripts/prefix.out with a PNG_PREFIX prefix.
Makefile:#pnglibconf.h: pnglibconf.out scripts/prefix.out scripts/macro.lst
Makefile:#	   END{print prev}' s=0 pnglibconf.out s=1 scripts/prefix.out\
Makefile:#pngprefix.h: scripts/intprefix.out
Makefile:#	rm -f pngprefix.tf1
Makefile:#	$(AWK) '{print "#define", $$1, "" $$1}' $? >pngprefix.tf1
Makefile:#	mv pngprefix.tf1 $@
Makefile:pngprefix.h: # is empty
Makefile:	@exit 1
Makefile:contrib/tools/pngfix.o: pnglibconf.h
Makefile:	pnglibconf.h pngpriv.h pngdebug.h pnginfo.h pngstruct.h pngprefix.h
Makefile:# Extra checks
Makefile:	@set -ex; cd '$(DESTDIR)$(includedir)'; for f in $(HEADERS); do \
Makefile:	@set -ex; cd '$(DESTDIR)$(pkgconfigdir)'; rm -f libpng.pc; \
Makefile:	@set -x; cd '$(DESTDIR)$(libdir)';\
Makefile:	for ext in $(EXT_LIST); do\
Makefile:	   rm -f "libpng.$$ext";\
Makefile:           if test -f "$(PNGLIB_BASENAME).$$ext"; then\
Makefile:              $(LN_S) "$(PNGLIB_BASENAME).$$ext" "libpng.$$ext" || exit 1;\
Makefile:	@set -x; cd '$(DESTDIR)$(libdir)'; for ext in $(EXT_LIST); do\
Makefile:	   rm -f "libpng.$$ext"; done
Makefile:	@set -ex; cd '$(DESTDIR)$(bindir)'; rm -f libpng-config; \
Makefile:install-exec-hook: install-library-links
Makefile:install-exec-hook: install-libpng-config
Makefile:# Tell versions [3.59,3.63) of GNU make to not export all variables.
Makefile:# Otherwise a system limit (for SysV at least) may be exceeded.
Makefile.am:bin_PROGRAMS= pngfix png-fix-itxt
Makefile.am:pngfix_SOURCES = contrib/tools/pngfix.c
Makefile.am:pngfix_LDADD = libpng@PNGLIB_MAJOR@@PNGLIB_MINOR@.la
Makefile.am:png_fix_itxt_SOURCES = contrib/tools/png-fix-itxt.c
Makefile.am:   tests/pngvalid-gamma-background tests/pngvalid-gamma-expand16-alpha-mode\
Makefile.am:   tests/pngvalid-gamma-expand16-background\
Makefile.am:   tests/pngvalid-gamma-expand16-transform tests/pngvalid-gamma-sbit\
Makefile.am:# These tests are expected, and required, to fail:
Makefile.am:libpng@PNGLIB_MAJOR@@PNGLIB_MINOR@_la_LDFLAGS = -no-undefined -export-dynamic \
Makefile.am:#   Versioned symbols and restricted exports
Makefile.am:#   Only restricted exports when possible
Makefile.am:  libpng@PNGLIB_MAJOR@@PNGLIB_MINOR@_la_LDFLAGS += -export-symbols libpng.sym
Makefile.am:# Extra source distribution files, '${srcdir}' is used below to stop build files
Makefile.am:	CMakeLists.txt example.c libpng-manual.txt
Makefile.am:	check.new pnglibconf.* pngprefix.h symbols.new pngtest-log.txt \
Makefile.am:# PNG_COPTS give extra options for the C compiler to be used on all compilation
Makefile.am:scripts/prefix.out: png.h pngconf.h pnglibconf.out
Makefile.am:scripts/intprefix.out: pnglibconf.h
Makefile.am:# Rename functions in scripts/prefix.out with a PNG_PREFIX prefix.
Makefile.am:pnglibconf.h: pnglibconf.out scripts/prefix.out scripts/macro.lst
Makefile.am:	   END{print prev}' s=0 pnglibconf.out s=1 scripts/prefix.out\
Makefile.am:pngprefix.h: scripts/intprefix.out
Makefile.am:	rm -f pngprefix.tf1
Makefile.am:	$(AWK) '{print "#define", $$1, "@PNG_PREFIX@" $$1}' $? >pngprefix.tf1
Makefile.am:	mv pngprefix.tf1 $@
Makefile.am:pngprefix.h: # is empty
Makefile.am:	@exit 1
Makefile.am:contrib/tools/pngfix.o: pnglibconf.h
Makefile.am:	pnglibconf.h pngpriv.h pngdebug.h pnginfo.h pngstruct.h pngprefix.h
Makefile.am:# Extra checks
Makefile.am:	@set -ex; cd '$(DESTDIR)$(includedir)'; for f in $(HEADERS); do \
Makefile.am:	@set -ex; cd '$(DESTDIR)$(pkgconfigdir)'; rm -f libpng.pc; \
Makefile.am:# EXT_LIST is a list of the possibly library directory extensions, this exists
Makefile.am:# because we can't find a good way of discovering the file extensions that are
Makefile.am:# actually installed on a given system, so instead we check for every extension
Makefile.am:	@set -x; cd '$(DESTDIR)$(libdir)';\
Makefile.am:	for ext in $(EXT_LIST); do\
Makefile.am:	   rm -f "libpng.$$ext";\
Makefile.am:           if test -f "$(PNGLIB_BASENAME).$$ext"; then\
Makefile.am:              $(LN_S) "$(PNGLIB_BASENAME).$$ext" "libpng.$$ext" || exit 1;\
Makefile.am:	@set -x; cd '$(DESTDIR)$(libdir)'; for ext in $(EXT_LIST); do\
Makefile.am:	   rm -f "libpng.$$ext"; done
Makefile.am:	@set -ex; cd '$(DESTDIR)$(bindir)'; rm -f libpng-config; \
Makefile.am:install-exec-hook: install-library-links
Makefile.am:install-exec-hook: install-libpng-config
Makefile.in:# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
Makefile.in:         exit 1;; \
Makefile.in:  skip_next=no; \
Makefile.in:    test $$skip_next = yes && { skip_next=no; continue; }; \
Makefile.in:        -*I) strip_trailopt 'I'; skip_next=yes;; \
Makefile.in:        -*O) strip_trailopt 'O'; skip_next=yes;; \
Makefile.in:        -*l) strip_trailopt 'l'; skip_next=yes;; \
Makefile.in:      -[dEDm]) skip_next=yes;; \
Makefile.in:      -[JT]) skip_next=yes;; \
Makefile.in:pkglibexecdir = $(libexecdir)/@PACKAGE@
Makefile.in:bin_PROGRAMS = pngfix$(EXEEXT) png-fix-itxt$(EXEEXT)
Makefile.in:#   Versioned symbols and restricted exports
Makefile.in:#   Only restricted exports when possible
Makefile.in:@HAVE_LD_VERSION_SCRIPT_FALSE@am__append_4 = -export-symbols libpng.sym
Makefile.in:am__install_max = 40
Makefile.in:    if (++n[$$2] == $(am__install_max)) \
Makefile.in:am_png_fix_itxt_OBJECTS = contrib/tools/png-fix-itxt.$(OBJEXT)
Makefile.in:png_fix_itxt_OBJECTS = $(am_png_fix_itxt_OBJECTS)
Makefile.in:png_fix_itxt_LDADD = $(LDADD)
Makefile.in:am_pngfix_OBJECTS = contrib/tools/pngfix.$(OBJEXT)
Makefile.in:pngfix_OBJECTS = $(am_pngfix_OBJECTS)
Makefile.in:pngfix_DEPENDENCIES = libpng@PNGLIB_MAJOR@@PNGLIB_MINOR@.la
Makefile.in:	$(png_fix_itxt_SOURCES) $(pngfix_SOURCES) $(pngimage_SOURCES) \
Makefile.in:	$(png_fix_itxt_SOURCES) $(pngfix_SOURCES) $(pngimage_SOURCES) \
Makefile.in:am__recheck_rx = ^[ 	]*:recheck:[ 	]*
Makefile.in:am__global_test_result_rx = ^[ 	]*:global-test-result:[ 	]*
Makefile.in:am__copy_in_global_log_rx = ^[ 	]*:copy-in-global-log:[ 	]*
Makefile.in:      else if (line ~ /$(am__recheck_rx)[nN][Oo]/) \
Makefile.in:      else if (line ~ /$(am__recheck_rx)[yY][eE][sS]/) \
Makefile.in:  exit 1; \
Makefile.in:      if (line ~ /$(am__global_test_result_rx)/) \
Makefile.in:          sub("$(am__global_test_result_rx)", "", line); \
Makefile.in:      else if (line ~ /$(am__copy_in_global_log_rx)[nN][oO]/) \
Makefile.in:# Restructured Text title.
Makefile.in:am__rst_title = { sed 's/.*/   &   /;h;s/./=/g;p;x;s/ *$$//;p;g' && echo; }
Makefile.in:# by disabling -e (using the XSI extension "set +e") if it's set.
Makefile.in:  --expect-failure "$$am__expect_failure"
Makefile.in:# containing $f, in $tst the test, in $log the log.  Executes the
Makefile.in:srcdir=$(srcdir); export srcdir;			\
Makefile.in:test "x$$am__odir" = x"." || test -d "$$am__odir" 	\
Makefile.in:  || $(MKDIR_P) "$$am__odir" || exit $$?;		\
Makefile.in:    am__expect_failure=yes;;				\
Makefile.in:    am__expect_failure=no;;				\
Makefile.in:# extension removed (i.e., equivalently, the names of the test logs, with
Makefile.in:# the '.log' extension removed).  The result is saved in the shell variable
Makefile.in:# since that might cause problem with VPATH rewrites for suffix-less tests.
Makefile.in:    find "$(distdir)" -type d ! -perm -200 -exec chmod u+w {} ';' \
Makefile.in:DIST_ARCHIVES = $(distdir).tar.gz $(distdir).tar.xz
Makefile.in:DIST_TARGETS = dist-xz dist-gzip
Makefile.in:  | sed 's|^\./|$(prefix)/|' | grep -v '$(infodir)/dir$$'
Makefile.in:# PNG_COPTS give extra options for the C compiler to be used on all compilation
Makefile.in:exec_prefix = @exec_prefix@
Makefile.in:libexecdir = @libexecdir@
Makefile.in:prefix = @prefix@
Makefile.in:top_build_prefix = @top_build_prefix@
Makefile.in:pngfix_SOURCES = contrib/tools/pngfix.c
Makefile.in:pngfix_LDADD = libpng@PNGLIB_MAJOR@@PNGLIB_MINOR@.la
Makefile.in:png_fix_itxt_SOURCES = contrib/tools/png-fix-itxt.c
Makefile.in:   tests/pngvalid-gamma-background tests/pngvalid-gamma-expand16-alpha-mode\
Makefile.in:   tests/pngvalid-gamma-expand16-background\
Makefile.in:   tests/pngvalid-gamma-expand16-transform tests/pngvalid-gamma-sbit\
Makefile.in:# These tests are expected, and required, to fail:
Makefile.in:	-export-dynamic -version-number \
Makefile.in:# Extra source distribution files, '${srcdir}' is used below to stop build files
Makefile.in:	CMakeLists.txt example.c libpng-manual.txt
Makefile.in:	check.new pnglibconf.* pngprefix.h symbols.new pngtest-log.txt \
Makefile.in:# EXT_LIST is a list of the possibly library directory extensions, this exists
Makefile.in:# because we can't find a good way of discovering the file extensions that are
Makefile.in:# actually installed on a given system, so instead we check for every extension
Makefile.in:		&& exit 0; \
Makefile.in:	      exit 1;; \
Makefile.in:	  $(MKDIR_P) "$(DESTDIR)$(libdir)" || exit 1; \
Makefile.in:	  $(MKDIR_P) "$(DESTDIR)$(bindir)" || exit 1; \
Makefile.in:	    -e 'p;x;s,.*/,,;s/$(EXEEXT)$$//;$(transform);s/$$/$(EXEEXT)/' | \
Makefile.in:	    $(INSTALL_PROGRAM_ENV) $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=install $(INSTALL_PROGRAM) $$files "$(DESTDIR)$(bindir)$$dir" || exit $$?; \
Makefile.in:	test -n "$$list" || exit 0; \
Makefile.in:	@list='$(bin_PROGRAMS)'; test -n "$$list" || exit 0; \
Makefile.in:	rm -f $$list || exit $$?; \
Makefile.in:	test -n "$(EXEEXT)" || exit 0; \
Makefile.in:	@list='$(check_PROGRAMS)'; test -n "$$list" || exit 0; \
Makefile.in:	rm -f $$list || exit $$?; \
Makefile.in:	test -n "$(EXEEXT)" || exit 0; \
Makefile.in:contrib/tools/png-fix-itxt.$(OBJEXT): contrib/tools/$(am__dirstamp) \
Makefile.in:png-fix-itxt$(EXEEXT): $(png_fix_itxt_OBJECTS) $(png_fix_itxt_DEPENDENCIES) $(EXTRA_png_fix_itxt_DEPENDENCIES) 
Makefile.in:	@rm -f png-fix-itxt$(EXEEXT)
Makefile.in:	$(AM_V_CCLD)$(LINK) $(png_fix_itxt_OBJECTS) $(png_fix_itxt_LDADD) $(LIBS)
Makefile.in:contrib/tools/pngfix.$(OBJEXT): contrib/tools/$(am__dirstamp) \
Makefile.in:pngfix$(EXEEXT): $(pngfix_OBJECTS) $(pngfix_DEPENDENCIES) $(EXTRA_pngfix_DEPENDENCIES) 
Makefile.in:	@rm -f pngfix$(EXEEXT)
Makefile.in:	$(AM_V_CCLD)$(LINK) $(pngfix_OBJECTS) $(pngfix_LDADD) $(LIBS)
Makefile.in:	  $(MKDIR_P) "$(DESTDIR)$(bindir)" || exit 1; \
Makefile.in:	    -e 'p;x;s,.*/,,;$(transform)' | sed 'N;N;N;s,\n, ,g' | \
Makefile.in:	      if (++n[d] == $(am__install_max)) { \
Makefile.in:	       $(INSTALL_SCRIPT) $$files "$(DESTDIR)$(bindir)$$dir" || exit $$?; \
Makefile.in:	@list='$(bin_SCRIPTS)'; test -n "$(bindir)" || exit 0; \
Makefile.in:@AMDEP_TRUE@@am__include@ @am__quote@contrib/tools/$(DEPDIR)/png-fix-itxt.Po@am__quote@
Makefile.in:@AMDEP_TRUE@@am__include@ @am__quote@contrib/tools/$(DEPDIR)/pngfix.Po@am__quote@
Makefile.in:	  || exit 0; \
Makefile.in:	$(MKDIR_P) "$(DESTDIR)$(man3dir)" || exit 1; \
Makefile.in:	sed -e 'n;s,.*/,,;p;h;s,.*\.,,;s,^[^3][0-9a-z]*$$,3,;x' \
Makefile.in:	    $(INSTALL_DATA) "$$file" "$(DESTDIR)$(man3dir)/$$inst" || exit $$?; \
Makefile.in:	    $(INSTALL_DATA) $$files "$(DESTDIR)$(man3dir)" || exit $$?; }; \
Makefile.in:	@list=''; test -n "$(man3dir)" || exit 0; \
Makefile.in:	} | sed -e 's,.*/,,;h;s,.*\.,,;s,^[^3][0-9a-z]*$$,3,;x' \
Makefile.in:	  || exit 0; \
Makefile.in:	$(MKDIR_P) "$(DESTDIR)$(man5dir)" || exit 1; \
Makefile.in:	sed -e 'n;s,.*/,,;p;h;s,.*\.,,;s,^[^5][0-9a-z]*$$,5,;x' \
Makefile.in:	    $(INSTALL_DATA) "$$file" "$(DESTDIR)$(man5dir)/$$inst" || exit $$?; \
Makefile.in:	    $(INSTALL_DATA) $$files "$(DESTDIR)$(man5dir)" || exit $$?; }; \
Makefile.in:	@list=''; test -n "$(man5dir)" || exit 0; \
Makefile.in:	} | sed -e 's,.*/,,;h;s,.*\.,,;s,^[^5][0-9a-z]*$$,5,;x' \
Makefile.in:	  $(MKDIR_P) "$(DESTDIR)$(pkgconfigdir)" || exit 1; \
Makefile.in:	  $(INSTALL_DATA) $$files "$(DESTDIR)$(pkgconfigdir)" || exit $$?; \
Makefile.in:	  $(MKDIR_P) "$(DESTDIR)$(pkgincludedir)" || exit 1; \
Makefile.in:	  $(INSTALL_HEADER) $$files "$(DESTDIR)$(pkgincludedir)" || exit $$?; \
Makefile.in:	  $(MKDIR_P) "$(DESTDIR)$(pkgincludedir)" || exit 1; \
Makefile.in:	  $(INSTALL_HEADER) $$files "$(DESTDIR)$(pkgincludedir)" || exit $$?; \
Makefile.in:	set x; \
Makefile.in:	  test -n "$$unique" || unique=$$empty_fix; \
Makefile.in:# expand to empty, as could happen e.g. with make check TESTS=''.
Makefile.in:	    rm -f $$redo_logs && rm -f $$redo_results || exit 1; \
Makefile.in:	  test $$st -eq 0 || exit 1; \
Makefile.in:	xfail=`grep "^$$ws*:test-result:$$ws*XFAIL" $$results | wc -l`; \
Makefile.in:	xpass=`grep "^$$ws*:test-result:$$ws*XPASS" $$results | wc -l`; \
Makefile.in:	if test `expr $$fail + $$xpass + $$error` -eq 0; then \
Makefile.in:	    if test x"$$1" = x"--maybe-color"; then \
Makefile.in:	    elif test x"$$1" = x"--no-color"; then \
Makefile.in:	      echo "$@: invalid 'result_count' usage" >&2; exit 4; \
Makefile.in:	  result_count $$1 "XFAIL:" $$xfail "$$lgn"; \
Makefile.in:	  result_count $$1 "XPASS:" $$xpass "$$red"; \
Makefile.in:	} >$(TEST_SUITE_LOG).tmp || exit 1;				\
Makefile.in:	  test x"$$VERBOSE" = x || cat $(TEST_SUITE_LOG);		\
Makefile.in:	$$success || exit 1
Makefile.in:	exit $$?;
Makefile.in:	         | $(am__list_recheck_tests)` || exit 1; \
Makefile.in:	exit $$?
Makefile.in:tests/pngvalid-gamma-expand16-alpha-mode.log: tests/pngvalid-gamma-expand16-alpha-mode
Makefile.in:	@p='tests/pngvalid-gamma-expand16-alpha-mode'; \
Makefile.in:	b='tests/pngvalid-gamma-expand16-alpha-mode'; \
Makefile.in:tests/pngvalid-gamma-expand16-background.log: tests/pngvalid-gamma-expand16-background
Makefile.in:	@p='tests/pngvalid-gamma-expand16-background'; \
Makefile.in:	b='tests/pngvalid-gamma-expand16-background'; \
Makefile.in:tests/pngvalid-gamma-expand16-transform.log: tests/pngvalid-gamma-expand16-transform
Makefile.in:	@p='tests/pngvalid-gamma-expand16-transform'; \
Makefile.in:	b='tests/pngvalid-gamma-expand16-transform'; \
Makefile.in:	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
Makefile.in:	      cp -fpR $(srcdir)/$$file "$(distdir)$$dir" || exit 1; \
Makefile.in:	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
Makefile.in:	    cp -fpR $$d/$$file "$(distdir)$$dir" || exit 1; \
Makefile.in:	    || exit 1; \
Makefile.in:	-test -n "$(am__skip_mode_fix)" \
Makefile.in:		-exec chmod u+rwx,go+rx {} \; -o \
Makefile.in:	  ! -type d ! -perm -444 -links 1 -exec chmod a+r {} \; -o \
Makefile.in:	  ! -type d ! -perm -400 -exec chmod a+r {} \; -o \
Makefile.in:	  ! -type d ! -perm -444 -exec $(install_sh) -c -m a+r {} {} \; \
Makefile.in:dist-xz: distdir
Makefile.in:	tardir=$(distdir) && $(am__tar) | XZ_OPT=$${XZ_OPT--e} xz -c >$(distdir).tar.xz
Makefile.in:	*.tar.xz*) \
Makefile.in:	  xz -dc $(distdir).tar.xz | $(am__untar) ;;\
Makefile.in:	test -d $(distdir)/_build || exit 0; \
Makefile.in:	    --srcdir=.. --prefix="$$dc_install_base" \
Makefile.in:	      } || { rm -rf "$$dc_destdir"; exit 1; }) \
Makefile.in:	  || exit 1
Makefile.in:	  sed -e 1h -e 1s/./=/g -e 1p -e 1x -e '$$p' -e '$$x'
Makefile.in:	  exit 1; \
Makefile.in:	  exit 1; \
Makefile.in:	        exit 1; } >&2
Makefile.in:	  exit 1 ; \
Makefile.in:	       exit 1; } >&2
Makefile.in:install-exec: install-exec-am
Makefile.in:	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
Makefile.in:@DO_INSTALL_LIBPNG_CONFIG_FALSE@@DO_INSTALL_LINKS_FALSE@install-exec-hook:
Makefile.in:install-exec-am: install-binPROGRAMS install-binSCRIPTS \
Makefile.in:	$(MAKE) $(AM_MAKEFLAGS) install-exec-hook
Makefile.in:	install-exec-am install-strip uninstall-am
Makefile.in:	dist-gzip dist-hook dist-lzip dist-shar dist-tarZ dist-xz \
Makefile.in:	install-exec install-exec-am install-exec-hook install-html \
Makefile.in:scripts/prefix.out: png.h pngconf.h pnglibconf.out
Makefile.in:scripts/intprefix.out: pnglibconf.h
Makefile.in:# Rename functions in scripts/prefix.out with a PNG_PREFIX prefix.
Makefile.in:@DO_PNG_PREFIX_TRUE@pnglibconf.h: pnglibconf.out scripts/prefix.out scripts/macro.lst
Makefile.in:@DO_PNG_PREFIX_TRUE@	   END{print prev}' s=0 pnglibconf.out s=1 scripts/prefix.out\
Makefile.in:@DO_PNG_PREFIX_TRUE@pngprefix.h: scripts/intprefix.out
Makefile.in:@DO_PNG_PREFIX_TRUE@	rm -f pngprefix.tf1
Makefile.in:@DO_PNG_PREFIX_TRUE@	$(AWK) '{print "#define", $$1, "@PNG_PREFIX@" $$1}' $? >pngprefix.tf1
Makefile.in:@DO_PNG_PREFIX_TRUE@	mv pngprefix.tf1 $@
Makefile.in:@DO_PNG_PREFIX_FALSE@pngprefix.h: # is empty
Makefile.in:	@exit 1
Makefile.in:contrib/tools/pngfix.o: pnglibconf.h
Makefile.in:	pnglibconf.h pngpriv.h pngdebug.h pnginfo.h pngstruct.h pngprefix.h
Makefile.in:# Extra checks
Makefile.in:	@set -ex; cd '$(DESTDIR)$(includedir)'; for f in $(HEADERS); do \
Makefile.in:	@set -ex; cd '$(DESTDIR)$(pkgconfigdir)'; rm -f libpng.pc; \
Makefile.in:	@set -x; cd '$(DESTDIR)$(libdir)';\
Makefile.in:	for ext in $(EXT_LIST); do\
Makefile.in:	   rm -f "libpng.$$ext";\
Makefile.in:           if test -f "$(PNGLIB_BASENAME).$$ext"; then\
Makefile.in:              $(LN_S) "$(PNGLIB_BASENAME).$$ext" "libpng.$$ext" || exit 1;\
Makefile.in:	@set -x; cd '$(DESTDIR)$(libdir)'; for ext in $(EXT_LIST); do\
Makefile.in:	   rm -f "libpng.$$ext"; done
Makefile.in:	@set -ex; cd '$(DESTDIR)$(bindir)'; rm -f libpng-config; \
Makefile.in:@DO_INSTALL_LINKS_TRUE@install-exec-hook: install-library-links
Makefile.in:@DO_INSTALL_LIBPNG_CONFIG_TRUE@install-exec-hook: install-libpng-config
Makefile.in:# Tell versions [3.59,3.63) of GNU make to not export all variables.
Makefile.in:# Otherwise a system limit (for SysV at least) may be exceeded.
missing:# As a special exception to the GNU General Public License, if you
missing:  exit 1
missing:    exit 0
missing:  -h, --help      display this help and exit
missing:  -v, --version   output version information and exit
missing:  bison     yacc      flex         lex       help2man
missing:Version suffixes to PROGRAM as well as the prefixes 'gnu-', 'gnu', and
missing:    exit $?
missing:    exit $?
missing:    exit 1
missing:# Run the given program, remember its exit status.
missing:test $st -eq 0 && exit 0
missing:# Also exit now if we it failed (or wasn't found), and '--version' was
missing:case $2 in --version|--help) exit $st;; esac
missing:# Exit code 63 means version mismatch.  This often happens when the user
missing:  # Program was found and executed, but failed.  Give up.
missing:  exit $st
missing:flex_URL=http://flex.sourceforge.net/
missing:    lex*|flex*)
missing:      echo "You may want to install the Fast Lexical Analyzer package:"
missing:      echo "<$flex_URL>"
missing:      echo "You should only need it if you modified a '.texi' file, or"
missing:      echo "You might want to install the Texinfo package:"
missing:      echo "<$gnu_software_URL/texinfo/>"
missing:# Propagate the correct exit status (expected to be 127 for a program
missing:exit $st
png.5:PNG (Portable Network Graphics) is an extensible file format for the
png.5:common uses of TIFF. Indexed-color, grayscale, and truecolor images are
png.5:ftp://ds.internic.net/rfc/rfc2083.txt
Binary file pngbar.jpg matches
Binary file pngbar.png matches
png.c: * can simply check the remaining bytes for extra assurance.  Returns
png.c:    * build enough context to allow the user provided memory allocator (if any)
png.c:      create_struct.user_width_max = PNG_USER_WIDTH_MAX;
png.c:      create_struct.user_height_max = PNG_USER_HEIGHT_MAX;
png.c:         create_struct.user_chunk_cache_max = PNG_USER_CHUNK_CACHE_MAX;
png.c:         /* Added at libpng-1.2.43 and 1.4.1, required only for read but exists
png.c:         create_struct.user_chunk_malloc_max = PNG_USER_CHUNK_MALLOC_MAX;
png.c:    * extremely sophisticated.  The design lacks merit but is implicit in the
png.c:    * has always been done in 'example.c'.
png.c:   /* Free text item num or (if num == -1) all text items */
png.c:   if (info_ptr->text != 0 &&
png.c:         png_free(png_ptr, info_ptr->text[num].key);
png.c:         info_ptr->text[num].key = NULL;
png.c:         for (i = 0; i < info_ptr->num_text; i++)
png.c:            png_free(png_ptr, info_ptr->text[i].key);
png.c:         png_free(png_ptr, info_ptr->text);
png.c:         info_ptr->text = NULL;
png.c:         info_ptr->num_text = 0;
png.c: * (compare the more complex code required on read for sign extension.)
png.c:   buf[0] = (png_byte)((i >> 24) & 0xff);
png.c:   buf[1] = (png_byte)((i >> 16) & 0xff);
png.c:   buf[2] = (png_byte)((i >> 8) & 0xff);
png.c:   buf[3] = (png_byte)(i & 0xff);
png.c: * a "Creation Time" or other text-based time string.
png.c:         color_inc = 0xff;
png.c:         color_inc = 0x55;
png.c:         color_inc = 0x11;
png.c:   /* WARNING: this resets the window bits to the maximum! */
png.c:         png_ptr->zstream.msg = PNGZ_MSG_CAST("unexpected zlib return code");
png.c:         /* Normal exit */
png.c:         png_ptr->zstream.msg = PNGZ_MSG_CAST("unexpected end of LZ stream");
png.c:         png_ptr->zstream.msg = PNGZ_MSG_CAST("unexpected zlib return");
png.c:   png_colorspacerp colorspace, png_fixed_point gAMA, int from)
png.c:   /* This is called to check a new gamma value against an existing one.  The
png.c:   png_fixed_point gtest;
png.c:       * approximation should match, or this is an image with a profile and the
png.c:   png_colorspacerp colorspace, png_fixed_point gAMA)
png.c:    * occur.  Since the fixed point representation is asymetrical it is
png.c:       * corresponds to the case where the existing gamma comes from an sRGB
png.c:   /* Error exit - errmsg has been set. */
png.c:png_xy_from_XYZ(png_xy *xy, const png_XYZ *XYZ)
png.c:   if (png_muldiv(&xy->redx, XYZ->red_X, PNG_FP_1, d) == 0)
png.c:   if (png_muldiv(&xy->redy, XYZ->red_Y, PNG_FP_1, d) == 0)
png.c:   if (png_muldiv(&xy->greenx, XYZ->green_X, PNG_FP_1, d) == 0)
png.c:   if (png_muldiv(&xy->greeny, XYZ->green_Y, PNG_FP_1, d) == 0)
png.c:   if (png_muldiv(&xy->bluex, XYZ->blue_X, PNG_FP_1, d) == 0)
png.c:   if (png_muldiv(&xy->bluey, XYZ->blue_Y, PNG_FP_1, d) == 0)
png.c:   if (png_muldiv(&xy->whitex, whiteX, PNG_FP_1, dwhite) == 0)
png.c:   if (png_muldiv(&xy->whitey, whiteY, PNG_FP_1, dwhite) == 0)
png.c:png_XYZ_from_xy(png_XYZ *XYZ, const png_xy *xy)
png.c:   png_fixed_point red_inverse, green_inverse, blue_scale;
png.c:   png_fixed_point left, right, denominator;
png.c:   /* Check xy and, implicitly, z.  Note that wide gamut color spaces typically
png.c:   if (xy->redx < 0 || xy->redx > PNG_FP_1) return 1;
png.c:   if (xy->redy < 0 || xy->redy > PNG_FP_1-xy->redx) return 1;
png.c:   if (xy->greenx < 0 || xy->greenx > PNG_FP_1) return 1;
png.c:   if (xy->greeny < 0 || xy->greeny > PNG_FP_1-xy->greenx) return 1;
png.c:   if (xy->bluex < 0 || xy->bluex > PNG_FP_1) return 1;
png.c:   if (xy->bluey < 0 || xy->bluey > PNG_FP_1-xy->bluex) return 1;
png.c:   if (xy->whitex < 0 || xy->whitex > PNG_FP_1) return 1;
png.c:   if (xy->whitey < 0 || xy->whitey > PNG_FP_1-xy->whitex) return 1;
png.c:    * value had 9 independent values (red,green,blue)x(X,Y,Z) however only 8
png.c:    * (red,green,blue,white)x(x,y).  This loses one degree of freedom and
png.c:    * For each c (x,y,z) from the corresponding original C (X,Y,Z).  Thus the
png.c:    * three chromaticity values (x,y,z) for each end-point obey the
png.c:    *   x + y + z = 1
png.c:    * This describes the plane in (X,Y,Z) space that intersects each axis at the
png.c:    * calculation has scaled each end-point so that it is on the x+y+z=1 plane
png.c:    * But cHRM records only white-x and white-y, so we have lost the white scale
png.c:    *    Given: color-x = color-X / (color-X + color-Y + color-Z)
png.c:    *    Hence: (color-x - 1)*color-X + color.x*color-Y + color.x*color-Z = 0
png.c:    * solved by Cramer's rule.  Cramer's rule requires calculating 10 9x9 matrix
png.c:    *    white-X = white-x * white-scale
png.c:    *    white-Z = (1 - white-x - white-y) * white_scale
png.c:    *    red-x*red-scale + green-x*green-scale + blue-x*blue-scale
png.c:    *       = white-x/white-y
png.c:    *       = (1 - white-x - white-y)/white-y
png.c:    * In the last equation color-z is (1 - color-x - color-y) so we can add all
png.c:    * 3x3 - far more tractible.  Unfortunately 3x3 determinants still involve
png.c:    * overflow in the libpng fixed point representation.  Using Cramer's rule in
png.c:    * fixed point.  Instead proceed to simplify the first two equations by
png.c:    *    (red-x - blue-x)*red-scale + (green-x - blue-x)*green-scale =
png.c:    *                (white-x - blue-x)*white-scale
png.c:    *                (white-x - blue-x)*white-scale - (red-x - blue-x)*red-scale
png.c:    *                                  green-x - blue-x
png.c:    *          ( (green-x - blue-x) * (white-y - blue-y) -
png.c:    *            (green-y - blue-y) * (white-x - blue-x) ) / white-y
png.c:    *  (green-x - blue-x)*(red-y - blue-y)-(green-y - blue-y)*(red-x - blue-x)
png.c:    *          ( (red-y - blue-y) * (white-x - blue-x) -
png.c:    *            (red-x - blue-x) * (white-y - blue-y) ) / white-y
png.c:    *  (green-x - blue-x)*(red-y - blue-y)-(green-y - blue-y)*(red-x - blue-x)
png.c:    * The approach used here is to preserve the maximum precision within the
png.c:    * chromaticities in the above equations tend to be small, for example for
png.c:   if (png_muldiv(&left, xy->greenx-xy->bluex, xy->redy - xy->bluey, 7) == 0)
png.c:   if (png_muldiv(&right, xy->greeny-xy->bluey, xy->redx - xy->bluex, 7) == 0)
png.c:   if (png_muldiv(&left, xy->greenx-xy->bluex, xy->whitey-xy->bluey, 7) == 0)
png.c:   if (png_muldiv(&right, xy->greeny-xy->bluey, xy->whitex-xy->bluex, 7) == 0)
png.c:   /* Overflow is possible here and it indicates an extreme set of PNG cHRM
png.c:   if (png_muldiv(&red_inverse, xy->whitey, denominator, left-right) == 0 ||
png.c:       red_inverse <= xy->whitey /* r+g+b scales = white scale */)
png.c:   if (png_muldiv(&left, xy->redy-xy->bluey, xy->whitex-xy->bluex, 7) == 0)
png.c:   if (png_muldiv(&right, xy->redx-xy->bluex, xy->whitey-xy->bluey, 7) == 0)
png.c:   if (png_muldiv(&green_inverse, xy->whitey, denominator, left-right) == 0 ||
png.c:       green_inverse <= xy->whitey)
png.c:    * can still produce 0 for extreme cHRM values.
png.c:   blue_scale = png_reciprocal(xy->whitey) - png_reciprocal(red_inverse) -
png.c:   if (png_muldiv(&XYZ->red_X, xy->redx, PNG_FP_1, red_inverse) == 0)
png.c:   if (png_muldiv(&XYZ->red_Y, xy->redy, PNG_FP_1, red_inverse) == 0)
png.c:   if (png_muldiv(&XYZ->red_Z, PNG_FP_1 - xy->redx - xy->redy, PNG_FP_1,
png.c:   if (png_muldiv(&XYZ->green_X, xy->greenx, PNG_FP_1, green_inverse) == 0)
png.c:   if (png_muldiv(&XYZ->green_Y, xy->greeny, PNG_FP_1, green_inverse) == 0)
png.c:   if (png_muldiv(&XYZ->green_Z, PNG_FP_1 - xy->greenx - xy->greeny, PNG_FP_1,
png.c:   if (png_muldiv(&XYZ->blue_X, xy->bluex, blue_scale, PNG_FP_1) == 0)
png.c:   if (png_muldiv(&XYZ->blue_Y, xy->bluey, blue_scale, PNG_FP_1) == 0)
png.c:   if (png_muldiv(&XYZ->blue_Z, PNG_FP_1 - xy->bluex - xy->bluey, blue_scale,
png.c:   if (0x7fffffff - Y < XYZ->green_X)
png.c:   if (0x7fffffff - Y < XYZ->blue_X)
png.c:png_colorspace_endpoints_match(const png_xy *xy1, const png_xy *xy2, int delta)
png.c:   if (PNG_OUT_OF_RANGE(xy1->whitex, xy2->whitex,delta) ||
png.c:       PNG_OUT_OF_RANGE(xy1->whitey, xy2->whitey,delta) ||
png.c:       PNG_OUT_OF_RANGE(xy1->redx,   xy2->redx,  delta) ||
png.c:       PNG_OUT_OF_RANGE(xy1->redy,   xy2->redy,  delta) ||
png.c:       PNG_OUT_OF_RANGE(xy1->greenx, xy2->greenx,delta) ||
png.c:       PNG_OUT_OF_RANGE(xy1->greeny, xy2->greeny,delta) ||
png.c:       PNG_OUT_OF_RANGE(xy1->bluex,  xy2->bluex, delta) ||
png.c:       PNG_OUT_OF_RANGE(xy1->bluey,  xy2->bluey, delta))
png.c: * condition (where the determinant of the matrix to solve for XYZ ends up zero
png.c: * check is to round-trip xy -> XYZ -> xy and then check that the result is
png.c:png_colorspace_check_xy(png_XYZ *XYZ, const png_xy *xy)
png.c:   png_xy xy_test;
png.c:   result = png_XYZ_from_xy(XYZ, xy);
png.c:   result = png_xy_from_XYZ(&xy_test, XYZ);
png.c:   if (png_colorspace_endpoints_match(xy, &xy_test,
png.c: * (another side-effect) and the xy chromaticities are returned.
png.c:png_colorspace_check_XYZ(png_xy *xy, png_XYZ *XYZ)
png.c:   result = png_xy_from_XYZ(xy, XYZ);
png.c:   return png_colorspace_check_xy(&XYZtemp, xy);
png.c:static const png_xy sRGB_xy = /* From ITU-R BT.709-3 */
png.c:   /* color      x       y */
png.c:png_colorspace_set_xy_and_XYZ(png_const_structrp png_ptr,
png.c:   png_colorspacerp colorspace, const png_xy *xy, const png_XYZ *XYZ,
png.c:      if (png_colorspace_endpoints_match(xy, &colorspace->end_points_xy,
png.c:   colorspace->end_points_xy = *xy;
png.c:   if (png_colorspace_endpoints_match(xy, &sRGB_xy, 1000) != 0)
png.c:   png_colorspacerp colorspace, const png_xy *xy, int preferred)
png.c:   switch (png_colorspace_check_xy(&XYZ, xy))
png.c:         return png_colorspace_set_xy_and_XYZ(png_ptr, colorspace, xy, &XYZ,
png.c:   png_xy xy;
png.c:   switch (png_colorspace_check_XYZ(&xy, &XYZ))
png.c:         return png_colorspace_set_xy_and_XYZ(png_ptr, colorspace, &xy, &XYZ,
png.c:   byte &= 0xff;
png.c:      is_ICC_signature_char((it >> 16) & 0xff) &&
png.c:      is_ICC_signature_char((it >> 8) & 0xff) &&
png.c:      is_ICC_signature_char(it & 0xff);
png.c:               PNG_NUMBER_FORMAT_x, value));
png.c:   /* The 'reason' is an arbitrary message, allow +79 maximum 195 */
png.c:    * expected that the ICC profile mediaWhitePointTag will be D50; see the
png.c:   /* Check the intent, then check for existing settings.  It is valid for the
png.c:      !png_colorspace_endpoints_match(&sRGB_xy, &colorspace->end_points_xy,
png.c:   colorspace->end_points_xy = sRGB_xy;
png.c:   { 0x00, 0x00, 0xf6, 0xd6, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0xd3, 0x2d };
png.c:    * long profile_length from the caller must be correct.  The caller can fix
png.c:   if (temp > 357913930 || /* (2^32-4-132)/12: maximum possible tag count */
png.c:   if (temp >= 0xffff) /* The ICC limit */
png.c:   if (temp != 0x61637370)
png.c:    * expects to be able to change this in the future (despite the rationale in
png.c:    * the introduction for using a fixed PCS adopted white.)  Consequently the
png.c:    * handled.  However it it is clear that using an RGB profile in this context
png.c:      case 0x52474220: /* 'RGB ' */
png.c:      case 0x47524159: /* 'GRAY' */
png.c:      case 0x73636E72: /* 'scnr' */
png.c:      case 0x6D6E7472: /* 'mntr' */
png.c:      case 0x70727472: /* 'prtr' */
png.c:      case 0x73706163: /* 'spac' */
png.c:      case 0x61627374: /* 'abst' */
png.c:      case 0x6C696E6B: /* 'link' */
png.c:            "unexpected DeviceLink ICC profile class");
png.c:      case 0x6E6D636C: /* 'nmcl' */
png.c:            "unexpected NamedColor ICC profile class");
png.c:      case 0x58595A20: /* 'XYZ ' */
png.c:      case 0x4C616220: /* 'Lab ' */
png.c:            "unexpected ICC PCS encoding");
png.c:      /* The ICC specification does not exclude zero length tags, therefore the
png.c:   PNG_ICC_CHECKSUM(0x0a3fd9f6, 0x3b8772b9,
png.c:      PNG_MD5(0x29f83dde, 0xaff255ae, 0x7842fae4, 0xca83390d), 0, 0,
png.c:   PNG_ICC_CHECKSUM(0x4909e5e1, 0x427ebb21,
png.c:      PNG_MD5(0xc95bd637, 0xe95d8a3b, 0x0df38f99, 0xc1320389), 1, 0,
png.c:   PNG_ICC_CHECKSUM(0xfd2144a1, 0x306fd8ae,
png.c:      PNG_MD5(0xfc663378, 0x37e2886b, 0xfd72e983, 0x8228f1b8), 0, 0,
png.c:   PNG_ICC_CHECKSUM(0x209c35d2, 0xbbef7812,
png.c:      PNG_MD5(0x34562abf, 0x994ccd06, 0x6d2c5721, 0xd0d68c5d), 0, 0,
png.c:   PNG_ICC_CHECKSUM(0xa054d762, 0x5d5129ce,
png.c:      PNG_MD5(0x00000000, 0x00000000, 0x00000000, 0x00000000), 1, 0,
png.c:    * the previous profile except for the mediaWhitePointTag error and a missing
png.c:   PNG_ICC_CHECKSUM(0xf784f3fb, 0x182ea552,
png.c:      PNG_MD5(0x00000000, 0x00000000, 0x00000000, 0x00000000), 0, 1/*broken*/,
png.c:   PNG_ICC_CHECKSUM(0x0398f3fc, 0xf29e526d,
png.c:      PNG_MD5(0x00000000, 0x00000000, 0x00000000, 0x00000000), 1, 1/*broken*/,
png.c:   png_uint_32 intent = 0x10000; /* invalid */
png.c:      png_fixed_point r = png_ptr->colorspace.end_points_XYZ.red_Y;
png.c:      png_fixed_point g = png_ptr->colorspace.end_points_XYZ.green_Y;
png.c:      png_fixed_point b = png_ptr->colorspace.end_points_XYZ.blue_Y;
png.c:      png_fixed_point total = r+g+b;
png.c:       * bug is fixed.
png.c:/* This exists solely to work round a warning from GNU C. */
png.c:                   (PNG_SIZE_MAX >> 3) /* 8-byte RGBA pixels */
png.c:                   - 7*8               /* rounding width to multiple of 8 pix */
png.c:                   - 8))               /* extra max_pixel_depth pad */
png.c:       * maximum size is checked here.  Because the code in png_read_start_row
png.c:       * adds extra space "for safety's sake" in several places a conservative
png.c:       * extensive, therefore much more dangerous and much more difficult to
png.c:      if (width > png_ptr->user_width_max)
png.c:         png_warning(png_ptr, "Image width exceeds user limit in IHDR");
png.c:      if (height > png_ptr->user_height_max)
png.c:         png_warning(png_ptr, "Image height exceeds user limit in IHDR");
png.c:   /* Accept filter_method 64 (intrapixel differencing) only if
png.c:      /* First find the type of the next character */
png.c:   png_size_t char_index=0;
png.c:   if (png_check_fp_number(string, size, &state, &char_index) != 0 &&
png.c:      (char_index == size || string[char_index] == 0))
png.c: * exponent.
png.c:   /* Handle negative exponent with a reciprocal at the end because
png.c:    * 10 is exact whereas .1 is inexact in base 2
png.c:         int exp_b10;       /* A base 10 exponent */
png.c:         double base;   /* 10^exp_b10 */
png.c:         /* First extract a base 10 exponent of the number,
png.c:          * 0.3010, but 77/256 is 0.3008, so exp_b10 needs to
png.c:          * exponents.
png.c:         (void)frexp(fp, &exp_b10); /* exponent to base 2 */
png.c:         exp_b10 = (exp_b10 * 77) >> 8; /* <= exponent to base 10 */
png.c:         base = png_pow10(exp_b10); /* May underflow */
png.c:            double test = png_pow10(exp_b10+1);
png.c:               ++exp_b10, base = test;
png.c:         /* Normalize fp and correct exp_b10, after this fp is in the
png.c:          * range [.1,1) and exp_b10 is both the exponent and the digit
png.c:          * works even if 10^exp_b10 is out of range because of the
png.c:         while (fp >= 1) fp /= 10, ++exp_b10;
png.c:            char exponent[10];
png.c:            if (exp_b10 < 0 && exp_b10 > -3) /* PLUS 3 TOTAL 4 */
png.c:               czero = -exp_b10; /* PLUS 2 digits: TOTAL 3 */
png.c:               exp_b10 = 0;      /* Dot added below before first output. */
png.c:             * inserting a '.' before a digit if the exponent is 0.
png.c:                           if (exp_b10 != (-1))
png.c:                              ++exp_b10;
png.c:                              /* Advance exp_b10 to '1', so that the
png.c:                              exp_b10 = 1;
png.c:                         * exponent but take into account the leading
png.c:                           if (exp_b10 == (-1))
png.c:                                 ++size, exp_b10 = 1;
png.c:                              /* Else lost a leading zero, so 'exp_b10' is
png.c:                              ++exp_b10;
png.c:                     /* exp_b10 == (-1) means we just output the decimal
png.c:                      * place - after the DP don't adjust 'exp_b10' any
png.c:                     if (exp_b10 != (-1))
png.c:                        if (exp_b10 == 0) *ascii++ = 46, --size;
png.c:                        --exp_b10;
png.c:                  if (exp_b10 != (-1))
png.c:                     if (exp_b10 == 0)
png.c:                     --exp_b10;
png.c:            /* The total output count (max) is now 4+precision */
png.c:            /* Check for an exponent, if we don't need one we are
png.c:             * this point exp_b10==(-1) is effectively if flag - it got
png.c:             * the decimal point above (the exponent required is
png.c:            if (exp_b10 >= (-1) && exp_b10 <= 2)
png.c:                * leading zeros above for negative exponent, so this
png.c:               while (--exp_b10 >= 0) *ascii++ = 48;
png.c:            /* Here if an exponent is required, adjust size for
png.c:             * the signed arithmetic on exp_b10 and permits GCC at least to do
png.c:               unsigned int uexp_b10;
png.c:               if (exp_b10 < 0)
png.c:                  uexp_b10 = -exp_b10;
png.c:                  uexp_b10 = exp_b10;
png.c:               while (uexp_b10 > 0)
png.c:                  exponent[cdigits++] = (char)(48 + uexp_b10 % 10);
png.c:                  uexp_b10 /= 10;
png.c:            /* Need another size check here for the exponent digits, so
png.c:               while (cdigits > 0) *ascii++ = exponent[--cdigits];
png.c:/* Function to format a fixed point value in ASCII.
png.c:png_ascii_from_fixed(png_const_structrp png_ptr, png_charp ascii,
png.c:    png_size_t size, png_fixed_point fp)
png.c:      if (num <= 0x80000000) /* else overflowed */
png.c:             * starting at 1, it's not actually the array index.
png.c:png_fixed_point
png.c:png_fixed(png_const_structrp png_ptr, double fp, png_const_charp text)
png.c:      png_fixed_error(png_ptr, text);
png.c:      PNG_UNUSED(text)
png.c:   return (png_fixed_point)r;
png.c: * integer (or, for a fixed point number - the standard argument - to
png.c:png_muldiv(png_fixed_point_p res, png_fixed_point a, png_int_32 times,
png.c:         /* A png_fixed_point is a 32-bit integer. */
png.c:            *res = (png_fixed_point)r;
png.c:         s16 = (A >> 16) * (T & 0xffff) +
png.c:                           (A & 0xffff) * (T >> 16);
png.c:         s00 = (A & 0xffff) * (T & 0xffff);
png.c:         s16 = (s16 & 0xffff) << 16;
png.c:             * division, we know that s32 < D, so the maximum
png.c:            png_fixed_point result = 0; /* NOTE: signed */
png.c:png_fixed_point
png.c:png_muldiv_warn(png_const_structrp png_ptr, png_fixed_point a, png_int_32 times,
png.c:   png_fixed_point result;
png.c:   png_warning(png_ptr, "fixed point overflow ignored");
png.c:#ifdef PNG_GAMMA_SUPPORTED /* more fixed point functions for gamma */
png.c:png_fixed_point
png.c:png_reciprocal(png_fixed_point a)
png.c:      return (png_fixed_point)r;
png.c:   png_fixed_point res;
png.c:png_gamma_significant(png_fixed_point gamma_val)
png.c:static png_fixed_point
png.c:png_product2(png_fixed_point a, png_fixed_point b)
png.c:      return (png_fixed_point)r;
png.c:   png_fixed_point res;
png.c:png_fixed_point
png.c:png_reciprocal2(png_fixed_point a, png_fixed_point b)
png.c:      return (png_fixed_point)r;
png.c:   /* This may overflow because the range of png_fixed_point isn't symmetric,
png.c:   png_fixed_point res = png_product2(a, b);
png.c:/* Fixed point gamma.
png.c: * To calculate gamma this code implements fast log() and exp() calls using only
png.c: * fixed point arithmetic.  This code has sufficient precision for either 8-bit
png.c:png_log8bit(unsigned int x)
png.c:   /* Each time 'x' is multiplied by 2, 1 must be subtracted off the final log,
png.c:   if ((x &= 0xff) == 0)
png.c:   if ((x & 0xf0) == 0)
png.c:      lg2  = 4, x <<= 4;
png.c:   if ((x & 0xc0) == 0)
png.c:      lg2 += 2, x <<= 2;
png.c:   if ((x & 0x80) == 0)
png.c:      lg2 += 1, x <<= 1;
png.c:   return (png_int_32)((lg2 << 16) + ((png_8bit_l2[x-128]+32768)>>16));
png.c:/* The above gives exact (to 16 binary places) log2 values for 8-bit images,
png.c: * get an approximation then multiply the approximation by a correction factor
png.c: * This gives a final formula using a calculated value 'x' which is value/v' and
png.c: *   log2(x/257) * 65536
png.c:png_log16bit(png_uint_32 x)
png.c:   if ((x &= 0xffff) == 0)
png.c:   if ((x & 0xff00) == 0)
png.c:      lg2  = 8, x <<= 8;
png.c:   if ((x & 0xf000) == 0)
png.c:      lg2 += 4, x <<= 4;
png.c:   if ((x & 0xc000) == 0)
png.c:      lg2 += 2, x <<= 2;
png.c:   if ((x & 0x8000) == 0)
png.c:      lg2 += 1, x <<= 1;
png.c:   lg2 += (png_8bit_l2[(x>>8)-128]+8) >> 4;
png.c:    * 8 bits.  Do this with maximum precision.
png.c:   x = ((x << 16) + (x >> 9)) / (x >> 8);
png.c:   /* Since we divided by the top 8 bits of 'x' there will be a '1' at 1<<24,
png.c:    * the value at 1<<16 (ignoring this) will be 0 or 1; this gives us exactly
png.c:    * precision and that 'lg2' is current scaled by an extra 12 bits, so adjust
png.c:   x -= 1U << 24;
png.c:   if (x <= 65536U) /* <= '257' */
png.c:      lg2 += ((23591U * (65536U-x)) + (1U << (16+6-12-1))) >> (16+6-12);
png.c:      lg2 -= ((23499U * (x-65536U)) + (1U << (16+6-12-1))) >> (16+6-12);
png.c:/* The 'exp()' case must invert the above, taking a 20-bit fixed point
png.c: * To deal with this the following exp() function works out the exponent of the
png.c:png_32bit_exp[16] =
png.c:   /* NOTE: the first entry is deliberately set to the maximum 32-bit value. */
png.c:/* Adjustment table; provided to explain the numbers in the code below. */
png.c:png_exp(png_fixed_point x)
png.c:   if (x > 0 && x <= 0xfffff) /* Else overflow or zero (underflow) */
png.c:      /* Obtain a 4-bit approximation */
png.c:      png_uint_32 e = png_32bit_exp[(x >> 12) & 0xf];
png.c:      if (x & 0x800)
png.c:      if (x & 0x400)
png.c:      if (x & 0x200)
png.c:      if (x & 0x100)
png.c:      if (x & 0x080)
png.c:      if (x & 0x040)
png.c:      e -= (((e >> 16) * 355U * (x & 0x3fU)) + 256U) >> 9;
png.c:      /* Handle the upper bits of x. */
png.c:      e >>= x >> 16;
png.c:   if (x <= 0)
png.c:      return png_32bit_exp[0];
png.c:png_exp8bit(png_fixed_point lg2)
png.c:   png_uint_32 x = png_exp(lg2);
png.c:   x -= x >> 8;
png.c:   return (png_byte)((x + 0x7fffffU) >> 24);
png.c:png_exp16bit(png_fixed_point lg2)
png.c:   png_uint_32 x = png_exp(lg2);
png.c:   x -= x >> 16;
png.c:   return (png_uint_16)((x + 32767U) >> 16);
png.c:png_gamma_8bit_correct(unsigned int value, png_fixed_point gamma_val)
png.c:          * on some (ARM) but not all (x86) platforms, possibly because of
png.c:          * conformant and therefore compile spurious extra code for the large
png.c:         png_fixed_point res;
png.c:            return png_exp8bit(res);
png.c:png_gamma_16bit_correct(unsigned int value, png_fixed_point gamma_val)
png.c:         png_fixed_point res;
png.c:            return png_exp16bit(res);
png.c:    png_fixed_point gamma_val)
png.c:   PNG_CONST unsigned int shift, PNG_CONST png_fixed_point gamma_val)
png.c:   PNG_CONST double fmax = 1./(((png_int_32)1 << (16U - shift))-1);
png.c:   PNG_CONST unsigned int max = (1U << (16U - shift))-1U;
png.c:   PNG_CONST unsigned int max_by_2 = 1U << (15U-shift);
png.c:          * arithmetic error.  This code follows the spec exactly; ig is
png.c:          * We want input * 65535/max, rounded, the arithmetic fits in 32
png.c:          * bits (unsigned) so long as max <= 32767.
png.c:               /* Inline the 'max' scaling operation: */
png.c:               double d = floor(65535.*pow(ig*fmax, gamma_val*.00001)+.5);
png.c:                  ig = (ig * 65535U + max_by_2)/max;
png.c:               ig = (ig * 65535U + max_by_2)/max;
png.c:/* NOTE: this function expects the *inverse* of the overall gamma transformation
png.c:   PNG_CONST unsigned int shift, PNG_CONST png_fixed_point gamma_val)
png.c:   PNG_CONST unsigned int max = (1U << (16U - shift))-1U;
png.c:    * itself indexed by the high 8 bits of the value.
png.c:    * table entries <= 'max'
png.c:      /* Find the corresponding maximum input value */
png.c:      bound = (bound * max + 32768U)/65535U + 1U;
png.c:         table[last & (0xffU >> shift)][last >> (8U - shift)] = out;
png.c:      table[last & (0xff >> shift)][last >> (8U - shift)] = 65535U;
png.c:   PNG_CONST png_fixed_point gamma_val)
png.c:  /* Remove any existing table; this copes with multiple calls to
png.c:      *   ov = table[(iv & 0xff) >> gamma_shift][iv >> 8]
png.c:      * the color value then indexed by the upper 8 bits:
png.c:         * TODO: fix this.
png.c: * is used, not the gamma=1/2.2 approximation use elsewhere in libpng.
png.c: * The sRGB to linear table is exact (to the nearest 16 bit linear fraction).
png.c: *    error: -0.515566 - 0.625971, 79441 (0.475369%) of readings inexact
png.c: *    error: -0.513727 - 0.607759, 308 (0.469978%) of readings inexact
png.c: * In all cases the inexact readings are only off by one.
png.c:    * (if not inside an error handling context).  Otherwise assume
png.c:    * png_safe_execute will call this API after the return.
png.c:      (void)png_safe_execute(image, png_image_free_function, image);
pngconf.h: * starting here down to where it starts to typedef png_color, png_text,
pngconf.h: * expects conformant implementations, however, an ISOC90 conformant system need
pngconf.h: * PNG_NO_CONST; this is no longer supported except for data declarations which
pngconf.h: * can be used.  Some are fixed at build time (e.g. PNG_API_RULE
pngconf.h: * a function - it just does it - however on x86 systems derived from
pngconf.h: * libpng specifies the calling convention of every exported function and
pngconf.h: * PNGAPI    Calling convention for exported functions.
pngconf.h: *                please post an explanation of the problem to the
pngconf.h: * (x86 DOS/Windows sytems) and, even then, this does not apply to
pngconf.h:/* Symbol export
pngconf.h: * the compiler which symbols to export.  The png.h macro 'PNG_EXPORT'
pngconf.h: * extracted at link time and need no special processing by the compiler,
pngconf.h: * PNG_IMPEXP The magic (if any) to cause a symbol to be exported from
pngconf.h: *                make a symbol exported from the DLL.  Not used in the
pngconf.h:      (defined(__BORLANDC__) && __BORLANDC__ < 0x500)
pngconf.h:     * compilers used '__export' and required this to be after
pngconf.h:#    define PNG_DLL_EXPORT __export
pngconf.h:#    define PNG_DLL_EXPORT __declspec(dllexport)
pngconf.h:#  else /* !Windows/x86 && !OS/2 */
pngconf.h:#endif /* !Windows/x86 */
pngconf.h:        extern attributes)
pngconf.h:#      ifdef __has_extension
pngconf.h:#        if __has_extension(attribute_unavailable_with_message)
pngconf.h:             "This function is not exported by libpng.")))
pngconf.h:            __attribute__((warning("This function is not exported by libpng.")))
pngconf.h:#ifndef PNG_FIXED_EXPORT  /* A fixed point API. */
pngconf.h:#  else                   /* No fixed point APIs */
pngconf.h:/* libpng needs to know the maximum value of 'size_t' and this controls the
pngconf.h: * definition of png_alloc_size_t, below.  This maximum value of size_t limits
pngconf.h: * but does not control the maximum allocations the library makes - there is
pngconf.h: * png_uint_32) should be explicitly applied; however, we do not expect to
pngconf.h: * PNG_SMALL_SIZE_T must be defined if the maximum value of size_t is less than
pngconf.h: * 4294967295 - i.e. less than the maximum value of png_uint_32.
pngconf.h:/* Typedef for floating-point numbers that are converted to fixed-point with a
pngconf.h:typedef png_int_32 png_fixed_point;
pngconf.h:typedef png_fixed_point       * png_fixed_point_p;
pngconf.h:typedef const png_fixed_point * png_const_fixed_point_p;
pngconf.h:typedef png_fixed_point * * png_fixed_point_pp;
pngdebug.h: *   Expands to a statement (either a simple expression or a compound
pngdebug.h: *   is undefined, 0 or 1 every png_debug expands to a simple expression
pngdebug.h: *   message: a printf(3) style text string.  A trailing '\n' is added
pngdebug.h:#    define PNG_LITERAL_SHARP 0x23
pngdebug.h:#    define PNG_LITERAL_LEFT_SQUARE_BRACKET 0x5b
pngdebug.h:#    define PNG_LITERAL_RIGHT_SQUARE_BRACKET 0x5d
pngerror.c: * need special error handling are expected to write replacement functions
pngerror.c:   /* If the custom handler doesn't exist, or if it returns,
pngerror.c:   /* Prior to 1.5.2 the error_fn received a NULL pointer, expressed
pngerror.c:   /* If the custom handler doesn't exist, or if it returns,
pngerror.c:   int output = 0;   /* digit output (for the fixed point format) */
pngerror.c:         case PNG_NUMBER_FORMAT_fixed:
pngerror.c:            /* Expects at least 2 digits. */
pngerror.c:         case PNG_NUMBER_FORMAT_02x:
pngerror.c:            /* This format expects at least two digits */
pngerror.c:         case PNG_NUMBER_FORMAT_x:
pngerror.c:            *--end = digits[number & 0xf];
pngerror.c:      /* Float a fixed number here: */
pngerror.c:      if ((format == PNG_NUMBER_FORMAT_fixed) && (count == 5) && (end > start))
pngerror.c:   size_t i = 0; /* Index in the msg[] buffer: */
pngerror.c:         /* Search for the parameter digit, the index in the string is the
pngerror.c: * which is used to prefix the message.  The message is limited in length
pngerror.c: * to 63 bytes. The name characters are output as hex digits wrapped in []
pngerror.c:      int c = (int)(chunk_name >> ishift) & 0xff;
pngerror.c:         buffer[iout++] = png_digit[(c & 0xf0) >> 4];
pngerror.c:         buffer[iout++] = png_digit[c & 0x0f];
pngerror.c:png_fixed_error,(png_const_structrp png_ptr, png_const_charp name),PNG_NORETURN)
pngerror.c:#  define fixed_message "fixed point overflow in "
pngerror.c:#  define fixed_message_ln ((sizeof fixed_message)-1)
pngerror.c:   char msg[fixed_message_ln+PNG_MAX_ERROR_TEXT];
pngerror.c:   memcpy(msg, fixed_message, fixed_message_ln);
pngerror.c:         msg[fixed_message_ln + iin] = name[iin];
pngerror.c:   msg[fixed_message_ln + iin] = 0;
pngerror.c:/* This API only exists if ANSI-C style error handling is used,
pngerror.c:             * control.  It's always possible to fix this up, but for the moment
pngerror.c:png_safe_execute(png_imagep image_in, int (*function)(png_voidp), png_voidp arg)
pngerror.c:   /* Safely execute function(arg) with png_error returning to this function. */
Binary file pngerror.o matches
Binary file pngfix matches
Binary file png-fix-itxt matches
pngget.c:png_get_x_pixels_per_meter(png_const_structrp png_ptr, png_const_inforp
pngget.c:             "png_get_x_pixels_per_meter");
pngget.c:            return (info_ptr->x_pixels_per_unit);
pngget.c:png_get_y_pixels_per_meter(png_const_structrp png_ptr, png_const_inforp
pngget.c:          "png_get_y_pixels_per_meter");
pngget.c:         return (info_ptr->y_pixels_per_unit);
pngget.c:png_get_pixels_per_meter(png_const_structrp png_ptr, png_const_inforp info_ptr)
pngget.c:      png_debug1(1, "in %s retrieval function", "png_get_pixels_per_meter");
pngget.c:          info_ptr->x_pixels_per_unit == info_ptr->y_pixels_per_unit)
pngget.c:         return (info_ptr->x_pixels_per_unit);
pngget.c:png_get_pixel_aspect_ratio(png_const_structrp png_ptr, png_const_inforp
pngget.c:      if (info_ptr->x_pixels_per_unit != 0)
pngget.c:         return ((float)((float)info_ptr->y_pixels_per_unit
pngget.c:             /(float)info_ptr->x_pixels_per_unit));
pngget.c:png_fixed_point PNGAPI
pngget.c:png_get_pixel_aspect_ratio_fixed(png_const_structrp png_ptr,
pngget.c:       info_ptr->x_pixels_per_unit > 0 && info_ptr->y_pixels_per_unit > 0 &&
pngget.c:       info_ptr->x_pixels_per_unit <= PNG_UINT_31_MAX &&
pngget.c:       info_ptr->y_pixels_per_unit <= PNG_UINT_31_MAX)
pngget.c:      png_fixed_point res;
pngget.c:      png_debug1(1, "in %s retrieval function", "png_get_aspect_ratio_fixed");
pngget.c:      if (png_muldiv(&res, (png_int_32)info_ptr->y_pixels_per_unit, PNG_FP_1,
pngget.c:          (png_int_32)info_ptr->x_pixels_per_unit) != 0)
pngget.c:png_get_x_offset_microns(png_const_structrp png_ptr, png_const_inforp info_ptr)
pngget.c:      png_debug1(1, "in %s retrieval function", "png_get_x_offset_microns");
pngget.c:         return (info_ptr->x_offset);
pngget.c:png_get_x_offset_pixels(png_const_structrp png_ptr, png_const_inforp info_ptr)
pngget.c:      png_debug1(1, "in %s retrieval function", "png_get_x_offset_pixels");
pngget.c:         return (info_ptr->x_offset);
pngget.c:png_get_y_offset_pixels(png_const_structrp png_ptr, png_const_inforp info_ptr)
pngget.c:      png_debug1(1, "in %s retrieval function", "png_get_y_offset_pixels");
pngget.c:   png_fixed_point result;
pngget.c:png_get_pixels_per_inch(png_const_structrp png_ptr, png_const_inforp info_ptr)
pngget.c:   return ppi_from_ppm(png_get_pixels_per_meter(png_ptr, info_ptr));
pngget.c:png_get_x_pixels_per_inch(png_const_structrp png_ptr, png_const_inforp info_ptr)
pngget.c:   return ppi_from_ppm(png_get_x_pixels_per_meter(png_ptr, info_ptr));
pngget.c:png_get_y_pixels_per_inch(png_const_structrp png_ptr, png_const_inforp info_ptr)
pngget.c:   return ppi_from_ppm(png_get_y_pixels_per_meter(png_ptr, info_ptr));
pngget.c:static png_fixed_point
pngget.c:png_fixed_inches_from_microns(png_const_structrp png_ptr, png_int_32 microns)
pngget.c:png_fixed_point PNGAPI
pngget.c:png_get_x_offset_inches_fixed(png_const_structrp png_ptr,
pngget.c:   return png_fixed_inches_from_microns(png_ptr,
pngget.c:       png_get_x_offset_microns(png_ptr, info_ptr));
pngget.c:png_fixed_point PNGAPI
pngget.c:png_get_y_offset_inches_fixed(png_const_structrp png_ptr,
pngget.c:   return png_fixed_inches_from_microns(png_ptr,
pngget.c:png_get_x_offset_inches(png_const_structrp png_ptr, png_const_inforp info_ptr)
pngget.c:   return (float)(png_get_x_offset_microns(png_ptr, info_ptr) * .00003937);
pngget.c:    png_uint_32 *res_x, png_uint_32 *res_y, int *unit_type)
pngget.c:      if (res_x != NULL)
pngget.c:         *res_x = info_ptr->x_pixels_per_unit;
pngget.c:         *res_y = info_ptr->y_pixels_per_unit;
pngget.c:            if (res_x != NULL) *res_x = (png_uint_32)(*res_x * .0254 + .50);
pngget.c:    double *white_x, double *white_y, double *red_x, double *red_y,
pngget.c:    double *green_x, double *green_y, double *blue_x, double *blue_y)
pngget.c:      if (white_x != NULL)
pngget.c:         *white_x = png_float(png_ptr,
pngget.c:            info_ptr->colorspace.end_points_xy.whitex, "cHRM white X");
pngget.c:            info_ptr->colorspace.end_points_xy.whitey, "cHRM white Y");
pngget.c:      if (red_x != NULL)
pngget.c:         *red_x = png_float(png_ptr, info_ptr->colorspace.end_points_xy.redx,
pngget.c:         *red_y = png_float(png_ptr, info_ptr->colorspace.end_points_xy.redy,
pngget.c:      if (green_x != NULL)
pngget.c:         *green_x = png_float(png_ptr,
pngget.c:            info_ptr->colorspace.end_points_xy.greenx, "cHRM green X");
pngget.c:            info_ptr->colorspace.end_points_xy.greeny, "cHRM green Y");
pngget.c:      if (blue_x != NULL)
pngget.c:         *blue_x = png_float(png_ptr, info_ptr->colorspace.end_points_xy.bluex,
pngget.c:         *blue_y = png_float(png_ptr, info_ptr->colorspace.end_points_xy.bluey,
pngget.c:png_get_cHRM_XYZ_fixed(png_const_structrp png_ptr, png_const_inforp info_ptr,
pngget.c:    png_fixed_point *int_red_X, png_fixed_point *int_red_Y,
pngget.c:    png_fixed_point *int_red_Z, png_fixed_point *int_green_X,
pngget.c:    png_fixed_point *int_green_Y, png_fixed_point *int_green_Z,
pngget.c:    png_fixed_point *int_blue_X, png_fixed_point *int_blue_Y,
pngget.c:    png_fixed_point *int_blue_Z)
pngget.c:png_get_cHRM_fixed(png_const_structrp png_ptr, png_const_inforp info_ptr,
pngget.c:    png_fixed_point *white_x, png_fixed_point *white_y, png_fixed_point *red_x,
pngget.c:    png_fixed_point *red_y, png_fixed_point *green_x, png_fixed_point *green_y,
pngget.c:    png_fixed_point *blue_x, png_fixed_point *blue_y)
pngget.c:      if (white_x != NULL)
pngget.c:         *white_x = info_ptr->colorspace.end_points_xy.whitex;
pngget.c:         *white_y = info_ptr->colorspace.end_points_xy.whitey;
pngget.c:      if (red_x != NULL)
pngget.c:         *red_x = info_ptr->colorspace.end_points_xy.redx;
pngget.c:         *red_y = info_ptr->colorspace.end_points_xy.redy;
pngget.c:      if (green_x != NULL)
pngget.c:         *green_x = info_ptr->colorspace.end_points_xy.greenx;
pngget.c:         *green_y = info_ptr->colorspace.end_points_xy.greeny;
pngget.c:      if (blue_x != NULL)
pngget.c:         *blue_x = info_ptr->colorspace.end_points_xy.bluex;
pngget.c:         *blue_y = info_ptr->colorspace.end_points_xy.bluey;
pngget.c:png_get_gAMA_fixed(png_const_structrp png_ptr, png_const_inforp info_ptr,
pngget.c:    png_fixed_point *file_gamma)
pngget.c:    png_int_32 *offset_x, png_int_32 *offset_y, int *unit_type)
pngget.c:       offset_x != NULL && offset_y != NULL && unit_type != NULL)
pngget.c:      *offset_x = info_ptr->x_offset;
pngget.c:png_get_sCAL_fixed(png_const_structrp png_ptr, png_const_inforp info_ptr,
pngget.c:    int *unit, png_fixed_point *width, png_fixed_point *height)
pngget.c:      *width = png_fixed(png_ptr, atof(info_ptr->scal_s_width), "sCAL width");
pngget.c:      *height = png_fixed(png_ptr, atof(info_ptr->scal_s_height),
pngget.c:    png_uint_32 *res_x, png_uint_32 *res_y, int *unit_type)
pngget.c:      if (res_x != NULL)
pngget.c:         *res_x = info_ptr->x_pixels_per_unit;
pngget.c:         *res_y = info_ptr->y_pixels_per_unit;
pngget.c:png_get_text(png_const_structrp png_ptr, png_inforp info_ptr,
pngget.c:    png_textp *text_ptr, int *num_text)
pngget.c:   if (png_ptr != NULL && info_ptr != NULL && info_ptr->num_text > 0)
pngget.c:      png_debug1(1, "in 0x%lx retrieval function",
pngget.c:      if (text_ptr != NULL)
pngget.c:         *text_ptr = info_ptr->text;
pngget.c:      if (num_text != NULL)
pngget.c:         *num_text = info_ptr->num_text;
pngget.c:      return info_ptr->num_text;
pngget.c:   if (num_text != NULL)
pngget.c:      *num_text = 0;
pngget.c:png_get_user_width_max (png_const_structrp png_ptr)
pngget.c:   return (png_ptr ? png_ptr->user_width_max : 0);
pngget.c:png_get_user_height_max (png_const_structrp png_ptr)
pngget.c:   return (png_ptr ? png_ptr->user_height_max : 0);
pngget.c:png_get_chunk_cache_max (png_const_structrp png_ptr)
pngget.c:   return (png_ptr ? png_ptr->user_chunk_cache_max : 0);
pngget.c:png_get_chunk_malloc_max (png_const_structrp png_ptr)
pngget.c:   return (png_ptr ? png_ptr->user_chunk_malloc_max : 0);
pngget.c:png_get_palette_max(png_const_structp png_ptr, png_const_infop info_ptr)
pngget.c:      return png_ptr->num_palette_max;
Binary file pngget.o matches
png.h: *    1.0.2a-b                      10003  version, except as noted.
png.h: *    1.0.6h                        10007  10.6h (testing xy.z so-numbering)
png.h: *   for applications, is an unsigned integer of the form xyyzz corresponding
png.h: *   to the source version x.y.z (leading zeros in y and z).  Beta versions
png.h: *   Binary incompatibility exists only when applications make direct access
png.h: * See libpng-manual.txt or libpng.3 for more information.  The PNG
png.h: *    Simon-Pierre Cadieux
png.h: * and Group 42, Inc. disclaim all warranties, expressed or implied,
png.h: * assume no liability for direct, indirect, incidental, special, exemplary,
png.h: * boxes and the like:
png.h: * files "pngbar.png" and "pngbar.jpg (88x31) and "pngnow.png" (98x31).
png.h: * with testing, bug fixes, and patience.  This wouldn't have been
png.h: *    holds the date in text format, and will hold years up to 9999.
png.h: *    in libpng-1.6.x and will be removed from libpng-1.7.0.
png.h: *          (formerly png_convert_to_rfc_1123() prior to libpng-1.5.x and
png.h:/* This is not the place to learn how to use libpng. The file libpng-manual.txt
png.h: * describes how to use libpng, and the file example.c summarizes it
png.h: * <http://www.libpng.org/pub/png/libpng-manual.txt>
png.h: * version 1.0.1 it's    xxyyzz, where x=major, y=minor, z=release
png.h:extern "C" {
png.h: * 3. Exported library functions.
png.h: * Use macros to read integers from PNG data or use the exported
png.h:/* Basic control structions.  Read libpng-manual.txt or libpng.3 for more info.
png.h: * or more of these must exist while reading or creating a PNG file.  The
png.h: * applications.  Read libpng-manual.txt or libpng.3 for more info.
png.h: * names ending 'rp' are identical pointer types except that the pointer is
png.h: * consequentially, writing portable application code is extremely difficult if
png.h: * exact size) is not important, although the size of the fields need to
png.h:   png_byte index;    /* used for palette files */
png.h:/* png_text holds the contents of a text/ztxt/itxt chunk in a PNG file,
png.h: * points to a regular zero-terminated C string.  The "text" fields can be a
png.h: * However, the structure returned by png_get_text() will always contain
png.h: * the "text" field as a regular zero-terminated C string (possibly
png.h: * other string-handling functions.  Note that the "itxt_length", "lang", and
png.h: * "lang_key" members of the structure only exist when the library is built
png.h:typedef struct png_text_struct
png.h:   png_charp key;          /* keyword, 1-79 character description of "text" */
png.h:   png_charp text;         /* comment, may be an empty string (ie "")
png.h:   png_size_t text_length; /* length of the text string */
png.h:   png_size_t itxt_length; /* length of the itxt string */
png.h:} png_text;
png.h:typedef png_text * png_textp;
png.h:typedef const png_text * png_const_textp;
png.h:typedef png_text * * png_textpp;
png.h:/* Supported compression types for text in PNG files (tEXt, and zTXt).
png.h:    png_byte name[5]; /* Textual chunk name with '\0' terminator */
png.h:#define PNG_HAVE_IHDR  0x01
png.h:#define PNG_HAVE_PLTE  0x02
png.h:#define PNG_AFTER_IDAT 0x08
png.h:/* Maximum positive integer used in PNG is (2^31)-1 */
png.h:#define PNG_UINT_31_MAX ((png_uint_32)0x7fffffffL)
png.h:/* These are constants for fixed point values encoded in the
png.h: * PNG specification manner (x100000)
png.h:#define PNG_FP_MAX  ((png_fixed_point)0x7fffffffL)
png.h:#define PNG_OFFSET_PIXEL          0 /* Offset in pixels */
png.h:#define PNG_EQUATION_BASE_E       1 /* Exponential base e transform */
png.h:#define PNG_EQUATION_ARBITRARY    2 /* Arbitrary base exponential transform */
png.h:#define PNG_SCALE_METER           1 /* meters per pixel */
png.h:#define PNG_SCALE_RADIAN          2 /* radians per pixel */
png.h:#define PNG_RESOLUTION_UNKNOWN    0 /* pixels/unknown unit (aspect ratio) */
png.h:#define PNG_RESOLUTION_METER      1 /* pixels/meter */
png.h:/* This is for text chunks */
png.h:/* Maximum number of entries in PLTE/sPLT/tRNS arrays */
png.h:#define PNG_INFO_gAMA 0x0001
png.h:#define PNG_INFO_sBIT 0x0002
png.h:#define PNG_INFO_cHRM 0x0004
png.h:#define PNG_INFO_PLTE 0x0008
png.h:#define PNG_INFO_tRNS 0x0010
png.h:#define PNG_INFO_bKGD 0x0020
png.h:#define PNG_INFO_hIST 0x0040
png.h:#define PNG_INFO_pHYs 0x0080
png.h:#define PNG_INFO_oFFs 0x0100
png.h:#define PNG_INFO_tIME 0x0200
png.h:#define PNG_INFO_pCAL 0x0400
png.h:#define PNG_INFO_sRGB 0x0800   /* GR-P, 0.96a */
png.h:#define PNG_INFO_iCCP 0x1000   /* ESR, 1.0.6 */
png.h:#define PNG_INFO_sPLT 0x2000   /* ESR, 1.0.6 */
png.h:#define PNG_INFO_sCAL 0x4000   /* ESR, 1.0.6 */
png.h:#define PNG_INFO_IDAT 0x8000   /* ESR, 1.0.6 */
png.h:   png_byte pixel_depth; /* bits per pixel (depth * channels) */
png.h: * expected to return the read data in the buffer.
png.h: * then reset to 0 for the next pass.
png.h: * find the output pixel (x,y) given an interlaced sub-image pixel
png.h:#define PNG_TRANSFORM_IDENTITY       0x0000    /* read and write */
png.h:#define PNG_TRANSFORM_STRIP_16       0x0001    /* read only */
png.h:#define PNG_TRANSFORM_STRIP_ALPHA    0x0002    /* read only */
png.h:#define PNG_TRANSFORM_PACKING        0x0004    /* read and write */
png.h:#define PNG_TRANSFORM_PACKSWAP       0x0008    /* read and write */
png.h:#define PNG_TRANSFORM_EXPAND         0x0010    /* read only */
png.h:#define PNG_TRANSFORM_INVERT_MONO    0x0020    /* read and write */
png.h:#define PNG_TRANSFORM_SHIFT          0x0040    /* read and write */
png.h:#define PNG_TRANSFORM_BGR            0x0080    /* read and write */
png.h:#define PNG_TRANSFORM_SWAP_ALPHA     0x0100    /* read and write */
png.h:#define PNG_TRANSFORM_SWAP_ENDIAN    0x0200    /* read and write */
png.h:#define PNG_TRANSFORM_INVERT_ALPHA   0x0400    /* read and write */
png.h:#define PNG_TRANSFORM_STRIP_FILLER   0x0800    /* write only */
png.h:#define PNG_TRANSFORM_STRIP_FILLER_AFTER 0x1000 /* write only */
png.h:#define PNG_TRANSFORM_GRAY_TO_RGB   0x2000      /* read only */
png.h:#define PNG_TRANSFORM_EXPAND_16     0x4000      /* read only */
png.h:#define PNG_TRANSFORM_SCALE_16      0x8000      /* read only */
png.h:#define PNG_FLAG_MNG_EMPTY_PLTE     0x01
png.h:#define PNG_FLAG_MNG_FILTER_64      0x04
png.h:#define PNG_ALL_MNG_FEATURES        0x05
png.h:/* Section 3: exported functions
png.h: * the place to find out how to use libpng.  See libpng-manual.txt for the
png.h: * full explanation, see example.c for the summary.  This just provides
png.h:/* Expand data to 24-bit RGB, or 8-bit grayscale, with alpha if available. */
png.h:PNG_EXPORT(26, void, png_set_expand, (png_structrp png_ptr));
png.h:PNG_EXPORT(27, void, png_set_expand_gray_1_2_4_to_8, (png_structrp png_ptr));
png.h:/* Expand to 16-bit channels, forces conversion of palette to RGB and expansion
png.h:PNG_EXPORT(221, void, png_set_expand_16, (png_structrp png_ptr));
png.h:/* Use blue, green, red order for pixels. */
png.h:/* Expand the grayscale to 24-bit RGB if necessary. */
png.h:PNG_FIXED_EXPORT(33, void, png_set_rgb_to_gray_fixed, (png_structrp png_ptr,
png.h:    int error_action, png_fixed_point red, png_fixed_point green))
png.h: * This has no effect on the way pixels are written into a PNG output
png.h: * channel is a linear measure of the contribution of the pixel to the
png.h: * corresponding composited pixel, and the color channels are unassociated
png.h: * For the 'OPTIMIZED' mode, a pixel is treated as opaque only if the alpha
png.h: * value is equal to the maximum value.
png.h:#define PNG_ALPHA_OPTIMIZED     2 /* 'PNG' for opaque pixels, else 'STANDARD' */
png.h:PNG_FIXED_EXPORT(228, void, png_set_alpha_mode_fixed, (png_structrp png_ptr,
png.h:    int mode, png_fixed_point output_gamma))
png.h:/* The output_gamma value is a screen gamma in libpng terminology: it expresses
png.h:/* The following are examples of calls to png_set_alpha_mode to achieve the
png.h: * png_set_expand_16(pp);
png.h: *    If you just need to composite the PNG image onto an existing background
png.h: *    setting.  In this case you just copy completely opaque pixels to the
png.h: *    output.  For pixels that are not completely transparent (you just skip
png.h: *    your hardware/software fixed!  (The OPTIMIZED approach is slightly
png.h:/* Use 1 byte per pixel in 1, 2, or 4-bit depth files. */
png.h:/* Swap packing order of pixels in bytes. */
png.h: * read.  Doing so will result in unexpected behavior and possible warnings or
png.h:    int need_expand, double background_gamma))
png.h:PNG_FIXED_EXPORT(215, void, png_set_background_fixed, (png_structrp png_ptr,
png.h:    int need_expand, png_fixed_point background_gamma))
png.h:    png_colorp palette, int num_palette, int maximum_colors,
png.h:/* Handle gamma correction. Screen_gamma=(display_exponent).
png.h: * API (floating point or fixed.)  Notice, however, that the 'file_gamma' value
png.h:PNG_FIXED_EXPORT(208, void, png_set_gamma_fixed, (png_structrp png_ptr,
png.h:    png_fixed_point screen_gamma, png_fixed_point override_file_gamma))
png.h: * expense of compression can modify them.  See the compression library
png.h: * header file (zlib.h) for an explination of the compression functions.
png.h:#define PNG_NO_FILTERS     0x00
png.h:#define PNG_FILTER_NONE    0x08
png.h:#define PNG_FILTER_SUB     0x10
png.h:#define PNG_FILTER_UP      0x20
png.h:#define PNG_FILTER_AVG     0x40
png.h:#define PNG_FILTER_PAETH   0x80
png.h: * the experimental method (weighted-minimum-sum-of-absolute-differences).
png.h: * filter type.  Higher costs indicate more decoding expense, and are
png.h:PNG_FIXED_EXPORT(209, void, png_set_filter_heuristics_fixed,
png.h:    png_const_fixed_point_p filter_weights,
png.h:    png_const_fixed_point_p filter_costs))
png.h:#define PNG_FILTER_HEURISTIC_WEIGHTED   2  /* Experimental feature */
png.h: * (0 - no compression, 9 - "maximal" compression).  Note that tests have
png.h:PNG_EXPORT(222, void, png_set_text_compression_level, (png_structrp png_ptr,
png.h:PNG_EXPORT(223, void, png_set_text_compression_mem_level, (png_structrp png_ptr,
png.h:PNG_EXPORT(224, void, png_set_text_compression_strategy, (png_structrp png_ptr,
png.h:PNG_EXPORT(225, void, png_set_text_compression_window_bits,
png.h:PNG_EXPORT(226, void, png_set_text_compression_method, (png_structrp png_ptr,
png.h:/* These next functions are called for input/output, memory, and error
png.h: * different manner by calling png_set_???_fn().  See libpng-manual.txt for
png.h: * APIs do not fail but will return unexpected results if called outside a user
png.h: * then reset to 0 for the next pass.
png.h: * find the output pixel (x,y) given an interlaced sub-image pixel
png.h: * remaining, excluding any that libpng has cached internally.  A subsequent
png.h: * following data to the next call to png_process_data.
png.h:/* Reassign responsibility for freeing existing data, whether allocated
png.h:#define PNG_FREE_HIST 0x0008
png.h:#define PNG_FREE_ICCP 0x0010
png.h:#define PNG_FREE_SPLT 0x0020
png.h:#define PNG_FREE_ROWS 0x0040
png.h:#define PNG_FREE_PCAL 0x0080
png.h:#define PNG_FREE_SCAL 0x0100
png.h:#  define PNG_FREE_UNKN 0x0200
png.h:/*      PNG_FREE_LIST 0x0400    removed in 1.6.0 because it is ignored */
png.h:#define PNG_FREE_PLTE 0x1000
png.h:#define PNG_FREE_TRNS 0x2000
png.h:#define PNG_FREE_TEXT 0x4000
png.h:#define PNG_FREE_ALL  0x7fff
png.h:#define PNG_FREE_MUL  0x4220 /* PNG_FREE_SPLT|PNG_FREE_TEXT|PNG_FREE_UNKN */
png.h:/* Returns image width in pixels. */
png.h:/* Returns image height in pixels. */
png.h:/* Returns image resolution in pixels per meter, from pHYs chunk data. */
png.h:PNG_EXPORT(122, png_uint_32, png_get_pixels_per_meter,
png.h:PNG_EXPORT(123, png_uint_32, png_get_x_pixels_per_meter,
png.h:PNG_EXPORT(124, png_uint_32, png_get_y_pixels_per_meter,
png.h:/* Returns pixel aspect ratio, computed from pHYs chunk data.  */
png.h:PNG_FP_EXPORT(125, float, png_get_pixel_aspect_ratio,
png.h:PNG_FIXED_EXPORT(210, png_fixed_point, png_get_pixel_aspect_ratio_fixed,
png.h:/* Returns image x, y offset in pixels or microns, from oFFs chunk data. */
png.h:PNG_EXPORT(126, png_int_32, png_get_x_offset_pixels,
png.h:PNG_EXPORT(127, png_int_32, png_get_y_offset_pixels,
png.h:PNG_EXPORT(128, png_int_32, png_get_x_offset_microns,
png.h:    png_const_inforp info_ptr, double *white_x, double *white_y, double *red_x,
png.h:    double *red_y, double *green_x, double *green_y, double *blue_x,
png.h:PNG_FIXED_EXPORT(134, png_uint_32, png_get_cHRM_fixed,
png.h:    png_fixed_point *int_white_x, png_fixed_point *int_white_y,
png.h:    png_fixed_point *int_red_x, png_fixed_point *int_red_y,
png.h:    png_fixed_point *int_green_x, png_fixed_point *int_green_y,
png.h:    png_fixed_point *int_blue_x, png_fixed_point *int_blue_y))
png.h:PNG_FIXED_EXPORT(231, png_uint_32, png_get_cHRM_XYZ_fixed,
png.h:    png_fixed_point *int_red_X, png_fixed_point *int_red_Y,
png.h:    png_fixed_point *int_red_Z, png_fixed_point *int_green_X,
png.h:    png_fixed_point *int_green_Y, png_fixed_point *int_green_Z,
png.h:    png_fixed_point *int_blue_X, png_fixed_point *int_blue_Y,
png.h:    png_fixed_point *int_blue_Z))
png.h:    double white_x, double white_y, double red_x, double red_y, double green_x,
png.h:    double green_y, double blue_x, double blue_y))
png.h:PNG_FIXED_EXPORT(136, void, png_set_cHRM_fixed, (png_const_structrp png_ptr,
png.h:    png_inforp info_ptr, png_fixed_point int_white_x,
png.h:    png_fixed_point int_white_y, png_fixed_point int_red_x,
png.h:    png_fixed_point int_red_y, png_fixed_point int_green_x,
png.h:    png_fixed_point int_green_y, png_fixed_point int_blue_x,
png.h:    png_fixed_point int_blue_y))
png.h:PNG_FIXED_EXPORT(233, void, png_set_cHRM_XYZ_fixed, (png_const_structrp png_ptr,
png.h:    png_inforp info_ptr, png_fixed_point int_red_X, png_fixed_point int_red_Y,
png.h:    png_fixed_point int_red_Z, png_fixed_point int_green_X,
png.h:    png_fixed_point int_green_Y, png_fixed_point int_green_Z,
png.h:    png_fixed_point int_blue_X, png_fixed_point int_blue_Y,
png.h:    png_fixed_point int_blue_Z))
png.h:PNG_FIXED_EXPORT(138, png_uint_32, png_get_gAMA_fixed,
png.h:    png_fixed_point *int_file_gamma))
png.h:PNG_FIXED_EXPORT(140, void, png_set_gAMA_fixed, (png_const_structrp png_ptr,
png.h:    png_inforp info_ptr, png_fixed_point int_file_gamma))
png.h:   png_const_inforp info_ptr, png_int_32 *offset_x, png_int_32 *offset_y,
png.h:    png_inforp info_ptr, png_int_32 offset_x, png_int_32 offset_y,
png.h:    png_const_inforp info_ptr, png_uint_32 *res_x, png_uint_32 *res_y,
png.h:    png_inforp info_ptr, png_uint_32 res_x, png_uint_32 res_y, int unit_type));
png.h:/* png_get_text also returns the number of text chunks in *num_text */
png.h:PNG_EXPORT(162, int, png_get_text, (png_const_structrp png_ptr,
png.h:    png_inforp info_ptr, png_textp *text_ptr, int *num_text));
png.h:/* Note while png_set_text() will accept a structure whose text,
png.h: * returned by png_get_text will always contain regular
png.h:PNG_EXPORT(163, void, png_set_text, (png_const_structrp png_ptr,
png.h:    png_inforp info_ptr, png_const_textp text_ptr, int num_text));
png.h: * In any case the range of values supported by png_fixed_point is small and it
png.h:PNG_FIXED_EXPORT(214, png_uint_32, png_get_sCAL_fixed,
png.h:    png_fixed_point *width, png_fixed_point *height))
png.h:PNG_FIXED_EXPORT(213, void, png_set_sCAL_fixed, (png_const_structrp png_ptr,
png.h:   png_inforp info_ptr, int unit, png_fixed_point width,
png.h:   png_fixed_point height))
png.h: *    except for the IHDR, PLTE, tRNS, IDAT, and IEND chunks (which continue to
png.h:    * invariably the wrong value on write.  To fix this call the following API
png.h:/* The "params" pointer is currently not used and is for future expansion. */
png.h:    png_uint_32 user_width_max, png_uint_32 user_height_max));
png.h:PNG_EXPORT(187, png_uint_32, png_get_user_width_max,
png.h:PNG_EXPORT(188, png_uint_32, png_get_user_height_max,
png.h:PNG_EXPORT(189, void, png_set_chunk_cache_max, (png_structrp png_ptr,
png.h:    png_uint_32 user_chunk_cache_max));
png.h:PNG_EXPORT(190, png_uint_32, png_get_chunk_cache_max,
png.h:PNG_EXPORT(191, void, png_set_chunk_malloc_max, (png_structrp png_ptr,
png.h:    png_alloc_size_t user_chunk_cache_max));
png.h:PNG_EXPORT(192, png_alloc_size_t, png_get_chunk_malloc_max,
png.h:PNG_EXPORT(193, png_uint_32, png_get_pixels_per_inch,
png.h:PNG_EXPORT(194, png_uint_32, png_get_x_pixels_per_inch,
png.h:PNG_EXPORT(195, png_uint_32, png_get_y_pixels_per_inch,
png.h:PNG_FP_EXPORT(196, float, png_get_x_offset_inches,
png.h:PNG_FIXED_EXPORT(211, png_fixed_point, png_get_x_offset_inches_fixed,
png.h:PNG_FIXED_EXPORT(212, png_fixed_point, png_get_y_offset_inches_fixed,
png.h:    png_const_inforp info_ptr, png_uint_32 *res_x, png_uint_32 *res_y,
png.h:#  define PNG_IO_NONE        0x0000   /* no I/O at this moment */
png.h:#  define PNG_IO_READING     0x0001   /* currently reading */
png.h:#  define PNG_IO_WRITING     0x0002   /* currently writing */
png.h:#  define PNG_IO_SIGNATURE   0x0010   /* currently at the file signature */
png.h:#  define PNG_IO_CHUNK_HDR   0x0020   /* currently at the chunk header */
png.h:#  define PNG_IO_CHUNK_DATA  0x0040   /* currently at the chunk data */
png.h:#  define PNG_IO_CHUNK_CRC   0x0080   /* currently at the chunk crc */
png.h:#  define PNG_IO_MASK_OP     0x000f   /* current operation: reading/writing */
png.h:#  define PNG_IO_MASK_LOC    0x00f0   /* current location: sig/hdr/data/crc */
png.h:/* A macro to return the offset between pixels in the output row for a pair of
png.h: * pixels in the input - effectively the inverse of the 'COL_SHIFT' macro that
png.h: * follows.  Note that ROW_OFFSET is the offset from one row to the next whereas
png.h: * COL_OFFSET is from one column to the next, within a row.
png.h: * pass.  This is expressed as a shift - effectively log2 of the number or
png.h: * rows or columns in each 8x8 tile of the original image.
png.h:#define PNG_COL_FROM_PASS_COL(x_in, pass) \
png.h:   (((x_in)<<PNG_PASS_COL_SHIFT(pass))+PNG_PASS_START_COL(pass))
png.h:   ((0x110145AF>>(((7-(off))-(pass))<<2)) & 0xF) | \
png.h:   ((0x01145AF0>>(((7-(off))-(pass))<<2)) & 0xF0))
png.h:#define PNG_COL_IN_INTERLACE_PASS(x, pass) \
png.h:   ((PNG_PASS_MASK(pass,1) >> ((x)&7)) & 1)
png.h:     ((png_int_32)((*(buf) & 0x80) \
png.h:      ? -((png_int_32)((png_get_uint_32(buf) ^ 0xffffffffL) + 1)) \
png.h:    * but defining a macro name prefixed with PNG_PREFIX.
png.h: * Please read the documentation in libpng-manual.txt (TODO: write said
png.h: * complex use of an alpha channel the transformation is extremely lossy and the
png.h:   png_uint_32  width;     /* Image width in pixels (columns) */
png.h:   png_uint_32  height;    /* Image height in pixels (rows) */
png.h:#  define PNG_IMAGE_FAILED(png_cntrl) ((((png_cntrl).warning_or_error)&0x03)>1)
png.h: * and matches the 8-bit format expected by typical display devices.
png.h: * approximation used elsewhere in libpng.
png.h: * When an alpha channel is present it is expected to denote pixel coverage
png.h: * bytes per pixel according to the encoding, or are held in a color-map indexed
png.h: * pixel to select the relevant sample from the color-map.
png.h:#define PNG_FORMAT_FLAG_ALPHA    0x01U /* format with an alpha channel */
png.h:#define PNG_FORMAT_FLAG_COLOR    0x02U /* color format: otherwise grayscale */
png.h:#define PNG_FORMAT_FLAG_LINEAR   0x04U /* 2 byte channels else 1 byte */
png.h:#define PNG_FORMAT_FLAG_COLORMAP 0x08U /* image data is color-mapped */
png.h:#  define PNG_FORMAT_FLAG_BGR    0x10U /* BGR colors, else order is RGB */
png.h:#  define PNG_FORMAT_FLAG_AFIRST 0x20U /* alpha channel comes first */
png.h:/* With color-mapped formats the image data is one byte for each pixel, the byte
png.h: * is an index into the color-map which is formatted as above.  To obtain a
png.h: * pixels in the image.  The PNG_IMAGE_PIXEL_ macros return corresponding values
png.h: * for the pixels and will always return 1 for color-mapped formats.  The
png.h:   /* Return the size in bytes of a single component of a pixel or color-map
png.h:    * color-mapped it is the size of one color-map entry (and image pixels are
png.h:    * one byte in size), otherwise it is the size of one image pixel.
png.h:   /* The maximum size of the color-map required by the format expressed in a
png.h:/* Corresponding information about the pixels */
png.h:   /* The number of separate channels (components) in a pixel; 1 for a
png.h:   /* The size, in bytes, of each component in a pixel; 1 for a color-mapped
png.h:   /* The size, in bytes, of a complete pixel; 1 for a color-mapped image. */
png.h:#define PNG_IMAGE_FLAG_COLORSPACE_NOT_sRGB 0x01
png.h:#define PNG_IMAGE_FLAG_FAST 0x02
png.h:#define PNG_IMAGE_FLAG_16BIT_sRGB 0x04
png.h:    * external source.  It is recommended that the application expose this flag
png.h: * width: image width in pixels
png.h: * from one row to the next in component sized units (1 or 2 bytes) and if
png.h: * Note that the write API does not support interlacing or sub-8-bit pixels.
png.h:PNG_EXPORT(242, void, png_set_check_for_invalid_index,
png.h:PNG_EXPORT(243, int, png_get_palette_max, (png_const_structp png_ptr,
png.h:#define PNG_MAXIMUM_INFLATE_WINDOW 2 /* SOFTWARE: force maximum window */
png.h:#define PNG_OPTION_NEXT  6 /* Next option - numbers must be even */
png.h:/* The last ordinal number (this is the *last* one already used; the next
Binary file pngimage matches
pnginfo.h: * order of the values had to remain fixed.  With libpng 0.95 and later,
pnginfo.h: * cleaned up before the structure is discarded: palette, trans, text,
pnginfo.h: * passed (they make their own copies), EXCEPT that the png_set_text
pnginfo.h: * functions use the same storage passed to them in the text_ptr or
pnginfo.h: * itxt_ptr structure argument, and the png_set_rows and png_set_unknowns
pnginfo.h:   png_uint_32 width;  /* width of image in pixels (from IHDR) */
pnginfo.h:   png_uint_32 height; /* height of image in pixels (from IHDR) */
pnginfo.h:   png_byte channels;       /* number of data channels per pixel (1, 2, 3, 4) */
pnginfo.h:   png_byte pixel_depth;    /* number of bits per pixel */
pnginfo.h:   /* The tEXt, and zTXt chunks contain human-readable textual data in
pnginfo.h:    * The data in "text" is an array of pointers to uncompressed,
pnginfo.h:    * textual data contained in that chunk.  Keywords are not required to be
pnginfo.h:    * unique, and the text string may be empty.  Any number of text chunks may
pnginfo.h:   int num_text; /* number of comments read or comments to write */
pnginfo.h:   int max_text; /* current size of text array */
pnginfo.h:   png_textp text; /* array of comments read or comments to write */
pnginfo.h:    * in the pixel data.  Values are in the range [1, bit_depth], and are
pnginfo.h:    * only specified for the channels in the pixel data.  The contents of
pnginfo.h:    * same order as the palette colors, starting from index 0.  Values
pnginfo.h:    * pixel data.  Data is valid if (valid & PNG_INFO_bKGD) is non-zero.
pnginfo.h:   png_int_32 x_offset; /* x offset on page */
pnginfo.h:   /* The pHYs chunk gives the physical pixel density of the image for
pnginfo.h:   png_uint_32 x_pixels_per_unit; /* horizontal pixel density */
pnginfo.h:   png_uint_32 y_pixels_per_unit; /* vertical pixel density */
pnginfo.h:   /* The pCAL chunk describes a transformation between the stored pixel
pnginfo.h:    * defines below, and the PNG-Group's PNG extensions document for a
pnginfo.h:   png_int_32 pcal_X1;      /* maximum value */
pnginfo.h:    * png_struct::user_chunk_cache_max, else overflow can occur.
pnginfo.h:    * values.  The values are width and height corresponsing to one pixel
pnglibconf.h:#define PNG_ZLIB_VERNUM 0x1250
pnglibconf.out:#define PNG_ZLIB_VERNUM 0x1250
pngmem.c: * need special memory handling are expected to supply replacement
pngmem.c:/* Allocate memory.  For reasonable files, size should never exceed
pngmem.c: * need to allocate exactly 64K, so whatever you call here must
pngmem.c: * png_malloc always exists, but if PNG_USER_MEM_SUPPORTED is defined a separate
Binary file pngmem.o matches
Binary file pngnow.png matches
Binary file png.o matches
Binary file pngout.png matches
pngpread.c:   png_size_t num_checked = png_ptr->sig_bytes, /* SAFE, does not exceed 8 */ 
pngpread.c:    * end of every chunk (except IDAT, which is handled separately).
pngpread.c:          (uInt) PNG_ROWBYTES(png_ptr->pixel_depth,
pngpread.c:      png_ptr->zstream.next_out = png_ptr->row_buf;
pngpread.c:       * the same problem exists as above and the same solution.
pngpread.c:       png_ptr->save_buffer_max)
pngpread.c:      png_size_t new_max;
pngpread.c:      new_max = png_ptr->save_buffer_size + png_ptr->current_buffer_size + 256;
pngpread.c:          (png_size_t)new_max);
pngpread.c:      png_ptr->save_buffer_max = new_max;
pngpread.c:   png_ptr->zstream.next_in = buffer;
pngpread.c:       * if we don't expect any results -- it may be the input
pngpread.c:         png_ptr->zstream.avail_out = (uInt)(PNG_ROWBYTES(png_ptr->pixel_depth,
pngpread.c:         png_ptr->zstream.next_out = png_ptr->row_buf;
pngpread.c:      if (png_ptr->zstream.next_out != png_ptr->row_buf)
pngpread.c:         /* Is this unexpected data after the last row?
pngpread.c:            /* Extra data. */
pngpread.c:            png_warning(png_ptr, "Extra compressed data in IDAT");
pngpread.c:      png_warning(png_ptr, "Extra compression data in IDAT");
pngpread.c:   row_info.pixel_depth = png_ptr->pixel_depth;
pngpread.c:   row_info.rowbytes = PNG_ROWBYTES(row_info.pixel_depth, row_info.width);
pngpread.c:   /* The transformed pixel depth should match the depth now in row_info. */
pngpread.c:   if (png_ptr->transformed_pixel_depth == 0)
pngpread.c:      png_ptr->transformed_pixel_depth = row_info.pixel_depth;
pngpread.c:      if (row_info.pixel_depth > png_ptr->maximum_pixel_depth)
pngpread.c:   else if (png_ptr->transformed_pixel_depth != row_info.pixel_depth)
pngpread.c:   /* Expand interlaced rows to full size */
pngpread.c:   /* Arrays to facilitate easy interlacing - use pass (0 - 6) as index */
pngpread.c:   /* Offset to next interlace block */
pngpread.c:   /* Offset to next interlace block in the y direction */
Binary file pngpread.o matches
pngpriv.h: * as extern) are PRIVATE.  They are not part of the libpng public
pngpriv.h: * configure generated config.h.  Libpng is expected to compile without *any*
pngpriv.h:/* To support symbol prefixing it is necessary to know *before* including png.h
pngpriv.h: * whether the fixed point (and maybe other) APIs are exported, because if they
pngpriv.h:/* Local renames may change non-exported API functions from png.h */
pngpriv.h:#  include "pngprefix.h"
pngpriv.h: * NOTE: symbol prefixing does not pass $(CFLAGS) to the preprocessor, because
pngpriv.h: * it is necessary to ensure that all extern functions that *might* be used
pngpriv.h: * below is one example of this behavior because it is controlled by the
pngpriv.h:    * libpng implementation list for incorporation in the next minor release.
pngpriv.h: * If libpng is used inside a DLL but that DLL does not export the libpng APIs
pngpriv.h:          * indication that PNG_IMPEXP needs to be set to the DLL export
pngpriv.h:      /* Not building a DLL, or the DLL doesn't require specific export
pngpriv.h: * always be used to declare an extern data or function object in this file.
pngpriv.h:#  define PNG_INTERNAL_DATA(type, name, array) extern type name array
pngpriv.h:      extern PNG_FUNCTION(type, name, args, PNG_EMPTY attributes)
pngpriv.h:      extern PNG_FUNCTION(type, (PNGCBAPI name), args, PNG_EMPTY attributes)
pngpriv.h:/* If floating or fixed point APIs are disabled they may still be compiled
pngpriv.h: * internal extern function (otherwise the symbol prefixing stuff won't work and
pngpriv.h:#     define PNG_USER_WIDTH_MAX 0x7fffffff
pngpriv.h:#     define PNG_USER_HEIGHT_MAX 0x7fffffff
pngpriv.h:/* NOTE: some of these may have been used in external applications as
pngpriv.h: * these definitions were exposed in pngconf.h prior to 1.5.
pngpriv.h: * which is expected to have no bad effects on performance (optimizing
pngpriv.h:#  define png_fixed_error(s1,s2) png_err(s1)
pngpriv.h: * explicit, static, cast and provides the static_cast<> rune to ensure that
pngpriv.h:/* Some fixed point APIs are still required even if not exported because
pngpriv.h:    *  DBL_DIG  Maximum number of decimal digits (can be set to any constant)
pngpriv.h:    *  DBL_MAX  Maximum floating point number (can be set to an arbitrary value)
pngpriv.h:#    define PNG_ABORT() ExitProcess(0)
pngpriv.h: * These are used internally by libpng and not exposed in the API
pngpriv.h:/* #define PNG_HAVE_IHDR            0x01 (defined in png.h) */
pngpriv.h:/* #define PNG_HAVE_PLTE            0x02 (defined in png.h) */
pngpriv.h:#define PNG_HAVE_IDAT               0x04
pngpriv.h:/* #define PNG_AFTER_IDAT           0x08 (defined in png.h) */
pngpriv.h:#define PNG_HAVE_IEND               0x10
pngpriv.h:                   /*               0x20 (unused) */
pngpriv.h:                   /*               0x40 (unused) */
pngpriv.h:                   /*               0x80 (unused) */
pngpriv.h:#define PNG_HAVE_CHUNK_HEADER      0x100
pngpriv.h:#define PNG_WROTE_tIME             0x200
pngpriv.h:#define PNG_WROTE_INFO_BEFORE_PLTE 0x400
pngpriv.h:#define PNG_BACKGROUND_IS_GRAY     0x800
pngpriv.h:#define PNG_HAVE_PNG_SIGNATURE    0x1000
pngpriv.h:#define PNG_HAVE_CHUNK_AFTER_IDAT 0x2000 /* Have another chunk after IDAT */
pngpriv.h:                   /*             0x4000 (unused) */
pngpriv.h:#define PNG_IS_READ_STRUCT        0x8000 /* Else is a write struct */
pngpriv.h:#define PNG_BGR                 0x0001
pngpriv.h:#define PNG_INTERLACE           0x0002
pngpriv.h:#define PNG_PACK                0x0004
pngpriv.h:#define PNG_SHIFT               0x0008
pngpriv.h:#define PNG_SWAP_BYTES          0x0010
pngpriv.h:#define PNG_INVERT_MONO         0x0020
pngpriv.h:#define PNG_QUANTIZE            0x0040
pngpriv.h:#define PNG_COMPOSE             0x0080     /* Was PNG_BACKGROUND */
pngpriv.h:#define PNG_BACKGROUND_EXPAND   0x0100
pngpriv.h:#define PNG_EXPAND_16           0x0200     /* Added to libpng 1.5.2 */
pngpriv.h:#define PNG_16_TO_8             0x0400     /* Becomes 'chop' in 1.5.4 */
pngpriv.h:#define PNG_RGBA                0x0800
pngpriv.h:#define PNG_EXPAND              0x1000
pngpriv.h:#define PNG_GAMMA               0x2000
pngpriv.h:#define PNG_GRAY_TO_RGB         0x4000
pngpriv.h:#define PNG_FILLER              0x8000
pngpriv.h:#define PNG_PACKSWAP           0x10000
pngpriv.h:#define PNG_SWAP_ALPHA         0x20000
pngpriv.h:#define PNG_STRIP_ALPHA        0x40000
pngpriv.h:#define PNG_INVERT_ALPHA       0x80000
pngpriv.h:#define PNG_USER_TRANSFORM    0x100000
pngpriv.h:#define PNG_RGB_TO_GRAY_ERR   0x200000
pngpriv.h:#define PNG_RGB_TO_GRAY_WARN  0x400000
pngpriv.h:#define PNG_RGB_TO_GRAY       0x600000 /* two bits, RGB_TO_GRAY_ERR|WARN */
pngpriv.h:#define PNG_ENCODE_ALPHA      0x800000 /* Added to libpng-1.5.4 */
pngpriv.h:#define PNG_ADD_ALPHA         0x1000000 /* Added to libpng-1.2.7 */
pngpriv.h:#define PNG_EXPAND_tRNS       0x2000000 /* Added to libpng-1.2.9 */
pngpriv.h:#define PNG_SCALE_16_TO_8     0x4000000 /* Added to libpng-1.5.4 */
pngpriv.h:                       /*   0x8000000 unused */
pngpriv.h:                       /*  0x10000000 unused */
pngpriv.h:                       /*  0x20000000 unused */
pngpriv.h:                       /*  0x40000000 unused */
pngpriv.h:#define PNG_STRUCT_PNG   0x0001
pngpriv.h:#define PNG_STRUCT_INFO  0x0002
pngpriv.h:#define PNG_FLAG_ZLIB_CUSTOM_STRATEGY     0x0001
pngpriv.h:#define PNG_FLAG_ZSTREAM_INITIALIZED      0x0002 /* Added to libpng-1.6.0 */
pngpriv.h:                                  /*      0x0004    unused */
pngpriv.h:#define PNG_FLAG_ZSTREAM_ENDED            0x0008 /* Added to libpng-1.6.0 */
pngpriv.h:                                  /*      0x0010    unused */
pngpriv.h:                                  /*      0x0020    unused */
pngpriv.h:#define PNG_FLAG_ROW_INIT                 0x0040
pngpriv.h:#define PNG_FLAG_FILLER_AFTER             0x0080
pngpriv.h:#define PNG_FLAG_CRC_ANCILLARY_USE        0x0100
pngpriv.h:#define PNG_FLAG_CRC_ANCILLARY_NOWARN     0x0200
pngpriv.h:#define PNG_FLAG_CRC_CRITICAL_USE         0x0400
pngpriv.h:#define PNG_FLAG_CRC_CRITICAL_IGNORE      0x0800
pngpriv.h:#define PNG_FLAG_ASSUME_sRGB              0x1000 /* Added to libpng-1.5.4 */
pngpriv.h:#define PNG_FLAG_OPTIMIZE_ALPHA           0x2000 /* Added to libpng-1.5.4 */
pngpriv.h:#define PNG_FLAG_DETECT_UNINITIALIZED     0x4000 /* Added to libpng-1.5.4 */
pngpriv.h:/* #define PNG_FLAG_KEEP_UNKNOWN_CHUNKS      0x8000 */
pngpriv.h:/* #define PNG_FLAG_KEEP_UNSAFE_CHUNKS      0x10000 */
pngpriv.h:#define PNG_FLAG_LIBRARY_MISMATCH        0x20000
pngpriv.h:#define PNG_FLAG_STRIP_ERROR_NUMBERS     0x40000
pngpriv.h:#define PNG_FLAG_STRIP_ERROR_TEXT        0x80000
pngpriv.h:#define PNG_FLAG_BENIGN_ERRORS_WARN     0x100000 /* Added to libpng-1.4.0 */
pngpriv.h:#define PNG_FLAG_APP_WARNINGS_WARN      0x200000 /* Added to libpng-1.6.0 */
pngpriv.h:#define PNG_FLAG_APP_ERRORS_WARN        0x400000 /* Added to libpng-1.6.0 */
pngpriv.h:                                  /*    0x800000    unused */
pngpriv.h:                                  /*   0x1000000    unused */
pngpriv.h:                                  /*   0x2000000    unused */
pngpriv.h:                                  /*   0x4000000    unused */
pngpriv.h:                                  /*   0x8000000    unused */
pngpriv.h:                                  /*  0x10000000    unused */
pngpriv.h:                                  /*  0x20000000    unused */
pngpriv.h:                                  /*  0x40000000    unused */
pngpriv.h: * by dividing by 257 *with rounding*.  This macro is exact for the given range.
pngpriv.h: * macro were established by experiment (modifying the added value).  The macro
pngpriv.h: * 65535 - this has a maximum error of .502.  Over the range 0..65535*65535 it
pngpriv.h:#define PNG_ROWBYTES(pixel_bits, width) \
pngpriv.h:    ((pixel_bits) >= 8 ? \
pngpriv.h:    ((png_size_t)(width) * (((png_size_t)(pixel_bits)) >> 3)) : \
pngpriv.h:    (( ((png_size_t)(width) * ((png_size_t)(pixel_bits))) + 7) >> 3) )
pngpriv.h:/* Conversions between fixed and floating point, only defined if
pngpriv.h: * does lose accuracy relative to the original fixed point value.
pngpriv.h: * In practice this doesn't matter because png_fixed_point only
pngpriv.h:#define png_float(png_ptr, fixed, s) (.00001 * (fixed))
pngpriv.h:/* The fixed point conversion performs range checking and evaluates
pngpriv.h: * 32 bit fixed point value except that the values are deliberately
pngpriv.h:#define png_fixed(png_ptr, fp, s) ((fp) <= 21474 && (fp) >= -21474 ?\
pngpriv.h:    ((png_fixed_point)(100000 * (fp))) : (png_fixed_error(png_ptr, s),0))
pngpriv.h: * the prefix is lower case.  Please use decimal values as the parameters to
pngpriv.h: * the prefix is lower case.  Please use decimal values as the parameters to
pngpriv.h: * type.  In fact the specification does not express chunk types this way,
pngpriv.h: * stream using exactly the same code as used for a 32-bit unsigned value and
pngpriv.h: * can be examined far more efficiently (using one arithmetic compare).
pngpriv.h: * Prior to 1.5.6 the chunk type constants were expressed as C strings.  The
pngpriv.h:#define png_gIFx PNG_U32(103,  73,  70, 120)
pngpriv.h: * macro will fail on top-bit-set values because of the sign extension.
pngpriv.h:   PNG_U32(0xff&(s)[0], 0xff&(s)[1], 0xff&(s)[2], 0xff&(s)[3])
pngpriv.h:    * The most likely explanation is that you passed a -I in CFLAGS. This will
pngpriv.h:   ((((linear)&0x7fff)*png_sRGB_delta[(linear)>>15])>>12)) >> 8))
pngpriv.h:    * encoded value with maximum error 0.646365.  Note that the input is not a
pngpriv.h:extern "C" {
pngpriv.h:/* Internal functions; these are not exported from a DLL however because they
pngpriv.h: * are used within several of the C source files they have to be C extern.
pngpriv.h:PNG_INTERNAL_FUNCTION(png_fixed_point,png_fixed,(png_const_structrp png_ptr,
pngpriv.h:   double fp, png_const_charp text),PNG_EMPTY);
pngpriv.h:/* The same but an existing array is extended by add_elements.  This function
pngpriv.h:#endif /* text, sPLT or unknown chunks */
pngpriv.h:/* Next four functions are used internally as callbacks.  PNGCBAPI is required
pngpriv.h: * passing a maximum of 64K on systems that have this as a memory limit,
pngpriv.h: * since this is the maximum buffer size we can specify.
pngpriv.h:PNG_INTERNAL_FUNCTION(void,png_write_gAMA_fixed,(png_structrp png_ptr,
pngpriv.h:    png_fixed_point file_gamma),PNG_EMPTY);
pngpriv.h:PNG_INTERNAL_FUNCTION(void,png_write_cHRM_fixed,(png_structrp png_ptr,
pngpriv.h:    const png_xy *xy), PNG_EMPTY);
pngpriv.h:    /* The xy value must have been previously validated */
pngpriv.h:   png_const_charp key, png_const_charp text, png_size_t text_len),PNG_EMPTY);
pngpriv.h:    key, png_const_charp text, int compression),PNG_EMPTY);
pngpriv.h:    png_const_charp lang_key, png_const_charp text),PNG_EMPTY);
pngpriv.h:PNG_INTERNAL_FUNCTION(int,png_set_text_2,(png_const_structrp png_ptr,
pngpriv.h:    png_inforp info_ptr, png_const_textp text_ptr, int num_text),PNG_EMPTY);
pngpriv.h:    png_int_32 x_offset, png_int_32 y_offset, int unit_type),PNG_EMPTY);
pngpriv.h:    png_uint_32 x_pixels_per_unit, png_uint_32 y_pixels_per_unit,
pngpriv.h: * array of png_ptr->width pixels.  If the image is not interlaced or this
pngpriv.h: * is used to determine whether to copy pixels that are not in the current pass.
pngpriv.h: * Because 'png_do_read_interlace' (below) replicates pixels this allows this
pngpriv.h: * if display is 1 and the 'sparkle' appearance, where existing pixels in 'row'
pngpriv.h:/* Expand an interlaced row: the 'row_info' describes the pass data that has
pngpriv.h: * been read in and must correspond to the pixels in 'row', the pixels are
pngpriv.h: * expanded (moved apart) in 'row' to match the final layout, when doing this
pngpriv.h: * the pixels are *replicated* to the intervening space.  This is essential for
pngpriv.h:/* Grab pixels out of a row for an interlaced pass */
pngpriv.h:    * extra data has to be consumed.
pngpriv.h:   /* Exactly as the API png_handle_as_unknown() except that the argument is a
pngpriv.h:    png_colorspacerp colorspace, png_fixed_point gAMA), PNG_EMPTY);
pngpriv.h:   (png_const_structrp png_ptr, png_colorspacerp colorspace, const png_xy *xy,
pngpriv.h:PNG_INTERNAL_FUNCTION(void,png_do_check_palette_indexes,
pngpriv.h:PNG_INTERNAL_FUNCTION(void,png_fixed_error,(png_const_structrp png_ptr,
pngpriv.h:#define PNG_NUMBER_FORMAT_x     3
pngpriv.h:#define PNG_NUMBER_FORMAT_02x   4
pngpriv.h:#define PNG_NUMBER_FORMAT_fixed 5 /* choose the signed API */
pngpriv.h:#  define PNG_WARNING_PARAMETER_COUNT 8 /* Maximum 9; see pngerror.c */
pngpriv.h: * explicitly disables benign errors (explicitly permitting the code to lose
pngpriv.h:/* MAX_DIGITS is actually the maximum number of characters in an sCAL
pngpriv.h: * maximum ridiculous exponent.
pngpriv.h:#define PNG_sCAL_MAX_DIGITS (PNG_sCAL_PRECISION+1/*.*/+1/*E*/+10/*exponent*/)
pngpriv.h:PNG_INTERNAL_FUNCTION(void,png_ascii_from_fixed,(png_const_structrp png_ptr,
pngpriv.h:   png_charp ascii, png_size_t size, png_fixed_point fp),PNG_EMPTY);
pngpriv.h: * The result is the index of the next character.  If the number is
pngpriv.h: * not valid it will be the index of a character in the supposed number.
pngpriv.h: * The format of a number is defined in the PNG extensions specification
pngpriv.h: * The format as a regular expression is:
pngpriv.h: * The complexity is that either integer or fraction must be present and the
pngpriv.h: *   if the value were ever to be embedded in something more complex.  Use
pngpriv.h:#define PNG_FP_EXPONENT   2  /* before or in exponent */
pngpriv.h: * the index into the string and the state variable (which must
pngpriv.h: * that omits the last character (i.e. set the size to the index of
pngpriv.h:PNG_INTERNAL_FUNCTION(int,png_muldiv,(png_fixed_point_p res, png_fixed_point a,
pngpriv.h:PNG_INTERNAL_FUNCTION(png_fixed_point,png_muldiv_warn,
pngpriv.h:   (png_const_structrp png_ptr, png_fixed_point a, png_int_32 multiplied_by,
pngpriv.h:PNG_INTERNAL_FUNCTION(png_fixed_point,png_reciprocal,(png_fixed_point a),
pngpriv.h:/* The same but gives a reciprocal of the product of two fixed point
pngpriv.h: * not exact - use png_muldiv for that.  Only required at present on read.
pngpriv.h:PNG_INTERNAL_FUNCTION(png_fixed_point,png_reciprocal2,(png_fixed_point a,
pngpriv.h:   png_fixed_point b),PNG_EMPTY);
pngpriv.h:PNG_INTERNAL_FUNCTION(int,png_gamma_significant,(png_fixed_point gamma_value),
pngpriv.h:/* Internal fixed point gamma correction.  These APIs are called as
pngpriv.h: * they are not used when processing image pixel values.
pngpriv.h:   unsigned int value, png_fixed_point gamma_value),PNG_EMPTY);
pngpriv.h:   png_fixed_point gamma_value),PNG_EMPTY);
pngpriv.h:   png_fixed_point gamma_value),PNG_EMPTY);
pngpriv.h:/* Utility to safely execute a piece of libpng code catching and logging any
pngpriv.h:PNG_INTERNAL_FUNCTION(int,png_safe_execute,(png_imagep image,
pngpriv.h:/* png_image_free is used by the write code but not exported */
pngpriv.h:    * CFLAGS in place of CPPFLAGS *and* uses symbol prefixing.
pngread.c: * been read from the beginning of the stream (up to the maximum of 8)
pngread.c: * the user to obtain a gamma-corrected palette, for example.
pngread.c:/* Undoes intrapixel differencing,
pngread.c:png_do_read_intrapixel(png_row_infop row_info, png_bytep row)
pngread.c:   png_debug(1, "in png_do_read_intrapixel");
pngread.c:      int bytes_per_pixel;
pngread.c:            bytes_per_pixel = 3;
pngread.c:            bytes_per_pixel = 4;
pngread.c:         for (i = 0, rp = row; i < row_width; i++, rp += bytes_per_pixel)
pngread.c:            *(rp) = (png_byte)((256 + *rp + *(rp + 1)) & 0xff);
pngread.c:            *(rp+2) = (png_byte)((256 + *(rp + 2) + *(rp + 1)) & 0xff);
pngread.c:            bytes_per_pixel = 6;
pngread.c:            bytes_per_pixel = 8;
pngread.c:         for (i = 0, rp = row; i < row_width; i++, rp += bytes_per_pixel)
pngread.c:            png_uint_32 red  = (s0 + s1 + 65536) & 0xffff;
pngread.c:            png_uint_32 blue = (s2 + s1 + 65536) & 0xffff;
pngread.c:            *(rp    ) = (png_byte)((red >> 8) & 0xff);
pngread.c:            *(rp + 1) = (png_byte)(red & 0xff);
pngread.c:            *(rp + 4) = (png_byte)((blue >> 8) & 0xff);
pngread.c:            *(rp + 5) = (png_byte)(blue & 0xff);
pngread.c:   row_info.pixel_depth = png_ptr->pixel_depth;
pngread.c:   row_info.rowbytes = PNG_ROWBYTES(row_info.pixel_depth, row_info.width);
pngread.c:    * Notice that the pixels we have from previous rows have been transformed
pngread.c:            if (png_ptr->row_number & 0x07)
pngread.c:            if ((png_ptr->row_number & 0x07) || png_ptr->width < 5)
pngread.c:            if ((png_ptr->row_number & 0x07) != 4)
pngread.c:      /* Intrapixel differencing */
pngread.c:      png_do_read_intrapixel(&row_info, png_ptr->row_buf + 1);
pngread.c:   /* The transformed pixel depth should match the depth now in row_info. */
pngread.c:   if (png_ptr->transformed_pixel_depth == 0)
pngread.c:      png_ptr->transformed_pixel_depth = row_info.pixel_depth;
pngread.c:      if (row_info.pixel_depth > png_ptr->maximum_pixel_depth)
pngread.c:   else if (png_ptr->transformed_pixel_depth != row_info.pixel_depth)
pngread.c:   /* Expand interlaced rows to full size */
pngread.c: * "row" holds the actual image, and pixels are placed in it
pngread.c: * [*] png_handle_alpha() does not exist yet, as of this version of libpng
pngread.c: * [*] png_handle_alpha() does not exist yet, as of this version of libpng
pngread.c:          * first turning on the PNG_INTERLACE transform.  We can fix this here,
pngread.c:   /* Report invalid palette index; added at libng-1.5.10 */
pngread.c:      png_ptr->num_palette_max > png_ptr->num_palette)
pngread.c:     png_benign_error(png_ptr, "Read palette index exceeding num_palette");
pngread.c:   png_free(png_ptr, png_ptr->quantize_index);
pngread.c:   png_ptr->quantize_index = NULL;
pngread.c:    * behavior.  Prior to 1.6.0 libpng did extra 'info' destruction in this API.
pngread.c:    * The extra was, apparently, unnecessary yet this hides memory leak bugs.
pngread.c:    * libpng builds.  The results can be unexpected - png_read_png may return
pngread.c:   /* Extract multiple pixels with bit depths of 1, 2, or 4 from a single
pngread.c:   /* Change the order of packed pixels to least significant bit first
pngread.c:   /* Expand paletted colors into true RGB triplets
pngread.c:    * Expand grayscale images to full 8 bits from 1, 2, or 4 bits/pixel
pngread.c:    * Expand paletted or RGB images with transparency to full alpha
pngread.c:      png_set_expand(png_ptr);
pngread.c:   /* If you want to shift the pixel values from the range [0,255] or
pngread.c:   /* Flip the RGB pixels to BGR (or RGBA to BGRA) */
pngread.c:   /* Expand grayscale image to RGB */
pngread.c:      png_set_expand_16(png_ptr);
pngread.c:    * and update info structure.  REQUIRED if you are expecting libpng to
pngread.c:#define PNG_CMAP_TRANS     2 /* Process GA data to a background index */
pngread.c:   png_fixed_point gamma_to_linear;     /* For P_FILE, reciprocal of gamma */
pngread.c:   /* Use png_ptr here, not info_ptr, because by examination png_handle_tRNS
pngread.c:png_gamma_not_sRGB(png_fixed_point g)
pngread.c: * header and fill in all the information.  This is executed in a safe context,
pngread.c:   /* We need the maximum number of entries regardless of the format the
pngread.c:            return png_safe_execute(image, png_image_read_header, image);
pngread.c:               return png_safe_execute(image, png_image_read_header, image);
pngread.c:            return png_safe_execute(image, png_image_read_header, image);
pngread.c:    * be used, i.e., all chunks recognized by libpng except for those
pngread.c:       /* Ignore unknown chunks and all other chunks except for the
pngread.c:/* The following macro gives the exact rounded answer for all values in the
pngread.c:   png_fixed_point g = display->image->opaque->png_ptr->colorspace.gamma;
pngread.c:            "unexpected encoding (internal error)");
pngread.c:      /* Scale to 65535; divide by 255, approximately (in fact this is extremely
pngread.c:      png_error(image->opaque->png_ptr, "color-map index out of range");
pngread.c:      png_fixed_point g = display->gamma_to_linear;
pngread.c:    * selected by six levels of alpha.  One transparent entry, 6 gray
pngread.c:    * for the opaque grays.  The color-map entries are the six values
pngread.c:   /* Build a 6x6x6 opaque RGB cube */
pngread.c:/* Return a palette index to the above palette given three 8-bit sRGB values. */
pngread.c:   /* Background information; the background color and the index of this color
pngread.c:    * in the color-map if it exists (else 256).
pngread.c:   unsigned int background_index = 256;
pngread.c:   int expand_tRNS = 0;
pngread.c:   /* Exclude the NYI feature of compositing onto a color-mapped buffer; it is
pngread.c:             * color-map indices; however, they may need to be expanded to 1
pngread.c:             * byte per pixel.  This is what png_set_packing does (i.e., it
pngread.c:             * entries are required.  This means that the extra entry requires
pngread.c:             * to do the exact match on the 16-bit value.
pngread.c:             * color exactly.
pngread.c:                     c.index = 0; /*unused*/
pngread.c:                     /* NOTE: does this work without expanding tRNS to alpha?
pngread.c:                     png_set_background_fixed(png_ptr, &c,
pngread.c:                        PNG_BACKGROUND_GAMMA_SCREEN, 0/*need_expand*/,
pngread.c:               expand_tRNS = 1;
pngread.c:               background_index = 254;
pngread.c:            background_index = PNG_CMAP_GA_BACKGROUND;
pngread.c:             * background entry (for a transparent pixel) and a set of four six
pngread.c:             * per-pixel processing.
pngread.c:             * for the background color be exactly the color specified.
pngread.c:               c.index = 0; /*unused*/
pngread.c:               png_set_background_fixed(png_ptr, &c,
pngread.c:                  PNG_BACKGROUND_GAMMA_SCREEN, 0/*need_expand*/,
pngread.c:               /* This is the same as png_make_ga_colormap, above, except that
pngread.c:               background_index = i;
pngread.c:                * reasonable approximate to the logarithmic curve of human
pngread.c:                  /* This may produce a value not exactly matching the
pngread.c:                  /* PNG_sRGB_FROM_LINEAR expects a 16-bit linear value scaled
pngread.c:                  png_uint_32 back_rx = (255-alpha) * back_r;
pngread.c:                  png_uint_32 back_gx = (255-alpha) * back_g;
pngread.c:                  png_uint_32 back_bx = (255-alpha) * back_b;
pngread.c:                        PNG_sRGB_FROM_LINEAR(gray + back_rx),
pngread.c:                        PNG_sRGB_FROM_LINEAR(gray + back_gx),
pngread.c:                        PNG_sRGB_FROM_LINEAR(gray + back_bx), 255, P_sRGB);
pngread.c:         /* Exclude the case where the output is gray; we can always handle this
pngread.c:             * png_set_tRNS_to_alpha before png_set_background_fixed.
pngread.c:            png_set_rgb_to_gray_fixed(png_ptr, PNG_ERROR_ACTION_NONE, -1,
pngread.c:             * channels.  The more complex case arises when the input has alpha.
pngread.c:               expand_tRNS = 1;
pngread.c:               background_index = PNG_CMAP_GA_BACKGROUND;
pngread.c:                * will be no non-opaque pixels in the color-map; it will just be
pngread.c:                * correction bug).  Fix this by dropping the gamma correction in
pngread.c:                  /* We need to ensure that the application background exists in
pngread.c:                   * the colormap and that completely transparent pixels map to
pngread.c:                  if (data_encoding == P_FILE) /* from the fixup above */
pngread.c:                      * exactly the required sRGB value.
pngread.c:                  c.index = 0; /*unused*/
pngread.c:                   * png_set_background_fixed seems to go wrong.
pngread.c:                  expand_tRNS = 1;
pngread.c:                  png_set_background_fixed(png_ptr, &c,
pngread.c:                     PNG_BACKGROUND_GAMMA_SCREEN, 0/*need_expand*/,
pngread.c:             * to do it once and using PNG_DIV51 on the 6x6x6 reduced RGB cube.
pngread.c:                  /* This is stored as the background index for the processing
pngread.c:                  background_index = cmap_entries++;
pngread.c:                  for (r=0; r<256; r = (r << 1) | 0x7f)
pngread.c:                     for (g=0; g<256; g = (g << 1) | 0x7f)
pngread.c:                        for (b=0; b<256; b = (b << 1) | 0x7f)
pngread.c:                  expand_tRNS = 1;
pngread.c:                   * exist in the color map (achieved by setting adding it after
pngread.c:                   * index.
pngread.c:                     background_index = cmap_entries++;
pngread.c:                     for (r=0; r<256; r = (r << 1) | 0x7f)
pngread.c:                        for (g=0; g<256; g = (g << 1) | 0x7f)
pngread.c:                           for (b=0; b<256; b = (b << 1) | 0x7f)
pngread.c:                     expand_tRNS = 1;
pngread.c:                     c.index = 0; /*unused*/
pngread.c:                     png_set_background_fixed(png_ptr, &c,
pngread.c:                        PNG_BACKGROUND_GAMMA_SCREEN, 0/*need_expand*/,
pngread.c:                * pixels to the 6x6x6 color-map.
pngread.c:             * must be expanded if so.
pngread.c:   if (expand_tRNS != 0 && png_ptr->num_trans > 0 &&
pngread.c:         png_set_alpha_mode_fixed(png_ptr, PNG_ALPHA_PNG, PNG_GAMMA_sRGB);
pngread.c:   /* Double check using the recorded background index */
pngread.c:         if (background_index != PNG_CMAP_NONE_BACKGROUND)
pngread.c:         if (background_index != PNG_CMAP_GA_BACKGROUND)
pngread.c:         if (background_index >= cmap_entries ||
pngread.c:            background_index != PNG_CMAP_TRANS_BACKGROUND)
pngread.c:         if (background_index != PNG_CMAP_RGB_BACKGROUND)
pngread.c:         if (background_index != PNG_CMAP_RGB_ALPHA_BACKGROUND)
pngread.c:         png_error(png_ptr, "bad background index (internal error)");
pngread.c:         unsigned int     startx, stepx, stepy;
pngread.c:            startx = PNG_PASS_START_COL(pass);
pngread.c:            stepx = PNG_PASS_COL_OFFSET(pass);
pngread.c:            startx = 0;
pngread.c:            stepx = stepy = 1;
pngread.c:            outrow += startx;
pngread.c:                  for (; outrow < end_row; outrow += stepx)
pngread.c:                  for (; outrow < end_row; outrow += stepx)
pngread.c:                  for (; outrow < end_row; outrow += stepx)
pngread.c:                  for (; outrow < end_row; outrow += stepx)
pngread.c:                         * 0x00 .. 0x3f -> 0
pngread.c:                         * 0x40 .. 0xbf -> 1
pngread.c:                         * 0xc0 .. 0xff -> 2
pngread.c:                         * So, as above with the explicit alpha checks, the
pngread.c:                        if (inrow[0] & 0x80) back_i += 9; /* red */
pngread.c:                        if (inrow[0] & 0x40) back_i += 9;
pngread.c:                        if (inrow[0] & 0x80) back_i += 3; /* green */
pngread.c:                        if (inrow[0] & 0x40) back_i += 3;
pngread.c:                        if (inrow[0] & 0x80) back_i += 1; /* blue */
pngread.c:                        if (inrow[0] & 0x40) back_i += 1;
pngread.c:   /* The expected output can be deduced from the colormap_processing option. */
pngread.c:         /* Output must be one channel and one byte per pixel, the output
pngread.c:          * can be checked with an exact number because it should have been set
pngread.c:    * the output buffer, otherwise allocate a local row buffer of the maximum
pngread.c:      /* The following expression is designed to work correctly whether it gives
pngread.c:      result = png_safe_execute(image, png_image_read_and_map, display);
pngread.c:         unsigned int     startx, stepx, stepy;
pngread.c:            startx = PNG_PASS_START_COL(pass) * channels;
pngread.c:            stepx = PNG_PASS_COL_OFFSET(pass) * channels;
pngread.c:            startx = 0;
pngread.c:            stepx = channels;
pngread.c:            /* Now do the composition on each pixel in this row. */
pngread.c:            outrow += startx;
pngread.c:            for (; outrow < end_row; outrow += stepx)
pngread.c: * correction.  The fix-up is to prevent the PNG_COMPOSITE operation from
pngread.c:   /* Double check the convoluted logic below.  We expect to get here with
pngread.c:      png_error(png_ptr, "unexpected compose");
pngread.c:   /* Expect the 8-bit case to always remove the alpha channel */
pngread.c:      png_error(png_ptr, "unexpected 8-bit transformation");
pngread.c:    * checking the value after libpng expansions, not the original value in the
pngread.c:         png_error(png_ptr, "unexpected bit depth");
pngread.c:               unsigned int     startx, stepx, stepy;
pngread.c:                  startx = PNG_PASS_START_COL(pass);
pngread.c:                  stepx = PNG_PASS_COL_OFFSET(pass);
pngread.c:                  startx = 0;
pngread.c:                  stepx = stepy = 1;
pngread.c:                     /* Now do the composition on each pixel in this row. */
pngread.c:                     outrow += startx;
pngread.c:                     for (; outrow < end_row; outrow += stepx)
pngread.c:                     /* Now do the composition on each pixel in this row. */
pngread.c:                     outrow += startx;
pngread.c:                     for (; outrow < end_row; outrow += stepx)
pngread.c:               unsigned int     startx, stepx, stepy;
pngread.c:               /* The 'x' start and step are adjusted to output components here.
pngread.c:                  startx = PNG_PASS_START_COL(pass) * outchannels;
pngread.c:                  stepx = PNG_PASS_COL_OFFSET(pass) * outchannels;
pngread.c:                  startx = 0;
pngread.c:                  stepx = outchannels;
pngread.c:                  /* Now do the pre-multiplication on each pixel in this row.
pngread.c:                  outrow += startx;
pngread.c:                  for (; outrow < end_row; outrow += stepx)
pngread.c:/* The guts of png_image_finish_read as a png_safe_execute callback. */
pngread.c:    * that the required implementation support is there.  Always expand; always
pngread.c:    * need 8 bits minimum, no palette and expanded tRNS.
pngread.c:   png_set_expand(png_ptr);
pngread.c:         ~PNG_FORMAT_FLAG_COLORMAP /* removed by png_set_expand */;
pngread.c:      png_fixed_point output_gamma;
pngread.c:             * TODO: fix this by rewriting pngrtran.c (!)
pngread.c:             * For the moment (given that fixing this in pngrtran.c is an
pngread.c:             * the problem exists.
pngread.c:            png_set_rgb_to_gray_fixed(png_ptr, PNG_ERROR_ACTION_NONE,
pngread.c:         png_fixed_point input_gamma_default;
pngread.c:         png_set_alpha_mode_fixed(png_ptr, PNG_ALPHA_PNG, input_gamma_default);
pngread.c:       * TODO: fix libpng and remove this.
pngread.c:         png_fixed_point gtest;
pngread.c:            png_set_expand_16(png_ptr);
pngread.c:             * TODO: fix libpng and remove this.
pngread.c:               c.index = 0; /*unused*/
pngread.c:                * the app expectations and that will show up in transparent
pngread.c:                * pixels.
pngread.c:               png_set_background_fixed(png_ptr, &c,
pngread.c:                  PNG_BACKGROUND_GAMMA_SCREEN, 0/*need_expand*/,
pngread.c:                * one so the code only has to hack on the pixels that require
pngread.c:      png_set_alpha_mode_fixed(png_ptr, mode, output_gamma);
pngread.c:             * the output is gray, but fix up the 'format' value in that case.
pngread.c:         PNG_CONST png_uint_16 le = 0x0001;
pngread.c:    * TODO: remove the do_local_background fixup below.
pngread.c:               png_error(png_ptr, "unexpected alpha swap transformation");
pngread.c:      /* The following expression is designed to work correctly whether it gives
pngread.c:      result = png_safe_execute(image, png_image_read_composite, display);
pngread.c:      result = png_safe_execute(image, png_image_read_background, display);
pngread.c:                  png_safe_execute(image, png_image_read_colormap, &display) &&
pngread.c:                  png_safe_execute(image, png_image_read_colormapped, &display);
pngread.c:                  png_safe_execute(image, png_image_read_direct, &display);
Binary file pngread.o matches
pngrio.c: * special handling are expected to write a function that has the same
pngrio.c: *                To exit and output any fatal error messages the new write
Binary file pngrio.o matches
pngrtran.c:png_set_background_fixed(png_structrp png_ptr,
pngrtran.c:    int need_expand, png_fixed_point background_gamma)
pngrtran.c:   png_debug(1, "in png_set_background_fixed");
pngrtran.c:   if (need_expand != 0)
pngrtran.c:    int need_expand, double background_gamma)
pngrtran.c:   png_set_background_fixed(png_ptr, background_color, background_gamma_code,
pngrtran.c:      need_expand, png_fixed(png_ptr, background_gamma, "png_set_background"));
pngrtran.c:static png_fixed_point
pngrtran.c:translate_gamma_flags(png_structrp png_ptr, png_fixed_point output_gamma,
pngrtran.c:static png_fixed_point
pngrtran.c:   /* The following silently ignores cases where fixed point (times 100,000)
pngrtran.c:    * means the fixed point constants work just fine with the floating point
pngrtran.c:    * bug reports.  Negative values fail inside the _fixed API unless they
pngrtran.c:   /* This preserves -1 and -2 exactly: */
pngrtran.c:      png_fixed_error(png_ptr, "gamma value");
pngrtran.c:   return (png_fixed_point)output_gamma;
pngrtran.c:png_set_alpha_mode_fixed(png_structrp png_ptr, int mode,
pngrtran.c:   png_fixed_point output_gamma)
pngrtran.c:   png_fixed_point file_gamma;
pngrtran.c:    * is expected to be 1 or greater, but this range test allows for some
pngrtran.c:      png_error(png_ptr, "output gamma out of expected range");
pngrtran.c:    *    do not encode non-opaque pixels
pngrtran.c:      case PNG_ALPHA_OPTIMIZED:  /* associated, non-opaque pixels linear */
pngrtran.c:         /* output_gamma records the encoding of opaque pixels! */
pngrtran.c:   png_set_alpha_mode_fixed(png_ptr, mode, convert_gamma_value(png_ptr,
pngrtran.c: * of elements in the palette, the maximum number of elements
pngrtran.c: * of colors is greater then the maximum number, the palette will be
pngrtran.c: * modified to fit in the maximum number.  "full_quantize" indicates
pngrtran.c:   struct png_dsort_struct * next;
pngrtran.c:    int num_palette, int maximum_colors, png_const_uint_16p histogram,
pngrtran.c:      png_ptr->quantize_index = (png_bytep)png_malloc(png_ptr,
pngrtran.c:         png_ptr->quantize_index[i] = (png_byte)i;
pngrtran.c:   if (num_palette > maximum_colors)
pngrtran.c:         for (i = num_palette - 1; i >= maximum_colors; i--)
pngrtran.c:            /* Put all the useful colors within the max, but don't
pngrtran.c:            for (i = 0; i < maximum_colors; i++)
pngrtran.c:               if ((int)png_ptr->quantize_sort[i] >= maximum_colors)
pngrtran.c:                  while ((int)png_ptr->quantize_sort[j] >= maximum_colors);
pngrtran.c:            /* Move all the used colors inside the max limit, and
pngrtran.c:            for (i = 0; i < maximum_colors; i++)
pngrtran.c:               if ((int)png_ptr->quantize_sort[i] >= maximum_colors)
pngrtran.c:                  while ((int)png_ptr->quantize_sort[j] >= maximum_colors);
pngrtran.c:                  png_ptr->quantize_index[j] = (png_byte)i;
pngrtran.c:                  png_ptr->quantize_index[i] = (png_byte)j;
pngrtran.c:               if ((int)png_ptr->quantize_index[i] >= maximum_colors)
pngrtran.c:                  int min_d, k, min_k, d_index;
pngrtran.c:                  d_index = png_ptr->quantize_index[i];
pngrtran.c:                  min_d = PNG_COLOR_DIST(palette[d_index], palette[0]);
pngrtran.c:                  for (k = 1, min_k = 0; k < maximum_colors; k++)
pngrtran.c:                     d = PNG_COLOR_DIST(palette[d_index], palette[k]);
pngrtran.c:                  png_ptr->quantize_index[i] = (png_byte)min_k;
pngrtran.c:         int max_d;
pngrtran.c:         /* Initialize palette index arrays */
pngrtran.c:         png_ptr->index_to_palette = (png_bytep)png_malloc(png_ptr,
pngrtran.c:         png_ptr->palette_to_index = (png_bytep)png_malloc(png_ptr,
pngrtran.c:            png_ptr->index_to_palette[i] = (png_byte)i;
pngrtran.c:            png_ptr->palette_to_index[i] = (png_byte)i;
pngrtran.c:         /* Initial wild guess at how far apart the farthest pixel
pngrtran.c:          * I have not done extensive checking on this number.
pngrtran.c:         max_d = 96;
pngrtran.c:         while (num_new_palette > maximum_colors)
pngrtran.c:                  if (d <= max_d)
pngrtran.c:                     t->next = hash[d];
pngrtran.c:            for (i = 0; i <= max_d; i++)
pngrtran.c:                  for (p = hash[i]; p; p = p->next)
pngrtran.c:                     if ((int)png_ptr->index_to_palette[p->left]
pngrtran.c:                         (int)png_ptr->index_to_palette[p->right]
pngrtran.c:                        int j, next_j;
pngrtran.c:                        if (num_new_palette & 0x01)
pngrtran.c:                           next_j = p->right;
pngrtran.c:                           next_j = p->left;
pngrtran.c:                        palette[png_ptr->index_to_palette[j]]
pngrtran.c:                              if (png_ptr->quantize_index[k] ==
pngrtran.c:                                  png_ptr->index_to_palette[j])
pngrtran.c:                                 png_ptr->quantize_index[k] =
pngrtran.c:                                     png_ptr->index_to_palette[next_j];
pngrtran.c:                              if ((int)png_ptr->quantize_index[k] ==
pngrtran.c:                                 png_ptr->quantize_index[k] =
pngrtran.c:                                     png_ptr->index_to_palette[j];
pngrtran.c:                        png_ptr->index_to_palette[png_ptr->palette_to_index
pngrtran.c:                            [num_new_palette]] = png_ptr->index_to_palette[j];
pngrtran.c:                        png_ptr->palette_to_index[png_ptr->index_to_palette[j]]
pngrtran.c:                            = png_ptr->palette_to_index[num_new_palette];
pngrtran.c:                        png_ptr->index_to_palette[j] =
pngrtran.c:                        png_ptr->palette_to_index[num_new_palette] =
pngrtran.c:                     if (num_new_palette <= maximum_colors)
pngrtran.c:                  if (num_new_palette <= maximum_colors)
pngrtran.c:                     t = p->next;
pngrtran.c:            max_d += 96;
pngrtran.c:         png_free(png_ptr, png_ptr->palette_to_index);
pngrtran.c:         png_free(png_ptr, png_ptr->index_to_palette);
pngrtran.c:         png_ptr->palette_to_index = NULL;
pngrtran.c:         png_ptr->index_to_palette = NULL;
pngrtran.c:      num_palette = maximum_colors;
pngrtran.c:      memset(distance, 0xff, num_entries * (sizeof (png_byte)));
pngrtran.c:            int index_r = (ir << (PNG_QUANTIZE_BLUE_BITS +
pngrtran.c:               int index_g = index_r | (ig << PNG_QUANTIZE_BLUE_BITS);
pngrtran.c:                  int d_index = index_g | ib;
pngrtran.c:                  int dmax = ((dm > db) ? dm : db);
pngrtran.c:                  int d = dmax + dt + db;
pngrtran.c:                  if (d < (int)distance[d_index])
pngrtran.c:                     distance[d_index] = (png_byte)d;
pngrtran.c:                     png_ptr->palette_lookup[d_index] = (png_byte)i;
pngrtran.c:png_set_gamma_fixed(png_structrp png_ptr, png_fixed_point scrn_gamma,
pngrtran.c:   png_fixed_point file_gamma)
pngrtran.c:   png_debug(1, "in png_set_gamma_fixed");
pngrtran.c:   png_set_gamma_fixed(png_ptr, convert_gamma_value(png_ptr, scrn_gamma),
pngrtran.c:/* Expand paletted images to RGB, expand grayscale images of
pngrtran.c: * less than 8-bit depth to 8-bit depth, and expand tRNS chunks
pngrtran.c:png_set_expand(png_structrp png_ptr)
pngrtran.c:   png_debug(1, "in png_set_expand");
pngrtran.c: *  to png_set_expand().  However, it is entirely reasonable that someone
pngrtran.c: *  might wish to expand an indexed image to RGB but *not* expand a single,
pngrtran.c: *  doing, whereas "expand" can (and does) mean any number of things.
pngrtran.c: *  to expand only the sample depth but not to expand the tRNS to alpha
pngrtran.c: *  and its name was changed to png_set_expand_gray_1_2_4_to_8().
pngrtran.c:/* Expand paletted images to RGB. */
pngrtran.c:/* Expand grayscale images of less than 8-bit depth to 8 bits. */
pngrtran.c:png_set_expand_gray_1_2_4_to_8(png_structrp png_ptr)
pngrtran.c:   png_debug(1, "in png_set_expand_gray_1_2_4_to_8");
pngrtran.c:/* Expand tRNS chunks to alpha channels. */
pngrtran.c:/* Expand to 16-bit channels, expand the tRNS chunk too (because otherwise
pngrtran.c:png_set_expand_16(png_structrp png_ptr)
pngrtran.c:   png_debug(1, "in png_set_expand_16");
pngrtran.c:   png_set_expand_gray_1_2_4_to_8(png_ptr);
pngrtran.c:png_set_rgb_to_gray_fixed(png_structrp png_ptr, int error_action,
pngrtran.c:    png_fixed_point red, png_fixed_point green)
pngrtran.c:   /* TODO: fix this */
pngrtran.c: * for example, to convert a 24 bpp RGB image into an 8 bpp grayscale image.
pngrtran.c:   png_set_rgb_to_gray_fixed(png_ptr, error_action,
pngrtran.c:      png_fixed(png_ptr, red, "rgb to gray red coefficient"),
pngrtran.c:      png_fixed(png_ptr, green, "rgb to gray green coefficient"));
pngrtran.c:png_gamma_threshold(png_fixed_point screen_gamma, png_fixed_point file_gamma)
pngrtran.c:   png_fixed_point gtest;
pngrtran.c: * extracted from 'png_init_read_transformations'.
pngrtran.c:    * the first step is to expand the palette if requested, so this code must
pngrtran.c:    * palette expansion, or only do them if there is no expansion.
pngrtran.c:   /* png_set_background handling - deals with the complexity of whether the
pngrtran.c:    * where an 'expand' will happen.
pngrtran.c:             png_ptr->palette[png_ptr->background.index].red;
pngrtran.c:             png_ptr->palette[png_ptr->background.index].green;
pngrtran.c:             png_ptr->palette[png_ptr->background.index].blue;
pngrtran.c:              /* Invert the alpha channel (in tRNS) unless the pixels are
pngrtran.c:               * going to be expanded, in which case leave it for later
pngrtran.c:   } /* background expand and (therefore) no alpha association. */
pngrtran.c:   /* png_set_background handling - deals with the complexity of whether the
pngrtran.c:    * where an 'expand' will happen.
pngrtran.c:         /* Expand background and tRNS chunks */
pngrtran.c:               gray *= 0xff;
pngrtran.c:               trans_gray *= 0xff;
pngrtran.c:               gray *= 0x55;
pngrtran.c:               trans_gray *= 0x55;
pngrtran.c:               gray *= 0x11;
pngrtran.c:               trans_gray *= 0x11;
pngrtran.c:   } /* background expand and (therefore) no alpha association. */
pngrtran.c:      /* Stripping the alpha channel happens immediately after the 'expand'
pngrtran.c:       * expanded.  This produces unexpected API changes if the set of things
pngrtran.c:    * RGB_ALPHA (in which case need_expand is superfluous anyway), the
pngrtran.c:    * TODO: this code needs to be revised to avoid the complexity and
pngrtran.c:    * of exactly what color space the background is currently in.
pngrtran.c:      /* PNG_COMPOSE: png_set_background was called with need_expand false,
pngrtran.c:   /* For indexed PNG data (PNG_COLOR_TYPE_PALETTE) many of the transformations
pngrtran.c:    * in the palette even if the result is expanded to RGB or gray afterward.
pngrtran.c:      /* TODO: fix this.  Because the expand_16 operation is after the compose
pngrtran.c:       * The PNG_BACKGROUND_EXPAND code above does not expand to 16 bits at
pngrtran.c:       * present, so that case is ok (until do_expand_16 is moved.)
pngrtran.c:       * color, but until expand_16 works properly there is no choice!
pngrtran.c:#     define CHOP(x) (x)=((png_uint_16)PNG_DIV257(x))
pngrtran.c:       * color must be pre-expanded here.
pngrtran.c:       * TODO: fix this too.
pngrtran.c:    * 1.5.4 betas simply to enable external critique and testing (i.e. to
pngrtran.c:    * PNG_GAMMA is cancelled even if the gamma is known?  The test excludes the
pngrtran.c:               png_fixed_point g, gs;
pngrtran.c:                   png_ptr->trans_alpha[i] != 0xff)
pngrtran.c:                  else /* if (png_ptr->trans_alpha[i] != 0xff) */
pngrtran.c:            png_fixed_point g = PNG_FP_1;  /* Correction to linear */
pngrtran.c:            png_fixed_point gs = PNG_FP_1; /* Correction to screen */
pngrtran.c:         else if (png_ptr->trans_alpha[i] != 0xff)
pngrtran.c:          * png_do_expand_palette; if it ever checks the tRNS chunk to see if
pngrtran.c:            png_error (png_ptr, "Palette is NULL in indexed image");
pngrtran.c:   info_ptr->pixel_depth = (png_byte)(info_ptr->channels *
pngrtran.c:   info_ptr->rowbytes = PNG_ROWBYTES(info_ptr->pixel_depth, info_ptr->width);
pngrtran.c:/* Unpack pixels of 1, 2, or 4 bits per pixel into 1 byte per pixel,
pngrtran.c:            png_uint_32 shift = 7 - (int)((row_width + 7) & 0x07);
pngrtran.c:               *dp = (png_byte)((*sp >> shift) & 0x01);
pngrtran.c:            png_uint_32 shift = (int)((3 - ((row_width + 3) & 0x03)) << 1);
pngrtran.c:               *dp = (png_byte)((*sp >> shift) & 0x03);
pngrtran.c:            png_uint_32 shift = (int)((1 - ((row_width + 1) & 0x01)) << 2);
pngrtran.c:               *dp = (png_byte)((*sp >> shift) & 0x0f);
pngrtran.c:      row_info->pixel_depth = (png_byte)(8 * row_info->channels);
pngrtran.c: * pixels back to their significant bits values.  Thus, if you have
pngrtran.c:               int b = (*bp >> 1) & 0x55;
pngrtran.c:            int mask =  0xf >> gray_shift;
pngrtran.c:               *bp++ = (png_byte)(value & 0xff);
pngrtran.c:          * This can be approximated using integer arithmetic (and a signed
pngrtran.c:          * The approximate differs from the exact answer only when (vlo-vhi) is
pngrtran.c:          * 128; it then gives a correction of +1 when the exact correction is
pngrtran.c:          * 0.  This gives 128 errors.  The exact answer (correct for all 16 bit
pngrtran.c:      row_info->pixel_depth = (png_byte)(8 * row_info->channels);
pngrtran.c:      row_info->pixel_depth = (png_byte)(8 * row_info->channels);
pngrtran.c:   png_byte hi_filler = (png_byte)((filler>>8) & 0xff);
pngrtran.c:   png_byte lo_filler = (png_byte)(filler & 0xff);
pngrtran.c:            row_info->pixel_depth = 16;
pngrtran.c:            row_info->pixel_depth = 16;
pngrtran.c:            row_info->pixel_depth = 32;
pngrtran.c:            row_info->pixel_depth = 32;
pngrtran.c:            row_info->pixel_depth = 32;
pngrtran.c:            row_info->pixel_depth = 32;
pngrtran.c:            row_info->pixel_depth = 64;
pngrtran.c:            row_info->pixel_depth = 64;
pngrtran.c:/* Expand grayscale files to RGB, with or without alpha */
pngrtran.c:      row_info->pixel_depth = (png_byte)(row_info->channels *
pngrtran.c:      row_info->rowbytes = PNG_ROWBYTES(row_info->pixel_depth, row_width);
pngrtran.c: * ~poynton/notes/colour_and_gamma/ColorFAQ.txt )
pngrtran.c: *  which can be expressed with integers as
pngrtran.c: *  which can be expressed with integers as
pngrtran.c: *  libpng uses, instead, the closest non-overflowing approximation:
pngrtran.c:                     w = png_ptr->gamma_16_table[(red & 0xff)
pngrtran.c:                  png_uint_16 red_1   = png_ptr->gamma_16_to_1[(red&0xff)
pngrtran.c:                      png_ptr->gamma_16_to_1[(green&0xff) >>
pngrtran.c:                  png_uint_16 blue_1  = png_ptr->gamma_16_to_1[(blue&0xff)
pngrtran.c:                  w = png_ptr->gamma_16_from_1[(gray16&0xff) >>
pngrtran.c:               *(dp++) = (png_byte)((w>>8) & 0xff);
pngrtran.c:               *(dp++) = (png_byte)(w & 0xff);
pngrtran.c:               *(dp++) = (png_byte)((gray16 >> 8) & 0xff);
pngrtran.c:               *(dp++) = (png_byte)(gray16 & 0xff);
pngrtran.c:      row_info->pixel_depth = (png_byte)(row_info->channels *
pngrtran.c:      row_info->rowbytes = PNG_ROWBYTES(row_info->pixel_depth, row_width);
pngrtran.c:                     if ((png_uint_16)((*sp >> shift) & 0x01)
pngrtran.c:                        unsigned int tmp = *sp & (0x7f7f >> (7 - shift));
pngrtran.c:                        *sp = (png_byte)(tmp & 0xff);
pngrtran.c:                        if ((png_uint_16)((*sp >> shift) & 0x03)
pngrtran.c:                           unsigned int tmp = *sp & (0x3f3f >> (6 - shift));
pngrtran.c:                           *sp = (png_byte)(tmp & 0xff);
pngrtran.c:                           unsigned int p = (*sp >> shift) & 0x03;
pngrtran.c:                               (p << 4) | (p << 6)] >> 6) & 0x03;
pngrtran.c:                           unsigned int tmp = *sp & (0x3f3f >> (6 - shift));
pngrtran.c:                           *sp = (png_byte)(tmp & 0xff);
pngrtran.c:                        if ((png_uint_16)((*sp >> shift) & 0x03)
pngrtran.c:                           unsigned int tmp = *sp & (0x3f3f >> (6 - shift));
pngrtran.c:                           *sp = (png_byte)(tmp & 0xff);
pngrtran.c:                        if ((png_uint_16)((*sp >> shift) & 0x0f)
pngrtran.c:                           unsigned int tmp = *sp & (0xf0f >> (4 - shift));
pngrtran.c:                           *sp = (png_byte)(tmp & 0xff);
pngrtran.c:                           unsigned int p = (*sp >> shift) & 0x0f;
pngrtran.c:                              0x0f;
pngrtran.c:                           unsigned int tmp = *sp & (0xf0f >> (4 - shift));
pngrtran.c:                           *sp = (png_byte)(tmp & 0xff);
pngrtran.c:                        if ((png_uint_16)((*sp >> shift) & 0x0f)
pngrtran.c:                           unsigned int tmp = *sp & (0xf0f >> (4 - shift));
pngrtran.c:                           *sp = (png_byte)(tmp & 0xff);
pngrtran.c:                                & 0xff);
pngrtran.c:                                & 0xff);
pngrtran.c:                           *sp = (png_byte)((v >> 8) & 0xff);
pngrtran.c:                           *(sp + 1) = (png_byte)(v & 0xff);
pngrtran.c:                                & 0xff);
pngrtran.c:                                & 0xff);
pngrtran.c:                        *sp = (png_byte)((png_ptr->background.red >> 8) & 0xff);
pngrtran.c:                        *(sp + 1) = (png_byte)(png_ptr->background.red & 0xff);
pngrtran.c:                                & 0xff);
pngrtran.c:                                & 0xff);
pngrtran.c:                                & 0xff);
pngrtran.c:                        *(sp + 5) = (png_byte)(png_ptr->background.blue & 0xff);
pngrtran.c:                        *sp = (png_byte)((v >> 8) & 0xff);
pngrtran.c:                        *(sp + 1) = (png_byte)(v & 0xff);
pngrtran.c:                        *(sp + 2) = (png_byte)((v >> 8) & 0xff);
pngrtran.c:                        *(sp + 3) = (png_byte)(v & 0xff);
pngrtran.c:                        *(sp + 4) = (png_byte)((v >> 8) & 0xff);
pngrtran.c:                        *(sp + 5) = (png_byte)(v & 0xff);
pngrtran.c:                        *sp = (png_byte)((png_ptr->background.red >> 8) & 0xff);
pngrtran.c:                        *(sp + 1) = (png_byte)(png_ptr->background.red & 0xff);
pngrtran.c:                                & 0xff);
pngrtran.c:                                & 0xff);
pngrtran.c:                                & 0xff);
pngrtran.c:                        *(sp + 5) = (png_byte)(png_ptr->background.blue & 0xff);
pngrtran.c:                     if (a == 0xff)
pngrtran.c:                     else if (a < 0xff)
pngrtran.c:                     if (a == (png_uint_16)0xffff)
pngrtran.c:                        *sp = (png_byte)((v >> 8) & 0xff);
pngrtran.c:                        *(sp + 1) = (png_byte)(v & 0xff);
pngrtran.c:                                & 0xff);
pngrtran.c:                        *(sp + 1) = (png_byte)(png_ptr->background.gray & 0xff);
pngrtran.c:                           w = gamma_16_from_1[(v&0xff) >> gamma_shift][v >> 8];
pngrtran.c:                        *sp = (png_byte)((w >> 8) & 0xff);
pngrtran.c:                        *(sp + 1) = (png_byte)(w & 0xff);
pngrtran.c:                                & 0xff);
pngrtran.c:                        *(sp + 1) = (png_byte)(png_ptr->background.gray & 0xff);
pngrtran.c:                     else if (a < 0xffff)
pngrtran.c:                        *sp = (png_byte)((v >> 8) & 0xff);
pngrtran.c:                        *(sp + 1) = (png_byte)(v & 0xff);
pngrtran.c:                     if (a == 0xff)
pngrtran.c:                     else if (a < 0xff)
pngrtran.c:                     if (a == (png_uint_16)0xffff)
pngrtran.c:                        *sp = (png_byte)((v >> 8) & 0xff);
pngrtran.c:                        *(sp + 1) = (png_byte)(v & 0xff);
pngrtran.c:                        *(sp + 2) = (png_byte)((v >> 8) & 0xff);
pngrtran.c:                        *(sp + 3) = (png_byte)(v & 0xff);
pngrtran.c:                        *(sp + 4) = (png_byte)((v >> 8) & 0xff);
pngrtran.c:                        *(sp + 5) = (png_byte)(v & 0xff);
pngrtran.c:                        *sp = (png_byte)((png_ptr->background.red >> 8) & 0xff);
pngrtran.c:                        *(sp + 1) = (png_byte)(png_ptr->background.red & 0xff);
pngrtran.c:                                & 0xff);
pngrtran.c:                                & 0xff);
pngrtran.c:                                & 0xff);
pngrtran.c:                        *(sp + 5) = (png_byte)(png_ptr->background.blue & 0xff);
pngrtran.c:                           w = gamma_16_from_1[((w&0xff) >> gamma_shift)][w >>
pngrtran.c:                        *sp = (png_byte)((w >> 8) & 0xff);
pngrtran.c:                        *(sp + 1) = (png_byte)(w & 0xff);
pngrtran.c:                           w = gamma_16_from_1[((w&0xff) >> gamma_shift)][w >>
pngrtran.c:                        *(sp + 2) = (png_byte)((w >> 8) & 0xff);
pngrtran.c:                        *(sp + 3) = (png_byte)(w & 0xff);
pngrtran.c:                           w = gamma_16_from_1[((w&0xff) >> gamma_shift)][w >>
pngrtran.c:                        *(sp + 4) = (png_byte)((w >> 8) & 0xff);
pngrtran.c:                        *(sp + 5) = (png_byte)(w & 0xff);
pngrtran.c:                        *sp = (png_byte)((png_ptr->background.red >> 8) & 0xff);
pngrtran.c:                        *(sp + 1) = (png_byte)(png_ptr->background.red & 0xff);
pngrtran.c:                                & 0xff);
pngrtran.c:                                & 0xff);
pngrtran.c:                                & 0xff);
pngrtran.c:                        *(sp + 5) = (png_byte)(png_ptr->background.blue & 0xff);
pngrtran.c:                     else if (a < 0xffff)
pngrtran.c:                        *sp = (png_byte)((v >> 8) & 0xff);
pngrtran.c:                        *(sp + 1) = (png_byte)(v & 0xff);
pngrtran.c:                        *(sp + 2) = (png_byte)((v >> 8) & 0xff);
pngrtran.c:                        *(sp + 3) = (png_byte)(v & 0xff);
pngrtran.c:                        *(sp + 4) = (png_byte)((v >> 8) & 0xff);
pngrtran.c:                        *(sp + 5) = (png_byte)(v & 0xff);
pngrtran.c:                  *sp = (png_byte)((v >> 8) & 0xff);
pngrtran.c:                  *(sp + 1) = (png_byte)(v & 0xff);
pngrtran.c:                  *sp = (png_byte)((v >> 8) & 0xff);
pngrtran.c:                  *(sp + 1) = (png_byte)(v & 0xff);
pngrtran.c:                  *sp = (png_byte)((v >> 8) & 0xff);
pngrtran.c:                  *(sp + 1) = (png_byte)(v & 0xff);
pngrtran.c:                  *sp = (png_byte)((v >> 8) & 0xff);
pngrtran.c:                  *(sp + 1) = (png_byte)(v & 0xff);
pngrtran.c:                  *sp = (png_byte)((v >> 8) & 0xff);
pngrtran.c:                  *(sp + 1) = (png_byte)(v & 0xff);
pngrtran.c:                  *sp = (png_byte)((v >> 8) & 0xff);
pngrtran.c:                  *(sp + 1) = (png_byte)(v & 0xff);
pngrtran.c:                  *sp = (png_byte)((v >> 8) & 0xff);
pngrtran.c:                  *(sp + 1) = (png_byte)(v & 0xff);
pngrtran.c:                  int a = *sp & 0xc0;
pngrtran.c:                  int b = *sp & 0x30;
pngrtran.c:                  int c = *sp & 0x0c;
pngrtran.c:                  int d = *sp & 0x03;
pngrtran.c:                      ((((int)gamma_table[a|(a>>2)|(a>>4)|(a>>6)])   ) & 0xc0)|
pngrtran.c:                      ((((int)gamma_table[(b<<2)|b|(b>>2)|(b>>4)])>>2) & 0x30)|
pngrtran.c:                      ((((int)gamma_table[(c<<4)|(c<<2)|c|(c>>2)])>>4) & 0x0c)|
pngrtran.c:                  int msb = *sp & 0xf0;
pngrtran.c:                  int lsb = *sp & 0x0f;
pngrtran.c:                  *sp = (png_byte)((((int)gamma_table[msb | (msb >> 4)]) & 0xf0)
pngrtran.c:                  *sp = (png_byte)((v >> 8) & 0xff);
pngrtran.c:                  *(sp + 1) = (png_byte)(v & 0xff);
pngrtran.c:               *row = (png_byte)((v >> 8) & 0xff);
pngrtran.c:               *(row + 1) = (png_byte)(v & 0xff);
pngrtran.c:   png_warning(png_ptr, "png_do_encode_alpha: unexpected call");
pngrtran.c:/* Expands a palette row to an RGB or RGBA row depending
pngrtran.c:png_do_expand_palette(png_row_infop row_info, png_bytep row,
pngrtran.c:   png_debug(1, "in png_do_expand_palette");
pngrtran.c:               shift = 7 - (int)((row_width + 7) & 0x07);
pngrtran.c:                  if ((*sp >> shift) & 0x01)
pngrtran.c:               shift = (int)((3 - ((row_width + 3) & 0x03)) << 1);
pngrtran.c:                  value = (*sp >> shift) & 0x03;
pngrtran.c:               shift = (int)((row_width & 0x01) << 2);
pngrtran.c:                  value = (*sp >> shift) & 0x0f;
pngrtran.c:         row_info->pixel_depth = 8;
pngrtran.c:                     *dp-- = 0xff;
pngrtran.c:               row_info->pixel_depth = 32;
pngrtran.c:               row_info->pixel_depth = 24;
pngrtran.c:/* If the bit depth < 8, it is expanded to 8.  Also, if the already
pngrtran.c: * expanded transparency value is supplied, an alpha channel is built.
pngrtran.c:png_do_expand(png_row_infop row_info, png_bytep row,
pngrtran.c:   png_debug(1, "in png_do_expand");
pngrtran.c:                  gray = (gray & 0x01) * 0xff;
pngrtran.c:                  shift = 7 - (int)((row_width + 7) & 0x07);
pngrtran.c:                     if ((*sp >> shift) & 0x01)
pngrtran.c:                        *dp = 0xff;
pngrtran.c:                  gray = (gray & 0x03) * 0x55;
pngrtran.c:                  shift = (int)((3 - ((row_width + 3) & 0x03)) << 1);
pngrtran.c:                     value = (*sp >> shift) & 0x03;
pngrtran.c:                  gray = (gray & 0x0f) * 0x11;
pngrtran.c:                  shift = (int)((1 - ((row_width + 1) & 0x01)) << 2);
pngrtran.c:                     value = (*sp >> shift) & 0x0f;
pngrtran.c:            row_info->pixel_depth = 8;
pngrtran.c:               gray = gray & 0xff;
pngrtran.c:                     *dp-- = 0xff;
pngrtran.c:               unsigned int gray_high = (gray >> 8) & 0xff;
pngrtran.c:               unsigned int gray_low = gray & 0xff;
pngrtran.c:                     *dp-- = 0xff;
pngrtran.c:                     *dp-- = 0xff;
pngrtran.c:            row_info->pixel_depth = (png_byte)(row_info->bit_depth << 1);
pngrtran.c:            row_info->rowbytes = PNG_ROWBYTES(row_info->pixel_depth,
pngrtran.c:            png_byte red = (png_byte)(trans_color->red & 0xff);
pngrtran.c:            png_byte green = (png_byte)(trans_color->green & 0xff);
pngrtran.c:            png_byte blue = (png_byte)(trans_color->blue & 0xff);
pngrtran.c:                  *dp-- = 0xff;
pngrtran.c:            png_byte red_high = (png_byte)((trans_color->red >> 8) & 0xff);
pngrtran.c:            png_byte green_high = (png_byte)((trans_color->green >> 8) & 0xff);
pngrtran.c:            png_byte blue_high = (png_byte)((trans_color->blue >> 8) & 0xff);
pngrtran.c:            png_byte red_low = (png_byte)(trans_color->red & 0xff);
pngrtran.c:            png_byte green_low = (png_byte)(trans_color->green & 0xff);
pngrtran.c:            png_byte blue_low = (png_byte)(trans_color->blue & 0xff);
pngrtran.c:                  *dp-- = 0xff;
pngrtran.c:                  *dp-- = 0xff;
pngrtran.c:         row_info->pixel_depth = (png_byte)(row_info->bit_depth << 2);
pngrtran.c:         row_info->rowbytes = PNG_ROWBYTES(row_info->pixel_depth, row_width);
pngrtran.c:/* If the bit depth is 8 and the color type is not a palette type expand the
pngrtran.c:png_do_expand_16(png_row_infop row_info, png_bytep row)
pngrtran.c:       *  Which happens to be exactly input * 257 and this can be achieved
pngrtran.c:      row_info->pixel_depth = (png_byte)(row_info->channels * 16);
pngrtran.c:             * it down to a reasonable formula.  For example, with
pngrtran.c:             * p = (((r >> 3) & 0x1f) << 10) |
pngrtran.c:             *    (((g >> 3) & 0x1f) << 5) |
pngrtran.c:             *    ((b >> 3) & 0x1f);
pngrtran.c:         row_info->pixel_depth = row_info->bit_depth;
pngrtran.c:         row_info->rowbytes = PNG_ROWBYTES(row_info->pixel_depth, row_width);
pngrtran.c:         row_info->pixel_depth = row_info->bit_depth;
pngrtran.c:         row_info->rowbytes = PNG_ROWBYTES(row_info->pixel_depth, row_width);
pngrtran.c:       * png_read_update_info() after setting transforms that expand pixels.
pngrtran.c:         png_do_expand_palette(row_info, png_ptr->row_buf + 1,
pngrtran.c:            png_do_expand(row_info, png_ptr->row_buf + 1,
pngrtran.c:            png_do_expand(row_info, png_ptr->row_buf + 1,
pngrtran.c:            png_warning(png_ptr, "png_do_rgb_to_gray found nongray pixel");
pngrtran.c:            png_error(png_ptr, "png_do_rgb_to_gray found nongray pixel");
pngrtran.c: *   gray-to-RGB, or you will have to test 3x as many bytes to check if a
pngrtran.c: *   pixel is transparent.  You would also need to make sure that the
pngrtran.c: *                                   (3x compare/pixel compared to doing
pngrtran.c: *                                   remove alpha bytes (3x float
pngrtran.c: *                                   operations/pixel compared with composite
pngrtran.c: *  performance, as this increases the per-pixel operations.  If we would check
pngrtran.c:          png_ptr->palette_lookup, png_ptr->quantize_index);
pngrtran.c:   /* Do the expansion now, after all the arithmetic has been done.  Notice
pngrtran.c:      png_do_expand_16(row_info, png_ptr->row_buf + 1);
pngrtran.c:       png_ptr->num_palette_max >= 0)
pngrtran.c:      png_do_check_palette_indexes(png_ptr, row_info);
pngrtran.c:                /*  png_byte color_type;     color type of pixels */
pngrtran.c:                /*  png_byte pixel_depth;    bits per pixel (depth*channels) */
pngrtran.c:             png_ptr->row_buf + 1);    /* start of pixel data for row */
pngrtran.c:      row_info->pixel_depth = (png_byte)(row_info->bit_depth *
pngrtran.c:      row_info->rowbytes = PNG_ROWBYTES(row_info->pixel_depth, row_info->width);
Binary file pngrtran.o matches
pngrutil.c:/* The following is a variation on the above for use with the fixed
pngrutil.c: * gAMA and cHRM use *unsigned* integers for fixed point values.
pngrutil.c:static png_fixed_point /* PRIVATE */
pngrutil.c:png_get_fixed_point(png_structrp png_ptr, png_const_bytep buf)
pngrutil.c:      return (png_fixed_point)uval; /* known to be in range */
pngrutil.c:      png_warning(png_ptr, "PNG fixed point integer out of range");
pngrutil.c: * but the APIs will still be available externally.
pngrutil.c: * functions are necessary because they allow the macros to co-exist with
pngrutil.c: * these (unused but exported) functions.
pngrutil.c: * is no guarantee that a 'png_int_32' is exactly 32 bits, therefore
pngrutil.c:   if ((uval & 0x80000000) == 0) /* non-negative */
pngrutil.c:   uval = (uval ^ 0xffffffff) + 1;  /* 2's complement: -x = ~x+1 */
pngrutil.c:   /* Exit if the user application does not expect a signature. */
pngrutil.c:   png_debug2(0, "Reading %lx chunk, length = %lu",
pngrutil.c:    * reset, therefore it is necessary to always allocate the maximum window
pngrutil.c:#if PNG_ZLIB_VERNUM >= 0x1240
pngrutil.c:      png_ptr->zstream.next_in = NULL;
pngrutil.c:      png_ptr->zstream.next_out = NULL;
pngrutil.c:#if PNG_ZLIB_VERNUM < 0x1240
pngrutil.c:#if PNG_ZLIB_VERNUM < 0x1240
pngrutil.c: * are not changed, so the next input is (data+input_size) and the next
pngrutil.c:       * zlib.  This code uses ZLIB_IO_MAX, from pngpriv.h, as the maximum (the
pngrutil.c:       * maximum value that can be stored in a uInt.)  It is possible to set
pngrutil.c:      png_ptr->zstream.next_in = PNGZ_INPUT_CAST(input);
pngrutil.c:         png_ptr->zstream.next_out = output;
pngrutil.c:          * zlib to advance the 'next_in' pointer.  This allows arbitrary
pngrutil.c:         avail = ZLIB_IO_MAX; /* maximum zlib can process */
pngrutil.c:            png_ptr->zstream.next_out = local_buffer;
pngrutil.c:         png_ptr->zstream.next_out = NULL;
pngrutil.c: * holding the original prefix part and an uncompressed version of the
pngrutil.c:   png_uint_32 chunklength, png_uint_32 prefix_size,
pngrutil.c:   png_alloc_size_t *newlength /* must be initialized to the maximum! */,
pngrutil.c:    * The caller supplies *newlength set to the maximum length of the
pngrutil.c:    * uncompressed data, but this routine allocates space for the prefix and
pngrutil.c:    * maybe a '\0' terminator too.  We have to assume that 'prefix_size' is
pngrutil.c:    * limited only by the maximum chunk size.
pngrutil.c:   if (png_ptr->user_chunk_malloc_max > 0 &&
pngrutil.c:       png_ptr->user_chunk_malloc_max < limit)
pngrutil.c:      limit = png_ptr->user_chunk_malloc_max;
pngrutil.c:   if (limit >= prefix_size + (terminate != 0))
pngrutil.c:      limit -= prefix_size + (terminate != 0);
pngrutil.c:         png_uint_32 lzsize = chunklength - prefix_size;
pngrutil.c:            /* input: */ png_ptr->read_buffer + prefix_size, &lzsize,
pngrutil.c:                * expanded, size will fit in a size_t (let alone an
pngrutil.c:                * extra OOM message.
pngrutil.c:               png_alloc_size_t buffer_size = prefix_size + new_size +
pngrutil.c:               png_bytep text = png_voidcast(png_bytep, png_malloc_base(png_ptr,
pngrutil.c:               if (text != NULL)
pngrutil.c:                     png_ptr->read_buffer + prefix_size, &lzsize,
pngrutil.c:                     text + prefix_size, newlength);
pngrutil.c:                           text[prefix_size + *newlength] = 0;
pngrutil.c:                        if (prefix_size > 0)
pngrutil.c:                           memcpy(text, png_ptr->read_buffer, prefix_size);
pngrutil.c:                           png_ptr->read_buffer = text;
pngrutil.c:                           text = old_ptr; /* freed below */
pngrutil.c:                         * The 'msg' pointer has been set to "unexpected end of
pngrutil.c:                  /* Free the text pointer (this is the old read_buffer on
pngrutil.c:                  png_free(png_ptr, text);
pngrutil.c:                  text = NULL;
pngrutil.c:                   * the extra space may otherwise be used as a Trojan Horse.
pngrutil.c:                     chunklength - prefix_size != lzsize)
pngrutil.c:                     png_chunk_benign_error(png_ptr, "extra compressed data");
pngrutil.c:      /* Application/configuration limits exceeded */
pngrutil.c:   png_uint_32p chunk_bytes, png_bytep next_out, png_alloc_size_t *out_size,
pngrutil.c:      /* next_in and avail_in must have been initialized by the caller. */
pngrutil.c:      png_ptr->zstream.next_out = next_out;
pngrutil.c:            png_ptr->zstream.next_in = read_buffer;
pngrutil.c:   png_ptr->pixel_depth = (png_byte)(png_ptr->bit_depth * png_ptr->channels);
pngrutil.c:   png_ptr->rowbytes = PNG_ROWBYTES(png_ptr->pixel_depth, png_ptr->width);
pngrutil.c:    * info_ptr palette gets changed.  This is extremely unexpected and
pngrutil.c:    * Fix this by not sharing the palette in this way.
pngrutil.c:   png_fixed_point igamma;
pngrutil.c:   igamma = png_get_fixed_point(NULL, buf);
pngrutil.c:   png_xy xy;
pngrutil.c:   xy.whitex = png_get_fixed_point(NULL, buf);
pngrutil.c:   xy.whitey = png_get_fixed_point(NULL, buf + 4);
pngrutil.c:   xy.redx   = png_get_fixed_point(NULL, buf + 8);
pngrutil.c:   xy.redy   = png_get_fixed_point(NULL, buf + 12);
pngrutil.c:   xy.greenx = png_get_fixed_point(NULL, buf + 16);
pngrutil.c:   xy.greeny = png_get_fixed_point(NULL, buf + 20);
pngrutil.c:   xy.bluex  = png_get_fixed_point(NULL, buf + 24);
pngrutil.c:   xy.bluey  = png_get_fixed_point(NULL, buf + 28);
pngrutil.c:   if (xy.whitex == PNG_FIXED_ERROR ||
pngrutil.c:       xy.whitey == PNG_FIXED_ERROR ||
pngrutil.c:       xy.redx   == PNG_FIXED_ERROR ||
pngrutil.c:       xy.redy   == PNG_FIXED_ERROR ||
pngrutil.c:       xy.greenx == PNG_FIXED_ERROR ||
pngrutil.c:       xy.greeny == PNG_FIXED_ERROR ||
pngrutil.c:       xy.bluex  == PNG_FIXED_ERROR ||
pngrutil.c:       xy.bluey  == PNG_FIXED_ERROR)
pngrutil.c:   (void)png_colorspace_set_chromaticities(png_ptr, &png_ptr->colorspace, &xy,
pngrutil.c:      read_length = 81; /* maximum */
pngrutil.c:               png_ptr->zstream.next_in = (Bytef*)keyword + (keyword_length+2);
pngrutil.c:                           /* Still expect a buffer error because we expect
pngrutil.c:                                    errmsg = "extra compressed data";
pngrutil.c:                                 /* But otherwise allow extra data: */
pngrutil.c:                                          "extra compressed data");
pngrutil.c:   png_size_t max_dl;
pngrutil.c:   if (png_ptr->user_chunk_cache_max != 0)
pngrutil.c:      if (png_ptr->user_chunk_cache_max == 1)
pngrutil.c:      if (--png_ptr->user_chunk_cache_max == 1)
pngrutil.c:    * potential breakage point if the types in pngconf.h aren't exactly right.
pngrutil.c:   max_dl = PNG_SIZE_MAX / (sizeof (png_sPLT_entry));
pngrutil.c:   if (dl > max_dl)
pngrutil.c:   /* Discard all chunk data except the name and stash that */
pngrutil.c:    * png_info.  Fix this.
pngrutil.c:   /* We convert the index value into RGB components so that we can allow
pngrutil.c:      background.index = buf[0];
pngrutil.c:            png_chunk_benign_error(png_ptr, "invalid index");
pngrutil.c:      background.index = 0;
pngrutil.c:      background.index = 0;
pngrutil.c:   png_uint_32 res_x, res_y;
pngrutil.c:   res_x = png_get_uint_32(buf);
pngrutil.c:   png_set_pHYs(png_ptr, info_ptr, res_x, res_y, unit_type);
pngrutil.c:   png_int_32 offset_x, offset_y;
pngrutil.c:   offset_x = png_get_int_32(buf);
pngrutil.c:   png_set_oFFs(png_ptr, info_ptr, offset_x, offset_y, unit_type);
pngrutil.c:/* Read the pCAL chunk (described in the PNG Extensions document) */
pngrutil.c:    * a '\0' and they need to fit exactly in the chunk data.
pngrutil.c:   png_text  text_info;
pngrutil.c:   png_charp text;
pngrutil.c:   if (png_ptr->user_chunk_cache_max != 0)
pngrutil.c:      if (png_ptr->user_chunk_cache_max == 1)
pngrutil.c:      if (--png_ptr->user_chunk_cache_max == 1)
pngrutil.c:   for (text = key; *text; text++)
pngrutil.c:   if (text != key + length)
pngrutil.c:      text++;
pngrutil.c:   text_info.compression = PNG_TEXT_COMPRESSION_NONE;
pngrutil.c:   text_info.key = key;
pngrutil.c:   text_info.lang = NULL;
pngrutil.c:   text_info.lang_key = NULL;
pngrutil.c:   text_info.itxt_length = 0;
pngrutil.c:   text_info.text = text;
pngrutil.c:   text_info.text_length = strlen(text);
pngrutil.c:   if (png_set_text_2(png_ptr, info_ptr, &text_info, 1) != 0)
pngrutil.c:      png_warning(png_ptr, "Insufficient memory to process text chunk");
pngrutil.c:   if (png_ptr->user_chunk_cache_max != 0)
pngrutil.c:      if (png_ptr->user_chunk_cache_max == 1)
pngrutil.c:      if (--png_ptr->user_chunk_cache_max == 1)
pngrutil.c:   /* zTXt must have some LZ data after the keyword, although it may expand to
pngrutil.c:       * and text chunks.
pngrutil.c:         png_text text;
pngrutil.c:         /* It worked; png_ptr->read_buffer now looks like a tEXt chunk except
pngrutil.c:          * for the extra compression type byte and the fact that it isn't
pngrutil.c:         text.compression = PNG_TEXT_COMPRESSION_zTXt;
pngrutil.c:         text.key = (png_charp)buffer;
pngrutil.c:         text.text = (png_charp)(buffer + keyword_length+2);
pngrutil.c:         text.text_length = uncompressed_length;
pngrutil.c:         text.itxt_length = 0;
pngrutil.c:         text.lang = NULL;
pngrutil.c:         text.lang_key = NULL;
pngrutil.c:         if (png_set_text_2(png_ptr, info_ptr, &text, 1) != 0)
pngrutil.c:   png_uint_32 prefix_length;
pngrutil.c:   if (png_ptr->user_chunk_cache_max != 0)
pngrutil.c:      if (png_ptr->user_chunk_cache_max == 1)
pngrutil.c:      if (--png_ptr->user_chunk_cache_max == 1)
pngrutil.c:   for (prefix_length=0;
pngrutil.c:      prefix_length < length && buffer[prefix_length] != 0;
pngrutil.c:      ++prefix_length)
pngrutil.c:   if (prefix_length > 79 || prefix_length < 1)
pngrutil.c:   /* Expect keyword, compression flag, compression type, language, translated
pngrutil.c:    * keyword (both may be empty but are 0 terminated) then the text, which may
pngrutil.c:   else if (prefix_length + 5 > length)
pngrutil.c:   else if (buffer[prefix_length+1] == 0 ||
pngrutil.c:      (buffer[prefix_length+1] == 1 &&
pngrutil.c:      buffer[prefix_length+2] == PNG_COMPRESSION_TYPE_BASE))
pngrutil.c:      int compressed = buffer[prefix_length+1] != 0;
pngrutil.c:      prefix_length += 3;
pngrutil.c:      language_offset = prefix_length;
pngrutil.c:      for (; prefix_length < length && buffer[prefix_length] != 0;
pngrutil.c:         ++prefix_length)
pngrutil.c:      translated_keyword_offset = ++prefix_length;
pngrutil.c:      for (; prefix_length < length && buffer[prefix_length] != 0;
pngrutil.c:         ++prefix_length)
pngrutil.c:      /* prefix_length should now be at the trailing '\0' of the translated
pngrutil.c:      ++prefix_length;
pngrutil.c:      if (compressed == 0 && prefix_length <= length)
pngrutil.c:         uncompressed_length = length - prefix_length;
pngrutil.c:      else if (compressed != 0 && prefix_length < length)
pngrutil.c:          * iCCP and text chunks.
pngrutil.c:         if (png_decompress_chunk(png_ptr, length, prefix_length,
pngrutil.c:         png_text text;
pngrutil.c:         buffer[uncompressed_length+prefix_length] = 0;
pngrutil.c:            text.compression = PNG_ITXT_COMPRESSION_NONE;
pngrutil.c:            text.compression = PNG_ITXT_COMPRESSION_zTXt;
pngrutil.c:         text.key = (png_charp)buffer;
pngrutil.c:         text.lang = (png_charp)buffer + language_offset;
pngrutil.c:         text.lang_key = (png_charp)buffer + translated_keyword_offset;
pngrutil.c:         text.text = (png_charp)buffer + prefix_length;
pngrutil.c:         text.text_length = 0;
pngrutil.c:         text.itxt_length = uncompressed_length;
pngrutil.c:         if (png_set_text_2(png_ptr, info_ptr, &text, 1) != 0)
pngrutil.c:      if (png_ptr->user_chunk_malloc_max > 0 &&
pngrutil.c:          png_ptr->user_chunk_malloc_max < limit)
pngrutil.c:         limit = png_ptr->user_chunk_malloc_max;
pngrutil.c:      png_chunk_benign_error(png_ptr, "unknown chunk exceeds memory limits");
pngrutil.c:   /* NOTE: this code is based on the code in libpng-1.4.12 except for fixing
pngrutil.c:         switch (png_ptr->user_chunk_cache_max)
pngrutil.c:               png_ptr->user_chunk_cache_max = 1;
pngrutil.c:               --(png_ptr->user_chunk_cache_max);
pngrutil.c:      int c = chunk_name & 0xff;
pngrutil.c:/* Combines the row recently read in with the existing pixels in the row.  This
pngrutil.c: * (dp) is filled from the start by replicating the available pixels.  If
pngrutil.c: * 'display' is false only those pixels present in the pass are filled in.
pngrutil.c:   unsigned int pixel_depth = png_ptr->transformed_pixel_depth;
pngrutil.c:   if (pixel_depth == 0)
pngrutil.c:   /* Added in 1.5.4: the pixel depth should match the information returned by
pngrutil.c:          PNG_ROWBYTES(pixel_depth, row_width))
pngrutil.c:   /* Don't expect this to ever happen: */
pngrutil.c:   end_mask = (pixel_depth * row_width) & 7;
pngrutil.c:      end_ptr = dp + PNG_ROWBYTES(pixel_depth, row_width) - 1;
pngrutil.c:            end_mask = 0xff << end_mask;
pngrutil.c:         end_mask = 0xff >> end_mask;
pngrutil.c:    * caller just gets a sequence of the unexpanded rows from each interlace
pngrutil.c:      if (pixel_depth < 8)
pngrutil.c:         /* For pixel depths up to 4 bpp the 8-pixel mask can be expanded to fit
pngrutil.c:          * expanded mask may also not require any masking within a byte.  To
pngrutil.c:          * simply requires the pixels to be reversed in each byte.
pngrutil.c:          * not) of the pixels in each byte.
pngrutil.c:          * understands the 'x' logic; the 'y' logic is handled by the caller.
pngrutil.c:          * masks for each pixel depth and each possibility of swapped or not
pngrutil.c:          * swapped bytes.  Pass 'p' is in the range 0..6; 'x', a pixel index,
pngrutil.c:          * is in the range 0..7; and the result is 1 if the pixel is to be
pngrutil.c:          * With some compilers a compile time expression of the general form:
pngrutil.c:          * because the right hand side of the ?: expression is evaluated by
pngrutil.c:#           define PNG_LSR(x,s) ((x)>>((s) & 0x1f))
pngrutil.c:#           define PNG_LSL(x,s) ((x)<<((s) & 0x1f))
pngrutil.c:#           define PNG_LSR(x,s) ((x)>>(s))
pngrutil.c:#           define PNG_LSL(x,s) ((x)<<(s))
pngrutil.c:#        define S_COPY(p,x) (((p)<4 ? PNG_LSR(0x80088822,(3-(p))*8+(7-(x))) :\
pngrutil.c:           PNG_LSR(0xaa55ff00,(7-(p))*8+(7-(x)))) & 1)
pngrutil.c:#        define B_COPY(p,x) (((p)<4 ? PNG_LSR(0xff0fff33,(3-(p))*8+(7-(x))) :\
pngrutil.c:           PNG_LSR(0xff55ff00,(7-(p))*8+(7-(x)))) & 1)
pngrutil.c:         /* Return a mask for pass 'p' pixel 'x' at depth 'd'.  The mask is
pngrutil.c:          * little endian - the first pixel is at bit 0 - however the extra
pngrutil.c:#        define PIXEL_MASK(p,x,d,s) \
pngrutil.c:            (PNG_LSL(((PNG_LSL(1U,(d)))-1),(((x)*(d))^((s)?8-(d):0))))
pngrutil.c:         /* Hence generate the appropriate 'block' or 'sparkle' pixel copy mask.
pngrutil.c:#        define S_MASKx(p,x,d,s) (S_COPY(p,x)?PIXEL_MASK(p,x,d,s):0)
pngrutil.c:#        define B_MASKx(p,x,d,s) (B_COPY(p,x)?PIXEL_MASK(p,x,d,s):0)
pngrutil.c:#        define MASK_EXPAND(m,d) ((m)*((d)==1?0x01010101:((d)==2?0x00010001:1)))
pngrutil.c:#        define S_MASK(p,d,s) MASK_EXPAND(S_MASKx(p,0,d,s) + S_MASKx(p,1,d,s) +\
pngrutil.c:            S_MASKx(p,2,d,s) + S_MASKx(p,3,d,s) + S_MASKx(p,4,d,s) +\
pngrutil.c:            S_MASKx(p,5,d,s) + S_MASKx(p,6,d,s) + S_MASKx(p,7,d,s), d)
pngrutil.c:#        define B_MASK(p,d,s) MASK_EXPAND(B_MASKx(p,0,d,s) + B_MASKx(p,1,d,s) +\
pngrutil.c:            B_MASKx(p,2,d,s) + B_MASKx(p,3,d,s) + B_MASKx(p,4,d,s) +\
pngrutil.c:            B_MASKx(p,5,d,s) + B_MASKx(p,6,d,s) + B_MASKx(p,7,d,s), d)
pngrutil.c:         /* Hence the pre-compiled masks indexed by PACKSWAP (or not), depth and
pngrutil.c:         /* display_mask has only three entries for the odd passes, so index by
pngrutil.c:          * the byte mask will be 0 or 0xff; optimize these cases.  row_width is
pngrutil.c:          * the number of pixels, but the code copies bytes, so it is necessary
pngrutil.c:         png_uint_32 pixels_per_byte = 8 / pixel_depth;
pngrutil.c:               mask = MASK(pass, pixel_depth, display, 0);
pngrutil.c:            mask = MASK(pass, pixel_depth, display, 1);
pngrutil.c:            m &= 0xff;
pngrutil.c:               if (m != 0xff)
pngrutil.c:             * is not an exact number of bytes wide; libpng has always done
pngrutil.c:            if (row_width <= pixels_per_byte)
pngrutil.c:            row_width -= pixels_per_byte;
pngrutil.c:      else /* pixel_depth >= 8 */
pngrutil.c:         if (pixel_depth & 7)
pngrutil.c:            png_error(png_ptr, "invalid user transform pixel depth");
pngrutil.c:         pixel_depth >>= 3; /* now in bytes */
pngrutil.c:         row_width *= pixel_depth;
pngrutil.c:          * fixed number of pixels to copy then to skip.  There may be a
pngrutil.c:          * different number of pixels to skip at the start though.
pngrutil.c:            unsigned int offset = PNG_PASS_START_COL(pass) * pixel_depth;
pngrutil.c:            /* When doing the 'block' algorithm the pixel in the pass gets
pngrutil.c:             * replicated to adjacent pixels.  This is why the even (0,2,4,6)
pngrutil.c:             * passes are skipped above - the entire expanded row is copied.
pngrutil.c:            bytes_to_copy = (1<<((6-pass)>>1)) * pixel_depth;
pngrutil.c:            /* But don't allow this number to exceed the actual row width. */
pngrutil.c:         else /* normal row; Adam7 only ever gives us one pixel to copy. */
pngrutil.c:            bytes_to_copy = pixel_depth;
pngrutil.c:         /* In Adam7 there is a constant offset between where the pixels go. */
pngrutil.c:         bytes_to_jump = PNG_PASS_COL_OFFSET(pass) * pixel_depth;
pngrutil.c:               /* This can only be the RGB case, so each copy is exactly one
pngrutil.c:                * pixel and it is not necessary to check for a partial copy.
pngrutil.c:      } /* pixel_depth >= 8 */
pngrutil.c:      /* Here if pixel_depth < 8 to check 'end_ptr' below. */
pngrutil.c:   memcpy(dp, sp, PNG_ROWBYTES(pixel_depth, row_width));
pngrutil.c:   /* Arrays to facilitate easy interlacing - use pass (0 - 6) as index */
pngrutil.c:   /* Offset to next interlace block */
pngrutil.c:      switch (row_info->pixel_depth)
pngrutil.c:                sshift = (int)((row_info->width + 7) & 0x07);
pngrutil.c:                dshift = (int)((final_width + 7) & 0x07);
pngrutil.c:                sshift = 7 - (int)((row_info->width + 7) & 0x07);
pngrutil.c:                dshift = 7 - (int)((final_width + 7) & 0x07);
pngrutil.c:               v = (png_byte)((*sp >> sshift) & 0x01);
pngrutil.c:                  unsigned int tmp = *dp & (0x7f7f >> (7 - dshift));
pngrutil.c:                  *dp = (png_byte)(tmp & 0xff);
pngrutil.c:               sshift = (int)(((row_info->width + 3) & 0x03) << 1);
pngrutil.c:               dshift = (int)(((final_width + 3) & 0x03) << 1);
pngrutil.c:               sshift = (int)((3 - ((row_info->width + 3) & 0x03)) << 1);
pngrutil.c:               dshift = (int)((3 - ((final_width + 3) & 0x03)) << 1);
pngrutil.c:               v = (png_byte)((*sp >> sshift) & 0x03);
pngrutil.c:                  unsigned int tmp = *dp & (0x3f3f >> (6 - dshift));
pngrutil.c:                  *dp = (png_byte)(tmp & 0xff);
pngrutil.c:               sshift = (int)(((row_info->width + 1) & 0x01) << 2);
pngrutil.c:               dshift = (int)(((final_width + 1) & 0x01) << 2);
pngrutil.c:               sshift = (int)((1 - ((row_info->width + 1) & 0x01)) << 2);
pngrutil.c:               dshift = (int)((1 - ((final_width + 1) & 0x01)) << 2);
pngrutil.c:               png_byte v = (png_byte)((*sp >> sshift) & 0x0f);
pngrutil.c:                  unsigned int tmp = *dp & (0xf0f >> (4 - dshift));
pngrutil.c:                  *dp = (png_byte)(tmp & 0xff);
pngrutil.c:            png_size_t pixel_bytes = (row_info->pixel_depth >> 3);
pngrutil.c:                * pixel_bytes;
pngrutil.c:            png_bytep dp = row + (png_size_t)(final_width - 1) * pixel_bytes;
pngrutil.c:               png_byte v[8]; /* SAFE; pixel_depth does not exceed 64 */
pngrutil.c:               memcpy(v, sp, pixel_bytes);
pngrutil.c:                  memcpy(dp, v, pixel_bytes);
pngrutil.c:                  dp -= pixel_bytes;
pngrutil.c:               sp -= pixel_bytes;
pngrutil.c:      row_info->rowbytes = PNG_ROWBYTES(row_info->pixel_depth, final_width);
pngrutil.c:   unsigned int bpp = (row_info->pixel_depth + 7) >> 3;
pngrutil.c:      *rp = (png_byte)(((int)(*rp) + (int)(*(rp-bpp))) & 0xff);
pngrutil.c:      *rp = (png_byte)(((int)(*rp) + (int)(*pp++)) & 0xff);
pngrutil.c:   unsigned int bpp = (row_info->pixel_depth + 7) >> 3;
pngrutil.c:         ((int)(*pp++) / 2 )) & 0xff);
pngrutil.c:         (int)(*pp++ + *(rp-bpp)) / 2 ) & 0xff);
pngrutil.c:png_read_filter_row_paeth_1byte_pixel(png_row_infop row_info, png_bytep row,
pngrutil.c:   /* First pixel/byte */
pngrutil.c:      a &= 0xff; /* From previous iteration or start */
pngrutil.c:      /* Calculate the current pixel in a, and move the previous row pixel to c
pngrutil.c:       * for the next time round the loop
pngrutil.c:png_read_filter_row_paeth_multibyte_pixel(png_row_infop row_info, png_bytep row,
pngrutil.c:   int bpp = (row_info->pixel_depth + 7) >> 3;
pngrutil.c:   /* Process the first pixel in the row completely (this is the same as 'up'
pngrutil.c:   /* This function is called once for every PNG image (except for PNG images
pngrutil.c:    * the image pixel format.  If the implementation depends on image width then
pngrutil.c:   unsigned int bpp = (pp->pixel_depth + 7) >> 3;
pngrutil.c:         png_read_filter_row_paeth_1byte_pixel;
pngrutil.c:         png_read_filter_row_paeth_multibyte_pixel;
pngrutil.c:    * To see an example of this examine what configure.ac does when
pngrutil.c:   png_ptr->zstream.next_out = output;
pngrutil.c:         png_ptr->zstream.next_in = buffer;
pngrutil.c:         png_ptr->zstream.next_out = tmpbuf;
pngrutil.c:      /* Use NO_FLUSH; this gives zlib the maximum opportunity to optimize the
pngrutil.c:       * following chunk (it then exits with png_error).
pngrutil.c:      else /* avail_out counts the extra bytes */
pngrutil.c:         png_ptr->zstream.next_out = NULL;
pngrutil.c:            png_chunk_benign_error(png_ptr, "Extra compressed data");
pngrutil.c:      else /* the deflate stream contained extra data */
pngrutil.c:      png_ptr->zstream.next_out = NULL; /* safety */
pngrutil.c:      png_ptr->zstream.next_in = NULL;
pngrutil.c:   /* Arrays to facilitate easy interlacing - use pass (0 - 6) as index */
pngrutil.c:   /* Offset to next interlace block */
pngrutil.c:   /* Offset to next interlace block in the y direction */
pngrutil.c:       * read-ahead of the next row's filter byte.
pngrutil.c:   /* Arrays to facilitate easy interlacing - use pass (0 - 6) as index */
pngrutil.c:   /* Offset to next interlace block */
pngrutil.c:   /* Offset to next interlace block in the y direction */
pngrutil.c:   int max_pixel_depth;
pngrutil.c:   max_pixel_depth = png_ptr->pixel_depth;
pngrutil.c:    * calculations to calculate the final pixel depth, then
pngrutil.c:    * TODO: fix this.
pngrutil.c:      max_pixel_depth = 8;
pngrutil.c:            max_pixel_depth = 32;
pngrutil.c:            max_pixel_depth = 24;
pngrutil.c:         if (max_pixel_depth < 8)
pngrutil.c:            max_pixel_depth = 8;
pngrutil.c:            max_pixel_depth *= 2;
pngrutil.c:            max_pixel_depth *= 4;
pngrutil.c:            max_pixel_depth /= 3;
pngrutil.c:               max_pixel_depth *= 2;
pngrutil.c:         if (max_pixel_depth <= 8)
pngrutil.c:            max_pixel_depth = 16;
pngrutil.c:            max_pixel_depth = 32;
pngrutil.c:         if (max_pixel_depth <= 32)
pngrutil.c:            max_pixel_depth = 32;
pngrutil.c:            max_pixel_depth = 64;
pngrutil.c:         if (max_pixel_depth <= 16)
pngrutil.c:            max_pixel_depth = 32;
pngrutil.c:            max_pixel_depth = 64;
pngrutil.c:         if (max_pixel_depth <= 8)
pngrutil.c:               max_pixel_depth = 32;
pngrutil.c:               max_pixel_depth = 24;
pngrutil.c:            max_pixel_depth = 64;
pngrutil.c:            max_pixel_depth = 48;
pngrutil.c:      int user_pixel_depth = png_ptr->user_transform_depth *
pngrutil.c:      if (user_pixel_depth > max_pixel_depth)
pngrutil.c:         max_pixel_depth = user_pixel_depth;
pngrutil.c:   png_ptr->maximum_pixel_depth = (png_byte)max_pixel_depth;
pngrutil.c:   png_ptr->transformed_pixel_depth = 0; /* calculated on demand */
pngrutil.c:   /* Align the width on the next larger 8 pixels.  Mainly used
pngrutil.c:   /* Calculate the maximum bytes needed, adding a byte and a pixel
pngrutil.c:   row_bytes = PNG_ROWBYTES(max_pixel_depth, row_bytes) +
pngrutil.c:       1 + ((max_pixel_depth + 7) >> 3);
pngrutil.c:      * NOTE: the alignment is to the start of the pixels, one beyond the start
pngrutil.c:      * was incorrect; the filter byte was aligned, which had the exact
pngrutil.c:        int extra = (int)((temp - (png_bytep)0) & 0x0f);
pngrutil.c:        png_ptr->row_buf = temp - extra - 1/*filter byte*/;
pngrutil.c:        extra = (int)((temp - (png_bytep)0) & 0x0f);
pngrutil.c:        png_ptr->prev_row = temp - extra - 1/*filter byte*/;
pngrutil.c:       (unsigned long)PNG_ROWBYTES(png_ptr->pixel_depth, png_ptr->iwidth) + 1);
Binary file pngrutil.o matches
pngset.c:png_set_cHRM_fixed(png_const_structrp png_ptr, png_inforp info_ptr,
pngset.c:    png_fixed_point white_x, png_fixed_point white_y, png_fixed_point red_x,
pngset.c:    png_fixed_point red_y, png_fixed_point green_x, png_fixed_point green_y,
pngset.c:    png_fixed_point blue_x, png_fixed_point blue_y)
pngset.c:   png_xy xy;
pngset.c:   png_debug1(1, "in %s storage function", "cHRM fixed");
pngset.c:   xy.redx = red_x;
pngset.c:   xy.redy = red_y;
pngset.c:   xy.greenx = green_x;
pngset.c:   xy.greeny = green_y;
pngset.c:   xy.bluex = blue_x;
pngset.c:   xy.bluey = blue_y;
pngset.c:   xy.whitex = white_x;
pngset.c:   xy.whitey = white_y;
pngset.c:   if (png_colorspace_set_chromaticities(png_ptr, &info_ptr->colorspace, &xy,
pngset.c:png_set_cHRM_XYZ_fixed(png_const_structrp png_ptr, png_inforp info_ptr,
pngset.c:    png_fixed_point int_red_X, png_fixed_point int_red_Y,
pngset.c:    png_fixed_point int_red_Z, png_fixed_point int_green_X,
pngset.c:    png_fixed_point int_green_Y, png_fixed_point int_green_Z,
pngset.c:    png_fixed_point int_blue_X, png_fixed_point int_blue_Y,
pngset.c:    png_fixed_point int_blue_Z)
pngset.c:   png_debug1(1, "in %s storage function", "cHRM XYZ fixed");
pngset.c:    double white_x, double white_y, double red_x, double red_y,
pngset.c:    double green_x, double green_y, double blue_x, double blue_y)
pngset.c:   png_set_cHRM_fixed(png_ptr, info_ptr,
pngset.c:      png_fixed(png_ptr, white_x, "cHRM White X"),
pngset.c:      png_fixed(png_ptr, white_y, "cHRM White Y"),
pngset.c:      png_fixed(png_ptr, red_x, "cHRM Red X"),
pngset.c:      png_fixed(png_ptr, red_y, "cHRM Red Y"),
pngset.c:      png_fixed(png_ptr, green_x, "cHRM Green X"),
pngset.c:      png_fixed(png_ptr, green_y, "cHRM Green Y"),
pngset.c:      png_fixed(png_ptr, blue_x, "cHRM Blue X"),
pngset.c:      png_fixed(png_ptr, blue_y, "cHRM Blue Y"));
pngset.c:   png_set_cHRM_XYZ_fixed(png_ptr, info_ptr,
pngset.c:      png_fixed(png_ptr, red_X, "cHRM Red X"),
pngset.c:      png_fixed(png_ptr, red_Y, "cHRM Red Y"),
pngset.c:      png_fixed(png_ptr, red_Z, "cHRM Red Z"),
pngset.c:      png_fixed(png_ptr, green_X, "cHRM Red X"),
pngset.c:      png_fixed(png_ptr, green_Y, "cHRM Red Y"),
pngset.c:      png_fixed(png_ptr, green_Z, "cHRM Red Z"),
pngset.c:      png_fixed(png_ptr, blue_X, "cHRM Red X"),
pngset.c:      png_fixed(png_ptr, blue_Y, "cHRM Red Y"),
pngset.c:      png_fixed(png_ptr, blue_Z, "cHRM Red Z"));
pngset.c:png_set_gAMA_fixed(png_const_structrp png_ptr, png_inforp info_ptr,
pngset.c:    png_fixed_point file_gamma)
pngset.c:   png_set_gAMA_fixed(png_ptr, info_ptr, png_fixed(png_ptr, file_gamma,
pngset.c:   info_ptr->pixel_depth = (png_byte)(info_ptr->channels * info_ptr->bit_depth);
pngset.c:   info_ptr->rowbytes = PNG_ROWBYTES(info_ptr->pixel_depth, width);
pngset.c:    png_int_32 offset_x, png_int_32 offset_y, int unit_type)
pngset.c:   info_ptr->x_offset = offset_x;
pngset.c:png_set_sCAL_fixed(png_const_structrp png_ptr, png_inforp info_ptr, int unit,
pngset.c:    png_fixed_point width, png_fixed_point height)
pngset.c:      png_ascii_from_fixed(png_ptr, swidth, (sizeof swidth), width);
pngset.c:      png_ascii_from_fixed(png_ptr, sheight, (sizeof sheight), height);
pngset.c:    png_uint_32 res_x, png_uint_32 res_y, int unit_type)
pngset.c:   info_ptr->x_pixels_per_unit = res_x;
pngset.c:   info_ptr->y_pixels_per_unit = res_y;
pngset.c:png_set_text(png_const_structrp png_ptr, png_inforp info_ptr,
pngset.c:    png_const_textp text_ptr, int num_text)
pngset.c:   ret = png_set_text_2(png_ptr, info_ptr, text_ptr, num_text);
pngset.c:      png_error(png_ptr, "Insufficient memory to store text");
pngset.c:png_set_text_2(png_const_structrp png_ptr, png_inforp info_ptr,
pngset.c:    png_const_textp text_ptr, int num_text)
pngset.c:   png_debug1(1, "in %lx storage function", png_ptr == NULL ? "unexpected" :
pngset.c:   if (png_ptr == NULL || info_ptr == NULL || num_text <= 0 || text_ptr == NULL)
pngset.c:   /* Make sure we have enough space in the "text" array in info_struct
pngset.c:    * to hold all of the incoming text_ptr objects.  This compare can't overflow
pngset.c:    * because max_text >= num_text (anyway, subtract of two positive integers
pngset.c:   if (num_text > info_ptr->max_text - info_ptr->num_text)
pngset.c:      int old_num_text = info_ptr->num_text;
pngset.c:      int max_text;
pngset.c:      png_textp new_text = NULL;
pngset.c:      /* Calculate an appropriate max_text, checking for overflow. */
pngset.c:      max_text = old_num_text;
pngset.c:      if (num_text <= INT_MAX - max_text)
pngset.c:         max_text += num_text;
pngset.c:         if (max_text < INT_MAX-8)
pngset.c:            max_text = (max_text + 8) & ~0x7;
pngset.c:            max_text = INT_MAX;
pngset.c:         new_text = png_voidcast(png_textp,png_realloc_array(png_ptr,
pngset.c:            info_ptr->text, old_num_text, max_text-old_num_text,
pngset.c:            sizeof *new_text));
pngset.c:      if (new_text == NULL)
pngset.c:         png_chunk_report(png_ptr, "too many text chunks",
pngset.c:      png_free(png_ptr, info_ptr->text);
pngset.c:      info_ptr->text = new_text;
pngset.c:      info_ptr->max_text = max_text;
pngset.c:      /* num_text is adjusted below as the entries are copied in */
pngset.c:      png_debug1(3, "allocated %d entries for info_ptr->text", max_text);
pngset.c:   for (i = 0; i < num_text; i++)
pngset.c:      size_t text_length, key_len;
pngset.c:      png_textp textp = &(info_ptr->text[info_ptr->num_text]);
pngset.c:      if (text_ptr[i].key == NULL)
pngset.c:      if (text_ptr[i].compression < PNG_TEXT_COMPRESSION_NONE ||
pngset.c:          text_ptr[i].compression >= PNG_TEXT_COMPRESSION_LAST)
pngset.c:         png_chunk_report(png_ptr, "text compression mode is out of range",
pngset.c:      key_len = strlen(text_ptr[i].key);
pngset.c:      if (text_ptr[i].compression <= 0)
pngset.c:         if (text_ptr[i].lang != NULL)
pngset.c:            lang_len = strlen(text_ptr[i].lang);
pngset.c:         if (text_ptr[i].lang_key != NULL)
pngset.c:            lang_key_len = strlen(text_ptr[i].lang_key);
pngset.c:      if (text_ptr[i].text == NULL || text_ptr[i].text[0] == '\0')
pngset.c:         text_length = 0;
pngset.c:         if (text_ptr[i].compression > 0)
pngset.c:            textp->compression = PNG_ITXT_COMPRESSION_NONE;
pngset.c:            textp->compression = PNG_TEXT_COMPRESSION_NONE;
pngset.c:         text_length = strlen(text_ptr[i].text);
pngset.c:         textp->compression = text_ptr[i].compression;
pngset.c:      textp->key = png_voidcast(png_charp,png_malloc_base(png_ptr,
pngset.c:          key_len + text_length + lang_len + lang_key_len + 4));
pngset.c:      if (textp->key == NULL)
pngset.c:         png_chunk_report(png_ptr, "text chunk: out of memory",
pngset.c:      png_debug2(2, "Allocated %lu bytes at %p in png_set_text",
pngset.c:          (key_len + lang_len + lang_key_len + text_length + 4),
pngset.c:          textp->key);
pngset.c:      memcpy(textp->key, text_ptr[i].key, key_len);
pngset.c:      *(textp->key + key_len) = '\0';
pngset.c:      if (text_ptr[i].compression > 0)
pngset.c:         textp->lang = textp->key + key_len + 1;
pngset.c:         memcpy(textp->lang, text_ptr[i].lang, lang_len);
pngset.c:         *(textp->lang + lang_len) = '\0';
pngset.c:         textp->lang_key = textp->lang + lang_len + 1;
pngset.c:         memcpy(textp->lang_key, text_ptr[i].lang_key, lang_key_len);
pngset.c:         *(textp->lang_key + lang_key_len) = '\0';
pngset.c:         textp->text = textp->lang_key + lang_key_len + 1;
pngset.c:         textp->lang=NULL;
pngset.c:         textp->lang_key=NULL;
pngset.c:         textp->text = textp->key + key_len + 1;
pngset.c:      if (text_length != 0)
pngset.c:         memcpy(textp->text, text_ptr[i].text, text_length);
pngset.c:      *(textp->text + text_length) = '\0';
pngset.c:      if (textp->compression > 0)
pngset.c:         textp->text_length = 0;
pngset.c:         textp->itxt_length = text_length;
pngset.c:         textp->text_length = text_length;
pngset.c:         textp->itxt_length = 0;
pngset.c:      info_ptr->num_text++;
pngset.c:      png_debug1(3, "transferred text chunk %d", info_ptr->num_text);
pngset.c:      int sample_max = (1 << info_ptr->bit_depth);
pngset.c:          trans_color->gray > sample_max) ||
pngset.c:          (trans_color->red > sample_max ||
pngset.c:          trans_color->green > sample_max ||
pngset.c:          trans_color->blue > sample_max)))
pngset.c:         "png_set_unknown_chunks now expects a valid location");
pngset.c:       * libpng except for IHDR, PLTE, tRNS, IDAT, and IEND
pngset.c:    * required because add_one_chunk above doesn't extend the list if the 'keep'
pngset.c:    * already exists the code is updated, otherwise the chunk is added to the
pngset.c:               "Compression buffer size limited to system maximum");
pngset.c:png_set_user_limits (png_structrp png_ptr, png_uint_32 user_width_max,
pngset.c:    png_uint_32 user_height_max)
pngset.c:    * regardless of dimensions, set both limits to 0x7ffffffL.
pngset.c:   png_ptr->user_width_max = user_width_max;
pngset.c:   png_ptr->user_height_max = user_height_max;
pngset.c:png_set_chunk_cache_max (png_structrp png_ptr, png_uint_32 user_chunk_cache_max)
pngset.c:       png_ptr->user_chunk_cache_max = user_chunk_cache_max;
pngset.c:png_set_chunk_malloc_max (png_structrp png_ptr,
pngset.c:    png_alloc_size_t user_chunk_malloc_max)
pngset.c:      png_ptr->user_chunk_malloc_max = user_chunk_malloc_max;
pngset.c:   /* Whether to report invalid palette index; added at libng-1.5.10.
pngset.c:    * It is possible for an indexed (color-type==3) PNG file to contain
pngset.c:    * pixels with invalid (out-of-range) indexes if the PLTE chunk has
pngset.c:png_set_check_for_invalid_index(png_structrp png_ptr, int allowed)
pngset.c:   png_debug(1, "in png_set_check_for_invalid_index");
pngset.c:      png_ptr->num_palette_max = 0;
pngset.c:      png_ptr->num_palette_max = -1;
Binary file pngset.o matches
Binary file pngstest matches
pngstruct.h:#if ZLIB_VERNUM < 0x1260
pngstruct.h: * can handle at once.  This type need be no larger than 16 bits (so maximum of
pngstruct.h: * maximuum for png_size_t.  The value can be overriden in a library build
pngstruct.h:   struct png_compression_buffer *next;
pngstruct.h:typedef struct png_xy
pngstruct.h:   png_fixed_point redx, redy;
pngstruct.h:   png_fixed_point greenx, greeny;
pngstruct.h:   png_fixed_point bluex, bluey;
pngstruct.h:   png_fixed_point whitex, whitey;
pngstruct.h:} png_xy;
pngstruct.h:   png_fixed_point red_X, red_Y, red_Z;
pngstruct.h:   png_fixed_point green_X, green_Y, green_Z;
pngstruct.h:   png_fixed_point blue_X, blue_Y, blue_Z;
pngstruct.h:   png_fixed_point gamma;        /* File gamma */
pngstruct.h:   png_xy      end_points_xy;    /* End points as chromaticities */
pngstruct.h:#define PNG_COLORSPACE_HAVE_GAMMA           0x0001
pngstruct.h:#define PNG_COLORSPACE_HAVE_ENDPOINTS       0x0002
pngstruct.h:#define PNG_COLORSPACE_HAVE_INTENT          0x0004
pngstruct.h:#define PNG_COLORSPACE_FROM_gAMA            0x0008
pngstruct.h:#define PNG_COLORSPACE_FROM_cHRM            0x0010
pngstruct.h:#define PNG_COLORSPACE_FROM_sRGB            0x0020
pngstruct.h:#define PNG_COLORSPACE_ENDPOINTS_MATCH_sRGB 0x0040
pngstruct.h:#define PNG_COLORSPACE_MATCHES_sRGB         0x0080 /* exact match on profile */
pngstruct.h:#define PNG_COLORSPACE_INVALID              0x8000
pngstruct.h:#define PNG_COLORSPACE_CANCEL(flags)        (0xffff ^ (flags))
pngstruct.h:   png_byte user_transform_depth;    /* bit depth of user transformed pixels */
pngstruct.h:   png_byte user_transform_channels; /* channels in user transformed pixels */
pngstruct.h:   int zlib_text_level;            /* holds zlib compression level */
pngstruct.h:   int zlib_text_method;           /* holds zlib compression method */
pngstruct.h:   int zlib_text_window_bits;      /* holds zlib compression window bits */
pngstruct.h:   int zlib_text_mem_level;        /* holds zlib compression memory level */
pngstruct.h:   int zlib_text_strategy;         /* holds zlib compression strategy */
pngstruct.h:   png_uint_32 width;         /* width of image in pixels */
pngstruct.h:   png_uint_32 height;        /* height of image in pixels */
pngstruct.h:   png_uint_32 iwidth;        /* width of current interlaced row in pixels */
pngstruct.h:   int num_palette_max;       /* maximum palette index found in IDAT */
pngstruct.h:   png_byte pixel_depth;      /* number of bits per pixel */
pngstruct.h:   png_byte maximum_pixel_depth;
pngstruct.h:                              /* pixel depth used for the row buffers */
pngstruct.h:   png_byte transformed_pixel_depth;
pngstruct.h:                              /* pixel depth after read/write transforms */
pngstruct.h:   png_uint_16 filler;           /* filler bytes for pixel expansion */
pngstruct.h:   png_fixed_point background_gamma;
pngstruct.h:   png_fixed_point screen_gamma; /* screen gamma value (display_exponent) */
pngstruct.h:   png_size_t save_buffer_max;       /* total size of save_buffer */
pngstruct.h:   int cur_palette;                  /* current push library palette index */
pngstruct.h:   png_bytep quantize_index; /* index translation for palette files */
pngstruct.h:   char time_buffer[29]; /* String to hold RFC 1123 time text */
pngstruct.h:   png_bytep    chunk_list;      /* List of png_byte[5]; the textual chunk name
pngstruct.h:   png_bytep index_to_palette;       /* where the original index currently is
pngstruct.h:   png_bytep palette_to_index;       /* which original index points to this
pngstruct.h:   png_uint_32 user_width_max;
pngstruct.h:   png_uint_32 user_height_max;
pngstruct.h:   /* Added in libpng-1.4.0: Total number of sPLT, text, and unknown
pngstruct.h:   png_uint_32 user_chunk_cache_max;
pngstruct.h:   png_alloc_size_t user_chunk_malloc_max;
Binary file pngtest matches
pngtest.c: * 2) when the maximum IDAT size (PNG_ZBUF_SIZE in pngconf.h) is not 8192.
pngtest.c: *    exist in the input file.
pngtest.c:/* Known chunks that exist in pngtest.png must be supported or pngtest will fail
pngtest.c: * simply as a result of re-ordering them.  This may be fixed in 1.7
pngtest.c: * horribly trying to write extra data after writing garbage).
pngtest.c:static int relaxed = 0;
pngtest.c:/* Example of using row callbacks to make a simple progress meter */
pngtest.c:/* Example of using user transform callback (we don't transform anything,
pngtest.c: * but merely examine the row filters.  We set this to 256 rather than
pngtest.c:/* Example of using user transform callback (we don't transform anything,
pngtest.c:    *  png_byte color_type    color type of pixels
pngtest.c:    *  png_byte pixel_depth   bits per pixel (depth*channels)
pngtest.c:    /* Counts the number of zero samples (or zero pixels if color_type is 3 */
pngtest.c:             if (((*dp << pos++ ) & 0x80) == 0)
pngtest.c:             if (((*dp << (pos+=2)) & 0xc0) == 0)
pngtest.c:             if (((*dp << (pos+=4)) & 0xf0) == 0)
pngtest.c:   /* Check if the current operation (reading / writing) is as expected. */
pngtest.c:    * (file signature / header / data / crc) is as expected.
pngtest.c:/* Allocate memory.  For reasonable files, size should never exceed
pngtest.c: * need to allocate exactly 64K, so whatever you call here must
pngtest.c: * This piece of code can be compiled to validate max 64K allocations
pngtest.c:   struct memory_information *next;
pngtest.c:static int maximum_allocation = 0;
pngtest.c:      if (current_allocation > maximum_allocation)
pngtest.c:         maximum_allocation = current_allocation;
pngtest.c:      pinfo->next = pinformation;
pngtest.c:      memset(pinfo->pointer, 0xdd, pinfo->size);
pngtest.c:            *ppinfo = pinfo->next;
pngtest.c:            memset(ptr, 0x55, pinfo->size);
pngtest.c:         if (pinfo->next == NULL)
pngtest.c:         ppinfo = &pinfo->next;
pngtest.c:#define have_sTER   0x01
pngtest.c:#define have_vpAg   0x02
pngtest.c:#define before_PLTE 0x10
pngtest.c:#define before_IDAT 0x20
pngtest.c:#define after_IDAT  0x40
pngtest.c:      fprintf(STDERR, " vpAg = %lu x %lu, units = %d\n",
pngtest.c:/* START of code to check that libpng has the required text support; this only
pngtest.c:pngtest_check_text_support(png_const_structp png_ptr, png_textp text_ptr,
pngtest.c:   int num_text)
pngtest.c:   while (num_text > 0)
pngtest.c:      switch (text_ptr[--num_text].compression)
pngtest.c:            png_error(png_ptr, "invalid text chunk compression field");
pngtest.c:/* END of code to check that libpng has the required text support */
pngtest.c:       * changed with '--relaxed'.
pngtest.c:   else if (relaxed != 0)
pngtest.c:      png_fixed_point white_x, white_y, red_x, red_y, green_x, green_y, blue_x,
pngtest.c:      if (png_get_cHRM_fixed(read_ptr, read_info_ptr, &white_x, &white_y,
pngtest.c:         &red_x, &red_y, &green_x, &green_y, &blue_x, &blue_y) != 0)
pngtest.c:         png_set_cHRM_fixed(write_ptr, write_info_ptr, white_x, white_y, red_x,
pngtest.c:            red_y, green_x, green_y, blue_x, blue_y);
pngtest.c:      png_fixed_point gamma;
pngtest.c:      if (png_get_gAMA_fixed(read_ptr, read_info_ptr, &gamma) != 0)
pngtest.c:         png_set_gAMA_fixed(write_ptr, write_info_ptr, gamma);
pngtest.c:      double white_x, white_y, red_x, red_y, green_x, green_y, blue_x,
pngtest.c:      if (png_get_cHRM(read_ptr, read_info_ptr, &white_x, &white_y, &red_x,
pngtest.c:         &red_y, &green_x, &green_y, &blue_x, &blue_y) != 0)
pngtest.c:         png_set_cHRM(write_ptr, write_info_ptr, white_x, white_y, red_x,
pngtest.c:            red_y, green_x, green_y, blue_x, blue_y);
pngtest.c:#endif /* Fixed point */
pngtest.c:      png_int_32 offset_x, offset_y;
pngtest.c:      if (png_get_oFFs(read_ptr, read_info_ptr, &offset_x, &offset_y,
pngtest.c:         png_set_oFFs(write_ptr, write_info_ptr, offset_x, offset_y, unit_type);
pngtest.c:      png_uint_32 res_x, res_y;
pngtest.c:      if (png_get_pHYs(read_ptr, read_info_ptr, &res_x, &res_y,
pngtest.c:         png_set_pHYs(write_ptr, write_info_ptr, res_x, res_y, unit_type);
pngtest.c:      png_textp text_ptr;
pngtest.c:      int num_text;
pngtest.c:      if (png_get_text(read_ptr, read_info_ptr, &text_ptr, &num_text) > 0)
pngtest.c:         pngtest_debug1("Handling %d iTXt/tEXt/zTXt chunks", num_text);
pngtest.c:         pngtest_check_text_support(read_ptr, text_ptr, num_text);
pngtest.c:            for (i=0; i<num_text; i++)
pngtest.c:               printf("   Text compression[%d]=%d\n",
pngtest.c:                     i, text_ptr[i].compression);
pngtest.c:         png_set_text(write_ptr, write_info_ptr, text_ptr, num_text);
pngtest.c:         int sample_max = (1 << bit_depth);
pngtest.c:             (int)trans_color->gray > sample_max) ||
pngtest.c:             ((int)trans_color->red > sample_max ||
pngtest.c:             (int)trans_color->green > sample_max ||
pngtest.c:             (int)trans_color->blue > sample_max))))
pngtest.c:   pngtest_debug1("\t0x%08lx", (unsigned long)row_buf);
pngtest.c:         pngtest_debug2("\t0x%08lx (%lu bytes)", (unsigned long)row_buf,
pngtest.c:      png_textp text_ptr;
pngtest.c:      int num_text;
pngtest.c:      if (png_get_text(read_ptr, end_info_ptr, &text_ptr, &num_text) > 0)
pngtest.c:         pngtest_debug1("Handling %d iTXt/tEXt/zTXt chunks", num_text);
pngtest.c:         pngtest_check_text_support(read_ptr, text_ptr, num_text);
pngtest.c:            for (i=0; i<num_text; i++)
pngtest.c:               printf("   Text compression[%d]=%d\n",
pngtest.c:                     i, text_ptr[i].compression);
pngtest.c:         png_set_text(write_ptr, write_end_info_ptr, text_ptr, num_text);
pngtest.c:   /* Normally one would use Z_DEFAULT_STRATEGY for text compression.
pngtest.c:   png_set_text_compression_strategy(write_ptr, Z_FILTERED);
pngtest.c:    * There seems to be no way round this, however vpAg/sTER are not expected
pngtest.c:      /* We don't really expect to get here because of the setjmp handling
pngtest.c:         "   Was %s written with the same maximum IDAT chunk size (%d bytes),",
pngtest.c:         "   Was %s written with the same maximum IDAT chunk size (%d bytes),",
pngtest.c:             * unsupported text chunk compression will result in the compression
pngtest.c:             * can be exactly the same size!
pngtest.c:      fprintf(STDERR, " NOTE: Zlib compiled for max 64k, libpng not\n");
pngtest.c:      fprintf(STDERR, " NOTE: libpng compiled for max 64k, zlib not\n");
pngtest.c:         relaxed = 0;
pngtest.c:      else if (strcmp(argv[1], "--relaxed") == 0)
pngtest.c:         relaxed++;
pngtest.c:     exit(1);
pngtest.c:               pinfo = pinfo->next;
pngtest.c:         fprintf(STDERR, " Maximum memory allocation: %10d bytes\n",
pngtest.c:            maximum_allocation);
pngtest.c:                pinfo = pinfo->next;
pngtest.c:       fprintf(STDERR, " Maximum memory allocation: %10d bytes\n",
pngtest.c:          maximum_allocation);
Binary file pngtest.o matches
Binary file pngtest.png matches
pngtrans.c:/* Turn on pixel packing */
pngtrans.c:/* Turn on packed pixel swapping */
pngtrans.c:          * filler code can execute (basically an 8 or 16-bit component RGB or G
pngtrans.c:   0x00, 0x80, 0x40, 0xC0, 0x20, 0xA0, 0x60, 0xE0,
pngtrans.c:   0x10, 0x90, 0x50, 0xD0, 0x30, 0xB0, 0x70, 0xF0,
pngtrans.c:   0x08, 0x88, 0x48, 0xC8, 0x28, 0xA8, 0x68, 0xE8,
pngtrans.c:   0x18, 0x98, 0x58, 0xD8, 0x38, 0xB8, 0x78, 0xF8,
pngtrans.c:   0x04, 0x84, 0x44, 0xC4, 0x24, 0xA4, 0x64, 0xE4,
pngtrans.c:   0x14, 0x94, 0x54, 0xD4, 0x34, 0xB4, 0x74, 0xF4,
pngtrans.c:   0x0C, 0x8C, 0x4C, 0xCC, 0x2C, 0xAC, 0x6C, 0xEC,
pngtrans.c:   0x1C, 0x9C, 0x5C, 0xDC, 0x3C, 0xBC, 0x7C, 0xFC,
pngtrans.c:   0x02, 0x82, 0x42, 0xC2, 0x22, 0xA2, 0x62, 0xE2,
pngtrans.c:   0x12, 0x92, 0x52, 0xD2, 0x32, 0xB2, 0x72, 0xF2,
pngtrans.c:   0x0A, 0x8A, 0x4A, 0xCA, 0x2A, 0xAA, 0x6A, 0xEA,
pngtrans.c:   0x1A, 0x9A, 0x5A, 0xDA, 0x3A, 0xBA, 0x7A, 0xFA,
pngtrans.c:   0x06, 0x86, 0x46, 0xC6, 0x26, 0xA6, 0x66, 0xE6,
pngtrans.c:   0x16, 0x96, 0x56, 0xD6, 0x36, 0xB6, 0x76, 0xF6,
pngtrans.c:   0x0E, 0x8E, 0x4E, 0xCE, 0x2E, 0xAE, 0x6E, 0xEE,
pngtrans.c:   0x1E, 0x9E, 0x5E, 0xDE, 0x3E, 0xBE, 0x7E, 0xFE,
pngtrans.c:   0x01, 0x81, 0x41, 0xC1, 0x21, 0xA1, 0x61, 0xE1,
pngtrans.c:   0x11, 0x91, 0x51, 0xD1, 0x31, 0xB1, 0x71, 0xF1,
pngtrans.c:   0x09, 0x89, 0x49, 0xC9, 0x29, 0xA9, 0x69, 0xE9,
pngtrans.c:   0x19, 0x99, 0x59, 0xD9, 0x39, 0xB9, 0x79, 0xF9,
pngtrans.c:   0x05, 0x85, 0x45, 0xC5, 0x25, 0xA5, 0x65, 0xE5,
pngtrans.c:   0x15, 0x95, 0x55, 0xD5, 0x35, 0xB5, 0x75, 0xF5,
pngtrans.c:   0x0D, 0x8D, 0x4D, 0xCD, 0x2D, 0xAD, 0x6D, 0xED,
pngtrans.c:   0x1D, 0x9D, 0x5D, 0xDD, 0x3D, 0xBD, 0x7D, 0xFD,
pngtrans.c:   0x03, 0x83, 0x43, 0xC3, 0x23, 0xA3, 0x63, 0xE3,
pngtrans.c:   0x13, 0x93, 0x53, 0xD3, 0x33, 0xB3, 0x73, 0xF3,
pngtrans.c:   0x0B, 0x8B, 0x4B, 0xCB, 0x2B, 0xAB, 0x6B, 0xEB,
pngtrans.c:   0x1B, 0x9B, 0x5B, 0xDB, 0x3B, 0xBB, 0x7B, 0xFB,
pngtrans.c:   0x07, 0x87, 0x47, 0xC7, 0x27, 0xA7, 0x67, 0xE7,
pngtrans.c:   0x17, 0x97, 0x57, 0xD7, 0x37, 0xB7, 0x77, 0xF7,
pngtrans.c:   0x0F, 0x8F, 0x4F, 0xCF, 0x2F, 0xAF, 0x6F, 0xEF,
pngtrans.c:   0x1F, 0x9F, 0x5F, 0xDF, 0x3F, 0xBF, 0x7F, 0xFF
pngtrans.c:   0x00, 0x40, 0x80, 0xC0, 0x10, 0x50, 0x90, 0xD0,
pngtrans.c:   0x20, 0x60, 0xA0, 0xE0, 0x30, 0x70, 0xB0, 0xF0,
pngtrans.c:   0x04, 0x44, 0x84, 0xC4, 0x14, 0x54, 0x94, 0xD4,
pngtrans.c:   0x24, 0x64, 0xA4, 0xE4, 0x34, 0x74, 0xB4, 0xF4,
pngtrans.c:   0x08, 0x48, 0x88, 0xC8, 0x18, 0x58, 0x98, 0xD8,
pngtrans.c:   0x28, 0x68, 0xA8, 0xE8, 0x38, 0x78, 0xB8, 0xF8,
pngtrans.c:   0x0C, 0x4C, 0x8C, 0xCC, 0x1C, 0x5C, 0x9C, 0xDC,
pngtrans.c:   0x2C, 0x6C, 0xAC, 0xEC, 0x3C, 0x7C, 0xBC, 0xFC,
pngtrans.c:   0x01, 0x41, 0x81, 0xC1, 0x11, 0x51, 0x91, 0xD1,
pngtrans.c:   0x21, 0x61, 0xA1, 0xE1, 0x31, 0x71, 0xB1, 0xF1,
pngtrans.c:   0x05, 0x45, 0x85, 0xC5, 0x15, 0x55, 0x95, 0xD5,
pngtrans.c:   0x25, 0x65, 0xA5, 0xE5, 0x35, 0x75, 0xB5, 0xF5,
pngtrans.c:   0x09, 0x49, 0x89, 0xC9, 0x19, 0x59, 0x99, 0xD9,
pngtrans.c:   0x29, 0x69, 0xA9, 0xE9, 0x39, 0x79, 0xB9, 0xF9,
pngtrans.c:   0x0D, 0x4D, 0x8D, 0xCD, 0x1D, 0x5D, 0x9D, 0xDD,
pngtrans.c:   0x2D, 0x6D, 0xAD, 0xED, 0x3D, 0x7D, 0xBD, 0xFD,
pngtrans.c:   0x02, 0x42, 0x82, 0xC2, 0x12, 0x52, 0x92, 0xD2,
pngtrans.c:   0x22, 0x62, 0xA2, 0xE2, 0x32, 0x72, 0xB2, 0xF2,
pngtrans.c:   0x06, 0x46, 0x86, 0xC6, 0x16, 0x56, 0x96, 0xD6,
pngtrans.c:   0x26, 0x66, 0xA6, 0xE6, 0x36, 0x76, 0xB6, 0xF6,
pngtrans.c:   0x0A, 0x4A, 0x8A, 0xCA, 0x1A, 0x5A, 0x9A, 0xDA,
pngtrans.c:   0x2A, 0x6A, 0xAA, 0xEA, 0x3A, 0x7A, 0xBA, 0xFA,
pngtrans.c:   0x0E, 0x4E, 0x8E, 0xCE, 0x1E, 0x5E, 0x9E, 0xDE,
pngtrans.c:   0x2E, 0x6E, 0xAE, 0xEE, 0x3E, 0x7E, 0xBE, 0xFE,
pngtrans.c:   0x03, 0x43, 0x83, 0xC3, 0x13, 0x53, 0x93, 0xD3,
pngtrans.c:   0x23, 0x63, 0xA3, 0xE3, 0x33, 0x73, 0xB3, 0xF3,
pngtrans.c:   0x07, 0x47, 0x87, 0xC7, 0x17, 0x57, 0x97, 0xD7,
pngtrans.c:   0x27, 0x67, 0xA7, 0xE7, 0x37, 0x77, 0xB7, 0xF7,
pngtrans.c:   0x0B, 0x4B, 0x8B, 0xCB, 0x1B, 0x5B, 0x9B, 0xDB,
pngtrans.c:   0x2B, 0x6B, 0xAB, 0xEB, 0x3B, 0x7B, 0xBB, 0xFB,
pngtrans.c:   0x0F, 0x4F, 0x8F, 0xCF, 0x1F, 0x5F, 0x9F, 0xDF,
pngtrans.c:   0x2F, 0x6F, 0xAF, 0xEF, 0x3F, 0x7F, 0xBF, 0xFF
pngtrans.c:   0x00, 0x10, 0x20, 0x30, 0x40, 0x50, 0x60, 0x70,
pngtrans.c:   0x80, 0x90, 0xA0, 0xB0, 0xC0, 0xD0, 0xE0, 0xF0,
pngtrans.c:   0x01, 0x11, 0x21, 0x31, 0x41, 0x51, 0x61, 0x71,
pngtrans.c:   0x81, 0x91, 0xA1, 0xB1, 0xC1, 0xD1, 0xE1, 0xF1,
pngtrans.c:   0x02, 0x12, 0x22, 0x32, 0x42, 0x52, 0x62, 0x72,
pngtrans.c:   0x82, 0x92, 0xA2, 0xB2, 0xC2, 0xD2, 0xE2, 0xF2,
pngtrans.c:   0x03, 0x13, 0x23, 0x33, 0x43, 0x53, 0x63, 0x73,
pngtrans.c:   0x83, 0x93, 0xA3, 0xB3, 0xC3, 0xD3, 0xE3, 0xF3,
pngtrans.c:   0x04, 0x14, 0x24, 0x34, 0x44, 0x54, 0x64, 0x74,
pngtrans.c:   0x84, 0x94, 0xA4, 0xB4, 0xC4, 0xD4, 0xE4, 0xF4,
pngtrans.c:   0x05, 0x15, 0x25, 0x35, 0x45, 0x55, 0x65, 0x75,
pngtrans.c:   0x85, 0x95, 0xA5, 0xB5, 0xC5, 0xD5, 0xE5, 0xF5,
pngtrans.c:   0x06, 0x16, 0x26, 0x36, 0x46, 0x56, 0x66, 0x76,
pngtrans.c:   0x86, 0x96, 0xA6, 0xB6, 0xC6, 0xD6, 0xE6, 0xF6,
pngtrans.c:   0x07, 0x17, 0x27, 0x37, 0x47, 0x57, 0x67, 0x77,
pngtrans.c:   0x87, 0x97, 0xA7, 0xB7, 0xC7, 0xD7, 0xE7, 0xF7,
pngtrans.c:   0x08, 0x18, 0x28, 0x38, 0x48, 0x58, 0x68, 0x78,
pngtrans.c:   0x88, 0x98, 0xA8, 0xB8, 0xC8, 0xD8, 0xE8, 0xF8,
pngtrans.c:   0x09, 0x19, 0x29, 0x39, 0x49, 0x59, 0x69, 0x79,
pngtrans.c:   0x89, 0x99, 0xA9, 0xB9, 0xC9, 0xD9, 0xE9, 0xF9,
pngtrans.c:   0x0A, 0x1A, 0x2A, 0x3A, 0x4A, 0x5A, 0x6A, 0x7A,
pngtrans.c:   0x8A, 0x9A, 0xAA, 0xBA, 0xCA, 0xDA, 0xEA, 0xFA,
pngtrans.c:   0x0B, 0x1B, 0x2B, 0x3B, 0x4B, 0x5B, 0x6B, 0x7B,
pngtrans.c:   0x8B, 0x9B, 0xAB, 0xBB, 0xCB, 0xDB, 0xEB, 0xFB,
pngtrans.c:   0x0C, 0x1C, 0x2C, 0x3C, 0x4C, 0x5C, 0x6C, 0x7C,
pngtrans.c:   0x8C, 0x9C, 0xAC, 0xBC, 0xCC, 0xDC, 0xEC, 0xFC,
pngtrans.c:   0x0D, 0x1D, 0x2D, 0x3D, 0x4D, 0x5D, 0x6D, 0x7D,
pngtrans.c:   0x8D, 0x9D, 0xAD, 0xBD, 0xCD, 0xDD, 0xED, 0xFD,
pngtrans.c:   0x0E, 0x1E, 0x2E, 0x3E, 0x4E, 0x5E, 0x6E, 0x7E,
pngtrans.c:   0x8E, 0x9E, 0xAE, 0xBE, 0xCE, 0xDE, 0xEE, 0xFE,
pngtrans.c:   0x0F, 0x1F, 0x2F, 0x3F, 0x4F, 0x5F, 0x6F, 0x7F,
pngtrans.c:   0x8F, 0x9F, 0xAF, 0xBF, 0xCF, 0xDF, 0xEF, 0xFF
pngtrans.c:/* Swaps pixel packing order within bytes */
pngtrans.c: * end (not in the middle) of each pixel.
pngtrans.c:         /* For a 1 pixel wide image there is nothing to do */
pngtrans.c:         row_info->pixel_depth = 8;
pngtrans.c:         row_info->pixel_depth = 16;
pngtrans.c:      /* Finally fix the color type if it records an alpha channel */
pngtrans.c:         row_info->pixel_depth = 24;
pngtrans.c:         row_info->pixel_depth = 48;
pngtrans.c:      /* Finally fix the color type if it records an alpha channel */
pngtrans.c:   /* Fix the rowbytes value. */
pngtrans.c:/* Swaps red and blue bytes within a pixel */
pngtrans.c:png_do_check_palette_indexes(png_structrp png_ptr, png_row_infop row_info)
pngtrans.c:       * an 'int' because pixel_depth becomes an 'int' in the expression below,
pngtrans.c:      int padding = (-row_info->pixel_depth * row_info->width) & 7;
pngtrans.c:             * to unpack the pixels except for the rightmost one.
pngtrans.c:                 png_ptr->num_palette_max = 1;
pngtrans.c:              int i = ((*rp >> padding) & 0x03);
pngtrans.c:              if (i > png_ptr->num_palette_max)
pngtrans.c:                 png_ptr->num_palette_max = i;
pngtrans.c:              i = (((*rp >> padding) >> 2) & 0x03);
pngtrans.c:              if (i > png_ptr->num_palette_max)
pngtrans.c:                 png_ptr->num_palette_max = i;
pngtrans.c:              i = (((*rp >> padding) >> 4) & 0x03);
pngtrans.c:              if (i > png_ptr->num_palette_max)
pngtrans.c:                 png_ptr->num_palette_max = i;
pngtrans.c:              i = (((*rp >> padding) >> 6) & 0x03);
pngtrans.c:              if (i > png_ptr->num_palette_max)
pngtrans.c:                 png_ptr->num_palette_max = i;
pngtrans.c:              int i = ((*rp >> padding) & 0x0f);
pngtrans.c:              if (i > png_ptr->num_palette_max)
pngtrans.c:                 png_ptr->num_palette_max = i;
pngtrans.c:              i = (((*rp >> padding) >> 4) & 0x0f);
pngtrans.c:              if (i > png_ptr->num_palette_max)
pngtrans.c:                 png_ptr->num_palette_max = i;
pngtrans.c:               if (*rp > png_ptr->num_palette_max)
pngtrans.c:                  png_ptr->num_palette_max = (int) *rp;
Binary file pngtrans.o matches
Binary file pngunknown matches
pngusr.dfa:# them to be passed through to the build of pnglibconf.h), for example:
Binary file pngvalid matches
pngwio.c: * special handling are expected to write functions that have the same
pngwio.c: *                 to exit and output any fatal error messages.  May be
Binary file pngwio.o matches
pngwrite.c:      png_debug(5, "writing extra chunks");
pngwrite.c:          * written if explicitly listed or if the default is set to write all
pngwrite.c:             ((up->name[3] & 0x20) /* safe-to-copy overrides everything */ ||
pngwrite.c:         png_write_gAMA_fixed(png_ptr, info_ptr->colorspace.gamma);
pngwrite.c:         png_write_cHRM_fixed(png_ptr, &info_ptr->colorspace.end_points_xy);
pngwrite.c:      png_write_oFFs(png_ptr, info_ptr->x_offset, info_ptr->y_offset,
pngwrite.c:      png_write_pHYs(png_ptr, info_ptr->x_pixels_per_unit,
pngwrite.c:          info_ptr->y_pixels_per_unit, info_ptr->phys_unit_type);
pngwrite.c:   /* Check to see if we need to write text chunks */
pngwrite.c:   for (i = 0; i < info_ptr->num_text; i++)
pngwrite.c:      png_debug2(2, "Writing header text chunk %d, type %d", i,
pngwrite.c:          info_ptr->text[i].compression);
pngwrite.c:      if (info_ptr->text[i].compression > 0)
pngwrite.c:             info_ptr->text[i].compression,
pngwrite.c:             info_ptr->text[i].key,
pngwrite.c:             info_ptr->text[i].lang,
pngwrite.c:             info_ptr->text[i].lang_key,
pngwrite.c:             info_ptr->text[i].text);
pngwrite.c:         if (info_ptr->text[i].compression == PNG_TEXT_COMPRESSION_NONE)
pngwrite.c:            info_ptr->text[i].compression = PNG_TEXT_COMPRESSION_NONE_WR;
pngwrite.c:            info_ptr->text[i].compression = PNG_TEXT_COMPRESSION_zTXt_WR;
pngwrite.c:         png_warning(png_ptr, "Unable to write international text");
pngwrite.c:      /* If we want a compressed text chunk */
pngwrite.c:      else if (info_ptr->text[i].compression == PNG_TEXT_COMPRESSION_zTXt)
pngwrite.c:         png_write_zTXt(png_ptr, info_ptr->text[i].key,
pngwrite.c:             info_ptr->text[i].text, info_ptr->text[i].compression);
pngwrite.c:         info_ptr->text[i].compression = PNG_TEXT_COMPRESSION_zTXt_WR;
pngwrite.c:         png_warning(png_ptr, "Unable to write compressed text");
pngwrite.c:      else if (info_ptr->text[i].compression == PNG_TEXT_COMPRESSION_NONE)
pngwrite.c:         png_write_tEXt(png_ptr, info_ptr->text[i].key,
pngwrite.c:             info_ptr->text[i].text,
pngwrite.c:         info_ptr->text[i].compression = PNG_TEXT_COMPRESSION_NONE_WR;
pngwrite.c:         png_warning(png_ptr, "Unable to write uncompressed text");
pngwrite.c:   if (png_ptr->num_palette_max > png_ptr->num_palette)
pngwrite.c:      png_benign_error(png_ptr, "Wrote palette index exceeding num_palette");
pngwrite.c:      int i; /* local index variable */
pngwrite.c:      for (i = 0; i < info_ptr->num_text; i++)
pngwrite.c:         png_debug2(2, "Writing trailer text chunk %d, type %d", i,
pngwrite.c:            info_ptr->text[i].compression);
pngwrite.c:         if (info_ptr->text[i].compression > 0)
pngwrite.c:                info_ptr->text[i].compression,
pngwrite.c:                info_ptr->text[i].key,
pngwrite.c:                info_ptr->text[i].lang,
pngwrite.c:                info_ptr->text[i].lang_key,
pngwrite.c:                info_ptr->text[i].text);
pngwrite.c:            if (info_ptr->text[i].compression == PNG_TEXT_COMPRESSION_NONE)
pngwrite.c:               info_ptr->text[i].compression = PNG_TEXT_COMPRESSION_NONE_WR;
pngwrite.c:               info_ptr->text[i].compression = PNG_TEXT_COMPRESSION_zTXt_WR;
pngwrite.c:            png_warning(png_ptr, "Unable to write international text");
pngwrite.c:         else if (info_ptr->text[i].compression >= PNG_TEXT_COMPRESSION_zTXt)
pngwrite.c:            png_write_zTXt(png_ptr, info_ptr->text[i].key,
pngwrite.c:                info_ptr->text[i].text, info_ptr->text[i].compression);
pngwrite.c:            info_ptr->text[i].compression = PNG_TEXT_COMPRESSION_zTXt_WR;
pngwrite.c:            png_warning(png_ptr, "Unable to write compressed text");
pngwrite.c:         else if (info_ptr->text[i].compression == PNG_TEXT_COMPRESSION_NONE)
pngwrite.c:            png_write_tEXt(png_ptr, info_ptr->text[i].key,
pngwrite.c:                info_ptr->text[i].text, 0);
pngwrite.c:            info_ptr->text[i].compression = PNG_TEXT_COMPRESSION_NONE_WR;
pngwrite.c:            png_warning(png_ptr, "Unable to write uncompressed text");
pngwrite.c:    * experiences a problem, please try building libpng with
pngwrite.c:      png_ptr->zlib_text_strategy = PNG_TEXT_Z_DEFAULT_STRATEGY;
pngwrite.c:      png_ptr->zlib_text_level = PNG_TEXT_Z_DEFAULT_COMPRESSION;
pngwrite.c:      png_ptr->zlib_text_mem_level = 8;
pngwrite.c:      png_ptr->zlib_text_window_bits = 15;
pngwrite.c:      png_ptr->zlib_text_method = 8;
pngwrite.c:       * extensions not conformant to the current specification, or of
pngwrite.c:   png_uint_32 i; /* row index */
pngwrite.c:/* Performs intrapixel differencing  */
pngwrite.c:png_do_write_intrapixel(png_row_infop row_info, png_bytep row)
pngwrite.c:   png_debug(1, "in png_do_write_intrapixel");
pngwrite.c:      int bytes_per_pixel;
pngwrite.c:            bytes_per_pixel = 3;
pngwrite.c:            bytes_per_pixel = 4;
pngwrite.c:         for (i = 0, rp = row; i < row_width; i++, rp += bytes_per_pixel)
pngwrite.c:            *(rp)     = (png_byte)((*rp       - *(rp + 1)) & 0xff);
pngwrite.c:            *(rp + 2) = (png_byte)((*(rp + 2) - *(rp + 1)) & 0xff);
pngwrite.c:            bytes_per_pixel = 6;
pngwrite.c:            bytes_per_pixel = 8;
pngwrite.c:         for (i = 0, rp = row; i < row_width; i++, rp += bytes_per_pixel)
pngwrite.c:            png_uint_32 red  = (png_uint_32)((s0 - s1) & 0xffffL);
pngwrite.c:            png_uint_32 blue = (png_uint_32)((s2 - s1) & 0xffffL);
pngwrite.c:            *(rp    ) = (png_byte)((red >> 8) & 0xff);
pngwrite.c:            *(rp + 1) = (png_byte)(red & 0xff);
pngwrite.c:            *(rp + 4) = (png_byte)((blue >> 8) & 0xff);
pngwrite.c:            *(rp + 5) = (png_byte)(blue & 0xff);
pngwrite.c:            if ((png_ptr->row_number & 0x07) != 0)
pngwrite.c:            if ((png_ptr->row_number & 0x07) != 0 || png_ptr->width < 5)
pngwrite.c:            if ((png_ptr->row_number & 0x07) != 4)
pngwrite.c:            if ((png_ptr->row_number & 0x03) != 0 || png_ptr->width < 3)
pngwrite.c:            if ((png_ptr->row_number & 0x03) != 2)
pngwrite.c:            if ((png_ptr->row_number & 0x01) != 0 || png_ptr->width < 2)
pngwrite.c:            if ((png_ptr->row_number & 0x01) == 0)
pngwrite.c:   row_info.pixel_depth = (png_byte)(row_info.bit_depth * row_info.channels);
pngwrite.c:   row_info.rowbytes = PNG_ROWBYTES(row_info.pixel_depth, row_info.width);
pngwrite.c:   png_debug1(3, "row_info->pixel_depth = %d", row_info.pixel_depth);
pngwrite.c:   /* At this point the row_info pixel depth must match the 'transformed' depth,
pngwrite.c:   if (row_info.pixel_depth != png_ptr->pixel_depth ||
pngwrite.c:      row_info.pixel_depth != png_ptr->transformed_pixel_depth)
pngwrite.c:   /* Write filter_method 64 (intrapixel differencing) only if
pngwrite.c:      /* Intrapixel differencing */
pngwrite.c:      png_do_write_intrapixel(&row_info, png_ptr->row_buf + 1);
pngwrite.c:   /* Check for out-of-range palette index */
pngwrite.c:       png_ptr->num_palette_max >= 0)
pngwrite.c:      png_do_check_palette_indexes(png_ptr, &row_info);
pngwrite.c:      switch (filters & (PNG_ALL_FILTERS | 0x07))
pngwrite.c:   /* Leave the filter_costs - this array is fixed size. */
pngwrite.c:/* Provide floating and fixed point APIs */
pngwrite.c:png_set_filter_heuristics_fixed(png_structrp png_ptr, int heuristic_method,
pngwrite.c:    int num_weights, png_const_fixed_point_p filter_weights,
pngwrite.c:    png_const_fixed_point_p filter_costs)
pngwrite.c:   png_debug(1, "in png_set_filter_heuristics_fixed");
pngwrite.c:png_set_text_compression_level(png_structrp png_ptr, int level)
pngwrite.c:   png_debug(1, "in png_set_text_compression_level");
pngwrite.c:   png_ptr->zlib_text_level = level;
pngwrite.c:png_set_text_compression_mem_level(png_structrp png_ptr, int mem_level)
pngwrite.c:   png_debug(1, "in png_set_text_compression_mem_level");
pngwrite.c:   png_ptr->zlib_text_mem_level = mem_level;
pngwrite.c:png_set_text_compression_strategy(png_structrp png_ptr, int strategy)
pngwrite.c:   png_debug(1, "in png_set_text_compression_strategy");
pngwrite.c:   png_ptr->zlib_text_strategy = strategy;
pngwrite.c:png_set_text_compression_window_bits(png_structrp png_ptr, int window_bits)
pngwrite.c:   png_ptr->zlib_text_window_bits = window_bits;
pngwrite.c:png_set_text_compression_method(png_structrp png_ptr, int method)
pngwrite.c:   png_debug(1, "in png_set_text_compression_method");
pngwrite.c:   png_ptr->zlib_text_method = method;
pngwrite.c:   /* Invert monochrome pixels */
pngwrite.c:   /* Shift the pixels up to a legal bit depth and fill in
pngwrite.c:   /* Pack pixels into bytes */
pngwrite.c:    * RGB, note that the code expects the input color type to be G or RGB; no
pngwrite.c:   /* Flip BGR pixels to RGB */
pngwrite.c:   /* Swap bits of 1, 2, 4 bit packed pixel formats */
pngwrite.c:   int aindex = 0;
pngwrite.c:            aindex = -1;
pngwrite.c:         aindex = channels;
pngwrite.c:         const png_uint_16 alpha = in_ptr[aindex];
pngwrite.c:         out_ptr[aindex] = alpha;
pngwrite.c:            reciprocal = ((0xffff<<15)+(alpha>>1))/alpha;
pngwrite.c:         /* Skip to next component (skip the intervening alpha channel) */
pngwrite.c:#define UNP_RECIPROCAL(alpha) ((((0xffff*0xff)<<7)+(alpha>>1))/alpha)
pngwrite.c:       * be exact!)  [Could also test reciprocal != 0]
pngwrite.c:      int aindex;
pngwrite.c:            aindex = -1;
pngwrite.c:         aindex = channels;
pngwrite.c:            png_uint_16 alpha = in_ptr[aindex];
pngwrite.c:            out_ptr[aindex] = alphabyte;
pngwrite.c:            /* Skip to next component (skip the intervening alpha channel) */
pngwrite.c:               reciprocal = (((0xffff*0xff)<<7)+(alpha>>1))/alpha;
pngwrite.c:      png_set_gAMA_fixed(png_ptr, info_ptr, PNG_GAMMA_LINEAR);
pngwrite.c:         png_set_cHRM_fixed(png_ptr, info_ptr,
pngwrite.c:            /* color      x       y */
pngwrite.c:      png_set_gAMA_fixed(png_ptr, info_ptr, PNG_GAMMA_sRGB_INVERSE);
pngwrite.c:      PNG_CONST png_uint_16 le = 0x0001;
pngwrite.c:      /* NOTE: determined by experiment using pngstest, this reflects some
pngwrite.c:         result = png_safe_execute(image, png_write_image_16bit, display);
pngwrite.c:         result = png_safe_execute(image, png_write_image_8bit, display);
pngwrite.c:            result = png_safe_execute(image, png_image_write_main, &display);
Binary file pngwrite.o matches
pngwtran.c:/* Pack pixels into bytes.  Pass the true bit depth in bit_depth.  The
pngwtran.c: * row_info bit depth should be 8 (one pixel per byte).  The channels
pngwtran.c:            mask = 0x80;
pngwtran.c:                  mask = 0x80;
pngwtran.c:            if (mask != 0x80)
pngwtran.c:               value = (png_byte)(*sp & 0x03);
pngwtran.c:               value = (png_byte)(*sp & 0x0f);
pngwtran.c:      row_info->pixel_depth = (png_byte)(bit_depth * row_info->channels);
pngwtran.c:      row_info->rowbytes = PNG_ROWBYTES(row_info->pixel_depth,
pngwtran.c:/* Shift pixel values to take advantage of whole range.  Pass the
pngwtran.c: * bit depth 4, but the pixels only had values from 0 to 7, you
pngwtran.c:            mask = 0x55;
pngwtran.c:            mask = 0x11;
pngwtran.c:            mask = 0xff;
pngwtran.c:            *bp = (png_byte)(out & 0xff);
pngwtran.c:            *bp = (png_byte)(out & 0xff);
pngwtran.c:            *bp++ = (png_byte)((value >> 8) & 0xff);
pngwtran.c:            *bp++ = (png_byte)(value & 0xff);
pngwtran.c:                /*  png_byte color_type;     color type of pixels */
pngwtran.c:                /*  png_byte pixel_depth;    bits per pixel (depth*channels) */
pngwtran.c:             png_ptr->row_buf + 1);      /* start of pixel data for row */
Binary file pngwtran.o matches
pngwutil.c:   buf[0] = (png_byte)((i >> 24) & 0xff);
pngwutil.c:   buf[1] = (png_byte)((i >> 16) & 0xff);
pngwutil.c:   buf[2] = (png_byte)((i >> 8) & 0xff);
pngwutil.c:   buf[3] = (png_byte)(i & 0xff);
pngwutil.c:   buf[0] = (png_byte)((i >> 8) & 0xff);
pngwutil.c:   buf[1] = (png_byte)(i & 0xff);
pngwutil.c:      png_error(png_ptr, "length exceeds PNG maximum");
pngwutil.c:   /* Only return sizes up to the maximum of a png_uint_32; do this by limiting
pngwutil.c:         unsigned int pd = png_ptr->pixel_depth;
pngwutil.c:      return 0xffffffffU;
pngwutil.c:      if ((z_cmf & 0x0f) == 8 && (z_cmf & 0xf0) <= 0x70)
pngwutil.c:            z_cmf = (z_cmf & 0x0f) | (z_cinfo << 4);
pngwutil.c:            tmp = data[1] & 0xe0;
pngwutil.c:            tmp += 0x1f - ((z_cmf << 8) + tmp) % 0x1f;
pngwutil.c:            level = png_ptr->zlib_text_level;
pngwutil.c:            method = png_ptr->zlib_text_method;
pngwutil.c:            windowBits = png_ptr->zlib_text_window_bits;
pngwutil.c:            memLevel = png_ptr->zlib_text_mem_level;
pngwutil.c:            strategy = png_ptr->zlib_text_strategy;
pngwutil.c:             * IDAT values except for the strategy, which is fixed to the
pngwutil.c:       * requires an extra 262 bytes in the window in addition to the data to be
pngwutil.c:       * next windowBits size we need to fix up the value later.  (Because even
pngwutil.c:       * though deflate needs the extra window, inflate does not!)
pngwutil.c:      png_ptr->zstream.next_in = NULL;
pngwutil.c:      png_ptr->zstream.next_out = NULL;
pngwutil.c:         png_compression_bufferp next = list->next;
pngwutil.c:         list = next;
pngwutil.c: * text string, and (b) issuing it later as a series of chunk data writes.
pngwutil.c: * The compression_state structure is shared context for these functions
pngwutil.c:png_text_compress_init(compression_state *comp, png_const_bytep input,
pngwutil.c:png_text_compress(png_structrp png_ptr, png_uint_32 chunk_name,
pngwutil.c:   compression_state *comp, png_uint_32 prefix_len)
pngwutil.c:      png_ptr->zstream.next_in = PNGZ_INPUT_CAST(comp->input);
pngwutil.c:      png_ptr->zstream.next_out = comp->output;
pngwutil.c:            png_compression_buffer *next;
pngwutil.c:            /* Chunk data is limited to 2^31 bytes in length, so the prefix
pngwutil.c:            if (output_len + prefix_len > PNG_UINT_31_MAX)
pngwutil.c:            next = *end;
pngwutil.c:            if (next == NULL)
pngwutil.c:               next = png_voidcast(png_compression_bufferp, png_malloc_base
pngwutil.c:               if (next == NULL)
pngwutil.c:               next->next = NULL;
pngwutil.c:               *end = next;
pngwutil.c:            png_ptr->zstream.next_out = next->output;
pngwutil.c:            /* Move 'end' to the next buffer pointer. */
pngwutil.c:            end = &next->next;
pngwutil.c:      if (output_len + prefix_len >= PNG_UINT_31_MAX)
pngwutil.c:         /* Fix up the deflate header, if required */
pngwutil.c:/* Ship the compressed text out via chunk writes */
pngwutil.c:   png_compression_buffer *next = png_ptr->zbuffer_list;
pngwutil.c:      if (output_len == 0 || next == NULL)
pngwutil.c:      output = next->output;
pngwutil.c:      next = next->next;
pngwutil.c:   /* This is an internal error; 'next' must have been NULL! */
pngwutil.c: * and the non-break space (0x80) from ISO 8859-1.  Returns keyword length.
pngwutil.c:      png_byte ch = (png_byte)(0xff & *key++);
pngwutil.c:      png_warning_parameter_signed(p, 2, PNG_NUMBER_FORMAT_02x, bad_character);
pngwutil.c:      png_formatted_warning(png_ptr, p, "keyword \"@1\": bad character '0x@2'");
pngwutil.c:   /* Write filter_method 64 (intrapixel differencing) only if
pngwutil.c:   png_ptr->pixel_depth = (png_byte)(bit_depth * png_ptr->channels);
pngwutil.c:   png_ptr->rowbytes = PNG_ROWBYTES(png_ptr->pixel_depth, width);
pngwutil.c:/* This is similar to png_text_compress, above, except that it does not require
pngwutil.c: * writes it as IDAT chunks.  Unlike png_text_compress it *can* png_error out
pngwutil.c: * just call png_error.  The input data length may exceed 32-bits.  The 'flush'
pngwutil.c: * parameter is exactly the same as that to deflate, with the following
pngwutil.c:         png_ptr->zbuffer_list->next = NULL;
pngwutil.c:         png_free_buffer_list(png_ptr, &png_ptr->zbuffer_list->next);
pngwutil.c:      png_ptr->zstream.next_out = png_ptr->zbuffer_list->output;
pngwutil.c:   png_ptr->zstream.next_in = PNGZ_INPUT_CAST(input);
pngwutil.c:         png_ptr->zstream.next_out = data;
pngwutil.c:         png_ptr->zstream.next_out = NULL;
pngwutil.c:png_write_gAMA_fixed(png_structrp png_ptr, png_fixed_point file_gamma)
pngwutil.c:   if (temp > 3 && (profile_len & 0x03))
pngwutil.c:   png_text_compress_init(&comp, profile, profile_len);
pngwutil.c:   if (png_text_compress(png_ptr, png_iCCP, &comp, name_len) != Z_OK)
pngwutil.c:      png_byte maxbits;
pngwutil.c:      maxbits = (png_byte)(color_type==PNG_COLOR_TYPE_PALETTE ? 8 :
pngwutil.c:      if (sbit->red == 0 || sbit->red > maxbits ||
pngwutil.c:          sbit->green == 0 || sbit->green > maxbits ||
pngwutil.c:          sbit->blue == 0 || sbit->blue > maxbits)
pngwutil.c:png_write_cHRM_fixed(png_structrp png_ptr, const png_xy *xy)
pngwutil.c:   png_save_int_32(buf,      xy->whitex);
pngwutil.c:   png_save_int_32(buf +  4, xy->whitey);
pngwutil.c:   png_save_int_32(buf +  8, xy->redx);
pngwutil.c:   png_save_int_32(buf + 12, xy->redy);
pngwutil.c:   png_save_int_32(buf + 16, xy->greenx);
pngwutil.c:   png_save_int_32(buf + 20, xy->greeny);
pngwutil.c:   png_save_int_32(buf + 24, xy->bluex);
pngwutil.c:   png_save_int_32(buf + 28, xy->bluey);
pngwutil.c:         back->index >= png_ptr->num_palette)
pngwutil.c:         png_warning(png_ptr, "Invalid background palette index");
pngwutil.c:      buf[0] = back->index;
pngwutil.c:png_write_tEXt(png_structrp png_ptr, png_const_charp key, png_const_charp text,
pngwutil.c:    png_size_t text_len)
pngwutil.c:   if (text == NULL || *text == '\0')
pngwutil.c:      text_len = 0;
pngwutil.c:      text_len = strlen(text);
pngwutil.c:   if (text_len > PNG_UINT_31_MAX - (key_len+1))
pngwutil.c:      png_error(png_ptr, "tEXt: text too long");
pngwutil.c:       (png_uint_32)/*checked above*/(key_len + text_len + 1));
pngwutil.c:    * contents of the text.  PNG-1.0 through PNG-1.2 discourage the use of
pngwutil.c:    * any non-Latin-1 characters except for NEWLINE.  ISO PNG will forbid them.
pngwutil.c:   if (text_len != 0)
pngwutil.c:      png_write_chunk_data(png_ptr, (png_const_bytep)text, text_len);
pngwutil.c:/* Write a compressed text chunk */
pngwutil.c:png_write_zTXt(png_structrp png_ptr, png_const_charp key, png_const_charp text,
pngwutil.c:      png_write_tEXt(png_ptr, key, text, 0);
pngwutil.c:   png_text_compress_init(&comp, (png_const_bytep)text,
pngwutil.c:      text == NULL ? 0 : strlen(text));
pngwutil.c:   if (png_text_compress(png_ptr, png_zTXt, &comp, key_len) != Z_OK)
pngwutil.c:    png_const_charp lang, png_const_charp lang_key, png_const_charp text)
pngwutil.c:   png_uint_32 key_len, prefix_len;
pngwutil.c:    * contents of the text.  PNG-1.0 through PNG-1.2 discourage the use of
pngwutil.c:    * any non-Latin-1 characters except for NEWLINE.  ISO PNG, however,
pngwutil.c:    * specifies that the text is UTF-8 and this really doesn't require any
pngwutil.c:   if (text == NULL) text = ""; /* may be empty */
pngwutil.c:   prefix_len = key_len;
pngwutil.c:   if (lang_len > PNG_UINT_31_MAX-prefix_len)
pngwutil.c:      prefix_len = PNG_UINT_31_MAX;
pngwutil.c:      prefix_len = (png_uint_32)(prefix_len + lang_len);
pngwutil.c:   if (lang_key_len > PNG_UINT_31_MAX-prefix_len)
pngwutil.c:      prefix_len = PNG_UINT_31_MAX;
pngwutil.c:      prefix_len = (png_uint_32)(prefix_len + lang_key_len);
pngwutil.c:   png_text_compress_init(&comp, (png_const_bytep)text, strlen(text));
pngwutil.c:      if (png_text_compress(png_ptr, png_iTXt, &comp, prefix_len) != Z_OK)
pngwutil.c:      if (comp.input_len > PNG_UINT_31_MAX-prefix_len)
pngwutil.c:         png_error(png_ptr, "iTXt: uncompressed text too long");
pngwutil.c:   png_write_chunk_header(png_ptr, png_iTXt, comp.output_len + prefix_len);
pngwutil.c:      png_write_chunk_data(png_ptr, (png_const_bytep)text, comp.input_len);
pngwutil.c:png_write_oFFs(png_structrp png_ptr, png_int_32 x_offset, png_int_32 y_offset,
pngwutil.c:   png_save_int_32(buf, x_offset);
pngwutil.c:/* Write the pCAL chunk (described in the PNG extensions document) */
pngwutil.c:png_write_pHYs(png_structrp png_ptr, png_uint_32 x_pixels_per_unit,
pngwutil.c:    png_uint_32 y_pixels_per_unit,
pngwutil.c:   png_save_uint_32(buf, x_pixels_per_unit);
pngwutil.c:   png_save_uint_32(buf + 4, y_pixels_per_unit);
pngwutil.c:   /* Arrays to facilitate easy interlacing - use pass (0 - 6) as index */
pngwutil.c:   /* Offset to next interlace block */
pngwutil.c:   /* Offset to next interlace block in the y direction */
pngwutil.c:   int usr_pixel_depth;
pngwutil.c:   usr_pixel_depth = png_ptr->usr_channels * png_ptr->usr_bit_depth;
pngwutil.c:   buf_size = PNG_ROWBYTES(usr_pixel_depth, png_ptr->width) + 1;
pngwutil.c:   png_ptr->transformed_pixel_depth = png_ptr->pixel_depth;
pngwutil.c:   png_ptr->maximum_pixel_depth = (png_byte)usr_pixel_depth;
pngwutil.c:   /* Arrays to facilitate easy interlacing - use pass (0 - 6) as index */
pngwutil.c:   /* Offset to next interlace block */
pngwutil.c:   /* Offset to next interlace block in the y direction */
pngwutil.c:   /* Next row */
pngwutil.c:   /* If interlaced, go to next pass */
pngwutil.c:      /* Reset the row above the image for the next pass */
pngwutil.c:/* Pick out the correct pixels for the interlace pass.
pngwutil.c: * correct pixels for the pass.  As the row gets compacted,
pngwutil.c:   /* Arrays to facilitate easy interlacing - use pass (0 - 6) as index */
pngwutil.c:   /* Offset to next interlace block */
pngwutil.c:      /* Each pixel depth is handled separately */
pngwutil.c:      switch (row_info->pixel_depth)
pngwutil.c:               value = (int)(*sp >> (7 - (int)(i & 0x07))) & 0x01;
pngwutil.c:               value = (*sp >> ((3 - (int)(i & 0x03)) << 1)) & 0x03;
pngwutil.c:               value = (*sp >> ((1 - (int)(i & 0x01)) << 2)) & 0x0f;
pngwutil.c:            png_size_t pixel_bytes;
pngwutil.c:            /* Find out how many bytes each pixel takes up */
pngwutil.c:            pixel_bytes = (row_info->pixel_depth >> 3);
pngwutil.c:            /* Loop through the row, only looking at the pixels that matter */
pngwutil.c:               /* Find out where the original pixel is */
pngwutil.c:               sp = row + (png_size_t)i * pixel_bytes;
pngwutil.c:               /* Move the pixel */
pngwutil.c:                  memcpy(dp, sp, pixel_bytes);
pngwutil.c:               /* Next pixel */
pngwutil.c:               dp += pixel_bytes;
pngwutil.c:      row_info->rowbytes = PNG_ROWBYTES(row_info->pixel_depth,
pngwutil.c:#define PNG_LOMASK ((png_uint_32)0xffffL)
pngwutil.c:   /* Find out how many bytes offset each pixel is */
pngwutil.c:   bpp = (row_info->pixel_depth + 7) >> 3;
pngwutil.c:    * (experimental and can in theory improve compression), and the "zlib
pngwutil.c:    * computationally expensive).
pngwutil.c:         *dp = (png_byte)(((int)*rp - (int)*lp) & 0xff);
pngwutil.c:       * early exit comparison without scaling the sum each time.
pngwutil.c:         v = *dp = (png_byte)(((int)*rp - (int)*lp) & 0xff);
pngwutil.c:         *dp = (png_byte)(((int)*rp - (int)*pp) & 0xff);
pngwutil.c:         v = *dp++ = (png_byte)(((int)*rp++ - (int)*pp++) & 0xff);
pngwutil.c:         *dp++ = (png_byte)(((int)*rp++ - ((int)*pp++ / 2)) & 0xff);
pngwutil.c:                 & 0xff);
pngwutil.c:         v = *dp++ = (png_byte)(((int)*rp++ - ((int)*pp++ / 2)) & 0xff);
pngwutil.c:             (png_byte)(((int)*rp++ - (((int)*pp++ + (int)*lp++) / 2)) & 0xff);
pngwutil.c:         *dp++ = (png_byte)(((int)*rp++ - (int)*pp++) & 0xff);
pngwutil.c:         *dp++ = (png_byte)(((int)*rp++ - p) & 0xff);
pngwutil.c:         v = *dp++ = (png_byte)(((int)*rp++ - (int)*pp++) & 0xff);
pngwutil.c:         v = *dp++ = (png_byte)(((int)*rp++ - p) & 0xff);
Binary file pngwutil.o matches
projects/owatcom/pngtest.tgt:pngtest.exe
projects/owatcom/pngstest.tgt:pngstest.exe
projects/owatcom/pngvalid.tgt:pngvalid.exe
projects/owatcom/pngconfig.mak:# pnglibconf.h must exist in the source directory, this is the final rule
projects/owatcom/pngconfig.mak:pnglibconf.h: ..\..\scripts\pnglibconf.h.prebuilt .existsonly
projects/owatcom/pngconfig.mak:$# awk.)  You can find source code and a built executable (called awk95.exe)
projects/owatcom/pngconfig.mak:$# The executable works just fine.
projects/owatcom/pngconfig.mak: $(DELETE) pngtest.exe pngtest.map pngtest.lk1 pngtest.mk1
projects/owatcom/pngconfig.mak: $(DELETE) pngvalid.exe pngvalid.map pngvalid.lk1 pngvalid.mk1
projects/owatcom/libpng.wpj:@if not exist pngconfig.dfa $(MAKE) $(__MAKEOPTS__) -f pngconfig.mak defaults
projects/owatcom/libpng.wpj:@if exist config.inf type config.inf
projects/vstudio/zlib/zlib.vcxproj:<?xml version="1.0" encoding="utf-8"?>
projects/vstudio/zlib/zlib.vcxproj:<Project DefaultTargets="Build" ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
projects/vstudio/zlib/zlib.vcxproj:  <ImportGroup Label="ExtensionSettings">
projects/vstudio/zlib/zlib.vcxproj:    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" />
projects/vstudio/zlib/zlib.vcxproj:    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" />
projects/vstudio/zlib/zlib.vcxproj:    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" />
projects/vstudio/zlib/zlib.vcxproj:    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
projects/vstudio/zlib/zlib.vcxproj:  <ImportGroup Label="ExtensionTargets">
projects/vstudio/pngvalid/pngvalid.vcxproj:<?xml version="1.0" encoding="utf-8"?>
projects/vstudio/pngvalid/pngvalid.vcxproj:<Project DefaultTargets="Build" ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
projects/vstudio/pngvalid/pngvalid.vcxproj:  <ImportGroup Label="ExtensionSettings">
projects/vstudio/pngvalid/pngvalid.vcxproj:    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
projects/vstudio/pngvalid/pngvalid.vcxproj:    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" />
projects/vstudio/pngvalid/pngvalid.vcxproj:    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
projects/vstudio/pngvalid/pngvalid.vcxproj:    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" />
projects/vstudio/pngvalid/pngvalid.vcxproj:      <FloatingPointExceptions>false</FloatingPointExceptions>
projects/vstudio/pngvalid/pngvalid.vcxproj:      <Message>Executing PNG validation program</Message>
projects/vstudio/pngvalid/pngvalid.vcxproj:      <Command>"$(OutDir)pngvalid.exe" --touch "$(IntDir)pngvalid.out"</Command>
projects/vstudio/pngvalid/pngvalid.vcxproj:      <Inputs>$(OutDir)pngvalid.exe</Inputs>
projects/vstudio/pngvalid/pngvalid.vcxproj:      <FloatingPointExceptions>false</FloatingPointExceptions>
projects/vstudio/pngvalid/pngvalid.vcxproj:      <Message>Executing PNG validation program</Message>
projects/vstudio/pngvalid/pngvalid.vcxproj:      <Command>"$(OutDir)pngvalid.exe" --touch "$(IntDir)pngvalid.out"</Command>
projects/vstudio/pngvalid/pngvalid.vcxproj:      <Inputs>$(OutDir)pngvalid.exe</Inputs>
projects/vstudio/pngvalid/pngvalid.vcxproj:      <FloatingPointExceptions>false</FloatingPointExceptions>
projects/vstudio/pngvalid/pngvalid.vcxproj:      <Message>Executing PNG validation program</Message>
projects/vstudio/pngvalid/pngvalid.vcxproj:      <Command>"$(OutDir)pngvalid.exe" --touch "$(IntDir)pngvalid.out"</Command>
projects/vstudio/pngvalid/pngvalid.vcxproj:      <Inputs>$(OutDir)pngvalid.exe</Inputs>
projects/vstudio/pngvalid/pngvalid.vcxproj:      <FloatingPointExceptions>false</FloatingPointExceptions>
projects/vstudio/pngvalid/pngvalid.vcxproj:      <Message>Executing PNG validation program</Message>
projects/vstudio/pngvalid/pngvalid.vcxproj:      <Command>"$(OutDir)pngvalid.exe" --touch "$(IntDir)pngvalid.out"</Command>
projects/vstudio/pngvalid/pngvalid.vcxproj:      <Inputs>$(OutDir)pngvalid.exe</Inputs>
projects/vstudio/pngvalid/pngvalid.vcxproj:  <ImportGroup Label="ExtensionTargets">
projects/vstudio/readme.txt:The release configurations default to /Ox optimization.  Full debugging
projects/vstudio/readme.txt:If you do not want to use the DLL, for example for a very small application,
projects/vstudio/pnglibconf/pnglibconf.vcxproj:<?xml version="1.0" encoding="utf-8"?>
projects/vstudio/pnglibconf/pnglibconf.vcxproj:<Project DefaultTargets="Build" ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
projects/vstudio/pnglibconf/pnglibconf.vcxproj:  <ImportGroup Label="ExtensionSettings">
projects/vstudio/pnglibconf/pnglibconf.vcxproj:    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
projects/vstudio/pnglibconf/pnglibconf.vcxproj:      <Optimization>MaxSpeed</Optimization>
projects/vstudio/pnglibconf/pnglibconf.vcxproj:  <ImportGroup Label="ExtensionTargets">
projects/vstudio/zlib.props:<?xml version="1.0" encoding="utf-8"?>
projects/vstudio/zlib.props:   xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
projects/vstudio/pngtest/pngtest.vcxproj:<?xml version="1.0" encoding="utf-8"?>
projects/vstudio/pngtest/pngtest.vcxproj:<Project DefaultTargets="Build" ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
projects/vstudio/pngtest/pngtest.vcxproj:  <ImportGroup Label="ExtensionSettings">
projects/vstudio/pngtest/pngtest.vcxproj:    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
projects/vstudio/pngtest/pngtest.vcxproj:    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" />
projects/vstudio/pngtest/pngtest.vcxproj:    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
projects/vstudio/pngtest/pngtest.vcxproj:    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" />
projects/vstudio/pngtest/pngtest.vcxproj:      <FloatingPointExceptions>false</FloatingPointExceptions>
projects/vstudio/pngtest/pngtest.vcxproj:      <Message>Executing PNG test program</Message>
projects/vstudio/pngtest/pngtest.vcxproj:      <Command>"$(OutDir)pngtest.exe" ..\..\..\pngtest.png "$(IntDir)pngout.png"</Command>
projects/vstudio/pngtest/pngtest.vcxproj:      <Inputs>..\..\..\pngtest.png;$(OutDir)pngtest.exe</Inputs>
projects/vstudio/pngtest/pngtest.vcxproj:      <FloatingPointExceptions>false</FloatingPointExceptions>
projects/vstudio/pngtest/pngtest.vcxproj:      <Message>Executing PNG test program</Message>
projects/vstudio/pngtest/pngtest.vcxproj:      <Command>"$(OutDir)pngtest.exe" ..\..\..\pngtest.png "$(IntDir)pngout.png"</Command>
projects/vstudio/pngtest/pngtest.vcxproj:      <Inputs>..\..\..\pngtest.png;$(OutDir)pngtest.exe</Inputs>
projects/vstudio/pngtest/pngtest.vcxproj:      <FloatingPointExceptions>false</FloatingPointExceptions>
projects/vstudio/pngtest/pngtest.vcxproj:      <Message>Executing PNG test program</Message>
projects/vstudio/pngtest/pngtest.vcxproj:      <Command>"$(OutDir)pngtest.exe" ..\..\..\pngtest.png "$(IntDir)pngout.png"</Command>
projects/vstudio/pngtest/pngtest.vcxproj:      <Inputs>..\..\..\pngtest.png;$(OutDir)pngtest.exe</Inputs>
projects/vstudio/pngtest/pngtest.vcxproj:      <FloatingPointExceptions>false</FloatingPointExceptions>
projects/vstudio/pngtest/pngtest.vcxproj:      <Message>Executing PNG test program</Message>
projects/vstudio/pngtest/pngtest.vcxproj:      <Command>$(OutDir)pngtest.exe ..\..\..\pngtest.png $(IntDir)pngout.png</Command>
projects/vstudio/pngtest/pngtest.vcxproj:      <Command>"$(OutDir)pngtest.exe" ..\..\..\pngtest.png "$(IntDir)pngout.png"</Command>
projects/vstudio/pngtest/pngtest.vcxproj:      <Inputs>..\..\..\pngtest.png;$(OutDir)pngtest.exe</Inputs>
projects/vstudio/pngtest/pngtest.vcxproj:  <ImportGroup Label="ExtensionTargets">
projects/vstudio/libpng/libpng.vcxproj:<?xml version="1.0" encoding="utf-8"?>
projects/vstudio/libpng/libpng.vcxproj:<Project DefaultTargets="Build" ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
projects/vstudio/libpng/libpng.vcxproj:  <ImportGroup Label="ExtensionSettings">
projects/vstudio/libpng/libpng.vcxproj:    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
projects/vstudio/libpng/libpng.vcxproj:    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" />
projects/vstudio/libpng/libpng.vcxproj:    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
projects/vstudio/libpng/libpng.vcxproj:    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" />
projects/vstudio/libpng/libpng.vcxproj:      <FloatingPointExceptions>false</FloatingPointExceptions>
projects/vstudio/libpng/libpng.vcxproj:      <FloatingPointExceptions>false</FloatingPointExceptions>
projects/vstudio/libpng/libpng.vcxproj:      <FloatingPointExceptions>false</FloatingPointExceptions>
projects/vstudio/libpng/libpng.vcxproj:      <FloatingPointExceptions>false</FloatingPointExceptions>
projects/vstudio/libpng/libpng.vcxproj:      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug Library|Win32'">true</ExcludedFromBuild>
projects/vstudio/libpng/libpng.vcxproj:      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release Library|Win32'">true</ExcludedFromBuild>
projects/vstudio/libpng/libpng.vcxproj:  <ImportGroup Label="ExtensionTargets">
projects/vstudio/pngunknown/pngunknown.vcxproj:<?xml version="1.0" encoding="utf-8"?>
projects/vstudio/pngunknown/pngunknown.vcxproj:<Project DefaultTargets="Build" ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
projects/vstudio/pngunknown/pngunknown.vcxproj:  <ImportGroup Label="ExtensionSettings">
projects/vstudio/pngunknown/pngunknown.vcxproj:    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
projects/vstudio/pngunknown/pngunknown.vcxproj:    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" />
projects/vstudio/pngunknown/pngunknown.vcxproj:    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
projects/vstudio/pngunknown/pngunknown.vcxproj:    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" />
projects/vstudio/pngunknown/pngunknown.vcxproj:      <FloatingPointExceptions>false</FloatingPointExceptions>
projects/vstudio/pngunknown/pngunknown.vcxproj:      <Message>Executing PNG validation program</Message>
projects/vstudio/pngunknown/pngunknown.vcxproj:      <Command>"$(OutDir)pngunknown.exe" --strict --default --touch "$(IntDir)pngunknown.out" ../../../pngtest.png</Command>
projects/vstudio/pngunknown/pngunknown.vcxproj:      <Inputs>$(OutDir)pngunknown.exe</Inputs>
projects/vstudio/pngunknown/pngunknown.vcxproj:      <FloatingPointExceptions>false</FloatingPointExceptions>
projects/vstudio/pngunknown/pngunknown.vcxproj:      <Message>Executing PNG validation program</Message>
projects/vstudio/pngunknown/pngunknown.vcxproj:      <Command>"$(OutDir)pngunknown.exe" --strict --default --touch "$(IntDir)pngunknown.out" ../../../pngtest.png</Command>
projects/vstudio/pngunknown/pngunknown.vcxproj:      <Inputs>$(OutDir)pngunknown.exe</Inputs>
projects/vstudio/pngunknown/pngunknown.vcxproj:      <FloatingPointExceptions>false</FloatingPointExceptions>
projects/vstudio/pngunknown/pngunknown.vcxproj:      <Message>Executing PNG validation program</Message>
projects/vstudio/pngunknown/pngunknown.vcxproj:      <Command>"$(OutDir)pngunknown.exe" --strict --default --touch "$(IntDir)pngunknown.out" ../../../pngtest.png</Command>
projects/vstudio/pngunknown/pngunknown.vcxproj:      <Inputs>$(OutDir)pngunknown.exe</Inputs>
projects/vstudio/pngunknown/pngunknown.vcxproj:      <FloatingPointExceptions>false</FloatingPointExceptions>
projects/vstudio/pngunknown/pngunknown.vcxproj:      <Message>Executing PNG validation program</Message>
projects/vstudio/pngunknown/pngunknown.vcxproj:      <Command>"$(OutDir)pngunknown.exe" --strict --default --touch "$(IntDir)pngunknown.out" ../../../pngtest.png</Command>
projects/vstudio/pngunknown/pngunknown.vcxproj:      <Inputs>$(OutDir)pngunknown.exe</Inputs>
projects/vstudio/pngunknown/pngunknown.vcxproj:  <ImportGroup Label="ExtensionTargets">
projects/vstudio/pngstest/pngstest.vcxproj:<?xml version="1.0" encoding="utf-8"?>
projects/vstudio/pngstest/pngstest.vcxproj:<Project DefaultTargets="Build" ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
projects/vstudio/pngstest/pngstest.vcxproj:  <ImportGroup Label="ExtensionSettings">
projects/vstudio/pngstest/pngstest.vcxproj:    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
projects/vstudio/pngstest/pngstest.vcxproj:    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" />
projects/vstudio/pngstest/pngstest.vcxproj:    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
projects/vstudio/pngstest/pngstest.vcxproj:    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" />
projects/vstudio/pngstest/pngstest.vcxproj:      <FloatingPointExceptions>false</FloatingPointExceptions>
projects/vstudio/pngstest/pngstest.vcxproj:      <Message>Executing libpng simplified API test program</Message>
projects/vstudio/pngstest/pngstest.vcxproj:      <Command>"$(OutDir)pngstest.exe" --strict --log --touch "$(IntDir)pngstest.out" ../../../contrib/pngsuite/basn0g01.png ../../../contrib/pngsuite/basn0g02.png ../../../contrib/pngsuite/basn0g04.png ../../../contrib/pngsuite/basn0g08.png ../../../contrib/pngsuite/basn0g16.png ../../../contrib/pngsuite/basn2c08.png ../../../contrib/pngsuite/basn2c16.png ../../../contrib/pngsuite/basn3p01.png ../../../contrib/pngsuite/basn3p02.png ../../../contrib/pngsuite/basn3p04.png ../../../contrib/pngsuite/basn3p08.png ../../../contrib/pngsuite/basn4a08.png ../../../contrib/pngsuite/basn4a16.png ../../../contrib/pngsuite/basn6a08.png ../../../contrib/pngsuite/basn6a16.png ../../../contrib/pngsuite/ftbbn0g01.png ../../../contrib/pngsuite/ftbbn0g02.png ../../../contrib/pngsuite/ftbbn0g04.png ../../../contrib/pngsuite/ftbbn2c16.png ../../../contrib/pngsuite/ftbbn3p08.png ../../../contrib/pngsuite/ftbgn2c16.png ../../../contrib/pngsuite/ftbgn3p08.png ../../../contrib/pngsuite/ftbrn2c08.png ../../../contrib/pngsuite/ftbwn0g16.png ../../../contrib/pngsuite/ftbwn3p08.png ../../../contrib/pngsuite/ftbyn3p08.png ../../../contrib/pngsuite/ftp0n0g08.png ../../../contrib/pngsuite/ftp0n2c08.png ../../../contrib/pngsuite/ftp0n3p08.png ../../../contrib/pngsuite/ftp1n3p08.png</Command>
projects/vstudio/pngstest/pngstest.vcxproj:      <Inputs>$(OutDir)pngstest.exe</Inputs>
projects/vstudio/pngstest/pngstest.vcxproj:      <FloatingPointExceptions>false</FloatingPointExceptions>
projects/vstudio/pngstest/pngstest.vcxproj:      <Message>Executing libpng simplified API test program</Message>
projects/vstudio/pngstest/pngstest.vcxproj:      <Command>"$(OutDir)pngstest.exe" --strict --log --touch "$(IntDir)pngstest.out" ../../../contrib/pngsuite/basn0g01.png ../../../contrib/pngsuite/basn0g02.png ../../../contrib/pngsuite/basn0g04.png ../../../contrib/pngsuite/basn0g08.png ../../../contrib/pngsuite/basn0g16.png ../../../contrib/pngsuite/basn2c08.png ../../../contrib/pngsuite/basn2c16.png ../../../contrib/pngsuite/basn3p01.png ../../../contrib/pngsuite/basn3p02.png ../../../contrib/pngsuite/basn3p04.png ../../../contrib/pngsuite/basn3p08.png ../../../contrib/pngsuite/basn4a08.png ../../../contrib/pngsuite/basn4a16.png ../../../contrib/pngsuite/basn6a08.png ../../../contrib/pngsuite/basn6a16.png ../../../contrib/pngsuite/ftbbn0g01.png ../../../contrib/pngsuite/ftbbn0g02.png ../../../contrib/pngsuite/ftbbn0g04.png ../../../contrib/pngsuite/ftbbn2c16.png ../../../contrib/pngsuite/ftbbn3p08.png ../../../contrib/pngsuite/ftbgn2c16.png ../../../contrib/pngsuite/ftbgn3p08.png ../../../contrib/pngsuite/ftbrn2c08.png ../../../contrib/pngsuite/ftbwn0g16.png ../../../contrib/pngsuite/ftbwn3p08.png ../../../contrib/pngsuite/ftbyn3p08.png ../../../contrib/pngsuite/ftp0n0g08.png ../../../contrib/pngsuite/ftp0n2c08.png ../../../contrib/pngsuite/ftp0n3p08.png ../../../contrib/pngsuite/ftp1n3p08.png</Command>
projects/vstudio/pngstest/pngstest.vcxproj:      <Inputs>$(OutDir)pngstest.exe</Inputs>
projects/vstudio/pngstest/pngstest.vcxproj:      <FloatingPointExceptions>false</FloatingPointExceptions>
projects/vstudio/pngstest/pngstest.vcxproj:      <Message>Executing libpng simplified API test program</Message>
projects/vstudio/pngstest/pngstest.vcxproj:      <Command>"$(OutDir)pngstest.exe" --strict --log --touch "$(IntDir)pngstest.out" ../../../contrib/pngsuite/basn0g01.png ../../../contrib/pngsuite/basn0g02.png ../../../contrib/pngsuite/basn0g04.png ../../../contrib/pngsuite/basn0g08.png ../../../contrib/pngsuite/basn0g16.png ../../../contrib/pngsuite/basn2c08.png ../../../contrib/pngsuite/basn2c16.png ../../../contrib/pngsuite/basn3p01.png ../../../contrib/pngsuite/basn3p02.png ../../../contrib/pngsuite/basn3p04.png ../../../contrib/pngsuite/basn3p08.png ../../../contrib/pngsuite/basn4a08.png ../../../contrib/pngsuite/basn4a16.png ../../../contrib/pngsuite/basn6a08.png ../../../contrib/pngsuite/basn6a16.png ../../../contrib/pngsuite/ftbbn0g01.png ../../../contrib/pngsuite/ftbbn0g02.png ../../../contrib/pngsuite/ftbbn0g04.png ../../../contrib/pngsuite/ftbbn2c16.png ../../../contrib/pngsuite/ftbbn3p08.png ../../../contrib/pngsuite/ftbgn2c16.png ../../../contrib/pngsuite/ftbgn3p08.png ../../../contrib/pngsuite/ftbrn2c08.png ../../../contrib/pngsuite/ftbwn0g16.png ../../../contrib/pngsuite/ftbwn3p08.png ../../../contrib/pngsuite/ftbyn3p08.png ../../../contrib/pngsuite/ftp0n0g08.png ../../../contrib/pngsuite/ftp0n2c08.png ../../../contrib/pngsuite/ftp0n3p08.png ../../../contrib/pngsuite/ftp1n3p08.png</Command>
projects/vstudio/pngstest/pngstest.vcxproj:      <Inputs>$(OutDir)pngstest.exe</Inputs>
projects/vstudio/pngstest/pngstest.vcxproj:      <FloatingPointExceptions>false</FloatingPointExceptions>
projects/vstudio/pngstest/pngstest.vcxproj:      <Message>Executing libpng simplified API test program</Message>
projects/vstudio/pngstest/pngstest.vcxproj:      <Command>"$(OutDir)pngstest.exe" --strict --log --touch "$(IntDir)pngstest.out" ../../../contrib/pngsuite/basn0g01.png ../../../contrib/pngsuite/basn0g02.png ../../../contrib/pngsuite/basn0g04.png ../../../contrib/pngsuite/basn0g08.png ../../../contrib/pngsuite/basn0g16.png ../../../contrib/pngsuite/basn2c08.png ../../../contrib/pngsuite/basn2c16.png ../../../contrib/pngsuite/basn3p01.png ../../../contrib/pngsuite/basn3p02.png ../../../contrib/pngsuite/basn3p04.png ../../../contrib/pngsuite/basn3p08.png ../../../contrib/pngsuite/basn4a08.png ../../../contrib/pngsuite/basn4a16.png ../../../contrib/pngsuite/basn6a08.png ../../../contrib/pngsuite/basn6a16.png ../../../contrib/pngsuite/ftbbn0g01.png ../../../contrib/pngsuite/ftbbn0g02.png ../../../contrib/pngsuite/ftbbn0g04.png ../../../contrib/pngsuite/ftbbn2c16.png ../../../contrib/pngsuite/ftbbn3p08.png ../../../contrib/pngsuite/ftbgn2c16.png ../../../contrib/pngsuite/ftbgn3p08.png ../../../contrib/pngsuite/ftbrn2c08.png ../../../contrib/pngsuite/ftbwn0g16.png ../../../contrib/pngsuite/ftbwn3p08.png ../../../contrib/pngsuite/ftbyn3p08.png ../../../contrib/pngsuite/ftp0n0g08.png ../../../contrib/pngsuite/ftp0n2c08.png ../../../contrib/pngsuite/ftp0n3p08.png ../../../contrib/pngsuite/ftp1n3p08.png</Command>
projects/vstudio/pngstest/pngstest.vcxproj:      <Inputs>$(OutDir)pngstest.exe</Inputs>
projects/vstudio/pngstest/pngstest.vcxproj:  <ImportGroup Label="ExtensionTargets">
projects/vstudio/vstudio.sln:Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "zlib", "zlib\zlib.vcxproj", "{60F89955-91C6-3A36-8000-13C592FEC2DF}"
projects/vstudio/vstudio.sln:Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "pnglibconf", "pnglibconf\pnglibconf.vcxproj", "{EB33566E-DA7F-4D28-9077-88C0B7C77E35}"
projects/vstudio/vstudio.sln:Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "libpng", "libpng\libpng.vcxproj", "{D6973076-9317-4EF2-A0B8-B7A18AC0713E}"
projects/vstudio/vstudio.sln:Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "pngtest", "pngtest\pngtest.vcxproj", "{228BA965-50D5-42B2-8BCF-AFCC227E3C1D}"
projects/vstudio/vstudio.sln:Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "pngvalid", "pngvalid\pngvalid.vcxproj", "{9B36B6FE-7FC0-434F-A71F-BBEF8099F1D8}"
projects/vstudio/vstudio.sln:Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "pngstest", "pngstest\pngstest.vcxproj", "{277AC57F-313B-4D06-B119-A3CDB672D2FF}"
projects/vstudio/vstudio.sln:Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "pngunknown", "pngunknown\pngunknown.vcxproj", "{C5D3156C-8C8C-4936-B35F-2B829BA36FEC}"
projects/visualc71/pngtest.vcproj:<?xml version="1.0" encoding="Windows-1252"?>
projects/visualc71/pngtest.vcproj:				InlineFunctionExpansion="1"
projects/visualc71/pngtest.vcproj:				OutputFile="$(OutDir)/pngtest.exe"
projects/visualc71/pngtest.vcproj:				Name="VCWebServiceProxyGeneratorTool"/>
projects/visualc71/pngtest.vcproj:				Name="VCAuxiliaryManagedWrapperGeneratorTool"/>
projects/visualc71/pngtest.vcproj:				OutputFile="$(OutDir)/pngtest.exe"
projects/visualc71/pngtest.vcproj:				Name="VCWebServiceProxyGeneratorTool"/>
projects/visualc71/pngtest.vcproj:				Name="VCAuxiliaryManagedWrapperGeneratorTool"/>
projects/visualc71/pngtest.vcproj:				InlineFunctionExpansion="1"
projects/visualc71/pngtest.vcproj:				OutputFile="$(OutDir)/pngtest.exe"
projects/visualc71/pngtest.vcproj:				Name="VCWebServiceProxyGeneratorTool"/>
projects/visualc71/pngtest.vcproj:				Name="VCAuxiliaryManagedWrapperGeneratorTool"/>
projects/visualc71/pngtest.vcproj:				InlineFunctionExpansion="1"
projects/visualc71/pngtest.vcproj:				OutputFile="$(OutDir)/pngtest.exe"
projects/visualc71/pngtest.vcproj:				Name="VCWebServiceProxyGeneratorTool"/>
projects/visualc71/pngtest.vcproj:				Name="VCAuxiliaryManagedWrapperGeneratorTool"/>
projects/visualc71/pngtest.vcproj:				OutputFile="$(OutDir)/pngtest.exe"
projects/visualc71/pngtest.vcproj:				Name="VCWebServiceProxyGeneratorTool"/>
projects/visualc71/pngtest.vcproj:				Name="VCAuxiliaryManagedWrapperGeneratorTool"/>
projects/visualc71/pngtest.vcproj:			Filter="cpp;c;cxx;rc;def;r;odl;idl;hpj;bat">
projects/visualc71/libpng.vcproj:<?xml version="1.0" encoding="Windows-1252"?>
projects/visualc71/libpng.vcproj:				InlineFunctionExpansion="1"
projects/visualc71/libpng.vcproj:				Name="VCWebServiceProxyGeneratorTool"/>
projects/visualc71/libpng.vcproj:				Name="VCAuxiliaryManagedWrapperGeneratorTool"/>
projects/visualc71/libpng.vcproj:				Name="VCWebServiceProxyGeneratorTool"/>
projects/visualc71/libpng.vcproj:				Name="VCAuxiliaryManagedWrapperGeneratorTool"/>
projects/visualc71/libpng.vcproj:				InlineFunctionExpansion="1"
projects/visualc71/libpng.vcproj:				AdditionalOptions="/d PNG_NO_PEDANTIC_WARNINGS /d PNG_LIBPNG_DLLFNAME_POSTFIX=&quot;&quot;&quot;&quot;VB&quot;&quot;&quot;&quot; /d PNG_LIBPNG_SPECIALBUILD=&quot;&quot;&quot;&quot;__stdcall calling convention used for exported functions&quot;&quot;&quot;&quot;"
projects/visualc71/libpng.vcproj:				Name="VCWebServiceProxyGeneratorTool"/>
projects/visualc71/libpng.vcproj:				Name="VCAuxiliaryManagedWrapperGeneratorTool"/>
projects/visualc71/libpng.vcproj:				InlineFunctionExpansion="1"
projects/visualc71/libpng.vcproj:				Name="VCWebServiceProxyGeneratorTool"/>
projects/visualc71/libpng.vcproj:				Name="VCAuxiliaryManagedWrapperGeneratorTool"/>
projects/visualc71/libpng.vcproj:				Name="VCWebServiceProxyGeneratorTool"/>
projects/visualc71/libpng.vcproj:				Name="VCAuxiliaryManagedWrapperGeneratorTool"/>
projects/visualc71/libpng.vcproj:			Filter="cpp;c;cxx;rc;def;r;odl;idl;hpj;bat">
projects/visualc71/libpng.vcproj:			Filter="h;hpp;hxx;hm;inl">
projects/visualc71/libpng.vcproj:					ExcludedFromBuild="TRUE">
projects/visualc71/libpng.vcproj:					ExcludedFromBuild="TRUE">
projects/visualc71/libpng.vcproj:					Outputs="$(IntDir)\alloc.h;$(IntDir)\fp.h;$(IntDir)\m68881.h;$(IntDir)\mem.h;$(IntDir)\pngusr.h;$(IntDir)\strings.h;$(IntDir)\unistd.h;$(IntDir)\unixio.h"/>
projects/visualc71/libpng.vcproj:					Outputs="$(IntDir)\alloc.h;$(IntDir)\fp.h;$(IntDir)\m68881.h;$(IntDir)\mem.h;$(IntDir)\pngusr.h;$(IntDir)\strings.h;$(IntDir)\unistd.h;$(IntDir)\unixio.h"/>
projects/visualc71/libpng.vcproj:					Outputs="$(IntDir)\alloc.h;$(IntDir)\fp.h;$(IntDir)\m68881.h;$(IntDir)\mem.h;$(IntDir)\pngusr.h;$(IntDir)\strings.h;$(IntDir)\unistd.h;$(IntDir)\unixio.h"/>
projects/visualc71/libpng.vcproj:			RelativePath="README.txt">
projects/visualc71/PRJ0041.mak:	 $(IntDir)\unixio.h
projects/visualc71/PRJ0041.mak:$(IntDir)\unixio.h:
projects/visualc71/README.txt:Copyright (C) 2004 Simon-Pierre Cadieux.
projects/visualc71/README.txt:  files get intergrated into the next zlib release. The final zlib project
projects/visualc71/README.txt:2) Display the Solution Explorer view (Ctrl+Alt+L)
projects/visualc71/README.txt:$(VCINSTALLDIR)\redist.txt.
projects/visualc71/zlib.vcproj:<?xml version="1.0" encoding="Windows-1252"?>
projects/visualc71/zlib.vcproj:				InlineFunctionExpansion="1"
projects/visualc71/zlib.vcproj:				Name="VCWebServiceProxyGeneratorTool"/>
projects/visualc71/zlib.vcproj:				Name="VCAuxiliaryManagedWrapperGeneratorTool"/>
projects/visualc71/zlib.vcproj:				Name="VCWebServiceProxyGeneratorTool"/>
projects/visualc71/zlib.vcproj:				Name="VCAuxiliaryManagedWrapperGeneratorTool"/>
projects/visualc71/zlib.vcproj:				InlineFunctionExpansion="1"
projects/visualc71/zlib.vcproj:				Name="VCWebServiceProxyGeneratorTool"/>
projects/visualc71/zlib.vcproj:				Name="VCAuxiliaryManagedWrapperGeneratorTool"/>
projects/visualc71/zlib.vcproj:				Name="VCWebServiceProxyGeneratorTool"/>
projects/visualc71/zlib.vcproj:				Name="VCAuxiliaryManagedWrapperGeneratorTool"/>
projects/visualc71/zlib.vcproj:			Filter="cpp;c;cxx;rc;def;r;odl;idl;hpj;bat">
projects/visualc71/zlib.vcproj:					ExcludedFromBuild="TRUE">
projects/visualc71/zlib.vcproj:					ExcludedFromBuild="TRUE">
projects/visualc71/zlib.vcproj:			Filter="h;hpp;hxx;hm;inl">
projects/visualc71/zlib.vcproj:				RelativePath="..\..\..\zlib\inffixed.h">
projects/visualc71/zlib.vcproj:					ExcludedFromBuild="TRUE">
projects/visualc71/zlib.vcproj:					ExcludedFromBuild="TRUE">
projects/visualc71/zlib.vcproj:			Filter="asm;obj;c;cpp;cxx;h;hpp;hxx">
projects/visualc71/zlib.vcproj:				RelativePath="..\..\..\zlib\contrib\masmx86\gvmat32.asm">
projects/visualc71/zlib.vcproj:					ExcludedFromBuild="TRUE">
projects/visualc71/zlib.vcproj:					ExcludedFromBuild="TRUE">
projects/visualc71/zlib.vcproj:					ExcludedFromBuild="TRUE">
projects/visualc71/zlib.vcproj:					ExcludedFromBuild="TRUE">
projects/visualc71/zlib.vcproj:				RelativePath="..\..\..\zlib\contrib\masmx86\gvmat32c.c">
projects/visualc71/zlib.vcproj:					ExcludedFromBuild="TRUE">
projects/visualc71/zlib.vcproj:					ExcludedFromBuild="TRUE">
projects/visualc71/zlib.vcproj:					ExcludedFromBuild="TRUE">
projects/visualc71/zlib.vcproj:					ExcludedFromBuild="TRUE">
projects/visualc71/zlib.vcproj:				RelativePath="..\..\..\zlib\contrib\masmx86\inffas32.asm">
projects/visualc71/zlib.vcproj:					ExcludedFromBuild="TRUE">
projects/visualc71/zlib.vcproj:					ExcludedFromBuild="TRUE">
projects/visualc71/zlib.vcproj:					ExcludedFromBuild="TRUE">
projects/visualc71/zlib.vcproj:					ExcludedFromBuild="TRUE">
projects/visualc71/zlib.vcproj:			RelativePath="README.txt">
projects/visualc71/libpng.sln:	GlobalSection(ExtensibilityGlobals) = postSolution
projects/visualc71/libpng.sln:	GlobalSection(ExtensibilityAddIns) = postSolution
projects/visualc71/README_zlib.txt:            It is expected to be part of the next zlib release under
projects/visualc71/README_zlib.txt:            "projects\visualc71\README.txt." */
projects/visualc71/README_zlib.txt:Copyright (C) 2004 Simon-Pierre Cadieux.
projects/visualc71/README_zlib.txt:2) Display the Solution Explorer view (Ctrl+Alt+L)
projects/visualc71/README_zlib.txt:   binaries set it to "example" (Select "example" tree view item + Project |
README:libpng-*.tar.xz or if you want UNIX-style line endings in the text files,
README:extensive use and testing since mid-1995.  By late 1997 it had
README:library, through libpng-1.2.x.  In libpng-1.4.x, which was meant to
README:programs use the new APIs (as shown in example.c and pngtest.c), and
README:Experimental functions include the ability to set weighting and cost
README:The changes made to the library, and bugs fixed are based on discussions
README:For a detailed description on using libpng, read libpng-manual.txt.  For
README:examples of libpng in a program, see example.c and pngtest.c.  For usage
README:I am not a lawyer, but I believe that the Export Control Classification
README:Number (ECCN) for libpng is EAR99, which means not subject to export
README:(note: not zlib), and they are easy to fix, I'd appreciate the
README:fix.  Please mention "libpng" somewhere in the subject line.  Thanks.
README:      example.c     =>  Example code for using libpng functions
README:      libpng.3      =>  manual page for libpng (includes libpng-manual.txt)
README:      libpng-manual.txt  =>  Description of libpng and its functions
README:      pngbar.png    =>  PNG logo, 88x31
README:      pngnow.png    =>  PNG logo, 98x31
README:       examples         =>  Example programs
README:                            (see scripts/README.txt for the list of scripts)
scripts/makefile.acorn:	<Prefix$Dir>.pngtest
scripts/makefile.acorn:	@remove <Prefix$Dir>.pngtest
scripts/makefile.hpux:prefix=/opt/libpng
scripts/makefile.hpux:exec_prefix=$(prefix)
scripts/makefile.hpux:INCPATH=$(prefix)/include
scripts/makefile.hpux:LIBPATH=$(exec_prefix)/lib
scripts/makefile.hpux:MANPATH=$(prefix)/man
scripts/makefile.hpux:BINPATH=$(exec_prefix)/bin
scripts/makefile.hpux:# installing into a temporary location.  Example:
scripts/makefile.hpux:# via DESTDIR, $(DESTDIR)$(prefix) must already exist before
scripts/makefile.hpux:# you execute make install.
scripts/makefile.hpux:	cat scripts/libpng.pc.in | sed -e s!@prefix@!$(prefix)! \
scripts/makefile.hpux:	-e s!@exec_prefix@!$(exec_prefix)! \
scripts/makefile.hpux:	echo prefix=\"$(prefix)\"; \
scripts/makefile.hpux:	chmod +x libpng-config
scripts/makefile.mips:prefix=/usr/local
scripts/makefile.mips:INCPATH=$(prefix)/include
scripts/makefile.mips:LIBPATH=$(prefix)/lib
scripts/makefile.mips:# installing into a temporary location.  Example:
scripts/makefile.mips:# via DESTDIR, $(DESTDIR)$(prefix) must already exist before
scripts/makefile.mips:# you execute make install.
scripts/makefile.hp64:prefix=/opt/libpng
scripts/makefile.hp64:exec_prefix=$(prefix)
scripts/makefile.hp64:INCPATH=$(prefix)/include
scripts/makefile.hp64:LIBPATH=$(exec_prefix)/lib
scripts/makefile.hp64:MANPATH=$(prefix)/man
scripts/makefile.hp64:BINPATH=$(exec_prefix)/bin
scripts/makefile.hp64:# installing into a temporary location.  Example:
scripts/makefile.hp64:# via DESTDIR, $(DESTDIR)$(prefix) must already exist before
scripts/makefile.hp64:# you execute make install.
scripts/makefile.hp64:	cat scripts/libpng.pc.in | sed -e s!@prefix@!$(prefix)! \
scripts/makefile.hp64:	-e s!@exec_prefix@!$(exec_prefix)! \
scripts/makefile.hp64:	echo prefix=\"$(prefix)\"; \
scripts/makefile.hp64:	chmod +x libpng-config
scripts/makefile.openbsd:	libpng-manual.txt
scripts/options.awk:   err=0                        # in-line exit sets this
scripts/options.awk:   # the lines, for example by inserting spaces around operators, and all
scripts/options.awk:   setval[""] = ""    # value to set (indexed: 'option sets[option]')
scripts/options.awk:   exit 1
scripts/options.awk:      next
scripts/options.awk:   exit 1
scripts/options.awk:   next
scripts/options.awk:   next
scripts/options.awk:#   Sets the given variable to the given value (the syntax is fairly
scripts/options.awk:#   free form, except for deb (you are expected to understand how to
scripts/options.awk:   next
scripts/options.awk:   next
scripts/options.awk:   next
scripts/options.awk:   next
scripts/options.awk:   next
scripts/options.awk:   next
scripts/options.awk:# that need preprocessing (just chunk at present) expanded
scripts/options.awk:   next
scripts/options.awk:# In the syntax below a 'name' is indicated by "NAME", other macro
scripts/options.awk:# is omitted, but in this case the "NO_" prefix and the "_SUPPORTED"
scripts/options.awk:# suffix are never used.
scripts/options.awk:   next
scripts/options.awk:   next
scripts/options.awk:      exit 1
scripts/options.awk:   next
scripts/options.awk:   next
scripts/options.awk:#   be later) entry may turn an option on or off explicitly.
scripts/options.awk:            exit 1
scripts/options.awk:                     exit 1
scripts/options.awk:      next
scripts/options.awk:#   Expands to the 'option' settings appropriate to the reading and
scripts/options.awk:            exit 1
scripts/options.awk:      next
scripts/options.awk:#   (BTW: this is somewhat restrictive, it mainly exists for the
scripts/options.awk:   next
scripts/options.awk:# 'NAME' is as above, but 'MACRO' is the full text of the equivalent
scripts/options.awk:   next
scripts/options.awk:   next
scripts/options.awk:   exit 1
scripts/options.awk:# to be checked.  For example:
scripts/options.awk:#   FIXED_POINT are set (this is an example; in fact both are allowed.)
scripts/options.awk:# If all these options were given the build would require exactly one
scripts/options.awk:   # END{} gets run on an exit (a traditional awk feature)
scripts/options.awk:   if (err) exit 1
scripts/options.awk:      exit 0
scripts/options.awk:   for (opt in enabledby) tree[opt] = 1  # may not be explicit options
scripts/options.awk:         exit 1
scripts/options.awk:            exit 1
scripts/options.awk:   # print the tree for extreme debugging
scripts/options.awk:   # Ok, now check all options marked explicitly 'on' or 'off':
scripts/options.awk:            exit 1
scripts/options.awk:   if (err) exit 1
scripts/options.awk:               continue  # next option
scripts/options.awk:         exit 1
scripts/options.awk:   # settings x depth, outputing the deepest required macros
scripts/options.awk:         #  1) External definition; trumps:
scripts/options.awk:         exit 1
scripts/symbols.def:; Contains all the symbols that can be exported from libpng
scripts/symbols.def: png_set_expand @26
scripts/symbols.def: png_set_expand_gray_1_2_4_to_8 @27
scripts/symbols.def: png_set_rgb_to_gray_fixed @33
scripts/symbols.def: png_get_pixels_per_meter @122
scripts/symbols.def: png_get_x_pixels_per_meter @123
scripts/symbols.def: png_get_y_pixels_per_meter @124
scripts/symbols.def: png_get_pixel_aspect_ratio @125
scripts/symbols.def: png_get_x_offset_pixels @126
scripts/symbols.def: png_get_y_offset_pixels @127
scripts/symbols.def: png_get_x_offset_microns @128
scripts/symbols.def: png_get_cHRM_fixed @134
scripts/symbols.def: png_set_cHRM_fixed @136
scripts/symbols.def: png_get_gAMA_fixed @138
scripts/symbols.def: png_set_gAMA_fixed @140
scripts/symbols.def: png_get_text @162
scripts/symbols.def: png_set_text @163
scripts/symbols.def: png_get_user_width_max @187
scripts/symbols.def: png_get_user_height_max @188
scripts/symbols.def: png_set_chunk_cache_max @189
scripts/symbols.def: png_get_chunk_cache_max @190
scripts/symbols.def: png_set_chunk_malloc_max @191
scripts/symbols.def: png_get_chunk_malloc_max @192
scripts/symbols.def: png_get_pixels_per_inch @193
scripts/symbols.def: png_get_x_pixels_per_inch @194
scripts/symbols.def: png_get_y_pixels_per_inch @195
scripts/symbols.def: png_get_x_offset_inches @196
scripts/symbols.def: png_set_gamma_fixed @208
scripts/symbols.def: png_set_filter_heuristics_fixed @209
scripts/symbols.def: png_get_pixel_aspect_ratio_fixed @210
scripts/symbols.def: png_get_x_offset_inches_fixed @211
scripts/symbols.def: png_get_y_offset_inches_fixed @212
scripts/symbols.def: png_set_sCAL_fixed @213
scripts/symbols.def: png_get_sCAL_fixed @214
scripts/symbols.def: png_set_background_fixed @215
scripts/symbols.def: png_set_expand_16 @221
scripts/symbols.def: png_set_text_compression_level @222
scripts/symbols.def: png_set_text_compression_mem_level @223
scripts/symbols.def: png_set_text_compression_strategy @224
scripts/symbols.def: png_set_text_compression_window_bits @225
scripts/symbols.def: png_set_text_compression_method @226
scripts/symbols.def: png_set_alpha_mode_fixed @228
scripts/symbols.def: png_get_cHRM_XYZ_fixed @231
scripts/symbols.def: png_set_cHRM_XYZ_fixed @233
scripts/symbols.def: png_set_check_for_invalid_index @242
scripts/symbols.def: png_get_palette_max @243
scripts/symbols.out:png_set_expand @26
scripts/symbols.out:png_set_expand_gray_1_2_4_to_8 @27
scripts/symbols.out:png_set_expand_16 @221
scripts/symbols.out:png_set_rgb_to_gray_fixed @33
scripts/symbols.out:png_set_alpha_mode_fixed @228
scripts/symbols.out:png_set_background_fixed @215
scripts/symbols.out:png_set_gamma_fixed @208
scripts/symbols.out:png_set_filter_heuristics_fixed @209
scripts/symbols.out:png_set_text_compression_level @222
scripts/symbols.out:png_set_text_compression_mem_level @223
scripts/symbols.out:png_set_text_compression_strategy @224
scripts/symbols.out:png_set_text_compression_window_bits @225
scripts/symbols.out:png_set_text_compression_method @226
scripts/symbols.out:png_get_pixels_per_meter @122
scripts/symbols.out:png_get_x_pixels_per_meter @123
scripts/symbols.out:png_get_y_pixels_per_meter @124
scripts/symbols.out:png_get_pixel_aspect_ratio @125
scripts/symbols.out:png_get_pixel_aspect_ratio_fixed @210
scripts/symbols.out:png_get_x_offset_pixels @126
scripts/symbols.out:png_get_y_offset_pixels @127
scripts/symbols.out:png_get_x_offset_microns @128
scripts/symbols.out:png_get_cHRM_fixed @134
scripts/symbols.out:png_get_cHRM_XYZ_fixed @231
scripts/symbols.out:png_set_cHRM_fixed @136
scripts/symbols.out:png_set_cHRM_XYZ_fixed @233
scripts/symbols.out:png_get_gAMA_fixed @138
scripts/symbols.out:png_set_gAMA_fixed @140
scripts/symbols.out:png_get_text @162
scripts/symbols.out:png_set_text @163
scripts/symbols.out:png_get_sCAL_fixed @214
scripts/symbols.out:png_set_sCAL_fixed @213
scripts/symbols.out:png_get_user_width_max @187
scripts/symbols.out:png_get_user_height_max @188
scripts/symbols.out:png_set_chunk_cache_max @189
scripts/symbols.out:png_get_chunk_cache_max @190
scripts/symbols.out:png_set_chunk_malloc_max @191
scripts/symbols.out:png_get_chunk_malloc_max @192
scripts/symbols.out:png_get_pixels_per_inch @193
scripts/symbols.out:png_get_x_pixels_per_inch @194
scripts/symbols.out:png_get_y_pixels_per_inch @195
scripts/symbols.out:png_get_x_offset_inches @196
scripts/symbols.out:png_get_x_offset_inches_fixed @211
scripts/symbols.out:png_get_y_offset_inches_fixed @212
scripts/symbols.out:png_set_check_for_invalid_index @242
scripts/symbols.out:png_get_palette_max @243
scripts/symbols.out:png_set_expand @26
scripts/symbols.out:png_set_expand_gray_1_2_4_to_8 @27
scripts/symbols.out:png_set_expand_16 @221
scripts/symbols.out:png_set_rgb_to_gray_fixed @33
scripts/symbols.out:png_set_alpha_mode_fixed @228
scripts/symbols.out:png_set_background_fixed @215
scripts/symbols.out:png_set_gamma_fixed @208
scripts/symbols.out:png_set_filter_heuristics_fixed @209
scripts/symbols.out:png_set_text_compression_level @222
scripts/symbols.out:png_set_text_compression_mem_level @223
scripts/symbols.out:png_set_text_compression_strategy @224
scripts/symbols.out:png_set_text_compression_window_bits @225
scripts/symbols.out:png_set_text_compression_method @226
scripts/symbols.out:png_get_pixels_per_meter @122
scripts/symbols.out:png_get_x_pixels_per_meter @123
scripts/symbols.out:png_get_y_pixels_per_meter @124
scripts/symbols.out:png_get_pixel_aspect_ratio @125
scripts/symbols.out:png_get_pixel_aspect_ratio_fixed @210
scripts/symbols.out:png_get_x_offset_pixels @126
scripts/symbols.out:png_get_y_offset_pixels @127
scripts/symbols.out:png_get_x_offset_microns @128
scripts/symbols.out:png_get_cHRM_fixed @134
scripts/symbols.out:png_get_cHRM_XYZ_fixed @231
scripts/symbols.out:png_set_cHRM_fixed @136
scripts/symbols.out:png_set_cHRM_XYZ_fixed @233
scripts/symbols.out:png_get_gAMA_fixed @138
scripts/symbols.out:png_set_gAMA_fixed @140
scripts/symbols.out:png_get_text @162
scripts/symbols.out:png_set_text @163
scripts/symbols.out:png_get_sCAL_fixed @214
scripts/symbols.out:png_set_sCAL_fixed @213
scripts/symbols.out:png_get_user_width_max @187
scripts/symbols.out:png_get_user_height_max @188
scripts/symbols.out:png_set_chunk_cache_max @189
scripts/symbols.out:png_get_chunk_cache_max @190
scripts/symbols.out:png_set_chunk_malloc_max @191
scripts/symbols.out:png_get_chunk_malloc_max @192
scripts/symbols.out:png_get_pixels_per_inch @193
scripts/symbols.out:png_get_x_pixels_per_inch @194
scripts/symbols.out:png_get_y_pixels_per_inch @195
scripts/symbols.out:png_get_x_offset_inches @196
scripts/symbols.out:png_get_x_offset_inches_fixed @211
scripts/symbols.out:png_get_y_offset_inches_fixed @212
scripts/symbols.out:png_set_check_for_invalid_index @242
scripts/symbols.out:png_get_palette_max @243
scripts/symbols.out:png_set_expand @26
scripts/symbols.out:png_set_expand_gray_1_2_4_to_8 @27
scripts/symbols.out:png_set_expand_16 @221
scripts/symbols.out:png_set_rgb_to_gray_fixed @33
scripts/symbols.out:png_set_alpha_mode_fixed @228
scripts/symbols.out:png_set_background_fixed @215
scripts/symbols.out:png_set_gamma_fixed @208
scripts/symbols.out:png_set_filter_heuristics_fixed @209
scripts/symbols.out:png_set_text_compression_level @222
scripts/symbols.out:png_set_text_compression_mem_level @223
scripts/symbols.out:png_set_text_compression_strategy @224
scripts/symbols.out:png_set_text_compression_window_bits @225
scripts/symbols.out:png_set_text_compression_method @226
scripts/symbols.out:png_get_pixels_per_meter @122
scripts/symbols.out:png_get_x_pixels_per_meter @123
scripts/symbols.out:png_get_y_pixels_per_meter @124
scripts/symbols.out:png_get_pixel_aspect_ratio @125
scripts/symbols.out:png_get_pixel_aspect_ratio_fixed @210
scripts/symbols.out:png_get_x_offset_pixels @126
scripts/symbols.out:png_get_y_offset_pixels @127
scripts/symbols.out:png_get_x_offset_microns @128
scripts/symbols.out:png_get_cHRM_fixed @134
scripts/symbols.out:png_get_cHRM_XYZ_fixed @231
scripts/symbols.out:png_set_cHRM_fixed @136
scripts/symbols.out:png_set_cHRM_XYZ_fixed @233
scripts/symbols.out:png_get_gAMA_fixed @138
scripts/symbols.out:png_set_gAMA_fixed @140
scripts/symbols.out:png_get_text @162
scripts/symbols.out:png_set_text @163
scripts/symbols.out:png_get_sCAL_fixed @214
scripts/symbols.out:png_set_sCAL_fixed @213
scripts/symbols.out:png_get_user_width_max @187
scripts/symbols.out:png_get_user_height_max @188
scripts/symbols.out:png_set_chunk_cache_max @189
scripts/symbols.out:png_get_chunk_cache_max @190
scripts/symbols.out:png_set_chunk_malloc_max @191
scripts/symbols.out:png_get_chunk_malloc_max @192
scripts/symbols.out:png_get_pixels_per_inch @193
scripts/symbols.out:png_get_x_pixels_per_inch @194
scripts/symbols.out:png_get_y_pixels_per_inch @195
scripts/symbols.out:png_get_x_offset_inches @196
scripts/symbols.out:png_get_x_offset_inches_fixed @211
scripts/symbols.out:png_get_y_offset_inches_fixed @212
scripts/symbols.out:png_set_check_for_invalid_index @242
scripts/symbols.out:png_get_palette_max @243
scripts/makefile.bc32:# Use this if you don't want Borland's fancy exception handling
scripts/makefile.bc32:.c.exe:
scripts/makefile.bc32:.obj.exe:
scripts/makefile.bc32:pngtest: pngtest.exe
scripts/makefile.bc32:test: pngtest.exe
scripts/makefile.bc32:	-del pngtest.exe
scripts/makefile.vcwin32:# File extensions
scripts/makefile.vcwin32:#uncomment next to put error messages in a file
scripts/makefile.vcwin32:pngtest.exe: pngtest$(O) libpng.lib
scripts/makefile.vcwin32:test: pngtest.exe
scripts/makefile.vcwin32:	-$(RM) pngtest.exe
scripts/libtool.m4:# As a special exception to the GNU General Public License,
scripts/libtool.m4:# Complain and exit if this libtool version is less that VERSION.
scripts/libtool.m4:dnl Autoconf doesn't catch unexpanded LT_ macros by default:
scripts/libtool.m4:# Only expand once:
scripts/libtool.m4:# Calculate cc_basename.  Skip known compiler wrappers and cross-prefix.
scripts/libtool.m4:_LT_DECL([objext], [ac_objext], [0], [Object file suffix (normally "o")])dnl
scripts/libtool.m4:_LT_DECL([], [exeext], [0], [Executable file suffix (normally "")])dnl
scripts/libtool.m4:aix3*)
scripts/libtool.m4:    export COLLECT_NAMES
scripts/libtool.m4:# All known linkers require a `.a' archive for static linking (except MSVC,
scripts/libtool.m4:libext=a
scripts/libtool.m4:test -z "$ac_objext" && ac_objext=o
scripts/libtool.m4:# Sed substitution to delay expansion of an escaped shell variable in a
scripts/libtool.m4:# Sed substitution to delay expansion of an escaped single quote.
scripts/libtool.m4:# Sed substitution to avoid accidental globbing in evaled expressions
scripts/libtool.m4:# `config.status' has no value for ac_aux_dir unless we are using Automake,
scripts/libtool.m4:_LT_CONFIG_LIBTOOL_INIT([ac_aux_dir='$ac_aux_dir'])
scripts/libtool.m4:ltmain="$ac_aux_dir/ltmain.sh"
scripts/libtool.m4:# embedded single quotes properly.  In configure, this macro expands
scripts/libtool.m4:# Extract the dictionary values for VARNAME (optionally with TAG) and
scripts/libtool.m4:# expand to a commented shell variable setting:
scripts/libtool.m4:# from calls to _LT_CONFIG_LIBTOOL_INIT is expanded.
scripts/libtool.m4:    dnl expand the accumulated commands and init code now:
scripts/libtool.m4:# file executable.  If COMMENT is supplied, it is inserted after the
scripts/libtool.m4:# `#!' sequence but before initialization text begins.  After this
scripts/libtool.m4:# macro, additional text can be appended to FILE to form the body of
scripts/libtool.m4:export SHELL
scripts/libtool.m4:exec AS_MESSAGE_FD>&1
scripts/libtool.m4:test $lt_write_fail = 0 && chmod +x $1[]dnl
scripts/libtool.m4:exec AS_MESSAGE_LOG_FD>>config.log
scripts/libtool.m4:  -h, --help      print this help, then exit
scripts/libtool.m4:  -V, --version   print version number, then exit
scripts/libtool.m4:      echo "$lt_cl_version"; exit 0 ;;
scripts/libtool.m4:      echo "$lt_cl_help"; exit 0 ;;
scripts/libtool.m4:  exec AS_MESSAGE_FD>/dev/null
scripts/libtool.m4:chmod +x "$CONFIG_LT"
scripts/libtool.m4:# open by configure.  Here we exec the FD to /dev/null, effectively closing
scripts/libtool.m4:exec AS_MESSAGE_LOG_FD>/dev/null
scripts/libtool.m4:exec AS_MESSAGE_LOG_FD>>config.log
scripts/libtool.m4:    trap "$RM \"$cfgfile\"; exit 1" 1 2 15
scripts/libtool.m4:  aix3*)
scripts/libtool.m4:  export COLLECT_NAMES
scripts/libtool.m4:  # if finds mixed CR/LF and LF-only lines.  Since sed operates in
scripts/libtool.m4:  # text mode, it properly converts lines to CR/LF.  This bash problem
scripts/libtool.m4:  # is reportedly fixed, but why not run on old versions too?
scripts/libtool.m4:     || (rm -f "$cfgfile"; exit 1)
scripts/libtool.m4:  chmod +x "$ofile"
scripts/libtool.m4:dnl Unfortunately we have to use $1 here, since _LT_TAG is not expanded
scripts/libtool.m4:  if test -n "$ac_tool_prefix"; then
scripts/libtool.m4:    AC_CHECK_PROG(GOC, [${ac_tool_prefix}gccgo], [${ac_tool_prefix}gccgo])
scripts/libtool.m4:ac_outfile=conftest.$ac_objext
scripts/libtool.m4:echo "$lt_simple_compile_test_code" >conftest.$ac_ext
scripts/libtool.m4:ac_outfile=conftest.$ac_objext
scripts/libtool.m4:echo "$lt_simple_link_test_code" >conftest.$ac_ext
scripts/libtool.m4:	# Otherwise, if the output was created with a 0 exit code from
scripts/libtool.m4:    AC_CACHE_CHECK([for -exported_symbols_list linker flag],
scripts/libtool.m4:      [lt_cv_ld_exported_symbols_list],
scripts/libtool.m4:      [lt_cv_ld_exported_symbols_list=no
scripts/libtool.m4:      LDFLAGS="$LDFLAGS -Wl,-exported_symbols_list,conftest.sym"
scripts/libtool.m4:	[lt_cv_ld_exported_symbols_list=yes],
scripts/libtool.m4:	[lt_cv_ld_exported_symbols_list=no])
scripts/libtool.m4:    darwin*) # darwin 5.x on
scripts/libtool.m4:      # to the OS version, if on x86, and 10.4, the deployment
scripts/libtool.m4:    if test "$lt_cv_ld_exported_symbols_list" = "yes"; then
scripts/libtool.m4:      _lt_dar_export_syms=' ${wl}-exported_symbols_list,$output_objdir/${libname}-symbols.expsym'
scripts/libtool.m4:      _lt_dar_export_syms='~$NMEDIT -s $output_objdir/${libname}-symbols.expsym ${lib}'
scripts/libtool.m4:    _LT_TAGVAR(archive_expsym_cmds, $1)="sed 's,^,_,' < \$export_symbols > \$output_objdir/\${libname}-symbols.expsym~\$CC -dynamiclib \$allow_undefined_flag -o \$lib \$libobjs \$deplibs \$compiler_flags -install_name \$rpath/\$soname \$verstring ${_lt_dar_single_mod}${_lt_dar_export_syms}${_lt_dsymutil}"
scripts/libtool.m4:    _LT_TAGVAR(module_expsym_cmds, $1)="sed -e 's,^,_,' < \$export_symbols > \$output_objdir/\${libname}-symbols.expsym~\$CC \$allow_undefined_flag -o \$lib -bundle \$libobjs \$deplibs \$compiler_flags${_lt_dar_export_syms}${_lt_dsymutil}"
scripts/libtool.m4:      _LT_TAGVAR(archive_cmds, $1)="\$CC -r -keep_private_externs -nostdlib -o \${lib}-master.o \$libobjs~\$CC -dynamiclib \$allow_undefined_flag -o \$lib \${lib}-master.o \$deplibs \$compiler_flags -install_name \$rpath/\$soname \$verstring${_lt_dsymutil}"
scripts/libtool.m4:      _LT_TAGVAR(archive_expsym_cmds, $1)="sed 's,^,_,' < \$export_symbols > \$output_objdir/\${libname}-symbols.expsym~\$CC -r -keep_private_externs -nostdlib -o \${lib}-master.o \$libobjs~\$CC -dynamiclib \$allow_undefined_flag -o \$lib \${lib}-master.o \$deplibs \$compiler_flags -install_name \$rpath/\$soname \$verstring${_lt_dar_export_syms}${_lt_dsymutil}"
scripts/libtool.m4:# Links a minimal program and checks the executable
scripts/libtool.m4:# to the aix ld manual.
scripts/libtool.m4:# Allow to override them for all tags through lt_cv_aix_libpath.
scripts/libtool.m4:if test "${lt_cv_aix_libpath+set}" = set; then
scripts/libtool.m4:  aix_libpath=$lt_cv_aix_libpath
scripts/libtool.m4:  AC_CACHE_VAL([_LT_TAGVAR([lt_cv_aix_libpath_], [$1])],
scripts/libtool.m4:  lt_aix_libpath_sed='[
scripts/libtool.m4:  _LT_TAGVAR([lt_cv_aix_libpath_], [$1])=`dump -H conftest$ac_exeext 2>/dev/null | $SED -n -e "$lt_aix_libpath_sed"`
scripts/libtool.m4:  if test -z "$_LT_TAGVAR([lt_cv_aix_libpath_], [$1])"; then
scripts/libtool.m4:    _LT_TAGVAR([lt_cv_aix_libpath_], [$1])=`dump -HX64 conftest$ac_exeext 2>/dev/null | $SED -n -e "$lt_aix_libpath_sed"`
scripts/libtool.m4:  if test -z "$_LT_TAGVAR([lt_cv_aix_libpath_], [$1])"; then
scripts/libtool.m4:    _LT_TAGVAR([lt_cv_aix_libpath_], [$1])="/usr/lib:/lib"
scripts/libtool.m4:  aix_libpath=$_LT_TAGVAR([lt_cv_aix_libpath_], [$1])
scripts/libtool.m4:[m4_divert_text([M4SH-INIT], [$1
scripts/libtool.m4:    PATH=/empty FPATH=/empty; export PATH FPATH
scripts/libtool.m4:test "x$enable_libtool_lock" != xno && enable_libtool_lock=yes
scripts/libtool.m4:ia64-*-hpux*)
scripts/libtool.m4:  echo 'int i;' > conftest.$ac_ext
scripts/libtool.m4:    case `/usr/bin/file conftest.$ac_objext` in
scripts/libtool.m4:*-*-irix6*)
scripts/libtool.m4:  echo '[#]line '$LINENO' "configure"' > conftest.$ac_ext
scripts/libtool.m4:      case `/usr/bin/file conftest.$ac_objext` in
scripts/libtool.m4:      case `/usr/bin/file conftest.$ac_objext` in
scripts/libtool.m4:x86_64-*kfreebsd*-gnu|x86_64-*linux*|ppc*-*linux*|powerpc*-*linux*| \
scripts/libtool.m4:s390*-*linux*|s390*-*tpf*|sparc*-*linux*)
scripts/libtool.m4:  echo 'int i;' > conftest.$ac_ext
scripts/libtool.m4:	  x86_64-*kfreebsd*-gnu)
scripts/libtool.m4:	  x86_64-*linux*)
scripts/libtool.m4:	  ppc64-*linux*|powerpc64-*linux*)
scripts/libtool.m4:	    LD="${LD-ld} -m elf32ppclinux"
scripts/libtool.m4:	  s390x-*linux*)
scripts/libtool.m4:	  sparc64-*linux*)
scripts/libtool.m4:	  x86_64-*kfreebsd*-gnu)
scripts/libtool.m4:	    LD="${LD-ld} -m elf_x86_64_fbsd"
scripts/libtool.m4:	  x86_64-*linux*)
scripts/libtool.m4:	    LD="${LD-ld} -m elf_x86_64"
scripts/libtool.m4:	  ppc*-*linux*|powerpc*-*linux*)
scripts/libtool.m4:	  s390*-*linux*|s390*-*tpf*)
scripts/libtool.m4:	  sparc*-*linux*)
scripts/libtool.m4:  if test x"$lt_cv_cc_needs_belf" != x"yes"; then
scripts/libtool.m4:  echo 'int i;' > conftest.$ac_ext
scripts/libtool.m4:          LD="${LD-ld} -m elf_x86_64"
scripts/libtool.m4:     [echo conftest.$ac_objext > conftest.lst
scripts/libtool.m4:	rm -f conftest.$ac_objext libconftest.a
scripts/libtool.m4:if test "x$lt_cv_ar_at_file" = xno; then
scripts/libtool.m4:    lock_old_archive_extraction=yes ;;
scripts/libtool.m4:    lock_old_archive_extraction=no ;;
scripts/libtool.m4:_LT_DECL([], [lock_old_archive_extraction], [0],
scripts/libtool.m4:    [Whether to use a lock for old archive extraction])
scripts/libtool.m4:   m4_if([$4], , [ac_outfile=conftest.$ac_objext], [ac_outfile=$4])
scripts/libtool.m4:   echo "$lt_simple_compile_test_code" > conftest.$ac_ext
scripts/libtool.m4:   if (exit $ac_status) && test -s "$ac_outfile"; then
scripts/libtool.m4:     $ECHO "$_lt_compiler_boilerplate" | $SED '/^$/d' >conftest.exp
scripts/libtool.m4:     if test ! -s conftest.er2 || diff conftest.exp conftest.er2 >/dev/null; then
scripts/libtool.m4:if test x"[$]$2" = xyes; then
scripts/libtool.m4:   echo "$lt_simple_link_test_code" > conftest.$ac_ext
scripts/libtool.m4:   if (eval $ac_link 2>conftest.err) && test -s conftest$ac_exeext; then
scripts/libtool.m4:       $ECHO "$_lt_linker_boilerplate" | $SED '/^$/d' > conftest.exp
scripts/libtool.m4:       if diff conftest.exp conftest.er2 >/dev/null; then
scripts/libtool.m4:if test x"[$]$2" = xyes; then
scripts/libtool.m4:# find the maximum length of command line arguments
scripts/libtool.m4:AC_MSG_CHECKING([the maximum length of command line arguments])
scripts/libtool.m4:AC_CACHE_VAL([lt_cv_sys_max_cmd_len], [dnl
scripts/libtool.m4:    # (any single argument exceeding 2000 bytes causes a buffer overrun
scripts/libtool.m4:    # during glob expansion).  Even if it were fixed, the result of this
scripts/libtool.m4:    lt_cv_sys_max_cmd_len=12288;    # 12K is about right
scripts/libtool.m4:    lt_cv_sys_max_cmd_len=-1;
scripts/libtool.m4:    # On Win9x/ME, this test blows up -- it succeeds, but takes
scripts/libtool.m4:    # about 5 minutes as the teststring grows exponentially.
scripts/libtool.m4:    # Worse, since 9x/ME are not pre-emptively multitasking,
scripts/libtool.m4:    # the test eventually succeeds (with a max line length of 256k).
scripts/libtool.m4:    lt_cv_sys_max_cmd_len=8192;
scripts/libtool.m4:    lt_cv_sys_max_cmd_len=8192;
scripts/libtool.m4:    lt_cv_sys_max_cmd_len=8192;
scripts/libtool.m4:    if test -x /sbin/sysctl; then
scripts/libtool.m4:      lt_cv_sys_max_cmd_len=`/sbin/sysctl -n kern.argmax`
scripts/libtool.m4:    elif test -x /usr/sbin/sysctl; then
scripts/libtool.m4:      lt_cv_sys_max_cmd_len=`/usr/sbin/sysctl -n kern.argmax`
scripts/libtool.m4:      lt_cv_sys_max_cmd_len=65536	# usable default for all BSDs
scripts/libtool.m4:    lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \/ 4`
scripts/libtool.m4:    lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \* 3`
scripts/libtool.m4:  interix*)
scripts/libtool.m4:    lt_cv_sys_max_cmd_len=196608
scripts/libtool.m4:    lt_cv_sys_max_cmd_len=8192
scripts/libtool.m4:    # due to this test when exec_disable_arg_limit is 1 on Tru64. It is not
scripts/libtool.m4:    lt_cv_sys_max_cmd_len=16384
scripts/libtool.m4:    if test -x /sbin/sysconfig; then
scripts/libtool.m4:      case `/sbin/sysconfig -q proc exec_disable_arg_limit` in
scripts/libtool.m4:        *1*) lt_cv_sys_max_cmd_len=-1 ;;
scripts/libtool.m4:    lt_cv_sys_max_cmd_len=102400
scripts/libtool.m4:    kargmax=`grep ARG_MAX /etc/conf/cf.d/stune 2>/dev/null`
scripts/libtool.m4:    if test -n "$kargmax"; then
scripts/libtool.m4:      lt_cv_sys_max_cmd_len=`echo $kargmax | sed 's/.*[[	 ]]//'`
scripts/libtool.m4:      lt_cv_sys_max_cmd_len=32768
scripts/libtool.m4:    lt_cv_sys_max_cmd_len=`(getconf ARG_MAX) 2> /dev/null`
scripts/libtool.m4:    if test -n "$lt_cv_sys_max_cmd_len"; then
scripts/libtool.m4:      lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \/ 4`
scripts/libtool.m4:      lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \* 3`
scripts/libtool.m4:      # maximum length that is only half of the actual maximum length, but
scripts/libtool.m4:        i=`expr $i + 1`
scripts/libtool.m4:      lt_cv_sys_max_cmd_len=`expr "X$teststring" : ".*" 2>&1`
scripts/libtool.m4:      lt_cv_sys_max_cmd_len=`expr $lt_cv_sys_max_cmd_len \/ 2`
scripts/libtool.m4:if test -n $lt_cv_sys_max_cmd_len ; then
scripts/libtool.m4:  AC_MSG_RESULT($lt_cv_sys_max_cmd_len)
scripts/libtool.m4:max_cmd_len=$lt_cv_sys_max_cmd_len
scripts/libtool.m4:_LT_DECL([], [max_cmd_len], [0],
scripts/libtool.m4:    [What is the maximum length of a command?])
scripts/libtool.m4:  cat > conftest.$ac_ext <<_LT_EOF
scripts/libtool.m4:  if AC_TRY_EVAL(ac_link) && test -s conftest${ac_exeext} 2>/dev/null; then
scripts/libtool.m4:    (./conftest; exit; ) >&AS_MESSAGE_LOG_FD 2>/dev/null
scripts/libtool.m4:    case x$lt_status in
scripts/libtool.m4:      x$lt_dlno_uscore) $1 ;;
scripts/libtool.m4:      x$lt_dlneed_uscore) $2 ;;
scripts/libtool.m4:      x$lt_dlunknown|x*) $3 ;;
scripts/libtool.m4:if test "x$enable_dlopen" != xyes; then
scripts/libtool.m4:  if test "x$lt_cv_dlopen" != xno; then
scripts/libtool.m4:    test "x$ac_cv_header_dlfcn_h" = xyes && CPPFLAGS="$CPPFLAGS -DHAVE_DLFCN_H"
scripts/libtool.m4:    wl=$lt_prog_compiler_wl eval LDFLAGS=\"\$LDFLAGS $export_dynamic_flag_spec\"
scripts/libtool.m4:    if test "x$lt_cv_dlopen_self" = xyes; then
scripts/libtool.m4:AC_CACHE_CHECK([if $compiler supports -c -o file.$ac_objext],
scripts/libtool.m4:   echo "$lt_simple_compile_test_code" > conftest.$ac_ext
scripts/libtool.m4:   lt_compiler_flag="-o out/conftest2.$ac_objext"
scripts/libtool.m4:   if (exit $ac_status) && test -s out/conftest2.$ac_objext
scripts/libtool.m4:     $ECHO "$_lt_compiler_boilerplate" | $SED '/^$/d' > out/conftest.exp
scripts/libtool.m4:     if test ! -s out/conftest.er2 || diff out/conftest.exp out/conftest.er2 >/dev/null; then
scripts/libtool.m4:  # We can hardcode non-existent directories.
scripts/libtool.m4:    # We can link without hardcoding, and we can hardcode nonexisting dirs.
scripts/libtool.m4:  # We cannot hardcode anything, or else we can only hardcode existing
scripts/libtool.m4:    [How to hardcode a shared library path into an executable])
scripts/libtool.m4:      striplib="$STRIP -x"
scripts/libtool.m4:shrext_cmds=".so"
scripts/libtool.m4:need_lib_prefix=unknown
scripts/libtool.m4:aix3*)
scripts/libtool.m4:  version_type=linux # correct to gnu/linux during the next big refactor
scripts/libtool.m4:  library_names_spec='${libname}${release}${shared_ext}$versuffix $libname.a'
scripts/libtool.m4:  soname_spec='${libname}${release}${shared_ext}$major'
scripts/libtool.m4:aix[[4-9]]*)
scripts/libtool.m4:  version_type=linux # correct to gnu/linux during the next big refactor
scripts/libtool.m4:  need_lib_prefix=no
scripts/libtool.m4:    library_names_spec='${libname}${release}${shared_ext}$major ${libname}${release}${shared_ext}$versuffix $libname${shared_ext}'
scripts/libtool.m4:    # With GCC up to 2.95.x, collect2 would create an import file
scripts/libtool.m4:    # depend on `.', always an invalid library.  This was fixed in
scripts/libtool.m4:      aix4 | aix4.[[01]] | aix4.[[01]].*)
scripts/libtool.m4:    # soname into executable. Probably we can add versioning support to
scripts/libtool.m4:    if test "$aix_use_runtimelinking" = yes; then
scripts/libtool.m4:      library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
scripts/libtool.m4:      # We preserve .a as extension for shared libraries through AIX4.2
scripts/libtool.m4:      soname_spec='${libname}${release}${shared_ext}$major'
scripts/libtool.m4:    # When compiling the executable, add -use-dynld -Lsobjs: to the compileline.
scripts/libtool.m4:    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
scripts/libtool.m4:    library_names_spec='$libname.ixlibrary $libname.a'
scripts/libtool.m4:    # Create ${libname}_ixlibrary.a entries in /sys/libs.
scripts/libtool.m4:    finish_eval='for lib in `ls $libdir/*.ixlibrary 2>/dev/null`; do libname=`func_echo_all "$lib" | $SED '\''s%^.*/\([[^/]]*\)\.ixlibrary$%\1%'\''`; test $RM /sys/libs/${libname}_ixlibrary.a; $show "cd /sys/libs && $LN_S $lib ${libname}_ixlibrary.a"; cd /sys/libs && $LN_S $lib ${libname}_ixlibrary.a || exit 1; done'
scripts/libtool.m4:  library_names_spec='${libname}${shared_ext}'
scripts/libtool.m4:  version_type=linux # correct to gnu/linux during the next big refactor
scripts/libtool.m4:  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
scripts/libtool.m4:  soname_spec='${libname}${release}${shared_ext}$major'
scripts/libtool.m4:  shrext_cmds=".dll"
scripts/libtool.m4:  need_lib_prefix=no
scripts/libtool.m4:      chmod a+x \$dldir/$dlname~
scripts/libtool.m4:        eval '\''$striplib \$dldir/$dlname'\'' || exit \$?;
scripts/libtool.m4:      # Cygwin DLLs use 'cyg' prefix rather than 'lib'
scripts/libtool.m4:      soname_spec='`echo ${libname} | sed -e 's/^lib/cyg/'``echo ${release} | $SED -e 's/[[.]]/-/g'`${versuffix}${shared_ext}'
scripts/libtool.m4:      # MinGW DLLs use traditional 'lib' prefix
scripts/libtool.m4:      soname_spec='${libname}`echo ${release} | $SED -e 's/[[.]]/-/g'`${versuffix}${shared_ext}'
scripts/libtool.m4:      # pw32 DLLs use 'pw' prefix rather than 'lib'
scripts/libtool.m4:      library_names_spec='`echo ${libname} | sed -e 's/^lib/pw/'``echo ${release} | $SED -e 's/[[.]]/-/g'`${versuffix}${shared_ext}'
scripts/libtool.m4:    dynamic_linker='Win32 ld.exe'
scripts/libtool.m4:    soname_spec='${libname}`echo ${release} | $SED -e 's/[[.]]/-/g'`${versuffix}${shared_ext}'
scripts/libtool.m4:        # Let DOS variable expansion print the short 8.3 style file name.
scripts/libtool.m4:      # Convert to unix form, then to dos form, then back to unix form
scripts/libtool.m4:      # but this time dos style (no spaces!) so that the unix form looks
scripts/libtool.m4:      sys_lib_search_path_spec=`cygpath --path --unix "$LIB"`
scripts/libtool.m4:      sys_lib_search_path_spec=`cygpath --path --unix "$sys_lib_search_path_spec" | $SED -e "s/$PATH_SEPARATOR/ /g"`
scripts/libtool.m4:    dynamic_linker='Win32 link.exe'
scripts/libtool.m4:    library_names_spec='${libname}`echo ${release} | $SED -e 's/[[.]]/-/g'`${versuffix}${shared_ext} $libname.lib'
scripts/libtool.m4:    dynamic_linker='Win32 ld.exe'
scripts/libtool.m4:  # FIXME: first we should search . and the directory the executable is in
scripts/libtool.m4:  need_lib_prefix=no
scripts/libtool.m4:  library_names_spec='${libname}${release}${major}$shared_ext ${libname}$shared_ext'
scripts/libtool.m4:  soname_spec='${libname}${release}${major}$shared_ext'
scripts/libtool.m4:  shrext_cmds='`test .$module = .yes && echo .so || echo .dylib`'
scripts/libtool.m4:dgux*)
scripts/libtool.m4:  version_type=linux # correct to gnu/linux during the next big refactor
scripts/libtool.m4:  need_lib_prefix=no
scripts/libtool.m4:  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname$shared_ext'
scripts/libtool.m4:  soname_spec='${libname}${release}${shared_ext}$major'
scripts/libtool.m4:  if test -x /usr/bin/objformat; then
scripts/libtool.m4:      library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext} $libname${shared_ext}'
scripts/libtool.m4:      need_lib_prefix=no
scripts/libtool.m4:      library_names_spec='${libname}${release}${shared_ext}$versuffix $libname${shared_ext}$versuffix'
scripts/libtool.m4:  version_type=linux # correct to gnu/linux during the next big refactor
scripts/libtool.m4:  need_lib_prefix=no
scripts/libtool.m4:  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}${major} ${libname}${shared_ext}'
scripts/libtool.m4:  soname_spec='${libname}${release}${shared_ext}$major'
scripts/libtool.m4:  version_type=linux # correct to gnu/linux during the next big refactor
scripts/libtool.m4:  need_lib_prefix=no
scripts/libtool.m4:  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}${major} ${libname}${shared_ext}'
scripts/libtool.m4:  soname_spec='${libname}${release}${shared_ext}$major'
scripts/libtool.m4:hpux9* | hpux10* | hpux11*)
scripts/libtool.m4:  need_lib_prefix=no
scripts/libtool.m4:    shrext_cmds='.so'
scripts/libtool.m4:    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
scripts/libtool.m4:    soname_spec='${libname}${release}${shared_ext}$major'
scripts/libtool.m4:      sys_lib_search_path_spec="/usr/lib/hpux32 /usr/local/lib/hpux32 /usr/local/lib"
scripts/libtool.m4:      sys_lib_search_path_spec="/usr/lib/hpux64 /usr/local/lib/hpux64"
scripts/libtool.m4:    shrext_cmds='.sl'
scripts/libtool.m4:    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
scripts/libtool.m4:    soname_spec='${libname}${release}${shared_ext}$major'
scripts/libtool.m4:    shrext_cmds='.sl'
scripts/libtool.m4:    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
scripts/libtool.m4:    soname_spec='${libname}${release}${shared_ext}$major'
scripts/libtool.m4:interix[[3-9]]*)
scripts/libtool.m4:  version_type=linux # correct to gnu/linux during the next big refactor
scripts/libtool.m4:  need_lib_prefix=no
scripts/libtool.m4:  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major ${libname}${shared_ext}'
scripts/libtool.m4:  soname_spec='${libname}${release}${shared_ext}$major'
scripts/libtool.m4:  dynamic_linker='Interix 3.x ld.so.1 (PE, like ELF)'
scripts/libtool.m4:irix5* | irix6* | nonstopux*)
scripts/libtool.m4:    nonstopux*) version_type=nonstopux ;;
scripts/libtool.m4:		version_type=linux # correct to gnu/linux during the next big refactor
scripts/libtool.m4:		version_type=irix
scripts/libtool.m4:  need_lib_prefix=no
scripts/libtool.m4:  soname_spec='${libname}${release}${shared_ext}$major'
scripts/libtool.m4:  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major ${libname}${release}${shared_ext} $libname${shared_ext}'
scripts/libtool.m4:  irix5* | nonstopux*)
scripts/libtool.m4:# No shared lib support for Linux oldld, aout, or coff.
scripts/libtool.m4:linux*oldld* | linux*aout* | linux*coff*)
scripts/libtool.m4:linux* | k*bsd*-gnu | kopensolaris*-gnu)
scripts/libtool.m4:  version_type=linux # correct to gnu/linux during the next big refactor
scripts/libtool.m4:  need_lib_prefix=no
scripts/libtool.m4:  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
scripts/libtool.m4:  soname_spec='${libname}${release}${shared_ext}$major'
scripts/libtool.m4:      [AS_IF([ ($OBJDUMP -p conftest$ac_exeext) 2>/dev/null | grep "RUNPATH.*$libdir" >/dev/null],
scripts/libtool.m4:    lt_ld_extra=`awk '/^include / { system(sprintf("cd /etc; cat %s 2>/dev/null", \[$]2)); skip = 1; } { if (!skip) print \[$]0; skip = 0; }' < /etc/ld.so.conf | $SED -e 's/#.*//;/^[	 ]*hwcap[	 ]/d;s/[:,	]/ /g;s/=[^=]*$//;s/=[^= ]* / /g;s/"//g;/^$/d' | tr '\n' ' '`
scripts/libtool.m4:    sys_lib_dlsearch_path_spec="/lib /usr/lib $lt_ld_extra"
scripts/libtool.m4:  # powerpc, because MkLinux only supported shared libraries with the
scripts/libtool.m4:  # most powerpc-linux boxes support dynamic linking these days and
scripts/libtool.m4:  # assume the GNU/Linux dynamic linker is in use.
scripts/libtool.m4:  dynamic_linker='GNU/Linux ld.so'
scripts/libtool.m4:  need_lib_prefix=no
scripts/libtool.m4:    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${shared_ext}$versuffix'
scripts/libtool.m4:    library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major ${libname}${shared_ext}'
scripts/libtool.m4:    soname_spec='${libname}${release}${shared_ext}$major'
scripts/libtool.m4:  version_type=linux # correct to gnu/linux during the next big refactor
scripts/libtool.m4:  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
scripts/libtool.m4:*nto* | *qnx*)
scripts/libtool.m4:  version_type=qnx
scripts/libtool.m4:  need_lib_prefix=no
scripts/libtool.m4:  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
scripts/libtool.m4:  soname_spec='${libname}${release}${shared_ext}$major'
scripts/libtool.m4:  dynamic_linker='ldqnx.so'
scripts/libtool.m4:  need_lib_prefix=no
scripts/libtool.m4:  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${shared_ext}$versuffix'
scripts/libtool.m4:  shrext_cmds=".dll"
scripts/libtool.m4:  need_lib_prefix=no
scripts/libtool.m4:  library_names_spec='$libname${shared_ext} $libname.a'
scripts/libtool.m4:  dynamic_linker='OS/2 ld.exe'
scripts/libtool.m4:  need_lib_prefix=no
scripts/libtool.m4:  soname_spec='${libname}${release}${shared_ext}$major'
scripts/libtool.m4:  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
scripts/libtool.m4:  version_type=linux # correct to gnu/linux during the next big refactor
scripts/libtool.m4:  need_lib_prefix=no
scripts/libtool.m4:  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
scripts/libtool.m4:  soname_spec='${libname}${release}${shared_ext}$major'
scripts/libtool.m4:  # ldd complains unless libraries are executable
scripts/libtool.m4:  postinstall_cmds='chmod +x $lib'
scripts/libtool.m4:  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${shared_ext}$versuffix'
scripts/libtool.m4:    need_lib_prefix=no
scripts/libtool.m4:  version_type=linux # correct to gnu/linux during the next big refactor
scripts/libtool.m4:  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
scripts/libtool.m4:  soname_spec='${libname}${release}${shared_ext}$major'
scripts/libtool.m4:      need_lib_prefix=no
scripts/libtool.m4:      need_lib_prefix=no
scripts/libtool.m4:      need_lib_prefix=no
scripts/libtool.m4:    version_type=linux # correct to gnu/linux during the next big refactor
scripts/libtool.m4:    library_names_spec='$libname${shared_ext}.$versuffix $libname${shared_ext}.$major $libname${shared_ext}'
scripts/libtool.m4:    soname_spec='$libname${shared_ext}.$major'
scripts/libtool.m4:sysv5* | sco3.2v5* | sco5v6* | unixware* | OpenUNIX* | sysv4*uw2*)
scripts/libtool.m4:  need_lib_prefix=no
scripts/libtool.m4:  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext} $libname${shared_ext}'
scripts/libtool.m4:  soname_spec='${libname}${release}${shared_ext}$major'
scripts/libtool.m4:  # TPF is a cross-target only.  Preferred cross-host = GNU/Linux.
scripts/libtool.m4:  version_type=linux # correct to gnu/linux during the next big refactor
scripts/libtool.m4:  need_lib_prefix=no
scripts/libtool.m4:  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
scripts/libtool.m4:  version_type=linux # correct to gnu/linux during the next big refactor
scripts/libtool.m4:  library_names_spec='${libname}${release}${shared_ext}$versuffix ${libname}${release}${shared_ext}$major $libname${shared_ext}'
scripts/libtool.m4:  soname_spec='${libname}${release}${shared_ext}$major'
scripts/libtool.m4:_LT_DECL([], [need_lib_prefix], [0],
scripts/libtool.m4:    [Do we need the "lib" prefix for modules?])
scripts/libtool.m4:_LT_DECL([], [libname_spec], [1], [Format of library name prefix])
scripts/libtool.m4:    [[As "finish_cmds", except a single script fragment to be evaled but
scripts/libtool.m4:dnl POSIX.2 word splitting is done only on the output of word expansions,
scripts/libtool.m4:	  file_magic_regex=`expr "$deplibs_check_method" : "file_magic \(.*\)"`
scripts/libtool.m4:	    $EGREP "$file_magic_regex" > /dev/null; then
scripts/libtool.m4:	 [Used to examine libraries when file_magic_cmd begins with "file"])dnl
scripts/libtool.m4:[_LT_PATH_TOOL_PREFIX(${ac_tool_prefix}file, /usr/bin$PATH_SEPARATOR$PATH)
scripts/libtool.m4:  if test -n "$ac_tool_prefix"; then
scripts/libtool.m4:    if test -f "$ac_dir/$ac_prog" || test -f "$ac_dir/$ac_prog$ac_exeext"; then
scripts/libtool.m4:# 'file_magic [[regex]]' -- check by looking for files in library path
scripts/libtool.m4:# which responds to the $file_magic_cmd with a given extended regex.
scripts/libtool.m4:aix[[4-9]]*)
scripts/libtool.m4:  lt_cv_deplibs_check_method='file_magic ^x86 archive import|^x86 DLL'
scripts/libtool.m4:  # unless we find 'file', for example because we are cross-compiling.
scripts/libtool.m4:    lt_cv_deplibs_check_method='file_magic ^x86 archive import|^x86 DLL'
scripts/libtool.m4:    lt_cv_deplibs_check_method='file_magic file format (pei*-i386(.*architecture: i386)?|pe-arm-wince|pe-x86-64)'
scripts/libtool.m4:hpux10.20* | hpux11*)
scripts/libtool.m4:    lt_cv_file_magic_test_file=/usr/lib/hpux32/libc.so
scripts/libtool.m4:interix[[3-9]]*)
scripts/libtool.m4:  # PIC code is broken on Interix 3.x, that's why |\.a not |_pic\.a here
scripts/libtool.m4:irix5* | irix6* | nonstopux*)
scripts/libtool.m4:linux* | k*bsd*-gnu | kopensolaris*-gnu)
scripts/libtool.m4:  lt_cv_deplibs_check_method='file_magic ELF [[0-9]][[0-9]]*-bit [[ML]]SB (executable|dynamic lib)'
scripts/libtool.m4:*nto* | *qnx*)
scripts/libtool.m4:sysv5* | sco3.2v5* | sco5v6* | unixware* | OpenUNIX* | sysv4*uw2*)
scripts/libtool.m4:      file_magic_glob=`echo aAbBcCdDeEfFgGhHiIjJkKlLmMnNoOpPqQrRsStTuUvVwWxXyYzZ | $SED -e "s/\(..\)/s\/[[\1]]\/[[\1]]\/g;/g"`
scripts/libtool.m4:  lt_nm_to_check="${ac_tool_prefix}nm"
scripts/libtool.m4:  if test -n "$ac_tool_prefix" && test "$build" = "$host"; then
scripts/libtool.m4:      if test -f "$tmp_nm" || test -f "$tmp_nm$ac_exeext" ; then
scripts/libtool.m4:  echo "int some_variable = 0;" > conftest.$ac_ext
scripts/libtool.m4:  (eval echo "\"\$as_me:$LINENO: $NM \\\"conftest.$ac_objext\\\"\"" >&AS_MESSAGE_LOG_FD)
scripts/libtool.m4:  (eval "$NM \"conftest.$ac_objext\"" 2>conftest.err > conftest.out)
scripts/libtool.m4:  if $GREP 'External.*some_variable' conftest.out > /dev/null; then
scripts/libtool.m4:if test "x$lt_cv_path_mainfest_tool" != xyes; then
scripts/libtool.m4:  _LT_COMPILER_OPTION([if $compiler supports -fno-rtti -fno-exceptions],
scripts/libtool.m4:    lt_cv_prog_compiler_rtti_exceptions,
scripts/libtool.m4:    [-fno-rtti -fno-exceptions], [],
scripts/libtool.m4:    [_LT_TAGVAR(lt_prog_compiler_no_builtin_flag, $1)="$_LT_TAGVAR(lt_prog_compiler_no_builtin_flag, $1) -fno-rtti -fno-exceptions"])
scripts/libtool.m4:# [They come from Ultrix.  What could be older than Ultrix?!! ;)]
scripts/libtool.m4:# Regexp to match symbols that can be accessed directly from C.
scripts/libtool.m4:aix*)
scripts/libtool.m4:hpux*)
scripts/libtool.m4:irix* | nonstopux*)
scripts/libtool.m4:sysv5* | sco5v6* | unixware* | OpenUNIX*)
scripts/libtool.m4:# Transform an extracted symbol line into a proper C declaration.
scripts/libtool.m4:lt_cv_sys_global_symbol_to_cdecl="sed -n -e 's/^T .* \(.*\)$/extern int \1();/p' -e 's/^$symcode* .* \(.*\)$/extern char \1;/p'"
scripts/libtool.m4:# Transform an extracted symbol line into symbol name and symbol address
scripts/libtool.m4:lt_cv_sys_global_symbol_to_c_name_address_lib_prefix="sed -n -e 's/^: \([[^ ]]*\)[[ ]]*$/  {\\\"\1\\\", (void *) 0},/p' -e 's/^$symcode* \([[^ ]]*\) \(lib[[^ ]]*\)$/  {\"\2\", (void *) \&\2},/p' -e 's/^$symcode* \([[^ ]]*\) \([[^ ]]*\)$/  {\"lib\2\", (void *) \&\2},/p'"
scripts/libtool.m4:  opt_cr=`$ECHO 'x\{0,1\}' | tr x '\015'` # option cr in regexp
scripts/libtool.m4:# Try without a prefix underscore, then with it.
scripts/libtool.m4:for ac_symprfx in "" "_"; do
scripts/libtool.m4:  # Transform symcode, sympat, and symprfx into a raw symbol and a C symbol.
scripts/libtool.m4:  symxfrm="\\1 $ac_symprfx\\2 \\2"
scripts/libtool.m4:"     \$ 0!~/External *\|/{next};"\
scripts/libtool.m4:"     / 0+ UNDEF /{next}; / UNDEF \([^|]\)*()/{next};"\
scripts/libtool.m4:"     {if(hide[section]) next};"\
scripts/libtool.m4:"     s[1]~/^[@?]/{print s[1], s[1]; next};"\
scripts/libtool.m4:"     s[1]~prfx {split(s[1],t,\"@\"); print t[1], substr(t[1],length(prfx))}"\
scripts/libtool.m4:"     ' prfx=^$ac_symprfx]"
scripts/libtool.m4:    lt_cv_sys_global_symbol_pipe="sed -n -e 's/^.*[[	 ]]\($symcode$symcode*\)[[	 ]][[	 ]]*$ac_symprfx$sympat$opt_cr$/$symxfrm/p'"
scripts/libtool.m4:  cat > conftest.$ac_ext <<_LT_EOF
scripts/libtool.m4:extern "C" {
scripts/libtool.m4:    if AC_TRY_EVAL(NM conftest.$ac_objext \| "$lt_cv_sys_global_symbol_pipe" \> $nlist) && test -s "$nlist"; then
scripts/libtool.m4:	  cat <<_LT_EOF > conftest.$ac_ext
scripts/libtool.m4:extern "C" {
scripts/libtool.m4:	  eval "$lt_cv_sys_global_symbol_to_cdecl"' < "$nlist" | $GREP -v main >> conftest.$ac_ext'
scripts/libtool.m4:	  cat <<_LT_EOF >> conftest.$ac_ext
scripts/libtool.m4:	  $SED "s/^$symcode$symcode* \(.*\) \(.*\)$/  {\"\2\", (void *) \&\2},/" < "$nlist" | $GREP -v main >> conftest.$ac_ext
scripts/libtool.m4:	  cat <<\_LT_EOF >> conftest.$ac_ext
scripts/libtool.m4:	  mv conftest.$ac_objext conftstm.$ac_objext
scripts/libtool.m4:	  LIBS="conftstm.$ac_objext"
scripts/libtool.m4:	  if AC_TRY_EVAL(ac_link) && test -s conftest${ac_exeext}; then
scripts/libtool.m4:    cat conftest.$ac_ext >&5
scripts/libtool.m4:_LT_DECL([global_symbol_to_c_name_address_lib_prefix],
scripts/libtool.m4:    [lt_cv_sys_global_symbol_to_c_name_address_lib_prefix], [1],
scripts/libtool.m4:    [Transform the output of nm in a C name address pair when lib prefix is needed])
scripts/libtool.m4:    aix*)
scripts/libtool.m4:    beos* | irix5* | irix6* | nonstopux* | osf3* | osf4* | osf5*)
scripts/libtool.m4:      # built for inclusion in a dll (and should export symbols for example).
scripts/libtool.m4:      # The "-static" flag exists, but is broken.
scripts/libtool.m4:    interix[[3-9]]*)
scripts/libtool.m4:      # Interix 3.x gcc -fpic/-fPIC options generate broken code.
scripts/libtool.m4:    hpux*)
scripts/libtool.m4:    *qnx* | *nto*)
scripts/libtool.m4:      aix[[4-9]]*)
scripts/libtool.m4:	  _LT_TAGVAR(lt_prog_compiler_static, $1)='-bnso -bI:/lib/syscalls.exp'
scripts/libtool.m4:	cxch68*)
scripts/libtool.m4:	  # _LT_TAGVAR(lt_prog_compiler_static, $1)="--no_auto_instantiation -u __main -u __premain -u _abort -r $COOL_DIR/lib/libOrb.a $MVME_DIR/lib/CC/libC.a $MVME_DIR/lib/classix/libcx.s.a"
scripts/libtool.m4:	# built for inclusion in a dll (and should export symbols for example).
scripts/libtool.m4:      dgux*)
scripts/libtool.m4:	  ghcx*)
scripts/libtool.m4:      hpux9* | hpux10* | hpux11*)
scripts/libtool.m4:      interix*)
scripts/libtool.m4:      irix5* | irix6* | nonstopux*)
scripts/libtool.m4:      linux* | k*bsd*-gnu | kopensolaris*-gnu)
scripts/libtool.m4:	    # old Intel C++ for x86_64 which still supported -KPIC.
scripts/libtool.m4:	  cxx*)
scripts/libtool.m4:	    # Linux and Compaq Tru64 Unix objects are PIC.
scripts/libtool.m4:	  xlc* | xlC* | bgxl[[cC]]* | mpixl[[cC]]*)
scripts/libtool.m4:      lynxos*)
scripts/libtool.m4:	  cxx*)
scripts/libtool.m4:	    _LT_TAGVAR(lt_prog_compiler_pic, $1)='-W c,exportall'
scripts/libtool.m4:      *qnx* | *nto*)
scripts/libtool.m4:	  cxx*)
scripts/libtool.m4:	    # Linux and Compaq Tru64 Unix objects are PIC.
scripts/libtool.m4:	    # Sun C++ 4.2, 5.x and Centerline C++
scripts/libtool.m4:	  gcx*)
scripts/libtool.m4:	    # Sun C++ 4.x
scripts/libtool.m4:      sysv5* | unixware* | sco3.2v5* | sco5v6* | OpenUNIX*)
scripts/libtool.m4:      vxworks*)
scripts/libtool.m4:      aix*)
scripts/libtool.m4:    beos* | irix5* | irix6* | nonstopux* | osf3* | osf4* | osf5*)
scripts/libtool.m4:      # built for inclusion in a dll (and should export symbols for example).
scripts/libtool.m4:      # The "-static" flag exists, but is broken.
scripts/libtool.m4:    hpux*)
scripts/libtool.m4:    interix[[3-9]]*)
scripts/libtool.m4:      # Interix 3.x gcc -fpic/-fPIC options generate broken code.
scripts/libtool.m4:    *nto* | *qnx*)
scripts/libtool.m4:    aix*)
scripts/libtool.m4:	_LT_TAGVAR(lt_prog_compiler_static, $1)='-bnso -bI:/lib/syscalls.exp'
scripts/libtool.m4:      # built for inclusion in a dll (and should export symbols for example).
scripts/libtool.m4:    hpux9* | hpux10* | hpux11*)
scripts/libtool.m4:    irix5* | irix6* | nonstopux*)
scripts/libtool.m4:    linux* | k*bsd*-gnu | kopensolaris*-gnu)
scripts/libtool.m4:      # old Intel for x86_64 which still supported -KPIC.
scripts/libtool.m4:      xl* | bgxl* | bgf* | mpixl*)
scripts/libtool.m4:    *nto* | *qnx*)
scripts/libtool.m4:    sysv5* | unixware* | sco3.2v5* | sco5v6* | OpenUNIX*)
scripts/libtool.m4:  _LT_TAGVAR(export_symbols_cmds, $1)='$NM $libobjs $convenience | $global_symbol_pipe | $SED '\''s/.* //'\'' | sort | uniq > $export_symbols'
scripts/libtool.m4:  _LT_TAGVAR(exclude_expsyms, $1)=['_GLOBAL_OFFSET_TABLE_|_GLOBAL__F[ID]_.*']
scripts/libtool.m4:  aix[[4-9]]*)
scripts/libtool.m4:      _LT_TAGVAR(export_symbols_cmds, $1)='$NM -Bpg $libobjs $convenience | awk '\''{ if (((\$ 2 == "T") || (\$ 2 == "D") || (\$ 2 == "B") || (\$ 2 == "W")) && ([substr](\$ 3,1,1) != ".")) { print \$ 3 } }'\'' | sort -u > $export_symbols'
scripts/libtool.m4:      _LT_TAGVAR(export_symbols_cmds, $1)='$NM -BCpg $libobjs $convenience | awk '\''{ if (((\$ 2 == "T") || (\$ 2 == "D") || (\$ 2 == "B")) && ([substr](\$ 3,1,1) != ".")) { print \$ 3 } }'\'' | sort -u > $export_symbols'
scripts/libtool.m4:    _LT_TAGVAR(export_symbols_cmds, $1)="$ltdll_cmds"
scripts/libtool.m4:      _LT_TAGVAR(exclude_expsyms, $1)='_NULL_IMPORT_DESCRIPTOR|_IMPORT_DESCRIPTOR_.*'
scripts/libtool.m4:      _LT_TAGVAR(export_symbols_cmds, $1)='$NM $libobjs $convenience | $global_symbol_pipe | $SED -e '\''/^[[BCDGRS]][[ ]]/s/.*[[ ]]\([[^ ]]*\)/\1 DATA/;s/^.*[[ ]]__nm__\([[^ ]]*\)[[ ]][[^ ]]*/\1 DATA/;/^I[[ ]]/d;/^[[AITW]][[ ]]/s/.* //'\'' | sort | uniq > $export_symbols'
scripts/libtool.m4:      _LT_TAGVAR(exclude_expsyms, $1)=['[_]+GLOBAL_OFFSET_TABLE_|[_]+GLOBAL__[FID]_.*|[_]+head_[A-Za-z0-9_]+_dll|[A-Za-z0-9_]+_dll_iname']
scripts/libtool.m4:    _LT_TAGVAR(export_symbols_cmds, $1)='$NM $libobjs $convenience | $global_symbol_pipe | $SED '\''s/.* //'\'' | sort | uniq > $export_symbols'
scripts/libtool.m4:  _LT_TAGVAR(always_export_symbols, $1)=no
scripts/libtool.m4:  _LT_TAGVAR(archive_expsym_cmds, $1)=
scripts/libtool.m4:  _LT_TAGVAR(export_dynamic_flag_spec, $1)=
scripts/libtool.m4:  _LT_TAGVAR(export_symbols_cmds, $1)='$NM $libobjs $convenience | $global_symbol_pipe | $SED '\''s/.* //'\'' | sort | uniq > $export_symbols'
scripts/libtool.m4:  _LT_TAGVAR(module_expsym_cmds, $1)=
scripts/libtool.m4:  _LT_TAGVAR(old_archive_from_expsyms_cmds, $1)=
scripts/libtool.m4:  # include_expsyms should be a list of space-separated symbols to be *always*
scripts/libtool.m4:  _LT_TAGVAR(include_expsyms, $1)=
scripts/libtool.m4:  # exclude_expsyms can be an extended regexp of symbols to exclude
scripts/libtool.m4:  # end of line.  Example: `a|bc|.*d.*' will exclude the symbols `a' and `bc',
scripts/libtool.m4:  _LT_TAGVAR(exclude_expsyms, $1)=['_GLOBAL_OFFSET_TABLE_|_GLOBAL__F[ID]_.*']
scripts/libtool.m4:  # the symbol is explicitly referenced.  Since portable code cannot
scripts/libtool.m4:  # Exclude shared library initialization/finalization symbols.
scripts/libtool.m4:dnl Note also adjust exclude_expsyms for C++ above.
scripts/libtool.m4:  extract_expsyms_cmds=
scripts/libtool.m4:  interix*)
scripts/libtool.m4:      aix*)
scripts/libtool.m4:    _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}--export-dynamic'
scripts/libtool.m4:    aix[[3-9]]*)
scripts/libtool.m4:            _LT_TAGVAR(archive_expsym_cmds, $1)=''
scripts/libtool.m4:            _LT_TAGVAR(archive_cmds, $1)='$RM $output_objdir/a2ixlibrary.data~$ECHO "#define NAME $libname" > $output_objdir/a2ixlibrary.data~$ECHO "#define LIBRARY_ID 1" >> $output_objdir/a2ixlibrary.data~$ECHO "#define VERSION $major" >> $output_objdir/a2ixlibrary.data~$ECHO "#define REVISION $revision" >> $output_objdir/a2ixlibrary.data~$AR $AR_FLAGS $lib $libobjs~$RANLIB $lib~(cd $output_objdir && a2ixlibrary -32)'
scripts/libtool.m4:      _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}--export-all-symbols'
scripts/libtool.m4:      _LT_TAGVAR(always_export_symbols, $1)=no
scripts/libtool.m4:      _LT_TAGVAR(export_symbols_cmds, $1)='$NM $libobjs $convenience | $global_symbol_pipe | $SED -e '\''/^[[BCDGRS]][[ ]]/s/.*[[ ]]\([[^ ]]*\)/\1 DATA/;s/^.*[[ ]]__nm__\([[^ ]]*\)[[ ]][[^ ]]*/\1 DATA/;/^I[[ ]]/d;/^[[AITW]][[ ]]/s/.* //'\'' | sort | uniq > $export_symbols'
scripts/libtool.m4:      _LT_TAGVAR(exclude_expsyms, $1)=['[_]+GLOBAL_OFFSET_TABLE_|[_]+GLOBAL__[FID]_.*|[_]+head_[A-Za-z0-9_]+_dll|[A-Za-z0-9_]+_dll_iname']
scripts/libtool.m4:	# If the export-symbols file already is a .def file (1st line
scripts/libtool.m4:	_LT_TAGVAR(archive_expsym_cmds, $1)='if test "x`$SED 1q $export_symbols`" = xEXPORTS; then
scripts/libtool.m4:	  cp $export_symbols $output_objdir/$soname.def;
scripts/libtool.m4:	  cat $export_symbols >> $output_objdir/$soname.def;
scripts/libtool.m4:    interix[[3-9]]*)
scripts/libtool.m4:      _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-E'
scripts/libtool.m4:      # Hack: On Interix 3.x, we cannot compile PIC because of a broken gcc.
scripts/libtool.m4:      # Instead, shared libraries are loaded at an image base (0x10000000 by
scripts/libtool.m4:      # 256 KiB-aligned image base between 0x50000000 and 0x6FFC0000 at link
scripts/libtool.m4:      # time.  Moving up from 0x10000000 also allows more sbrk(2) space.
scripts/libtool.m4:      _LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-h,$soname ${wl}--image-base,`expr ${RANDOM-$$} % 4096 / 2 \* 262144 + 1342177280` -o $lib'
scripts/libtool.m4:      _LT_TAGVAR(archive_expsym_cmds, $1)='sed "s,^,_," $export_symbols >$output_objdir/$soname.expsym~$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-h,$soname ${wl}--retain-symbols-file,$output_objdir/$soname.expsym ${wl}--image-base,`expr ${RANDOM-$$} % 4096 / 2 \* 262144 + 1342177280` -o $lib'
scripts/libtool.m4:    gnu* | linux* | tpf* | k*bsd*-gnu | kopensolaris*-gnu)
scripts/libtool.m4:      if test "$host_os" = linux-dietlibc; then
scripts/libtool.m4:	  diet\ *) tmp_diet=yes;;	# linux-dietlibc with static linking (!diet-dyn)
scripts/libtool.m4:	xl[[cC]]* | bgxl[[cC]]* | mpixl[[cC]]*) # IBM XL C 8.0 on PPC (deal with xlf below)
scripts/libtool.m4:        if test "x$supports_anon_versioning" = xyes; then
scripts/libtool.m4:          _LT_TAGVAR(archive_expsym_cmds, $1)='echo "{ global:" > $output_objdir/$libname.ver~
scripts/libtool.m4:	    cat $export_symbols | sed -e "s/\(.*\)/\1;/" >> $output_objdir/$libname.ver~
scripts/libtool.m4:	xlf* | bgf* | bgxlf* | mpixlf*)
scripts/libtool.m4:	  if test "x$supports_anon_versioning" = xyes; then
scripts/libtool.m4:	    _LT_TAGVAR(archive_expsym_cmds, $1)='echo "{ global:" > $output_objdir/$libname.ver~
scripts/libtool.m4:	      cat $export_symbols | sed -e "s/\(.*\)/\1;/" >> $output_objdir/$libname.ver~
scripts/libtool.m4:	_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'
scripts/libtool.m4:	_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'
scripts/libtool.m4:    sysv5* | sco3.2v5* | sco5v6* | unixware* | OpenUNIX*)
scripts/libtool.m4:	  # use absolute paths for naming shared libraries, and exclude the
scripts/libtool.m4:	  # DT_RUNPATH tag from executables and libraries.  But doing so
scripts/libtool.m4:	    _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'
scripts/libtool.m4:      _LT_TAGVAR(archive_cmds, $1)='$LD -assert pure-text -Bshareable -o $lib $libobjs $deplibs $linker_flags'
scripts/libtool.m4:	_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'
scripts/libtool.m4:      _LT_TAGVAR(export_dynamic_flag_spec, $1)=
scripts/libtool.m4:    aix3*)
scripts/libtool.m4:      _LT_TAGVAR(always_export_symbols, $1)=yes
scripts/libtool.m4:      _LT_TAGVAR(archive_expsym_cmds, $1)='$LD -o $output_objdir/$soname $libobjs $deplibs $linker_flags -bE:$export_symbols -T512 -H512 -bM:SRE~$AR $AR_FLAGS $lib $output_objdir/$soname'
scripts/libtool.m4:    aix[[4-9]]*)
scripts/libtool.m4:	aix_use_runtimelinking=no
scripts/libtool.m4:	exp_sym_flag='-Bexport'
scripts/libtool.m4:	  _LT_TAGVAR(export_symbols_cmds, $1)='$NM -Bpg $libobjs $convenience | awk '\''{ if (((\$ 2 == "T") || (\$ 2 == "D") || (\$ 2 == "B") || (\$ 2 == "W")) && ([substr](\$ 3,1,1) != ".")) { print \$ 3 } }'\'' | sort -u > $export_symbols'
scripts/libtool.m4:	  _LT_TAGVAR(export_symbols_cmds, $1)='$NM -BCpg $libobjs $convenience | awk '\''{ if (((\$ 2 == "T") || (\$ 2 == "D") || (\$ 2 == "B")) && ([substr](\$ 3,1,1) != ".")) { print \$ 3 } }'\'' | sort -u > $export_symbols'
scripts/libtool.m4:	aix_use_runtimelinking=no
scripts/libtool.m4:	case $host_os in aix4.[[23]]|aix4.[[23]].*|aix[[5-9]]*)
scripts/libtool.m4:	    aix_use_runtimelinking=yes
scripts/libtool.m4:	exp_sym_flag='-bexport'
scripts/libtool.m4:      # When large executables or shared objects are built, AIX ld can
scripts/libtool.m4:      # enough to fix the problem, add -Wl,-bbigtoc to LDFLAGS.
scripts/libtool.m4:	case $host_os in aix4.[[012]]|aix4.[[012]].*)
scripts/libtool.m4:	if test "$aix_use_runtimelinking" = yes; then
scripts/libtool.m4:	  if test "$aix_use_runtimelinking" = yes; then
scripts/libtool.m4:      _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-bexpall'
scripts/libtool.m4:      # It seems that -bexpall does not export symbols beginning with
scripts/libtool.m4:      # underscore (_), so it is better to generate a list of symbols to export.
scripts/libtool.m4:      _LT_TAGVAR(always_export_symbols, $1)=yes
scripts/libtool.m4:      if test "$aix_use_runtimelinking" = yes; then
scripts/libtool.m4:        # empty executable.
scripts/libtool.m4:        _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-blibpath:$libdir:'"$aix_libpath"
scripts/libtool.m4:        _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -o $output_objdir/$soname $libobjs $deplibs '"\${wl}$no_entry_flag"' $compiler_flags `if test "x${allow_undefined_flag}" != "x"; then func_echo_all "${wl}${allow_undefined_flag}"; else :; fi` '"\${wl}$exp_sym_flag:\$export_symbols $shared_flag"
scripts/libtool.m4:	  _LT_TAGVAR(archive_expsym_cmds, $1)="\$CC $shared_flag"' -o $output_objdir/$soname $libobjs $deplibs '"\${wl}$no_entry_flag"' $compiler_flags ${wl}${allow_undefined_flag} '"\${wl}$exp_sym_flag:\$export_symbols"
scripts/libtool.m4:	 # empty executable.
scripts/libtool.m4:	 _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-blibpath:$libdir:'"$aix_libpath"
scripts/libtool.m4:	    # Exported symbols can be pulled into shared objects from archives
scripts/libtool.m4:	  _LT_TAGVAR(archive_expsym_cmds, $1)="\$CC $shared_flag"' -o $output_objdir/$soname $libobjs $deplibs ${wl}-bnoentry $compiler_flags ${wl}-bE:$export_symbols${allow_undefined_flag}~$AR $AR_FLAGS $output_objdir/$libname$release.a $output_objdir/$soname'
scripts/libtool.m4:            _LT_TAGVAR(archive_expsym_cmds, $1)=''
scripts/libtool.m4:            _LT_TAGVAR(archive_cmds, $1)='$RM $output_objdir/a2ixlibrary.data~$ECHO "#define NAME $libname" > $output_objdir/a2ixlibrary.data~$ECHO "#define LIBRARY_ID 1" >> $output_objdir/a2ixlibrary.data~$ECHO "#define VERSION $major" >> $output_objdir/a2ixlibrary.data~$ECHO "#define REVISION $revision" >> $output_objdir/a2ixlibrary.data~$AR $AR_FLAGS $lib $libobjs~$RANLIB $lib~(cd $output_objdir && a2ixlibrary -32)'
scripts/libtool.m4:      _LT_TAGVAR(export_dynamic_flag_spec, $1)=-rdynamic
scripts/libtool.m4:	_LT_TAGVAR(always_export_symbols, $1)=yes
scripts/libtool.m4:	libext=lib
scripts/libtool.m4:	shrext_cmds=".dll"
scripts/libtool.m4:	_LT_TAGVAR(archive_expsym_cmds, $1)='if test "x`$SED 1q $export_symbols`" = xEXPORTS; then
scripts/libtool.m4:	    sed -n -e 's/\\\\\\\(.*\\\\\\\)/-link\\\ -EXPORT:\\\\\\\1/' -e '1\\\!p' < $export_symbols > $output_objdir/$soname.exp;
scripts/libtool.m4:	    sed -e 's/\\\\\\\(.*\\\\\\\)/-link\\\ -EXPORT:\\\\\\\1/' < $export_symbols > $output_objdir/$soname.exp;
scripts/libtool.m4:	  $CC -o $tool_output_objdir$soname $libobjs $compiler_flags $deplibs "@$tool_output_objdir$soname.exp" -Wl,-DLL,-IMPLIB:"$tool_output_objdir$libname.dll.lib"~
scripts/libtool.m4:	_LT_TAGVAR(exclude_expsyms, $1)='_NULL_IMPORT_DESCRIPTOR|_IMPORT_DESCRIPTOR_.*'
scripts/libtool.m4:	_LT_TAGVAR(export_symbols_cmds, $1)='$NM $libobjs $convenience | $global_symbol_pipe | $SED -e '\''/^[[BCDGRS]][[ ]]/s/.*[[ ]]\([[^ ]]*\)/\1,DATA/'\'' | $SED -e '\''/^[[AITW]][[ ]]/s/.*[[ ]]//'\'' | sort | uniq > $export_symbols'
scripts/libtool.m4:	    *.exe|*.EXE) ;;
scripts/libtool.m4:	      lt_outputfile="$lt_outputfile.exe"
scripts/libtool.m4:	      lt_tool_outputfile="$lt_tool_outputfile.exe"
scripts/libtool.m4:	    $MANIFEST_TOOL -manifest "$lt_tool_outputfile.manifest" -outputresource:"$lt_tool_outputfile" || exit 1;
scripts/libtool.m4:	libext=lib
scripts/libtool.m4:	shrext_cmds=".dll"
scripts/libtool.m4:    dgux*)
scripts/libtool.m4:    # support.  Future versions do this automatically, but an explicit c++rt0.o
scripts/libtool.m4:    # extra space).
scripts/libtool.m4:    hpux9*)
scripts/libtool.m4:      _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-E'
scripts/libtool.m4:    hpux10*)
scripts/libtool.m4:	_LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-E'
scripts/libtool.m4:    hpux11*)
scripts/libtool.m4:	  _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-E'
scripts/libtool.m4:    irix5* | irix6* | nonstopux*)
scripts/libtool.m4:	# Try to use the -exported_symbol ld option, if it does not
scripts/libtool.m4:	# work, assume that -exports_file does not work either and
scripts/libtool.m4:	# implicitly export all symbols.
scripts/libtool.m4:	AC_CACHE_CHECK([whether the $host_os linker accepts -exported_symbol],
scripts/libtool.m4:	  [lt_cv_irix_exported_symbol],
scripts/libtool.m4:	   LDFLAGS="$LDFLAGS -shared ${wl}-exported_symbol ${wl}foo ${wl}-update_registry ${wl}/dev/null"
scripts/libtool.m4:	      [lt_cv_irix_exported_symbol=yes],
scripts/libtool.m4:	      [lt_cv_irix_exported_symbol=no])
scripts/libtool.m4:	if test "$lt_cv_irix_exported_symbol" = yes; then
scripts/libtool.m4:          _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-soname ${wl}$soname `test -n "$verstring" && func_echo_all "${wl}-set_version ${wl}$verstring"` ${wl}-update_registry ${wl}${output_objdir}/so_locations ${wl}-exports_file ${wl}$export_symbols -o $lib'
scripts/libtool.m4:	_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $libobjs $deplibs $compiler_flags -soname $soname `test -n "$verstring" && func_echo_all "-set_version $verstring"` -update_registry ${output_objdir}/so_locations -exports_file $export_symbols -o $lib'
scripts/libtool.m4:    *nto* | *qnx*)
scripts/libtool.m4:      if test -f /usr/libexec/ld.so; then
scripts/libtool.m4:	  _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $pic_flag -o $lib $libobjs $deplibs $compiler_flags ${wl}-retain-symbols-file,$export_symbols'
scripts/libtool.m4:	  _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-E'
scripts/libtool.m4:      _LT_TAGVAR(archive_cmds, $1)='$ECHO "LIBRARY $libname INITINSTANCE" > $output_objdir/$libname.def~$ECHO "DESCRIPTION \"$libname\"" >> $output_objdir/$libname.def~echo DATA >> $output_objdir/$libname.def~echo " SINGLE NONSHARED" >> $output_objdir/$libname.def~echo EXPORTS >> $output_objdir/$libname.def~emxexp $libobjs >> $output_objdir/$libname.def~$CC -Zdll -Zcrtdll -o $lib $libobjs $deplibs $compiler_flags $output_objdir/$libname.def'
scripts/libtool.m4:      _LT_TAGVAR(old_archive_from_new_cmds, $1)='emximp -o $output_objdir/$libname.a $output_objdir/$libname.def'
scripts/libtool.m4:	_LT_TAGVAR(allow_undefined_flag, $1)=' ${wl}-expect_unresolved ${wl}\*'
scripts/libtool.m4:	_LT_TAGVAR(allow_undefined_flag, $1)=' -expect_unresolved \*'
scripts/libtool.m4:	_LT_TAGVAR(allow_undefined_flag, $1)=' ${wl}-expect_unresolved ${wl}\*'
scripts/libtool.m4:	_LT_TAGVAR(allow_undefined_flag, $1)=' -expect_unresolved \*'
scripts/libtool.m4:	_LT_TAGVAR(archive_expsym_cmds, $1)='for i in `cat $export_symbols`; do printf "%s %s\\n" -exported_symbol "\$i" >> $lib.exp; done; printf "%s\\n" "-hidden">> $lib.exp~
scripts/libtool.m4:	$CC -shared${allow_undefined_flag} ${wl}-input ${wl}$lib.exp $compiler_flags $libobjs $deplibs -soname $soname `test -n "$verstring" && $ECHO "-set_version $verstring"` -update_registry ${output_objdir}/so_locations -o $lib~$RM $lib.exp'
scripts/libtool.m4:	# Both c and cxx compiler support -rpath directly
scripts/libtool.m4:	_LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag ${wl}-z ${wl}text ${wl}-h ${wl}$soname -o $lib $libobjs $deplibs $compiler_flags'
scripts/libtool.m4:	_LT_TAGVAR(archive_expsym_cmds, $1)='echo "{ global:" > $lib.exp~cat $export_symbols | $SED -e "s/\(.*\)/\1;/" >> $lib.exp~echo "local: *; };" >> $lib.exp~
scripts/libtool.m4:	  $CC -shared $pic_flag ${wl}-z ${wl}text ${wl}-M ${wl}$lib.exp ${wl}-h ${wl}$soname -o $lib $libobjs $deplibs $compiler_flags~$RM $lib.exp'
scripts/libtool.m4:	  _LT_TAGVAR(archive_expsym_cmds, $1)='echo "{ global:" > $lib.exp~cat $export_symbols | $SED -e "s/\(.*\)/\1;/" >> $lib.exp~echo "local: *; };" >> $lib.exp~
scripts/libtool.m4:	  $LD -G${allow_undefined_flag} -M $lib.exp -h $soname -o $lib $libobjs $deplibs $linker_flags~$RM $lib.exp'
scripts/libtool.m4:	  _LT_TAGVAR(archive_expsym_cmds, $1)='echo "{ global:" > $lib.exp~cat $export_symbols | $SED -e "s/\(.*\)/\1;/" >> $lib.exp~echo "local: *; };" >> $lib.exp~
scripts/libtool.m4:	  $CC -G${allow_undefined_flag} -M $lib.exp -h $soname -o $lib $libobjs $deplibs $compiler_flags~$RM $lib.exp'
scripts/libtool.m4:	  _LT_TAGVAR(whole_archive_flag_spec, $1)='${wl}-z ${wl}allextract$convenience ${wl}-z ${wl}defaultextract'
scripts/libtool.m4:	  _LT_TAGVAR(whole_archive_flag_spec, $1)='-z allextract$convenience -z defaultextract'
scripts/libtool.m4:      if test "x$host_vendor" = xsequent; then
scripts/libtool.m4:	# Use $CC to link under sequent, because it throws in some extra .o
scripts/libtool.m4:	_LT_TAGVAR(archive_cmds, $1)='$LD -assert pure-text -Bstatic -o $lib $libobjs $deplibs $linker_flags'
scripts/libtool.m4:      _LT_TAGVAR(export_dynamic_flag_spec, $1)='-Bexport'
scripts/libtool.m4:    sysv4*uw2* | sysv5OpenUNIX* | sysv5UnixWare7.[[01]].[[10]]* | unixware7* | sco3.2v5.0.[[024]]*)
scripts/libtool.m4:      _LT_TAGVAR(no_undefined_flag, $1)='${wl}-z,text'
scripts/libtool.m4:	_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
scripts/libtool.m4:	_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -G ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
scripts/libtool.m4:      # ever link correctly.  If we're not using GNU ld we use -z text
scripts/libtool.m4:      _LT_TAGVAR(no_undefined_flag, $1)='${wl}-z,text'
scripts/libtool.m4:      _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-Bexport'
scripts/libtool.m4:	_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
scripts/libtool.m4:	_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -G ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
scripts/libtool.m4:    if test x$host_vendor = xsni; then
scripts/libtool.m4:	_LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-Blargedynsym'
scripts/libtool.m4:_LT_DECL([], [libext], [0], [Old archive suffix (normally "a")])dnl
scripts/libtool.m4:_LT_DECL([], [shrext_cmds], [1], [Shared library suffix (normally ".so")])dnl
scripts/libtool.m4:_LT_DECL([], [extract_expsyms_cmds], [2],
scripts/libtool.m4:    [The commands to extract the exported symbol list from a shared archive])
scripts/libtool.m4:# Do we need to explicitly link libc?
scripts/libtool.m4:case "x$_LT_TAGVAR(archive_cmds_need_lc, $1)" in
scripts/libtool.m4:x|xyes)
scripts/libtool.m4:      AC_CACHE_CHECK([whether -lc should be explicitly linked in],
scripts/libtool.m4:	echo "$lt_simple_compile_test_code" > conftest.$ac_ext
scripts/libtool.m4:	  libobjs=conftest.$ac_objext
scripts/libtool.m4:_LT_TAGDECL([], [export_dynamic_flag_spec], [1],
scripts/libtool.m4:    [Compiler flag to allow reflexive dlopens])
scripts/libtool.m4:_LT_TAGDECL([], [old_archive_from_expsyms_cmds], [2],
scripts/libtool.m4:_LT_TAGDECL([], [archive_expsym_cmds], [2])
scripts/libtool.m4:_LT_TAGDECL([], [module_expsym_cmds], [2])
scripts/libtool.m4:    This must work even if $libdir does not exist])
scripts/libtool.m4:    [Set to "yes" if using DIR/libNAME${shared_ext} during linking hardcodes
scripts/libtool.m4:    [Set to "yes" if using DIR/libNAME${shared_ext} during linking hardcodes
scripts/libtool.m4:    into the library and all subsequent libraries and executables linked
scripts/libtool.m4:_LT_TAGDECL([], [always_export_symbols], [0],
scripts/libtool.m4:    [Set to "yes" if exported symbols are required])
scripts/libtool.m4:_LT_TAGDECL([], [export_symbols_cmds], [2],
scripts/libtool.m4:    [The commands to list exported symbols])
scripts/libtool.m4:_LT_TAGDECL([], [exclude_expsyms], [1],
scripts/libtool.m4:_LT_TAGDECL([], [include_expsyms], [1],
scripts/libtool.m4:    [Symbols that must always be exported])
scripts/libtool.m4:# Source file extension for C test sources.
scripts/libtool.m4:ac_ext=c
scripts/libtool.m4:# Object file extension for compiled C test sources.
scripts/libtool.m4:objext=o
scripts/libtool.m4:_LT_TAGVAR(objext, $1)=$objext
scripts/libtool.m4:## the running order or otherwise move them around unless you know exactly
scripts/libtool.m4:  aix3*)
scripts/libtool.m4:  aix[[4-9]]*)
scripts/libtool.m4:    if test "$host_cpu" != ia64 && test "$aix_use_runtimelinking" = no ; then
scripts/libtool.m4:_LT_TAGVAR(always_export_symbols, $1)=no
scripts/libtool.m4:_LT_TAGVAR(archive_expsym_cmds, $1)=
scripts/libtool.m4:_LT_TAGVAR(export_dynamic_flag_spec, $1)=
scripts/libtool.m4:_LT_TAGVAR(module_expsym_cmds, $1)=
scripts/libtool.m4:# Source file extension for C++ test sources.
scripts/libtool.m4:ac_ext=cpp
scripts/libtool.m4:# Object file extension for compiled C++ test sources.
scripts/libtool.m4:objext=o
scripts/libtool.m4:_LT_TAGVAR(objext, $1)=$objext
scripts/libtool.m4:  if test -n "${lt_cv_prog_gnu_ldcxx+set}"; then
scripts/libtool.m4:    lt_cv_prog_gnu_ld=$lt_cv_prog_gnu_ldcxx
scripts/libtool.m4:    # We don't want -fno-exception when compiling C++ code, so set the
scripts/libtool.m4:        _LT_TAGVAR(archive_expsym_cmds, $1)='$CC $pic_flag -shared -nostdlib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'
scripts/libtool.m4:        _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}--export-dynamic'
scripts/libtool.m4:        # XXX I think wlarc can be eliminated in ltcf-cxx, but I need to
scripts/libtool.m4:      output_verbose_link_cmd='$CC -shared $CFLAGS -v conftest.$objext 2>&1 | $GREP -v "^Configured with:" | $GREP "\-L"'
scripts/libtool.m4:      aix3*)
scripts/libtool.m4:      aix[[4-9]]*)
scripts/libtool.m4:          aix_use_runtimelinking=no
scripts/libtool.m4:          exp_sym_flag='-Bexport'
scripts/libtool.m4:          aix_use_runtimelinking=no
scripts/libtool.m4:          case $host_os in aix4.[[23]]|aix4.[[23]].*|aix[[5-9]]*)
scripts/libtool.m4:	        aix_use_runtimelinking=yes
scripts/libtool.m4:          exp_sym_flag='-bexport'
scripts/libtool.m4:        # When large executables or shared objects are built, AIX ld can
scripts/libtool.m4:        # enough to fix the problem, add -Wl,-bbigtoc to LDFLAGS.
scripts/libtool.m4:          case $host_os in aix4.[[012]]|aix4.[[012]].*)
scripts/libtool.m4:	  if test "$aix_use_runtimelinking" = yes; then
scripts/libtool.m4:	    if test "$aix_use_runtimelinking" = yes; then
scripts/libtool.m4:        _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-bexpall'
scripts/libtool.m4:        # It seems that -bexpall does not export symbols beginning with
scripts/libtool.m4:	# export.
scripts/libtool.m4:        _LT_TAGVAR(always_export_symbols, $1)=yes
scripts/libtool.m4:        if test "$aix_use_runtimelinking" = yes; then
scripts/libtool.m4:          # executable.
scripts/libtool.m4:          _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-blibpath:$libdir:'"$aix_libpath"
scripts/libtool.m4:          _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -o $output_objdir/$soname $libobjs $deplibs '"\${wl}$no_entry_flag"' $compiler_flags `if test "x${allow_undefined_flag}" != "x"; then func_echo_all "${wl}${allow_undefined_flag}"; else :; fi` '"\${wl}$exp_sym_flag:\$export_symbols $shared_flag"
scripts/libtool.m4:	    _LT_TAGVAR(archive_expsym_cmds, $1)="\$CC $shared_flag"' -o $output_objdir/$soname $libobjs $deplibs '"\${wl}$no_entry_flag"' $compiler_flags ${wl}${allow_undefined_flag} '"\${wl}$exp_sym_flag:\$export_symbols"
scripts/libtool.m4:	    # empty executable.
scripts/libtool.m4:	    _LT_TAGVAR(hardcode_libdir_flag_spec, $1)='${wl}-blibpath:$libdir:'"$aix_libpath"
scripts/libtool.m4:	      # Exported symbols can be pulled into shared objects from archives
scripts/libtool.m4:	    _LT_TAGVAR(archive_expsym_cmds, $1)="\$CC $shared_flag"' -o $output_objdir/$soname $libobjs $deplibs ${wl}-bnoentry $compiler_flags ${wl}-bE:$export_symbols${allow_undefined_flag}~$AR $AR_FLAGS $output_objdir/$libname$release.a $output_objdir/$soname'
scripts/libtool.m4:	  _LT_TAGVAR(always_export_symbols, $1)=yes
scripts/libtool.m4:	  libext=lib
scripts/libtool.m4:	  shrext_cmds=".dll"
scripts/libtool.m4:	  _LT_TAGVAR(archive_expsym_cmds, $1)='if test "x`$SED 1q $export_symbols`" = xEXPORTS; then
scripts/libtool.m4:	      $SED -n -e 's/\\\\\\\(.*\\\\\\\)/-link\\\ -EXPORT:\\\\\\\1/' -e '1\\\!p' < $export_symbols > $output_objdir/$soname.exp;
scripts/libtool.m4:	      $SED -e 's/\\\\\\\(.*\\\\\\\)/-link\\\ -EXPORT:\\\\\\\1/' < $export_symbols > $output_objdir/$soname.exp;
scripts/libtool.m4:	    $CC -o $tool_output_objdir$soname $libobjs $compiler_flags $deplibs "@$tool_output_objdir$soname.exp" -Wl,-DLL,-IMPLIB:"$tool_output_objdir$libname.dll.lib"~
scripts/libtool.m4:	      *.exe|*.EXE) ;;
scripts/libtool.m4:		lt_outputfile="$lt_outputfile.exe"
scripts/libtool.m4:		lt_tool_outputfile="$lt_tool_outputfile.exe"
scripts/libtool.m4:	      $MANIFEST_TOOL -manifest "$lt_tool_outputfile.manifest" -outputresource:"$lt_tool_outputfile" || exit 1;
scripts/libtool.m4:	  _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}--export-all-symbols'
scripts/libtool.m4:	  _LT_TAGVAR(always_export_symbols, $1)=no
scripts/libtool.m4:	    # If the export-symbols file already is a .def file (1st line
scripts/libtool.m4:	    _LT_TAGVAR(archive_expsym_cmds, $1)='if test "x`$SED 1q $export_symbols`" = xEXPORTS; then
scripts/libtool.m4:	      cp $export_symbols $output_objdir/$soname.def;
scripts/libtool.m4:	      cat $export_symbols >> $output_objdir/$soname.def;
scripts/libtool.m4:      dgux*)
scripts/libtool.m4:          ghcx*)
scripts/libtool.m4:      hpux9*)
scripts/libtool.m4:        _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-E'
scripts/libtool.m4:            # explicitly linking system object files so we need to strip them
scripts/libtool.m4:            output_verbose_link_cmd='templist=`($CC -b $CFLAGS -v conftest.$objext 2>&1) | $EGREP "\-L"`; list=""; for z in $templist; do case $z in conftest.$objext) list="$list $z";; *.$objext);; *) list="$list $z";;esac; done; func_echo_all "$list"'
scripts/libtool.m4:      hpux10*|hpux11*)
scripts/libtool.m4:	      _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-E'
scripts/libtool.m4:	    # explicitly linking system object files so we need to strip them
scripts/libtool.m4:	    output_verbose_link_cmd='templist=`($CC -b $CFLAGS -v conftest.$objext 2>&1) | $GREP "\-L"`; list=""; for z in $templist; do case $z in conftest.$objext) list="$list $z";; *.$objext);; *) list="$list $z";;esac; done; func_echo_all "$list"'
scripts/libtool.m4:      interix[[3-9]]*)
scripts/libtool.m4:	_LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-E'
scripts/libtool.m4:	# Hack: On Interix 3.x, we cannot compile PIC because of a broken gcc.
scripts/libtool.m4:	# Instead, shared libraries are loaded at an image base (0x10000000 by
scripts/libtool.m4:	# 256 KiB-aligned image base between 0x50000000 and 0x6FFC0000 at link
scripts/libtool.m4:	# time.  Moving up from 0x10000000 also allows more sbrk(2) space.
scripts/libtool.m4:	_LT_TAGVAR(archive_cmds, $1)='$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-h,$soname ${wl}--image-base,`expr ${RANDOM-$$} % 4096 / 2 \* 262144 + 1342177280` -o $lib'
scripts/libtool.m4:	_LT_TAGVAR(archive_expsym_cmds, $1)='sed "s,^,_," $export_symbols >$output_objdir/$soname.expsym~$CC -shared $pic_flag $libobjs $deplibs $compiler_flags ${wl}-h,$soname ${wl}--retain-symbols-file,$output_objdir/$soname.expsym ${wl}--image-base,`expr ${RANDOM-$$} % 4096 / 2 \* 262144 + 1342177280` -o $lib'
scripts/libtool.m4:      irix5* | irix6*)
scripts/libtool.m4:      linux* | k*bsd*-gnu | kopensolaris*-gnu)
scripts/libtool.m4:	    _LT_TAGVAR(archive_cmds, $1)='tempext=`echo $shared_ext | $SED -e '\''s/\([[^()0-9A-Za-z{}]]\)/\\\\\1/g'\''`; templib=`echo $lib | $SED -e "s/\${tempext}\..*/.so/"`; $CC $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags --soname $soname -o \$templib; mv \$templib $lib'
scripts/libtool.m4:	    _LT_TAGVAR(archive_expsym_cmds, $1)='tempext=`echo $shared_ext | $SED -e '\''s/\([[^()0-9A-Za-z{}]]\)/\\\\\1/g'\''`; templib=`echo $lib | $SED -e "s/\${tempext}\..*/.so/"`; $CC $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags --soname $soname -o \$templib ${wl}-retain-symbols-file,$export_symbols; mv \$templib $lib'
scripts/libtool.m4:	    # explicitly linking system object files so we need to strip them
scripts/libtool.m4:	    output_verbose_link_cmd='templist=`$CC $CFLAGS -v conftest.$objext -o libconftest$shared_ext 2>&1 | $GREP "ld"`; rm -f libconftest$shared_ext; list=""; for z in $templist; do case $z in conftest.$objext) list="$list $z";; *.$objext);; *) list="$list $z";;esac; done; func_echo_all "$list"'
scripts/libtool.m4:	    _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}--export-dynamic'
scripts/libtool.m4:		_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'
scripts/libtool.m4:		_LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared'"$tmp_idyn"' $libobjs $deplibs $compiler_flags ${wl}-soname $wl$soname ${wl}-retain-symbols-file $wl$export_symbols -o $lib'
scripts/libtool.m4:	    _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}--export-dynamic'
scripts/libtool.m4:	      _LT_TAGVAR(archive_expsym_cmds, $1)='tpldir=Template.dir~
scripts/libtool.m4:		$CC -shared $pic_flag $predep_objects $libobjs $deplibs `find $tpldir -name \*.o | sort | $NL2SP` $postdep_objects $compiler_flags ${wl}-soname ${wl}$soname ${wl}-retain-symbols-file ${wl}$export_symbols -o $lib'
scripts/libtool.m4:	      _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $pic_flag $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname ${wl}$soname ${wl}-retain-symbols-file ${wl}$export_symbols -o $lib'
scripts/libtool.m4:	    _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}--export-dynamic'
scripts/libtool.m4:	  cxx*)
scripts/libtool.m4:	    _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-soname $wl$soname  -o $lib ${wl}-retain-symbols-file $wl$export_symbols'
scripts/libtool.m4:	    # explicitly linking system object files so we need to strip them
scripts/libtool.m4:	    output_verbose_link_cmd='templist=`$CC -shared $CFLAGS -v conftest.$objext 2>&1 | $GREP "ld"`; templist=`func_echo_all "$templist" | $SED "s/\(^.*ld.*\)\( .*ld .*$\)/\1/"`; list=""; for z in $templist; do case $z in conftest.$objext) list="$list $z";; *.$objext);; *) list="$list $z";;esac; done; func_echo_all "X$list" | $Xsed'
scripts/libtool.m4:	  xl* | mpixl* | bgxl*)
scripts/libtool.m4:	    _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}--export-dynamic'
scripts/libtool.m4:	    if test "x$supports_anon_versioning" = xyes; then
scripts/libtool.m4:	      _LT_TAGVAR(archive_expsym_cmds, $1)='echo "{ global:" > $output_objdir/$libname.ver~
scripts/libtool.m4:		cat $export_symbols | sed -e "s/\(.*\)/\1;/" >> $output_objdir/$libname.ver~
scripts/libtool.m4:	      _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -G${allow_undefined_flag} -h$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-retain-symbols-file ${wl}$export_symbols'
scripts/libtool.m4:	      # $CC $CFLAGS -v conftest.$objext -o libconftest$shared_ext 2>&1
scripts/libtool.m4:	      # "CC -xar", where "CC" is the Sun C++ compiler.  This is
scripts/libtool.m4:	      _LT_TAGVAR(old_archive_cmds, $1)='$CC -xar -o $oldlib $oldobjs'
scripts/libtool.m4:      lynxos*)
scripts/libtool.m4:          cxx*)
scripts/libtool.m4:	output_verbose_link_cmd='$CC -shared $CFLAGS -v conftest.$objext 2>&1 | $GREP conftest.$objext | $SED -e "s:-lgcc -lc -lgcc::"'
scripts/libtool.m4:      *nto* | *qnx*)
scripts/libtool.m4:	if test -f /usr/libexec/ld.so; then
scripts/libtool.m4:	    _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared $pic_flag $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags ${wl}-retain-symbols-file,$export_symbols -o $lib'
scripts/libtool.m4:	    _LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-E'
scripts/libtool.m4:	    _LT_TAGVAR(archive_cmds, $1)='tempext=`echo $shared_ext | $SED -e '\''s/\([[^()0-9A-Za-z{}]]\)/\\\\\1/g'\''`; templib=`echo "$lib" | $SED -e "s/\${tempext}\..*/.so/"`; $CC $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags --soname $soname -o \$templib; mv \$templib $lib'
scripts/libtool.m4:          cxx*)
scripts/libtool.m4:	        _LT_TAGVAR(allow_undefined_flag, $1)=' ${wl}-expect_unresolved ${wl}\*'
scripts/libtool.m4:	        _LT_TAGVAR(allow_undefined_flag, $1)=' -expect_unresolved \*'
scripts/libtool.m4:	        _LT_TAGVAR(archive_expsym_cmds, $1)='for i in `cat $export_symbols`; do printf "%s %s\\n" -exported_symbol "\$i" >> $lib.exp; done~
scripts/libtool.m4:	          echo "-hidden">> $lib.exp~
scripts/libtool.m4:	          $CC -shared$allow_undefined_flag $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags -msym -soname $soname ${wl}-input ${wl}$lib.exp  `test -n "$verstring" && $ECHO "-set_version $verstring"` -update_registry ${output_objdir}/so_locations -o $lib~
scripts/libtool.m4:	          $RM $lib.exp'
scripts/libtool.m4:	    # explicitly linking system object files so we need to strip them
scripts/libtool.m4:	    output_verbose_link_cmd='templist=`$CC -shared $CFLAGS -v conftest.$objext 2>&1 | $GREP "ld" | $GREP -v "ld:"`; templist=`func_echo_all "$templist" | $SED "s/\(^.*ld.*\)\( .*ld.*$\)/\1/"`; list=""; for z in $templist; do case $z in conftest.$objext) list="$list $z";; *.$objext);; *) list="$list $z";;esac; done; func_echo_all "$list"'
scripts/libtool.m4:	      _LT_TAGVAR(allow_undefined_flag, $1)=' ${wl}-expect_unresolved ${wl}\*'
scripts/libtool.m4:	      output_verbose_link_cmd='$CC -shared $CFLAGS -v conftest.$objext 2>&1 | $GREP -v "^Configured with:" | $GREP "\-L"'
scripts/libtool.m4:	    # Sun C++ 4.x
scripts/libtool.m4:	    # Sun C++ 4.2, 5.x and Centerline C++
scripts/libtool.m4:	    _LT_TAGVAR(archive_expsym_cmds, $1)='echo "{ global:" > $lib.exp~cat $export_symbols | $SED -e "s/\(.*\)/\1;/" >> $lib.exp~echo "local: *; };" >> $lib.exp~
scripts/libtool.m4:	      $CC -G${allow_undefined_flag} ${wl}-M ${wl}$lib.exp -h$soname -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags~$RM $lib.exp'
scripts/libtool.m4:		_LT_TAGVAR(whole_archive_flag_spec, $1)='-z allextract$convenience -z defaultextract'
scripts/libtool.m4:	    # "CC -xar", where "CC" is the Sun C++ compiler.  This is
scripts/libtool.m4:	    _LT_TAGVAR(old_archive_cmds, $1)='$CC -xar -o $oldlib $oldobjs'
scripts/libtool.m4:          gcx*)
scripts/libtool.m4:	        _LT_TAGVAR(archive_expsym_cmds, $1)='echo "{ global:" > $lib.exp~cat $export_symbols | $SED -e "s/\(.*\)/\1;/" >> $lib.exp~echo "local: *; };" >> $lib.exp~
scripts/libtool.m4:		  $CC -shared $pic_flag -nostdlib ${wl}-M $wl$lib.exp -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags~$RM $lib.exp'
scripts/libtool.m4:	        output_verbose_link_cmd='$CC -shared $CFLAGS -v conftest.$objext 2>&1 | $GREP -v "^Configured with:" | $GREP "\-L"'
scripts/libtool.m4:	        _LT_TAGVAR(archive_expsym_cmds, $1)='echo "{ global:" > $lib.exp~cat $export_symbols | $SED -e "s/\(.*\)/\1;/" >> $lib.exp~echo "local: *; };" >> $lib.exp~
scripts/libtool.m4:		  $CC -G -nostdlib ${wl}-M $wl$lib.exp -o $lib $predep_objects $libobjs $deplibs $postdep_objects $compiler_flags~$RM $lib.exp'
scripts/libtool.m4:	        output_verbose_link_cmd='$CC -G $CFLAGS -v conftest.$objext 2>&1 | $GREP -v "^Configured with:" | $GREP "\-L"'
scripts/libtool.m4:		  _LT_TAGVAR(whole_archive_flag_spec, $1)='${wl}-z ${wl}allextract$convenience ${wl}-z ${wl}defaultextract'
scripts/libtool.m4:    sysv4*uw2* | sysv5OpenUNIX* | sysv5UnixWare7.[[01]].[[10]]* | unixware7* | sco3.2v5.0.[[024]]*)
scripts/libtool.m4:      _LT_TAGVAR(no_undefined_flag, $1)='${wl}-z,text'
scripts/libtool.m4:	  _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -G ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
scripts/libtool.m4:	  _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
scripts/libtool.m4:	# ever link correctly.  If we're not using GNU ld we use -z text
scripts/libtool.m4:	_LT_TAGVAR(no_undefined_flag, $1)='${wl}-z,text'
scripts/libtool.m4:	_LT_TAGVAR(export_dynamic_flag_spec, $1)='${wl}-Bexport'
scripts/libtool.m4:	    _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -G ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
scripts/libtool.m4:	    _LT_TAGVAR(archive_expsym_cmds, $1)='$CC -shared ${wl}-Bexport:$export_symbols ${wl}-h,$soname -o $lib $libobjs $deplibs $compiler_flags'
scripts/libtool.m4:      vxworks*)
scripts/libtool.m4:    ## the running order or otherwise move them around unless you know exactly
scripts/libtool.m4:  lt_cv_prog_gnu_ldcxx=$lt_cv_prog_gnu_ld
scripts/libtool.m4:# func_stripname_cnf prefix suffix name
scripts/libtool.m4:# PREFIX and SUFFIX must not contain globbing or regex special
scripts/libtool.m4:# except this one can be used by m4 code that may be executed by configure,
scripts/libtool.m4:# Parse the compiler output and extract the necessary
scripts/libtool.m4:dnl because it contains code intended for an executable,
scripts/libtool.m4:m4_if([$1], [], [cat > conftest.$ac_ext <<_LT_EOF
scripts/libtool.m4:], [$1], [CXX], [cat > conftest.$ac_ext <<_LT_EOF
scripts/libtool.m4:], [$1], [F77], [cat > conftest.$ac_ext <<_LT_EOF
scripts/libtool.m4:], [$1], [FC], [cat > conftest.$ac_ext <<_LT_EOF
scripts/libtool.m4:], [$1], [GCJ], [cat > conftest.$ac_ext <<_LT_EOF
scripts/libtool.m4:], [$1], [GO], [cat > conftest.$ac_ext <<_LT_EOF
scripts/libtool.m4:dnl Parse the compiler output and extract the necessary
scripts/libtool.m4:  # Parse the compiler output and extract the necessary
scripts/libtool.m4:       # Expand the sysroot to ease extracting the directories later.
scripts/libtool.m4:    *.lto.$objext) ;; # Ignore GCC LTO objects
scripts/libtool.m4:    *.$objext)
scripts/libtool.m4:       if test "$p" = "conftest.$objext"; then
scripts/libtool.m4:  rm -f a.out a.exe
scripts/libtool.m4:$RM -f confest.$objext
scripts/libtool.m4:interix[[3-9]]*)
scripts/libtool.m4:  # Interix 3.5 installs completely hosed .la files for C++, so rather than
scripts/libtool.m4:linux*)
scripts/libtool.m4:_LT_TAGVAR(always_export_symbols, $1)=no
scripts/libtool.m4:_LT_TAGVAR(archive_expsym_cmds, $1)=
scripts/libtool.m4:_LT_TAGVAR(export_dynamic_flag_spec, $1)=
scripts/libtool.m4:_LT_TAGVAR(module_expsym_cmds, $1)=
scripts/libtool.m4:# Source file extension for f77 test sources.
scripts/libtool.m4:ac_ext=f
scripts/libtool.m4:# Object file extension for compiled f77 test sources.
scripts/libtool.m4:objext=o
scripts/libtool.m4:_LT_TAGVAR(objext, $1)=$objext
scripts/libtool.m4:      aix3*)
scripts/libtool.m4:      aix[[4-9]]*)
scripts/libtool.m4:	if test "$host_cpu" != ia64 && test "$aix_use_runtimelinking" = no ; then
scripts/libtool.m4:    ## the running order or otherwise move them around unless you know exactly
scripts/libtool.m4:_LT_TAGVAR(always_export_symbols, $1)=no
scripts/libtool.m4:_LT_TAGVAR(archive_expsym_cmds, $1)=
scripts/libtool.m4:_LT_TAGVAR(export_dynamic_flag_spec, $1)=
scripts/libtool.m4:_LT_TAGVAR(module_expsym_cmds, $1)=
scripts/libtool.m4:# Source file extension for fc test sources.
scripts/libtool.m4:ac_ext=${ac_fc_srcext-f}
scripts/libtool.m4:# Object file extension for compiled fc test sources.
scripts/libtool.m4:objext=o
scripts/libtool.m4:_LT_TAGVAR(objext, $1)=$objext
scripts/libtool.m4:      aix3*)
scripts/libtool.m4:      aix[[4-9]]*)
scripts/libtool.m4:	if test "$host_cpu" != ia64 && test "$aix_use_runtimelinking" = no ; then
scripts/libtool.m4:    ## the running order or otherwise move them around unless you know exactly
scripts/libtool.m4:# Source file extension for Java test sources.
scripts/libtool.m4:ac_ext=java
scripts/libtool.m4:# Object file extension for compiled Java test sources.
scripts/libtool.m4:objext=o
scripts/libtool.m4:_LT_TAGVAR(objext, $1)=$objext
scripts/libtool.m4:# GCJ did not exist at the time GCC didn't implicitly link libc in.
scripts/libtool.m4:## the running order or otherwise move them around unless you know exactly
scripts/libtool.m4:# Source file extension for Go test sources.
scripts/libtool.m4:ac_ext=go
scripts/libtool.m4:# Object file extension for compiled Go test sources.
scripts/libtool.m4:objext=o
scripts/libtool.m4:_LT_TAGVAR(objext, $1)=$objext
scripts/libtool.m4:# Go did not exist at the time GCC didn't implicitly link libc in.
scripts/libtool.m4:## the running order or otherwise move them around unless you know exactly
scripts/libtool.m4:# Source file extension for RC test sources.
scripts/libtool.m4:ac_ext=rc
scripts/libtool.m4:# Object file extension for compiled RC test sources.
scripts/libtool.m4:objext=o
scripts/libtool.m4:_LT_TAGVAR(objext, $1)=$objext
scripts/libtool.m4:      test "x${GCJFLAGS+set}" = xset || GCJFLAGS="-g -O2"
scripts/libtool.m4:    for ac_exec_ext in '' $ac_executable_extensions; do
scripts/libtool.m4:      if $as_executable_p "$as_dir/$lt_ac_prog$ac_exec_ext"; then
scripts/libtool.m4:        lt_ac_sed_list="$lt_ac_sed_list $as_dir/$lt_ac_prog$ac_exec_ext"
scripts/libtool.m4:lt_ac_max=0
scripts/libtool.m4:# Add /usr/xpg4/bin/sed as it is typically found on Solaris
scripts/libtool.m4:for lt_ac_sed in $lt_ac_sed_list /usr/xpg4/bin/sed; do
scripts/libtool.m4:    lt_ac_count=`expr $lt_ac_count + 1`
scripts/libtool.m4:    if test $lt_ac_count -gt $lt_ac_max; then
scripts/libtool.m4:      lt_ac_max=$lt_ac_count
scripts/libtool.m4:xsi_shell=no
scripts/libtool.m4:  && xsi_shell=yes
scripts/libtool.m4:AC_MSG_RESULT([$xsi_shell])
scripts/libtool.m4:_LT_CONFIG_LIBTOOL_INIT([xsi_shell='$xsi_shell'])
scripts/libtool.m4:if ( (MAIL=60; unset MAIL) || exit) >/dev/null 2>&1; then
scripts/libtool.m4:} # Extended-shell $1 implementation' "$cfgfile" > $cfgfile.tmp \
scripts/libtool.m4:# Replace existing portable implementations of several shell functions with
scripts/libtool.m4:# equivalent extended shell implementations where those features are available..
scripts/libtool.m4:[if test x"$xsi_shell" = xyes; then
scripts/libtool.m4:      *.lo) func_lo2o_result=${1%.lo}.${objext} ;;
scripts/libtool.m4:  _LT_PROG_FUNCTION_REPLACE([func_xform], [    func_xform_result=${1%.*}.lo])
scripts/libtool.m4:if test x"$lt_shell_append" = xyes; then
scripts/libtool.m4:dnl m4 expansion turns \\\\ into \\, and then the shell eval turns that into \
scripts/libtool.m4:if test x"$_lt_function_replace_fail" = x":"; then
scripts/libtool.m4:  AC_MSG_WARN([Unable to substitute extended shell functions in $ofile])
scripts/libtool.m4:      * ) # otherwise, assume *nix
scripts/libtool.m4:        lt_cv_to_host_file_cmd=func_convert_file_nix_to_w32
scripts/libtool.m4:      * ) # otherwise, assume *nix
scripts/libtool.m4:        lt_cv_to_host_file_cmd=func_convert_file_nix_to_cygwin
scripts/intprefix.c:/* intprefix.c - generate an unprefixed internal symbol list
scripts/makevms.com:$   exit
scripts/makevms.com:$  ccopt = "/prefix=all"+ccopt
scripts/makevms.com:$      comp = "__vaxc__=1"
scripts/makevms.com:$    ccopt = "/decc/prefix=all"+ccopt
scripts/makevms.com:$   call make pngtest.exe -
scripts/makevms.com:$ exit
scripts/makevms.com:$       If Argument .Eqs. "" Then Goto Exit
scripts/makevms.com:$       If AFile .Eqs. "" .Or. AFile .Eqs. OFile Then Goto NextEl
scripts/makevms.com:$NextEL:
scripts/makevms.com:$ Goto Exit
scripts/makevms.com:$Exit:
scripts/libpng-config-body.in:  --prefix        print libpng prefix
scripts/libpng-config-body.in:  --help          print this help and exit
scripts/libpng-config-body.in:    exit $1
scripts/libpng-config-body.in:    --prefix)
scripts/libpng-config-body.in:        echo ${prefix}
scripts/libpng-config-body.in:        exit 0
scripts/libpng-config-body.in:        exit 1
scripts/libpng-config-body.in:exit 0
scripts/symbols.chk:; Contains all the symbols that can be exported from libpng
scripts/symbols.chk: png_set_expand @26
scripts/symbols.chk: png_set_expand_gray_1_2_4_to_8 @27
scripts/symbols.chk: png_set_rgb_to_gray_fixed @33
scripts/symbols.chk: png_get_pixels_per_meter @122
scripts/symbols.chk: png_get_x_pixels_per_meter @123
scripts/symbols.chk: png_get_y_pixels_per_meter @124
scripts/symbols.chk: png_get_pixel_aspect_ratio @125
scripts/symbols.chk: png_get_x_offset_pixels @126
scripts/symbols.chk: png_get_y_offset_pixels @127
scripts/symbols.chk: png_get_x_offset_microns @128
scripts/symbols.chk: png_get_cHRM_fixed @134
scripts/symbols.chk: png_set_cHRM_fixed @136
scripts/symbols.chk: png_get_gAMA_fixed @138
scripts/symbols.chk: png_set_gAMA_fixed @140
scripts/symbols.chk: png_get_text @162
scripts/symbols.chk: png_set_text @163
scripts/symbols.chk: png_get_user_width_max @187
scripts/symbols.chk: png_get_user_height_max @188
scripts/symbols.chk: png_set_chunk_cache_max @189
scripts/symbols.chk: png_get_chunk_cache_max @190
scripts/symbols.chk: png_set_chunk_malloc_max @191
scripts/symbols.chk: png_get_chunk_malloc_max @192
scripts/symbols.chk: png_get_pixels_per_inch @193
scripts/symbols.chk: png_get_x_pixels_per_inch @194
scripts/symbols.chk: png_get_y_pixels_per_inch @195
scripts/symbols.chk: png_get_x_offset_inches @196
scripts/symbols.chk: png_set_gamma_fixed @208
scripts/symbols.chk: png_set_filter_heuristics_fixed @209
scripts/symbols.chk: png_get_pixel_aspect_ratio_fixed @210
scripts/symbols.chk: png_get_x_offset_inches_fixed @211
scripts/symbols.chk: png_get_y_offset_inches_fixed @212
scripts/symbols.chk: png_set_sCAL_fixed @213
scripts/symbols.chk: png_get_sCAL_fixed @214
scripts/symbols.chk: png_set_background_fixed @215
scripts/symbols.chk: png_set_expand_16 @221
scripts/symbols.chk: png_set_text_compression_level @222
scripts/symbols.chk: png_set_text_compression_mem_level @223
scripts/symbols.chk: png_set_text_compression_strategy @224
scripts/symbols.chk: png_set_text_compression_window_bits @225
scripts/symbols.chk: png_set_text_compression_method @226
scripts/symbols.chk: png_set_alpha_mode_fixed @228
scripts/symbols.chk: png_get_cHRM_XYZ_fixed @231
scripts/symbols.chk: png_set_cHRM_XYZ_fixed @233
scripts/symbols.chk: png_set_check_for_invalid_index @242
scripts/symbols.chk: png_get_palette_max @243
scripts/makefile.tc3:E=.exe
scripts/def.c:/* Write the export file header: */
scripts/def.c:PNG_DFN "; If you give the library an explicit name one or other files"
scripts/makefile.darwin:# derived from makefile.linux:
scripts/makefile.darwin:prefix=/usr/local
scripts/makefile.darwin:exec_prefix=$(prefix)
scripts/makefile.darwin:INCPATH=$(prefix)/include
scripts/makefile.darwin:LIBPATH=$(exec_prefix)/lib
scripts/makefile.darwin:MANPATH=$(prefix)/man
scripts/makefile.darwin:BINPATH=$(exec_prefix)/bin
scripts/makefile.darwin:# installing into a temporary location.  Example:
scripts/makefile.darwin:# via DESTDIR, $(DESTDIR)$(prefix) must already exist before
scripts/makefile.darwin:# you execute make install.
scripts/makefile.darwin:	cat scripts/libpng.pc.in | sed -e s!@prefix@!$(prefix)! \
scripts/makefile.darwin:	-e s!@exec_prefix@!$(exec_prefix)! \
scripts/makefile.darwin:	echo prefix=\"$(prefix)\"; \
scripts/makefile.darwin:	chmod +x libpng-config
scripts/checksym.awk:   of="symbols.new" # default to a fixed name
scripts/checksym.awk:# Read existing definitions from the master file (the first
scripts/checksym.awk:         next
scripts/checksym.awk:      print master ": bad export line format:", $0
scripts/checksym.awk:   next
scripts/checksym.awk:#  symbol @ordinal   # two fields, exported symbol
scripts/checksym.awk:   next
scripts/checksym.awk:   next
scripts/checksym.awk:NF==2 && $2 ~ /^@[1-9][0-9]*$/ { # exported symbol
scripts/checksym.awk:   next # skip all other lines
scripts/checksym.awk:      print "highest symbol ordinal in png.h,", symbolo ", exceeds last ordinal from png.h", lasto
scripts/checksym.awk:      print "highest symbol ordinal in", master ",", mastero ", exceeds last ordinal from png.h", lasto
scripts/checksym.awk:   unexported=0
scripts/checksym.awk:   print "; Contains all the symbols that can be exported from libpng" >of
scripts/checksym.awk:         if (unexported == 0) unexported = o
scripts/checksym.awk:            # missing in export list too, so ok
scripts/checksym.awk:      if (unexported != 0) {
scripts/checksym.awk:         # the 'unexported' symbols aren't in either.  By default this
scripts/checksym.awk:            if (o-1 > unexported)
scripts/checksym.awk:               print "png.h:", missing ": missing symbols:", unexported "-" o-1
scripts/checksym.awk:               print "png.h:", missing ": missing symbol:", unexported
scripts/checksym.awk:         unexported = 0
scripts/checksym.awk:         print "png.h: symbol", o, "both exported as '" symbol[o] "' and removed as '" removed[o] "'"
scripts/checksym.awk:            print "png.h: symbol", o, "is exported as '" official[o] "' in", master
scripts/checksym.awk:            print "png.h: exported symbol", o, "'" symbol[o] "' not present in", master
scripts/checksym.awk:            print "png.h: exported symbol", o, "'" symbol[o] "' exists as '" official[o] "' in", master
scripts/checksym.awk:      exit 1
scripts/descrip.mms:pref = /prefix=all
scripts/descrip.mms:all : pngtest.exe libpng.olb
scripts/descrip.mms:pngtest.exe : pngtest.obj libpng.olb
scripts/descrip.mms:test : pngtest.exe
scripts/descrip.mms:	delete *.obj;*,*.exe;
scripts/makefile.msc:#-Ox generates bad code with MSC 5.1
scripts/makefile.msc:LDFLAGS=/e/st:0x1500/noe
scripts/makefile.msc:#uncomment next to put error messages in a file
scripts/makefile.msc:pngtest.exe: pngtest.obj libpng.lib
scripts/makefile.msc:test: pngtest.exe
scripts/makefile.cegcc:	cd $(PACKAGE) && CPPFLAGS="$(CPPFLAGS) -DPNG_CONSOLE_IO_SUPPORTED -D_WIN32_WCE=0x0420" \
scripts/makefile.cegcc:		./configure --prefix=/opt/wince --host=arm-mingw32ce && make
scripts/makefile.gcc:# File extensions
scripts/makefile.hpgcc:prefix=/usr/local
scripts/makefile.hpgcc:exec_prefix=$(prefix)
scripts/makefile.hpgcc:INCPATH=$(prefix)/include
scripts/makefile.hpgcc:LIBPATH=$(exec_prefix)/lib
scripts/makefile.hpgcc:MANPATH=$(prefix)/man
scripts/makefile.hpgcc:BINPATH=$(exec_prefix)/bin
scripts/makefile.hpgcc:# installing into a temporary location.  Example:
scripts/makefile.hpgcc:# via DESTDIR, $(DESTDIR)$(prefix) must already exist before
scripts/makefile.hpgcc:# you execute make install.
scripts/makefile.hpgcc:	cat scripts/libpng.pc.in | sed -e s!@prefix@!$(prefix)! \
scripts/makefile.hpgcc:	-e s!@exec_prefix@!$(exec_prefix)! \
scripts/makefile.hpgcc:	echo prefix=\"$(prefix)\"; \
scripts/makefile.hpgcc:	chmod +x libpng-config
scripts/makefile.32sunu:# makefile for libpng on Solaris 2.x with cc
scripts/makefile.32sunu:# Contributed by William L. Sebok, based on makefile.linux
scripts/makefile.32sunu:SUN_CC_FLAGS=-fast -xtarget=ultra
scripts/makefile.32sunu:SUN_LD_FLAGS=-fast -xtarget=ultra
scripts/makefile.32sunu:prefix=/a
scripts/makefile.32sunu:exec_prefix=$(prefix)
scripts/makefile.32sunu:INCPATH=$(prefix)/include
scripts/makefile.32sunu:LIBPATH=$(exec_prefix)/lib
scripts/makefile.32sunu:MANPATH=$(prefix)/man
scripts/makefile.32sunu:BINPATH=$(exec_prefix)/bin
scripts/makefile.32sunu:# installing into a temporary location.  Example:
scripts/makefile.32sunu:# via DESTDIR, $(DESTDIR)$(prefix) must already exist before
scripts/makefile.32sunu:# you execute make install.
scripts/makefile.32sunu:	cat scripts/libpng.pc.in | sed -e s!@prefix@!$(prefix)! \
scripts/makefile.32sunu:	-e s!@exec_prefix@!$(exec_prefix)! \
scripts/makefile.32sunu:	echo prefix=\"$(prefix)\"; \
scripts/makefile.32sunu:	echo ccopts=\"-fast -xtarget=ultra\"; \
scripts/makefile.32sunu:	echo ldopts=\"-fast -xtarget=ultra\"; \
scripts/makefile.32sunu:	chmod +x libpng-config
scripts/makefile.amiga:# makefile for libpng and SAS C V6.5x compiler
scripts/ltoptions.m4:# Execute IF-SET if OPTION is set, IF-NOT-SET otherwise.
scripts/ltoptions.m4:# Execute IF-NOT-SET unless all options in OPTION-LIST for MACRO-NAME
scripts/ltoptions.m4:# the unknown option and exit.
scripts/ltoptions.m4:  dnl we run the default mode handler for the pair.  For example, if neither
scripts/makefile.beos:# makefile for libpng on BeOS x86 ELF with gcc
scripts/makefile.beos:# modified from makefile.linux by Sander Stoks
scripts/makefile.beos:prefix=/usr/local
scripts/makefile.beos:exec_prefix=$(prefix)
scripts/makefile.beos:INCPATH=$(prefix)/include
scripts/makefile.beos:LIBPATH=$(exec_prefix)/lib
scripts/makefile.beos:MANPATH=$(prefix)/man
scripts/makefile.beos:BINPATH=$(exec_prefix)/bin
scripts/makefile.beos:# installing into a temporary location.  Example:
scripts/makefile.beos:# via DESTDIR, $(DESTDIR)$(prefix) must already exist before
scripts/makefile.beos:# you execute make install.
scripts/makefile.beos:	cat scripts/libpng.pc.in | sed -e s!@prefix@!$(prefix)! \
scripts/makefile.beos:	-e s!@exec_prefix@!$(exec_prefix)! \
scripts/makefile.beos:	echo prefix=\"$(prefix)\"; \
scripts/makefile.beos:	chmod +x libpng-config
scripts/makefile.std:prefix=/usr/local
scripts/makefile.std:INCPATH=$(prefix)/include
scripts/makefile.std:LIBPATH=$(prefix)/lib
scripts/makefile.std:# installing into a temporary location.  Example:
scripts/makefile.std:# via DESTDIR, $(DESTDIR)$(prefix) must already exist before
scripts/makefile.std:# you execute make install.
scripts/makefile.std:DFA_EXTRA = # extra files that can be used to control configuration
scripts/makefile.std:# The standard pnglibconf.h exists as scripts/pnglibconf.h.prebuilt,
scripts/makefile.sco:# makefile for SCO OSr5  ELF and Unixware 7 with Native cc
scripts/makefile.sco:# Contributed by Mike Hopkirk (hops@sco.com) modified from Makefile.lnx
scripts/makefile.sco:prefix=/usr/local
scripts/makefile.sco:exec_prefix=$(prefix)
scripts/makefile.sco:INCPATH=$(prefix)/include
scripts/makefile.sco:LIBPATH=$(exec_prefix)/lib
scripts/makefile.sco:MANPATH=$(prefix)/man
scripts/makefile.sco:BINPATH=$(exec_prefix)/bin
scripts/makefile.sco:# installing into a temporary location.  Example:
scripts/makefile.sco:# via DESTDIR, $(DESTDIR)$(prefix) must already exist before
scripts/makefile.sco:# you execute make install.
scripts/makefile.sco:	cat scripts/libpng.pc.in | sed -e s!@prefix@!$(prefix)! \
scripts/makefile.sco:	-e s!@exec_prefix@!$(exec_prefix)! \
scripts/makefile.sco:	echo prefix=\"$(prefix)\"; \
scripts/makefile.sco:	chmod +x libpng-config
scripts/makefile.sunos:prefix=/usr/local
scripts/makefile.sunos:INCPATH=$(prefix)/include
scripts/makefile.sunos:LIBPATH=$(prefix)/lib
scripts/makefile.sunos:# installing into a temporary location.  Example:
scripts/makefile.sunos:# via DESTDIR, $(DESTDIR)$(prefix) must already exist before
scripts/makefile.sunos:# you execute make install.
scripts/makefile.dec:# makefile for libpng on DEC Alpha Unix
scripts/makefile.dec:prefix=/usr/local
scripts/makefile.dec:exec_prefix=$(prefix)
scripts/makefile.dec:INCPATH=$(prefix)/include
scripts/makefile.dec:LIBPATH=$(exec_prefix)/lib
scripts/makefile.dec:MANPATH=$(prefix)/man
scripts/makefile.dec:BINPATH=$(exec_prefix)/bin
scripts/makefile.dec:# installing into a temporary location.  Example:
scripts/makefile.dec:# via DESTDIR, $(DESTDIR)$(prefix) must already exist before
scripts/makefile.dec:# you execute make install.
scripts/makefile.dec:	cat scripts/libpng.pc.in | sed -e s!@prefix@!$(prefix)! \
scripts/makefile.dec:	-e s!@exec_prefix@!$(exec_prefix)! \
scripts/makefile.dec:	echo prefix=\"$(prefix)\"; \
scripts/makefile.dec:	chmod +x libpng-config
scripts/README.txt: makefile.linux    =>  Linux/ELF makefile
scripts/README.txt: makefile.aix      =>  AIX/gcc makefile
scripts/README.txt: makefile.hpux     =>  HPUX (10.20 and 11.00) makefile
scripts/README.txt: makefile.ibmc     =>  IBM C/C++ version 3.x for Win32 and OS/2 (static)
scripts/README.txt: makefile.os2      =>  OS/2 Makefile (gcc and emx, requires libpng.def)
scripts/README.txt: makefile.sco      =>  For SCO OSr5  ELF and Unixware 7 with Native cc
scripts/README.txt: README.txt        =>  This file
scripts/README.txt: intprefix.dfn     =>  Used by autoconf tools
scripts/README.txt: prefix.dfn        =>  Used by autoconf tools
scripts/lt~obsolete.m4:# These exist entirely to fool aclocal when bootstrapping libtool.
scripts/lt~obsolete.m4:# exported API, or moved to Autoconf or Automake where they belong.
scripts/lt~obsolete.m4:# because those macros already exist, or will be overwritten later.
scripts/makefile.knr:prefix=/usr/local
scripts/makefile.knr:INCPATH=$(prefix)/include
scripts/makefile.knr:LIBPATH=$(prefix)/lib
scripts/makefile.knr:# installing into a temporary location.  Example:
scripts/makefile.knr:# via DESTDIR, $(DESTDIR)$(prefix) must already exist before
scripts/makefile.knr:# you execute make install.
scripts/pnglibconf.mak:# the make command line (AWK='nawk' for example).
scripts/pnglibconf.mak:# The standard pnglibconf.h exists as scripts/pnglibconf.h.prebuilt,
scripts/makefile.sggcc:# Prefix must be a full pathname.
scripts/makefile.sggcc:prefix=/usr/local
scripts/makefile.sggcc:exec_prefix=$(prefix)
scripts/makefile.sggcc:INCPATH=$(prefix)/include
scripts/makefile.sggcc:LIBPATH=$(exec_prefix)/lib
scripts/makefile.sggcc:#LIBPATH=$(exec_prefix)/lib32
scripts/makefile.sggcc:MANPATH=$(prefix)/man
scripts/makefile.sggcc:BINPATH=$(exec_prefix)/bin
scripts/makefile.sggcc:# installing into a temporary location.  Example:
scripts/makefile.sggcc:# via DESTDIR, $(DESTDIR)$(prefix) must already exist before
scripts/makefile.sggcc:# you execute make install.
scripts/makefile.sggcc:	cat scripts/libpng.pc.in | sed -e s!@prefix@!$(prefix)! \
scripts/makefile.sggcc:	-e s!@exec_prefix@!$(exec_prefix)! \
scripts/makefile.sggcc:	echo prefix=\"$(prefix)\"; \
scripts/makefile.sggcc:	chmod +x libpng-config
scripts/prefix.c:/* prefix.c - generate an unprefixed symbol list
scripts/prefix.c: * the list is the C name list; no symbol prefix.
scripts/makefile.solaris:# makefile for libpng on Solaris 2.x with gcc
scripts/makefile.solaris:# Contributed by William L. Sebok, based on makefile.linux
scripts/makefile.solaris:prefix=/usr/local
scripts/makefile.solaris:exec_prefix=$(prefix)
scripts/makefile.solaris:INCPATH=$(prefix)/include
scripts/makefile.solaris:LIBPATH=$(exec_prefix)/lib
scripts/makefile.solaris:MANPATH=$(prefix)/man
scripts/makefile.solaris:BINPATH=$(exec_prefix)/bin
scripts/makefile.solaris:# installing into a temporary location.  Example:
scripts/makefile.solaris:# via DESTDIR, $(DESTDIR)$(prefix) must already exist before
scripts/makefile.solaris:# you execute make install.
scripts/makefile.solaris:	cat scripts/libpng.pc.in | sed -e s!@prefix@!$(prefix)! \
scripts/makefile.solaris:	-e s!@exec_prefix@!$(exec_prefix)! \
scripts/makefile.solaris:	echo prefix=\"$(prefix)\"; \
scripts/makefile.solaris:	chmod +x libpng-config
scripts/ltsugar.m4:# Note that neither SEPARATOR nor STRING are expanded; they are appended
scripts/ltsugar.m4:# to MACRO-NAME as is (leaving the expansion for when MACRO-NAME is invoked).
scripts/ltsugar.m4:# versions of m4sugar mistakenly expanded SEPARATOR but not STRING.
scripts/ltsugar.m4:[[m4_foreach([_Lt_prefix], [$2],
scripts/ltsugar.m4:	     [m4_foreach([_Lt_suffix],
scripts/ltsugar.m4:	[_Lt_sep([$1])[]m4_defn([_Lt_prefix])[$3]m4_defn([_Lt_suffix])])])])])
scripts/ltsugar.m4:# by SEPARATOR if supplied) and expand UNIQ, else NOT-UNIQ.
scripts/ltsugar.m4:	  [m4_if(m4_index([$3]m4_defn([$1])[$3], [$3$2$3]), [-1],
scripts/makefile.bor:# Use this if you don't want Borland's fancy exception handling
scripts/makefile.bor:.c.exe:
scripts/makefile.bor:pngtest: pngtest$(MODEL).exe
scripts/makefile.bor:test: pngtest$(MODEL).exe
scripts/makefile.bor:pngtest$(MODEL).exe: pngtest$(MODEL).obj
scripts/makefile.bor:	-del *.exe
scripts/makefile.intel:# Uncomment next to put error messages in a file
scripts/makefile.intel:	if exist libpng.lib del libpng.lib
scripts/makefile.intel:pngtest.exe: pngtest.obj libpng.lib
scripts/makefile.intel:	$(LD) $(LDFLAGS) /OUT:pngtest.exe pngtest.obj libpng.lib $(ZLIBLIB)\zlib.lib
scripts/makefile.intel:test: pngtest.exe
scripts/makefile.intel:	pngtest.exe
scripts/pngwin.rc:#define _QUOTE(x) # x
scripts/pngwin.rc:#define QUOTE(x) _QUOTE(x)
scripts/pngwin.rc:/* Prioritize PNG_USER_x over PNG_LIBPNG_x */
scripts/pngwin.rc:  BEGIN BLOCK "040904E4" /* Language type = U.S English(0x0409) and Character Set = Windows, Multilingual(0x04E4) */
scripts/pngwin.rc:    VALUE "Translation", 0x0409, 0x04E4
scripts/makefile.ibmc:# IBM C version 3.x for Win32 and OS/2
scripts/makefile.ibmc:#   Tested under Win32, expected to work under OS/2
scripts/makefile.ibmc:# File extensions
scripts/makefile.ibmc:E=.exe
scripts/makefile.64sunu:# makefile for libpng on Solaris 2.x with cc
scripts/makefile.64sunu:# Contributed by William L. Sebok, based on makefile.linux
scripts/makefile.64sunu:SUN_CC_FLAGS=-fast -xtarget=ultra -xarch=v9
scripts/makefile.64sunu:SUN_LD_FLAGS=-fast -xtarget=ultra -xarch=v9
scripts/makefile.64sunu:prefix=/a
scripts/makefile.64sunu:exec_prefix=$(prefix)
scripts/makefile.64sunu:INCPATH=$(prefix)/include
scripts/makefile.64sunu:LIBPATH=$(exec_prefix)/lib
scripts/makefile.64sunu:MANPATH=$(prefix)/man
scripts/makefile.64sunu:BINPATH=$(exec_prefix)/bin
scripts/makefile.64sunu:# installing into a temporary location.  Example:
scripts/makefile.64sunu:# via DESTDIR, $(DESTDIR)$(prefix) must already exist before
scripts/makefile.64sunu:# you execute make install.
scripts/makefile.64sunu:	cat scripts/libpng.pc.in | sed -e s!@prefix@!$(prefix)! \
scripts/makefile.64sunu:	-e s!@exec_prefix@!$(exec_prefix)! \
scripts/makefile.64sunu:	echo prefix=\"$(prefix)\"; \
scripts/makefile.64sunu:	echo ccopts=\"-fast -xtarget=ultra -xarch=v9\"; \
scripts/makefile.64sunu:	echo ldopts=\"-fast -xtarget=ultra -xarch=v9\"; \
scripts/makefile.64sunu:	chmod +x libpng-config
scripts/makefile.so9:# Contributed by William L. Sebok, based on makefile.linux
scripts/makefile.so9:prefix=/usr/local
scripts/makefile.so9:exec_prefix=$(prefix)
scripts/makefile.so9:INCPATH=$(prefix)/include
scripts/makefile.so9:LIBPATH=$(exec_prefix)/lib
scripts/makefile.so9:MANPATH=$(prefix)/man
scripts/makefile.so9:BINPATH=$(exec_prefix)/bin
scripts/makefile.so9:# installing into a temporary location.  Example:
scripts/makefile.so9:# via DESTDIR, $(DESTDIR)$(prefix) must already exist before
scripts/makefile.so9:# you execute make install.
scripts/makefile.so9:	cat scripts/libpng.pc.in | sed -e s!@prefix@!$(prefix)! \
scripts/makefile.so9:	-e s!@exec_prefix@!$(exec_prefix)! \
scripts/makefile.so9:	echo prefix=\"$(prefix)\"; \
scripts/makefile.so9:	chmod +x libpng-config
scripts/makefile.msys:# Portions taken from makefile.linux:
scripts/makefile.msys:prefix=/usr/local
scripts/makefile.msys:exec_prefix=$(prefix)
scripts/makefile.msys:# File extensions
scripts/makefile.msys:EXEEXT=.exe
scripts/makefile.msys:INCPATH=$(prefix)/include
scripts/makefile.msys:LIBPATH=$(exec_prefix)/lib
scripts/makefile.msys:MANPATH=$(prefix)/man
scripts/makefile.msys:BINPATH=$(exec_prefix)/bin
scripts/makefile.msys:# installing into a temporary location.  Example:
scripts/makefile.msys:# via DESTDIR, $(DESTDIR)$(prefix) must already exist before
scripts/makefile.msys:# you execute make install.
scripts/makefile.msys:	cat scripts/libpng.pc.in | sed -e s!@prefix@!$(prefix)! \
scripts/makefile.msys:	-e s!@exec_prefix@!$(exec_prefix)! \
scripts/makefile.msys:	echo prefix=\"$(prefix)\"; \
scripts/makefile.dj2:#prefix=/usr/local
scripts/makefile.dj2:prefix=.
scripts/makefile.dj2:INCPATH=$(prefix)/include
scripts/makefile.dj2:LIBPATH=$(prefix)/lib
scripts/makefile.dj2:	coff2exe pngtest
scripts/symbols.c:/* symbols.c - find all exported symbols
scripts/symbols.c:/* NOTE: making 'symbols.chk' checks both that the exported
scripts/symbols.c: * scripts/pnglibconf.h.prebuilt is as expected.
scripts/symbols.c: * on here (by hand) to get the APIs they expose and validate
scripts/symbols.c:#undef  PNG_FLOATING_POINT_SUPPORTED /* Exposes 'fixed' APIs */
scripts/symbols.c:#undef  PNG_ERROR_TEXT_SUPPORTED     /* Exposes unsupported APIs */
scripts/makefile.sgi:# Prefix must be a full pathname.
scripts/makefile.sgi:prefix=/usr/local
scripts/makefile.sgi:exec_prefix=$(prefix)
scripts/makefile.sgi:INCPATH=$(prefix)/include
scripts/makefile.sgi:LIBPATH=$(exec_prefix)/lib
scripts/makefile.sgi:#LIBPATH=$(exec_prefix)/lib32
scripts/makefile.sgi:MANPATH=$(prefix)/man
scripts/makefile.sgi:BINPATH=$(exec_prefix)/bin
scripts/makefile.sgi:# installing into a temporary location.  Example:
scripts/makefile.sgi:# via DESTDIR, $(DESTDIR)$(prefix) must already exist before
scripts/makefile.sgi:# you execute make install.
scripts/makefile.sgi:	cat scripts/libpng.pc.in | sed -e s!@prefix@!$(prefix)! \
scripts/makefile.sgi:	-e s!@exec_prefix@!$(exec_prefix)! \
scripts/makefile.sgi:	echo prefix=\"$(prefix)\"; \
scripts/makefile.sgi:	chmod +x libpng-config
scripts/dfn.awk:# the script will exit with error code 1.
scripts/dfn.awk:   next
scripts/dfn.awk:   next
scripts/dfn.awk:   # A definition line, apparently correctly formatted; extract the
scripts/dfn.awk:       next
scripts/dfn.awk:   # Now examine quotes within the value:
scripts/dfn.awk:      # While there is an @" remove it and the next "@
scripts/dfn.awk:            # Do this special case first to avoid swallowing extra spaces
scripts/dfn.awk:                  exit 1
scripts/dfn.awk:            if (getline nextline) {
scripts/dfn.awk:               if (nextline !~ /^#/) {
scripts/dfn.awk:                  line = line " " nextline
scripts/dfn.awk:               next
scripts/dfn.awk:         if (getline nextline) {
scripts/dfn.awk:            if (nextline !~ /^#/) {
scripts/dfn.awk:               line = line " " nextline
scripts/dfn.awk:            next
scripts/dfn.awk:   next
scripts/dfn.awk:	exit err
scripts/dfn.awk:   exit 1
scripts/makefile.aix:prefix=/usr/local
scripts/makefile.aix:INCPATH=$(prefix)/include
scripts/makefile.aix:LIBPATH=$(prefix)/lib
scripts/makefile.aix:# installing into a temporary location.  Example:
scripts/makefile.aix:# via DESTDIR, $(DESTDIR)$(prefix) must already exist before
scripts/makefile.aix:# you execute make install.
scripts/pnglibconf.dfa:# The syntax is detailed in scripts/options.awk; this is a summary
scripts/pnglibconf.dfa:#    'requires something' expands to READ_something for read and
scripts/pnglibconf.dfa:#    used as given (e.g. enables GAMMA just expands to that on the
scripts/pnglibconf.dfa:# continuation (the next line is included in the option too.)
scripts/pnglibconf.dfa:# CPPFLAGS; for example:
scripts/pnglibconf.dfa:# chunk values explicitly 'on' or 'off':
scripts/pnglibconf.dfa:# Look at the builds below contrib/pngminim for some extreme examples
scripts/pnglibconf.dfa:#  e.g. #define PNG_USER_PRIVATEBUILD "Build by MyCompany for xyz reasons."
scripts/pnglibconf.dfa:# #define PNG_USER_DLLFNAME_POSTFIX <two-letter postfix that serve to
scripts/pnglibconf.dfa:#  e.g. // private DLL "libpng13gx.dll"
scripts/pnglibconf.dfa:#       #define PNG_USER_DLLFNAME_POSTFIX "gx"
scripts/pnglibconf.dfa:# This is a special fixup for the Watcom C compiler on Windows, which has
scripts/pnglibconf.dfa:# multiple procedure call standards.  Unless PNG_API_RULE is set explicitly
scripts/pnglibconf.dfa:# These are currently experimental features; define them if you want (NOTE:
scripts/pnglibconf.dfa:# experimental options must be disabled before they are defined in this file!)
scripts/pnglibconf.dfa:# This allows a prefix to be added to the front of every API functon name (and
scripts/pnglibconf.dfa:# therefore every symbol) by redefining all the function names with the prefix
scripts/pnglibconf.dfa:# by causing a similar build-time only file, pngprefix.h, to be generated.
scripts/pnglibconf.dfa:#                 extensions are supported. This is poorly supported and
scripts/pnglibconf.dfa:# because the name of the setting is prefixed by PNG_
scripts/pnglibconf.dfa:# The TEXT values are the defaults when writing compressed text (all forms)
scripts/pnglibconf.dfa:# appropriate for PNG images, maybe it doesn't exist in all versions?
scripts/pnglibconf.dfa:# floating and fixed point arithmetic implementations - it does not affect any
scripts/pnglibconf.dfa:# without enabling any of the low level fixed/floating APIs.
scripts/pnglibconf.dfa:# This is only for PowerPC big-endian and 680x0 systems
scripts/pnglibconf.dfa:# USER_WIDTH_MAX: maximum width of an image that will be read
scripts/pnglibconf.dfa:# USER_HEIGHT_MAX: maximum height
scripts/pnglibconf.dfa:# USER_CHUNK_MALLOC_MAX: maximum in-memory (decompressed) size of a single chunk
scripts/pnglibconf.dfa:# USER_CHUNK_CACHE_MAX: maximum number of chunks to be cached
scripts/pnglibconf.dfa:# will probably see build failures due to missing APIs.  Fixing these failures
scripts/pnglibconf.dfa:# Note: these can be turned off explicitly if not required by the
scripts/pnglibconf.dfa:# ones that allocate memory may be expecially important (hIST,
scripts/pnglibconf.dfa:# The size of the png_text structure changed in libpng-1.0.6 when
scripts/pnglibconf.dfa:# libpng-1.2.x, to support old apps that malloc the png_text structure
scripts/pnglibconf.dfa:# instead of calling png_set_text() and letting libpng malloc it.  It
scripts/pnglibconf.dfa:# These options disable *all* the text chunks if turned off
scripts/pnglibconf.dfa:# we actually start doing gamma conversion, it's a fixed point value,
scripts/pnglibconf.dfa:# extension format string in an sCAL chunk (only relevant if the
scripts/pnglibconf.dfa:# calculations.  Making this an extremely small size may slow
scripts/pnglibconf.dfa:# the library down, but you may want to experiment to determine
scripts/pnglibconf.dfa:# This is the maximum amount of IDAT data that the sequential reader will
scripts/pnglibconf.dfa:# The second option extends the unknown handling to allow known chunks to be
scripts/pnglibconf.dfa:# explicitly.
scripts/pnglibconf.dfa:# Turn this off to disable warning about invalid palette index and
scripts/pnglibconf.dfa:# leave the num_palette_max member out of the png structure.
scripts/pnglibconf.dfa:#  API couldn't be turned off without explicitly turning off the simplified
scripts/makefile.linux:# makefile for libpng.a and libpng16.so on Linux ELF with gcc
scripts/makefile.linux:# Prefix must be a full pathname.
scripts/makefile.linux:prefix=/usr/local
scripts/makefile.linux:exec_prefix=$(prefix)
scripts/makefile.linux:INCPATH=$(prefix)/include
scripts/makefile.linux:LIBPATH=$(exec_prefix)/lib
scripts/makefile.linux:MANPATH=$(prefix)/man
scripts/makefile.linux:BINPATH=$(exec_prefix)/bin
scripts/makefile.linux:# installing into a temporary location.  Example:
scripts/makefile.linux:# via DESTDIR, $(DESTDIR)$(prefix) must already exist before
scripts/makefile.linux:# you execute make install.
scripts/makefile.linux:	cat scripts/libpng.pc.in | sed -e s!@prefix@!$(prefix)! \
scripts/makefile.linux:	-e s!@exec_prefix@!$(exec_prefix)! \
scripts/makefile.linux:	echo prefix=\"$(prefix)\"; \
scripts/makefile.linux:	chmod +x libpng-config
scripts/makefile.solaris-x86:# makefile for libpng on Solaris 2.x with gcc
scripts/makefile.solaris-x86:# Contributed by William L. Sebok, based on makefile.linux
scripts/makefile.solaris-x86:prefix=/usr/local
scripts/makefile.solaris-x86:exec_prefix=$(prefix)
scripts/makefile.solaris-x86:INCPATH=$(prefix)/include
scripts/makefile.solaris-x86:LIBPATH=$(exec_prefix)/lib
scripts/makefile.solaris-x86:MANPATH=$(prefix)/man
scripts/makefile.solaris-x86:BINPATH=$(exec_prefix)/bin
scripts/makefile.solaris-x86:# installing into a temporary location.  Example:
scripts/makefile.solaris-x86:# via DESTDIR, $(DESTDIR)$(prefix) must already exist before
scripts/makefile.solaris-x86:# you execute make install.
scripts/makefile.solaris-x86:	cat scripts/libpng.pc.in | sed -e s!@prefix@!$(prefix)! \
scripts/makefile.solaris-x86:	-e s!@exec_prefix@!$(exec_prefix)! \
scripts/makefile.solaris-x86:	echo prefix=\"$(prefix)\"; \
scripts/makefile.solaris-x86:	chmod +x libpng-config
scripts/libpng.pc.in:prefix=@prefix@
scripts/libpng.pc.in:exec_prefix=@exec_prefix@
scripts/makefile.freebsd:INCDIR=		${INCSDIR}		# for 4.x bsd.lib.mk
scripts/sym.out:png_set_expand
scripts/sym.out:png_set_expand_gray_1_2_4_to_8
scripts/sym.out:png_set_expand_16
scripts/sym.out:png_set_rgb_to_gray_fixed
scripts/sym.out:png_set_alpha_mode_fixed
scripts/sym.out:png_set_background_fixed
scripts/sym.out:png_set_gamma_fixed
scripts/sym.out:png_set_filter_heuristics_fixed
scripts/sym.out:png_set_text_compression_level
scripts/sym.out:png_set_text_compression_mem_level
scripts/sym.out:png_set_text_compression_strategy
scripts/sym.out:png_set_text_compression_window_bits
scripts/sym.out:png_set_text_compression_method
scripts/sym.out:png_get_pixels_per_meter
scripts/sym.out:png_get_x_pixels_per_meter
scripts/sym.out:png_get_y_pixels_per_meter
scripts/sym.out:png_get_pixel_aspect_ratio
scripts/sym.out:png_get_pixel_aspect_ratio_fixed
scripts/sym.out:png_get_x_offset_pixels
scripts/sym.out:png_get_y_offset_pixels
scripts/sym.out:png_get_x_offset_microns
scripts/sym.out:png_get_cHRM_fixed
scripts/sym.out:png_get_cHRM_XYZ_fixed
scripts/sym.out:png_set_cHRM_fixed
scripts/sym.out:png_set_cHRM_XYZ_fixed
scripts/sym.out:png_get_gAMA_fixed
scripts/sym.out:png_set_gAMA_fixed
scripts/sym.out:png_get_text
scripts/sym.out:png_set_text
scripts/sym.out:png_get_sCAL_fixed
scripts/sym.out:png_set_sCAL_fixed
scripts/sym.out:png_get_user_width_max
scripts/sym.out:png_get_user_height_max
scripts/sym.out:png_set_chunk_cache_max
scripts/sym.out:png_get_chunk_cache_max
scripts/sym.out:png_set_chunk_malloc_max
scripts/sym.out:png_get_chunk_malloc_max
scripts/sym.out:png_get_pixels_per_inch
scripts/sym.out:png_get_x_pixels_per_inch
scripts/sym.out:png_get_y_pixels_per_inch
scripts/sym.out:png_get_x_offset_inches
scripts/sym.out:png_get_x_offset_inches_fixed
scripts/sym.out:png_get_y_offset_inches_fixed
scripts/sym.out:png_set_check_for_invalid_index
scripts/sym.out:png_get_palette_max
scripts/makefile.atari:prefix=/usr/local
scripts/makefile.atari:INCPATH=$(prefix)/include
scripts/makefile.atari:LIBPATH=$(prefix)/lib
scripts/makefile.atari:# installing into a temporary location.  Example:
scripts/makefile.atari:# via DESTDIR, $(DESTDIR)$(prefix) must already exist before
scripts/makefile.atari:# you execute make install.
scripts/libpng-config-head.in:# Modeled after libxml-config.
scripts/libpng-config-head.in:prefix=""
share/man/man3/libpngpf.3:available for use by applications.  They are not "exported" to applications
share/man/man3/libpng.3:\fBpng_uint_32 png_get_cHRM (png_const_structp \fP\fIpng_ptr\fP\fB, png_const_infop \fP\fIinfo_ptr\fP\fB, double \fP\fI*white_x\fP\fB, double \fP\fI*white_y\fP\fB, double \fP\fI*red_x\fP\fB, double \fP\fI*red_y\fP\fB, double \fP\fI*green_x\fP\fB, double \fP\fI*green_y\fP\fB, double \fP\fI*blue_x\fP\fB, double \fI*blue_y\fP\fB);\fP
share/man/man3/libpng.3:\fBpng_uint_32 png_get_cHRM_fixed (png_const_structp \fP\fIpng_ptr\fP\fB, png_const_infop \fP\fIinfo_ptr\fP\fB, png_uint_32 \fP\fI*white_x\fP\fB, png_uint_32 \fP\fI*white_y\fP\fB, png_uint_32 \fP\fI*red_x\fP\fB, png_uint_32 \fP\fI*red_y\fP\fB, png_uint_32 \fP\fI*green_x\fP\fB, png_uint_32 \fP\fI*green_y\fP\fB, png_uint_32 \fP\fI*blue_x\fP\fB, png_uint_32 \fI*blue_y\fP\fB);\fP
share/man/man3/libpng.3:\fBpng_uint_32 png_get_cHRM_XYZ_fixed (png_structp \fP\fIpng_ptr\fP\fB, png_const_infop \fP\fIinfo_ptr\fP\fB, png_fixed_point \fP\fI*int_red_X\fP\fB, png_fixed_point \fP\fI*int_red_Y\fP\fB, png_fixed_point \fP\fI*int_red_Z\fP\fB, png_fixed_point \fP\fI*int_green_X\fP\fB, png_fixed_point \fP\fI*int_green_Y\fP\fB, png_fixed_point \fP\fI*int_green_Z\fP\fB, png_fixed_point \fP\fI*int_blue_X\fP\fB, png_fixed_point \fP\fI*int_blue_Y\fP\fB, png_fixed_point \fI*int_blue_Z\fP\fB);\fP
share/man/man3/libpng.3:\fBpng_uint_32 png_get_chunk_cache_max (png_const_structp \fIpng_ptr\fP\fB);\fP
share/man/man3/libpng.3:\fBpng_alloc_size_t png_get_chunk_malloc_max (png_const_structp \fIpng_ptr\fP\fB);\fP
share/man/man3/libpng.3:\fBpng_uint_32 png_get_gAMA_fixed (png_const_structp \fP\fIpng_ptr\fP\fB, png_const_infop \fP\fIinfo_ptr\fP\fB, png_uint_32 \fI*int_file_gamma\fP\fB);\fP
share/man/man3/libpng.3:\fBpng_uint_32 png_get_oFFs (png_const_structp \fP\fIpng_ptr\fP\fB, png_const_infop \fP\fIinfo_ptr\fP\fB, png_uint_32 \fP\fI*offset_x\fP\fB, png_uint_32 \fP\fI*offset_y\fP\fB, int \fI*unit_type\fP\fB);\fP
share/man/man3/libpng.3:\fBpng_uint_32 png_get_pHYs (png_const_structp \fP\fIpng_ptr\fP\fB, png_const_infop \fP\fIinfo_ptr\fP\fB, png_uint_32 \fP\fI*res_x\fP\fB, png_uint_32 \fP\fI*res_y\fP\fB, int \fI*unit_type\fP\fB);\fP
share/man/man3/libpng.3:\fBfloat png_get_pixel_aspect_ratio (png_const_structp \fP\fIpng_ptr\fP\fB, png_const_infop \fIinfo_ptr\fP\fB);\fP
share/man/man3/libpng.3:\fBpng_uint_32 png_get_pHYs_dpi (png_const_structp \fP\fIpng_ptr\fP\fB, png_const_infop \fP\fIinfo_ptr\fP\fB, png_uint_32 \fP\fI*res_x\fP\fB, png_uint_32 \fP\fI*res_y\fP\fB, int \fI*unit_type\fP\fB);\fP
share/man/man3/libpng.3:\fBpng_fixed_point png_get_pixel_aspect_ratio_fixed (png_const_structp \fP\fIpng_ptr\fP\fB, png_const_infop \fIinfo_ptr\fP\fB);\fP
share/man/man3/libpng.3:\fBpng_uint_32 png_get_pixels_per_inch (png_const_structp \fP\fIpng_ptr\fP\fB, png_const_infop \fIinfo_ptr\fP\fB);\fP
share/man/man3/libpng.3:\fBpng_uint_32 png_get_pixels_per_meter (png_const_structp \fP\fIpng_ptr\fP\fB, png_const_infop \fIinfo_ptr\fP\fB);\fP
share/man/man3/libpng.3:\fBvoid png_get_sCAL_fixed (png_const_structp \fP\fIpng_ptr\fP\fB, png_const_infop \fP\fIinfo_ptr\fP\fB, int* \fP\fIunit\fP\fB, png_fixed_pointp \fP\fIwidth\fP\fB, png_fixed_pointp \fIheight\fP\fB);\fP
share/man/man3/libpng.3:\fBpng_uint_32 png_get_text (png_const_structp \fP\fIpng_ptr\fP\fB, png_const_infop \fP\fIinfo_ptr\fP\fB, png_textp \fP\fI*text_ptr\fP\fB, int \fI*num_text\fP\fB);\fP
share/man/man3/libpng.3:\fBpng_uint_32 png_get_user_height_max (png_const_structp \fIpng_ptr\fP\fB);\fP
share/man/man3/libpng.3:\fBpng_uint_32 png_get_user_width_max (png_const_structp \fIpng_ptr\fP\fB);\fP
share/man/man3/libpng.3:\fBfloat png_get_x_offset_inches (png_const_structp \fP\fIpng_ptr\fP\fB, png_const_infop \fIinfo_ptr\fP\fB);\fP
share/man/man3/libpng.3:\fBpng_fixed_point png_get_x_offset_inches_fixed (png_structp \fP\fIpng_ptr\fP\fB, png_const_infop \fIinfo_ptr\fP\fB);\fP
share/man/man3/libpng.3:\fBpng_int_32 png_get_x_offset_microns (png_const_structp \fP\fIpng_ptr\fP\fB, png_const_infop \fIinfo_ptr\fP\fB);\fP
share/man/man3/libpng.3:\fBpng_int_32 png_get_x_offset_pixels (png_const_structp \fP\fIpng_ptr\fP\fB, png_const_infop \fIinfo_ptr\fP\fB);\fP
share/man/man3/libpng.3:\fBpng_uint_32 png_get_x_pixels_per_inch (png_const_structp \fP\fIpng_ptr\fP\fB, png_const_infop \fIinfo_ptr\fP\fB);\fP
share/man/man3/libpng.3:\fBpng_uint_32 png_get_x_pixels_per_meter (png_const_structp \fP\fIpng_ptr\fP\fB, png_const_infop \fIinfo_ptr\fP\fB);\fP
share/man/man3/libpng.3:\fBpng_fixed_point png_get_y_offset_inches_fixed (png_structp \fP\fIpng_ptr\fP\fB, png_const_infop \fIinfo_ptr\fP\fB);\fP
share/man/man3/libpng.3:\fBpng_int_32 png_get_y_offset_pixels (png_const_structp \fP\fIpng_ptr\fP\fB, png_const_infop \fIinfo_ptr\fP\fB);\fP
share/man/man3/libpng.3:\fBpng_uint_32 png_get_y_pixels_per_inch (png_const_structp \fP\fIpng_ptr\fP\fB, png_const_infop \fIinfo_ptr\fP\fB);\fP
share/man/man3/libpng.3:\fBpng_uint_32 png_get_y_pixels_per_meter (png_const_structp \fP\fIpng_ptr\fP\fB, png_const_infop \fIinfo_ptr\fP\fB);\fP
share/man/man3/libpng.3:\fBvoid png_set_alpha_mode_fixed (png_structp \fP\fIpng_ptr\fP\fB, int \fP\fImode\fP\fB, png_fixed_point \fIoutput_gamma\fP\fB);\fP
share/man/man3/libpng.3:\fBvoid png_set_background (png_structp \fP\fIpng_ptr\fP\fB, png_color_16p \fP\fIbackground_color\fP\fB, int \fP\fIbackground_gamma_code\fP\fB, int \fP\fIneed_expand\fP\fB, double \fIbackground_gamma\fP\fB);\fP
share/man/man3/libpng.3:\fBvoid png_set_background_fixed (png_structp \fP\fIpng_ptr\fP\fB, png_color_16p \fP\fIbackground_color\fP\fB, int \fP\fIbackground_gamma_code\fP\fB, int \fP\fIneed_expand\fP\fB, png_uint_32 \fIbackground_gamma\fP\fB);\fP
share/man/man3/libpng.3:\fBvoid png_set_check_for_invalid_index(png_structrp \fP\fIpng_ptr\fP\fB, int \fIallowed\fP\fB);\fP
share/man/man3/libpng.3:\fBvoid png_set_cHRM (png_structp \fP\fIpng_ptr\fP\fB, png_infop \fP\fIinfo_ptr\fP\fB, double \fP\fIwhite_x\fP\fB, double \fP\fIwhite_y\fP\fB, double \fP\fIred_x\fP\fB, double \fP\fIred_y\fP\fB, double \fP\fIgreen_x\fP\fB, double \fP\fIgreen_y\fP\fB, double \fP\fIblue_x\fP\fB, double \fIblue_y\fP\fB);\fP
share/man/man3/libpng.3:\fBvoid png_set_cHRM_fixed (png_structp \fP\fIpng_ptr\fP\fB, png_infop \fP\fIinfo_ptr\fP\fB, png_uint_32 \fP\fIwhite_x\fP\fB, png_uint_32 \fP\fIwhite_y\fP\fB, png_uint_32 \fP\fIred_x\fP\fB, png_uint_32 \fP\fIred_y\fP\fB, png_uint_32 \fP\fIgreen_x\fP\fB, png_uint_32 \fP\fIgreen_y\fP\fB, png_uint_32 \fP\fIblue_x\fP\fB, png_uint_32 \fIblue_y\fP\fB);\fP
share/man/man3/libpng.3:\fBvoid png_set_cHRM_XYZ_fixed (png_structp \fP\fIpng_ptr\fP\fB, png_infop \fP\fIinfo_ptr\fP\fB, png_fixed_point \fP\fIint_red_X\fP\fB, png_fixed_point \fP\fIint_red_Y\fP\fB, png_fixed_point \fP\fIint_red_Z\fP\fB, png_fixed_point \fP\fIint_green_X\fP\fB, png_fixed_point \fP\fIint_green_Y\fP\fB, png_fixed_point \fP\fIint_green_Z\fP\fB, png_fixed_point \fP\fIint_blue_X\fP\fB, png_fixed_point \fP\fIint_blue_Y\fP\fB, png_fixed_point \fIint_blue_Z\fP\fB);\fP
share/man/man3/libpng.3:\fBvoid png_set_chunk_cache_max (png_structp \fP\fIpng_ptr\fP\fB, png_uint_32 \fIuser_chunk_cache_max\fP\fB);\fP
share/man/man3/libpng.3:\fBvoid png_set_expand (png_structp \fIpng_ptr\fP\fB);\fP
share/man/man3/libpng.3:\fBvoid png_set_expand_16 (png_structp \fIpng_ptr\fP\fB);\fP
share/man/man3/libpng.3:\fBvoid png_set_expand_gray_1_2_4_to_8 (png_structp \fIpng_ptr\fP\fB);\fP
share/man/man3/libpng.3:\fBvoid png_set_filter_heuristics_fixed (png_structp \fP\fIpng_ptr\fP\fB, int \fP\fIheuristic_method\fP\fB, int \fP\fInum_weights\fP\fB, png_fixed_point_p \fP\fIfilter_weights\fP\fB, png_fixed_point_p \fIfilter_costs\fP\fB);\fP
share/man/man3/libpng.3:\fBvoid png_set_gamma_fixed (png_structp \fP\fIpng_ptr\fP\fB, png_uint_32 \fP\fIscreen_gamma\fP\fB, png_uint_32 \fIdefault_file_gamma\fP\fB);\fP
share/man/man3/libpng.3:\fBvoid png_set_gAMA_fixed (png_structp \fP\fIpng_ptr\fP\fB, png_infop \fP\fIinfo_ptr\fP\fB, png_uint_32 \fIfile_gamma\fP\fB);\fP
share/man/man3/libpng.3:\fBvoid png_set_chunk_malloc_max (png_structp \fP\fIpng_ptr\fP\fB, png_alloc_size_t \fIuser_chunk_cache_max\fP\fB);\fP
share/man/man3/libpng.3:\fBvoid png_set_oFFs (png_structp \fP\fIpng_ptr\fP\fB, png_infop \fP\fIinfo_ptr\fP\fB, png_uint_32 \fP\fIoffset_x\fP\fB, png_uint_32 \fP\fIoffset_y\fP\fB, int \fIunit_type\fP\fB);\fP
share/man/man3/libpng.3:\fBvoid png_set_pHYs (png_structp \fP\fIpng_ptr\fP\fB, png_infop \fP\fIinfo_ptr\fP\fB, png_uint_32 \fP\fIres_x\fP\fB, png_uint_32 \fP\fIres_y\fP\fB, int \fIunit_type\fP\fB);\fP
share/man/man3/libpng.3:\fBvoid png_set_quantize (png_structp \fP\fIpng_ptr\fP\fB, png_colorp \fP\fIpalette\fP\fB, int \fP\fInum_palette\fP\fB, int \fP\fImaximum_colors\fP\fB, png_uint_16p \fP\fIhistogram\fP\fB, int \fIfull_quantize\fP\fB);\fP
share/man/man3/libpng.3:\fBvoid png_set_rgb_to_gray_fixed (png_structp \fP\fIpng_ptr\fP\fB, int error_action png_uint_32 \fP\fIred\fP\fB, png_uint_32 \fIgreen\fP\fB);\fP
share/man/man3/libpng.3:\fBvoid png_set_sCAL_fixed (png_structp \fP\fIpng_ptr\fP\fB, png_infop \fP\fIinfo_ptr\fP\fB, int \fP\fIunit\fP\fB, png_fixed_point \fP\fIwidth\fP\fB, png_fixed_point \fIheight\fP\fB);\fP
share/man/man3/libpng.3:\fBvoid png_set_text (png_structp \fP\fIpng_ptr\fP\fB, png_infop \fP\fIinfo_ptr\fP\fB, png_textp \fP\fItext_ptr\fP\fB, int \fInum_text\fP\fB);\fP
share/man/man3/libpng.3:\fBvoid png_set_text_compression_level (png_structp \fP\fIpng_ptr\fP\fB, int \fIlevel\fP\fB);\fP
share/man/man3/libpng.3:\fBvoid png_set_text_compression_mem_level (png_structp \fP\fIpng_ptr\fP\fB, int \fImem_level\fP\fB);\fP
share/man/man3/libpng.3:\fBvoid png_set_text_compression_strategy (png_structp \fP\fIpng_ptr\fP\fB, int \fIstrategy\fP\fB);\fP
share/man/man3/libpng.3:\fBvoid png_set_text_compression_window_bits (png_structp \fP\fIpng_ptr\fP\fB, int \fIwindow_bits\fP\fB);\fP
share/man/man3/libpng.3:\fBvoid \fP\fIpng_set_text_compression_method\fP\fB, (png_structp \fP\fIpng_ptr\fP\fB, int \fImethod)\fP\fB);\fP
share/man/man3/libpng.3:\fBvoid png_set_user_limits (png_structp \fP\fIpng_ptr\fP\fB, png_uint_32 \fP\fIuser_width_max\fP\fB, png_uint_32 \fIuser_height_max\fP\fB);\fP
share/man/man3/libpng.3:Following is a copy of the libpng-manual.txt file that accompanies libpng.
share/man/man3/libpng.3:libpng-manual.txt - A description on how to use and modify libpng
share/man/man3/libpng.3:   IX. Changes to Libpng from version 1.0.x to 1.2.x
share/man/man3/libpng.3:    X. Changes to Libpng from version 1.0.x/1.2.x to 1.4.x
share/man/man3/libpng.3:   XI. Changes to Libpng from version 1.4.x to 1.5.x
share/man/man3/libpng.3:  XII. Changes to Libpng from version 1.5.x to 1.6.x
share/man/man3/libpng.3:file, example.c is a good starting point for using the library, as
share/man/man3/libpng.3:For examples of libpng usage, see the files "example.c", "pngtest.c",
share/man/man3/libpng.3:and png_info.  Both are internal structures that are no longer exposed
share/man/man3/libpng.3:single image.  As of 1.5.0 this structure is also not exposed.
share/man/man3/libpng.3:APIs.  Most of these are fairly obvious; for example types corresponding
share/man/man3/libpng.3:One exception is how non-integral numbers are handled.  For application
share/man/man3/libpng.3:macro PNG_FP_1 is defined in png.h along with a type (png_fixed_point)
share/man/man3/libpng.3:takes the corresponding fixed point integer arguments.  The fixed point
share/man/man3/libpng.3:API has the same name as the floating point one with "_fixed" appended.
share/man/man3/libpng.3:the full range of (png_fixed_point) (\-21474 to +21474).  When APIs require
share/man/man3/libpng.3:the header file and the text below for more information.
share/man/man3/libpng.3:should check the feature macros before using an API for maximum
share/man/man3/libpng.3:the next section ("Reading").
share/man/man3/libpng.3:using (typically) CPPFLAGS.  For example:
share/man/man3/libpng.3:other arithmetic calculations to fixed point, avoiding the need for fast
share/man/man3/libpng.3:If you need to make more extensive configuration changes - more than one or two
share/man/man3/libpng.3:A variety of methods exist to build libpng.  Not all of these support
share/man/man3/libpng.3:examine the intermediate file pnglibconf.dfn to find the full set of
share/man/man3/libpng.3:in a PNG file sequentially, briefly explaining the syntax and purpose
share/man/man3/libpng.3:of each one.  See example.c and png.h for more detail.  While
share/man/man3/libpng.3:progressive reading is covered in the next section, you will still
share/man/man3/libpng.3:Next, png_struct and png_info need to be allocated and initialized.  In
share/man/man3/libpng.3:When libpng encounters an error, it expects to longjmp back
share/man/man3/libpng.3:If you would rather avoid the complexity of setjmp/longjmp issues,
share/man/man3/libpng.3:callback returns 0.  If you want the existing behavior you should set the global
share/man/man3/libpng.3:the 'row' and 'pass' refer to the next row to be handled.  For the
share/man/man3/libpng.3:                 all known chunks except for the IHDR,
share/man/man3/libpng.3:Here is an example of the usage of png_set_keep_unknown_chunks(),
share/man/man3/libpng.3:      /* except for vpAg: */
share/man/man3/libpng.3:large as 2^(31\-1 (0x7fffffff), or about 2.147 billion rows and columns.
share/man/man3/libpng.3:   png_set_user_limits(png_ptr, width_max, height_max);
share/man/man3/libpng.3:   width_max = png_get_user_width_max(png_ptr);
share/man/man3/libpng.3:   height_max = png_get_user_height_max(png_ptr);
share/man/man3/libpng.3:   png_set_chunk_cache_max(png_ptr, user_chunk_cache_max);
share/man/man3/libpng.3:where 0x7fffffffL means unlimited.  You can retrieve this limit with
share/man/man3/libpng.3:   chunk_cache_max = png_get_chunk_cache_max(png_ptr);
share/man/man3/libpng.3:   png_set_chunk_malloc_max(png_ptr, user_chunk_malloc_max);
share/man/man3/libpng.3:   chunk_malloc_max = png_get_chunk_malloc_max(png_ptr);
share/man/man3/libpng.3:Any chunks that would cause either of these limits to be exceeded will
share/man/man3/libpng.3:header.  In earlier versions png_set_gamma() existed but behaved incorrectly if
share/man/man3/libpng.3:exist.
share/man/man3/libpng.3:You give libpng the encoding expected by your system expressed as a 'gamma'
share/man/man3/libpng.3:or you can use the fixed point equivalent:
share/man/man3/libpng.3:   png_set_gamma_fixed(png_ptr, PNG_FP_1*screen_gamma,
share/man/man3/libpng.3:approximation to the IEC standard for display systems (sRGB).  If images are
share/man/man3/libpng.3:   PNG_GAMMA_LINEAR: Just the fixed point value for 1.0 - indicates
share/man/man3/libpng.3:                     that the system expects data with no gamma
share/man/man3/libpng.3:You would use the linear (unencoded) value if you need to process the pixel
share/man/man3/libpng.3:The output_gamma value expresses how to decode the output values, not how
share/man/man3/libpng.3:describe the overall gamma of a computer display system; for example 2.2 for
share/man/man3/libpng.3:an sRGB conformant system.  The values are scaled by 100000 in the _fixed
share/man/man3/libpng.3:opaque pixels however pixels with lower alpha values are not encoded,
share/man/man3/libpng.3:highly unexpected!
share/man/man3/libpng.3:behind it.  sRGB is defined to be approximated by a PNG gAMA chunk value of
share/man/man3/libpng.3:value expresses how to *decode* the image for display, not how the original
share/man/man3/libpng.3:sRGB itself, and earlier TV standards, actually use a more complex transform
share/man/man3/libpng.3:(a linear portion then a gamma 2.4 power law) than PNG can express.  (PNG is
share/man/man3/libpng.3:extra viewing correction used in early Mac display systems was implemented as
share/man/man3/libpng.3:difficult and most PNG gamma correction only requires an approximate value.
share/man/man3/libpng.3:NOTE: the values can be passed to either the fixed or floating
share/man/man3/libpng.3:contribution of the pixel to the corresponding final output pixel.
share/man/man3/libpng.3:unnecessarily complex.
share/man/man3/libpng.3:gamma encoding is used.  In addition all non-transparent pixel values,
share/man/man3/libpng.3:convert the pixels to an associated form before returning them to your
share/man/man3/libpng.3:possible to optimize the handling of alpha by storing the opaque pixels in
share/man/man3/libpng.3:opaque pixels in the standard, linear, format.  The accuracy required for
share/man/man3/libpng.3:standard alpha composition is relatively low, because the pixels are
share/man/man3/libpng.3:this case!)  This is the 'OPTIMIZED' mode.  For this mode a pixel is
share/man/man3/libpng.3:treated as opaque only if the alpha value is equal to the maximum value.
share/man/man3/libpng.3:perform arithmetic on the pixels without decoding them,
share/man/man3/libpng.3:pre-multiplied pixel values will be gamma encoded but
share/man/man3/libpng.3:supports it, use png_set_expand_16() to force all
share/man/man3/libpng.3:except that completely opaque pixels are gamma encoded according to
share/man/man3/libpng.3:the screen_gamma value.  Pixels with alpha less than 1.0
share/man/man3/libpng.3:compositing software can simply copy opaque pixels to
share/man/man3/libpng.3:non-opaque pixels.
share/man/man3/libpng.3:partial pixel coverage (as opposed to broad area
share/man/man3/libpng.3:representation of non-opaque pixels are irrelevant.
share/man/man3/libpng.3:If you don't have to deal with bugs in software or hardware, or if you can fix
share/man/man3/libpng.3:   png_set_expand_16(png_ptr);
share/man/man3/libpng.3:If you are using the high level interface, don't call png_set_expand_16();
share/man/man3/libpng.3:You can avoid the expansion to 16-bit components with this mode, but you
share/man/man3/libpng.3:The following are examples of calls to png_set_alpha_mode to achieve the
share/man/man3/libpng.3:    png_set_expand_16(pp);
share/man/man3/libpng.3:If you just need to composite the PNG image onto an existing background
share/man/man3/libpng.3:setting.  In this case you just copy completely opaque pixels to the
share/man/man3/libpng.3:output.  For pixels that are not completely transparent (you just skip
share/man/man3/libpng.3:your hardware/software fixed!  (The OPTIMIZED approach is slightly
share/man/man3/libpng.3:png_set_background() to remove it by compositing against a fixed color.  Don't
share/man/man3/libpng.3:call png_set_strip_alpha() to do this - it will leave spurious pixel values in
share/man/man3/libpng.3:   png_set_expand(png_ptr); png_set_scale_16(png_ptr);
share/man/man3/libpng.3:   If you must get exactly the same inaccurate results
share/man/man3/libpng.3:   png_set_expand_16(png_ptr);
share/man/man3/libpng.3:In either case palette image data will be expanded to RGB.  If you just want
share/man/man3/libpng.3:prior to libpng-1.5.4.  Because the failure may result in unexpected warnings or
share/man/man3/libpng.3:    PNG_TRANSFORM_PACKING       Expand 1, 2 and 4-bit
share/man/man3/libpng.3:                                pixels to LSB first
share/man/man3/libpng.3:    PNG_TRANSFORM_EXPAND        Perform set_expand()
share/man/man3/libpng.3:    PNG_TRANSFORM_SHIFT         Normalize pixels to the
share/man/man3/libpng.3:    PNG_TRANSFORM_GRAY_TO_RGB   Expand grayscale samples
share/man/man3/libpng.3:    PNG_TRANSFORM_EXPAND_16     Expand samples to 16 bits
share/man/man3/libpng.3:(This excludes setting a background color, doing gamma transformation,
share/man/man3/libpng.3:where row_pointers is an array of pointers to the pixel data for each row:
share/man/man3/libpng.3:If you know your image size and pixel size ahead of time, you can allocate
share/man/man3/libpng.3:   if (width > PNG_UINT_32_MAX/pixel_size)
share/man/man3/libpng.3:          width*pixel_size);
share/man/man3/libpng.3:resulting in unexpected behavior.  Libpng-1.5.4 no longer does this.
share/man/man3/libpng.3:                     in pixels (up to 2^31).
share/man/man3/libpng.3:                     in pixels (up to 2^31).
share/man/man3/libpng.3:pointer into the info_ptr is returned for any complex types.
share/man/man3/libpng.3:gamma when combining semitransparent pixels with the background color, and,
share/man/man3/libpng.3:since libpng-1.6.0, when converting between 8-bit sRGB and 16-bit linear pixels
share/man/man3/libpng.3:    png_get_gAMA_fixed(png_ptr, info_ptr, &int_file_gamma);
share/man/man3/libpng.3:    png_get_cHRM(png_ptr, info_ptr,  &white_x, &white_y, &red_x,
share/man/man3/libpng.3:                     &red_y, &green_x, &green_y, &blue_x, &blue_y)
share/man/man3/libpng.3:    png_get_cHRM_fixed(png_ptr, info_ptr, &int_white_x,
share/man/man3/libpng.3:                     &int_white_y, &int_red_x, &int_red_y,
share/man/man3/libpng.3:                     &int_green_x, &int_green_y, &int_blue_x,
share/man/man3/libpng.3:    png_get_cHRM_XYZ_fixed(png_ptr, info_ptr, &int_red_X, &int_red_Y,
share/man/man3/libpng.3:    {white,red,green,blue}_{x,y}
share/man/man3/libpng.3:                     means that the pixel data is in the
share/man/man3/libpng.3:    num_comments   = png_get_text(png_ptr, info_ptr,
share/man/man3/libpng.3:                     &text_ptr, &num_text);
share/man/man3/libpng.3:    text_ptr       - array of png_text holding image
share/man/man3/libpng.3:    text_ptr[i].compression - type of compression used
share/man/man3/libpng.3:                 on "text" PNG_TEXT_COMPRESSION_NONE
share/man/man3/libpng.3:    text_ptr[i].key   - keyword for comment.  Must contain
share/man/man3/libpng.3:    text_ptr[i].text  - text comments for current
share/man/man3/libpng.3:    text_ptr[i].text_length - length of text string,
share/man/man3/libpng.3:    text_ptr[i].itxt_length - length of itxt string,
share/man/man3/libpng.3:    text_ptr[i].lang  - language of comment (empty
share/man/man3/libpng.3:    text_ptr[i].lang_key  - keyword in UTF-8
share/man/man3/libpng.3:    Note that the itxt_length, lang, and lang_key
share/man/man3/libpng.3:    members of the text_ptr structure only exist when the
share/man/man3/libpng.3:    num_text       - number of comments (same as
share/man/man3/libpng.3:    Note while png_set_text() will accept text, language,
share/man/man3/libpng.3:    structure returned by png_get_text will always contain
share/man/man3/libpng.3:    png_get_oFFs(png_ptr, info_ptr, &offset_x, &offset_y,
share/man/man3/libpng.3:    offset_x       - positive offset from the left edge
share/man/man3/libpng.3:    png_get_pHYs(png_ptr, info_ptr, &res_x, &res_y,
share/man/man3/libpng.3:    res_x          - pixels/unit physical resolution in
share/man/man3/libpng.3:                     x direction
share/man/man3/libpng.3:    res_y          - pixels/unit physical resolution in
share/man/man3/libpng.3:                     x direction
share/man/man3/libpng.3:    width       - width of a pixel in physical scale units
share/man/man3/libpng.3:    height      - height of a pixel in physical scale units
share/man/man3/libpng.3:    width       - width of a pixel in physical scale units
share/man/man3/libpng.3:                  (expressed as a string)
share/man/man3/libpng.3:    height      - height of a pixel in physical scale units
share/man/man3/libpng.3:         PNG_HAVE_IHDR  (0x01)
share/man/man3/libpng.3:         PNG_HAVE_PLTE  (0x02)
share/man/man3/libpng.3:         PNG_AFTER_IDAT (0x08)
share/man/man3/libpng.3:    res_x = png_get_x_pixels_per_meter(png_ptr,
share/man/man3/libpng.3:    res_y = png_get_y_pixels_per_meter(png_ptr,
share/man/man3/libpng.3:    res_x_and_y = png_get_pixels_per_meter(png_ptr,
share/man/man3/libpng.3:    res_x = png_get_x_pixels_per_inch(png_ptr,
share/man/man3/libpng.3:    res_y = png_get_y_pixels_per_inch(png_ptr,
share/man/man3/libpng.3:    res_x_and_y = png_get_pixels_per_inch(png_ptr,
share/man/man3/libpng.3:    aspect_ratio = png_get_pixel_aspect_ratio(png_ptr,
share/man/man3/libpng.3:       the data is not present or if res_x is 0;
share/man/man3/libpng.3:       res_x_and_y is 0 if res_x != res_y
share/man/man3/libpng.3:       come out to exactly even number.  For example,
share/man/man3/libpng.3:       72 dpi is stored as 0.28346 pixels/meter, and
share/man/man3/libpng.3:    x_offset = png_get_x_offset_microns(png_ptr, info_ptr);
share/man/man3/libpng.3:    x_offset = png_get_x_offset_inches(png_ptr, info_ptr);
share/man/man3/libpng.3:       x and y are 0] if the data is not present or if the
share/man/man3/libpng.3:       chunk is present but the unit is the pixel.  The
share/man/man3/libpng.3:       remark about inexact inch conversions applies here
share/man/man3/libpng.3:needed to hold a row (expand, filler, gray_to_rgb, etc.).
share/man/man3/libpng.3:A quick word about text_ptr and num_text.  PNG stores comments in
share/man/man3/libpng.3:keyword/text pairs, one pair per chunk, with no limit on the number
share/man/man3/libpng.3:of text chunks, and a 2^31 byte limit on their size.  While there are
share/man/man3/libpng.3:strings.  It is strongly suggested that keywords and text be sensible
share/man/man3/libpng.3:There is also no requirement to have text after the keyword.
share/man/man3/libpng.3:The text_ptr is an array of png_text structures, each holding a
share/man/man3/libpng.3:a text string.  The text string, language code, and translated
share/man/man3/libpng.3:keyword may be empty or NULL pointers.  The keyword/text
share/man/man3/libpng.3:However, some or all of the text chunks may be after the image, so, to
share/man/man3/libpng.3:make sure you have read all the text chunks, don't mess with these
share/man/man3/libpng.3:transformations, for example both adding and removing the alpha channel, you
share/man/man3/libpng.3:as the image data in a tRNS chunk, so this is what libpng expects for this data.
share/man/man3/libpng.3:The color used for the background value depends on the need_expand argument as
share/man/man3/libpng.3:For example, 4 bit/pixel paletted or grayscale data will be returned
share/man/man3/libpng.3:2 pixels/byte with the leftmost pixel in the high-order bits of the
share/man/man3/libpng.3:        bit_depth < 8) png_set_expand_gray_1_2_4_to_8(png_ptr);
share/man/man3/libpng.3:The first two functions are actually aliases for png_set_expand(), added
share/man/man3/libpng.3:in libpng version 1.0.4, with the function names expanded to improve code
share/man/man3/libpng.3:As of libpng version 1.2.9, png_set_expand_gray_1_2_4_to_8() was
share/man/man3/libpng.3:added.  It expands the sample depth without changing tRNS to alpha.
share/man/man3/libpng.3:As of libpng version 1.5.2, png_set_expand_16() was added.  It behaves as
share/man/man3/libpng.3:png_set_expand(); however, the resultant channels have 16 bits rather than 8.
share/man/man3/libpng.3:      png_set_expand_16(png_ptr);
share/man/man3/libpng.3:8 bits per channel, this will strip the pixels down to 8-bit.
share/man/man3/libpng.3:data (for example if you convert it to a bitmap mask) it is possible to have
share/man/man3/libpng.3:As of libpng version 1.5.2, almost all useful expansions are supported, the
share/man/man3/libpng.3:major ommissions are conversion of grayscale to indexed images (which can be
share/man/man3/libpng.3:done trivially in the application) and conversion of indexed to grayscale (which
share/man/man3/libpng.3:indexed with depth<8, other numerals represent the color type, "T" means
share/man/man3/libpng.3:means tRNS or alpha is present but all pixels in the image are opaque.
share/man/man3/libpng.3:Within the matrix,
share/man/man3/libpng.3:     "X" means the transformation is obtained by png_set_expand().
share/man/man3/libpng.3:         png_set_expand_gray_1_2_4_to_8() (and by png_set_expand()
share/man/man3/libpng.3:         png_set_expand_palette_to_rgb().
share/man/man3/libpng.3:PNG files pack pixels of bit depths 1, 2, and 4 into bytes as small as
share/man/man3/libpng.3:they can, resulting in, for example, 8 pixels per byte for 1 bit
share/man/man3/libpng.3:files.  This code expands to 1 pixel per byte without changing the
share/man/man3/libpng.3:values of the pixels:
share/man/man3/libpng.3:PNG files have possible bit depths of 1, 2, 4, 8, and 16.  All pixels
share/man/man3/libpng.3:stored in a PNG image have been "scaled" or "shifted" up to the next
share/man/man3/libpng.3:to convert the PNG pixel data back to the original bit depth of the
share/man/man3/libpng.3:image.  This call reduces the pixels back down to the original bit depth:
share/man/man3/libpng.3:PNG files store 3-color pixels in red, green, blue order.  This code
share/man/man3/libpng.3:changes the storage of the pixels to blue, green, red:
share/man/man3/libpng.3:PNG files store RGB pixels packed into 3 or 6 bytes. This code expands them
share/man/man3/libpng.3:opaque alpha channel, use filler=0xff or 0xffff and PNG_FILLER_AFTER which
share/man/man3/libpng.3:will generate RGBA pixels.
share/man/man3/libpng.3:where "filler" contains the alpha value to assign to each pixel.
share/man/man3/libpng.3:                      image has any pixel where
share/man/man3/libpng.3:                      image has any pixel where
share/man/man3/libpng.3:In the corresponding fixed point API the red_weight and green_weight values are
share/man/man3/libpng.3:       png_fixed_point red_weight,
share/man/man3/libpng.3:       png_fixed_point green_weight);
share/man/man3/libpng.3:1 if there were any non-gray pixels.  Background and sBIT data
share/man/man3/libpng.3:Libpng uses an integer approximation:
share/man/man3/libpng.3:header, even if you don't want to use the color in a bKGD chunk, if one exists.
share/man/man3/libpng.3:color.  The function takes two arguments, background_gamma_mode and need_expand
share/man/man3/libpng.3:           PNG_BACKGROUND_GAMMA_FILE, 1/*needs to be expanded*/, 1);
share/man/man3/libpng.3:           PNG_BACKGROUND_GAMMA_SCREEN, 0/*do not expand*/, 1);
share/man/man3/libpng.3:index and for low bit greyscale images the color is a reduced bit value in
share/man/man3/libpng.3:If you didn't call png_set_gamma() before reading the file header, for example
share/man/man3/libpng.3:pass a palette that is larger than maximum_colors, the file will
share/man/man3/libpng.3:maximum_colors.  If there is a histogram, libpng will use it to make
share/man/man3/libpng.3:            max_screen_colors, histogram, 1);
share/man/man3/libpng.3:PNG files store 16-bit pixels in network byte order (big-endian,
share/man/man3/libpng.3:If you are using packed-pixel images (1, 2, or 4 bits/pixel), and you
share/man/man3/libpng.3:need to change the order the pixels are packed into bytes, you can use:
share/man/man3/libpng.3:the existing ones meets your needs.  This is done by setting a callback
share/man/man3/libpng.3:See pngtest.c for a working example.  Your function will be called
share/man/man3/libpng.3:unexpected results unless the row is actually being processed at the moment they
share/man/man3/libpng.3:find the output pixel (x,y) given an interlaced sub-image pixel (row,col,pass).
share/man/man3/libpng.3:png_get_user_transform_ptr().  For example:
share/man/man3/libpng.3:but you must call the function here if you want libpng to handle expansion
share/man/man3/libpng.3:varies among applications, no example will be given.  If you
share/man/man3/libpng.3:You can point to void or char or whatever you use for pixels.
share/man/man3/libpng.3:on an 8x8 grid.  This number is defined (from libpng 1.5) as
share/man/man3/libpng.3:mentioned in the PNG specification is to expand each pixel to cover
share/man/man3/libpng.3:those pixels that have not been read yet (the "rectangle" method).
share/man/man3/libpng.3:smooths out as more pixels are read.  The other method is the "sparkle"
share/man/man3/libpng.3:method, where pixels are drawn only in their final locations, with the
share/man/man3/libpng.3:but tends to be slower, as there are more pixels to put in the rows.
share/man/man3/libpng.3:If, as is likely, you want libpng to expand the images, call this before
share/man/man3/libpng.3:will distribute the pixels from the current pass to the correct place in
share/man/man3/libpng.3:is exactly the same.  If you are planning on displaying the image
share/man/man3/libpng.3:not the data.  Each pass only writes the pixels appropriate for that
share/man/man3/libpng.3:before except pass the row buffer in the third parameter, and leave
share/man/man3/libpng.3:certainly need to distribute the pixels from each sub-image to the
share/man/man3/libpng.3:not even exist because either their width or height ends up zero.
share/man/man3/libpng.3:produce optimal code to make a pixel-by-pixel transformation of an
share/man/man3/libpng.3:macros to help that tell you where to place the pixels in the output image.
share/man/man3/libpng.3:Because the interlacing scheme is rectangular - sub-image pixels are always
share/man/man3/libpng.3:starting column and row in the output image of the first pixel plus the
share/man/man3/libpng.3:spacing between each pixel.  As of libpng 1.5 there are four macros to
share/man/man3/libpng.3:   png_uint_32 x = PNG_PASS_START_COL(pass);
share/man/man3/libpng.3:   png_uint_32 xStep = 1U << PNG_PASS_COL_SHIFT(pass);
share/man/man3/libpng.3:      png_uint_32 input_x = 0;
share/man/man3/libpng.3:      png_uint_32 output_x = PNG_PASS_START_COL(pass);
share/man/man3/libpng.3:      while (output_x < output_image_width)
share/man/man3/libpng.3:         image[output_y][output_x] =
share/man/man3/libpng.3:             subimage[pass][input_y][input_x++];
share/man/man3/libpng.3:         output_x += xStep;
share/man/man3/libpng.3:returned as shifts.  This is possible because the pixels in the subimages
share/man/man3/libpng.3:are always a power of 2 apart - 1, 2, 4 or 8 pixels - in the original
share/man/man3/libpng.3:   png_uint_32 output_x = PNG_COL_FROM_PASS_COL(input_x, pass);
share/man/man3/libpng.3:   int col_in_pass = PNG_COL_IN_INTERLACE_PASS(output_x, pass);
share/man/man3/libpng.3:of the pass in addition to the above to be sure the pass even exists!
share/man/man3/libpng.3:is if you are processing PNG files on a pixel-by-pixel basis and don't want
share/man/man3/libpng.3:not what you want if you expect to read something beyond the end of
share/man/man3/libpng.3:are allowed for the data type identified in the mask, such as text or
share/man/man3/libpng.3:function is responsible for freeing any existing data that might be present,
share/man/man3/libpng.3:If you allocated text_ptr.text, text_ptr.lang, and text_ptr.translated_keyword
share/man/man3/libpng.3:separately, do not transfer responsibility for freeing text_ptr to libpng,
share/man/man3/libpng.3:because when libpng fills a png_text structure it combines these members with
share/man/man3/libpng.3:the key member, and png_free_data() will free only text_ptr.key.  Similarly,
share/man/man3/libpng.3:if you transfer responsibility for free'ing text_ptr from libpng to your
share/man/man3/libpng.3:For a more compact example of reading a PNG image, see the file example.c.
share/man/man3/libpng.3: /*  An example code fragment of how you would
share/man/man3/libpng.3:       libpng skipping that number of bytes on the next
share/man/man3/libpng.3:       call - it is up to you to ensure that the next call
share/man/man3/libpng.3:Next, png_struct and png_info need to be allocated and initialized.
share/man/man3/libpng.3:"read_ptr" and "write_ptr".  Look at pngtest.c, for example.
share/man/man3/libpng.3:error handling.  When libpng encounters an error, it expects to
share/man/man3/libpng.3:If you would rather avoid the complexity of setjmp/longjmp issues,
share/man/man3/libpng.3:Checking for invalid palette index on write was added at libpng
share/man/man3/libpng.3:1.5.10.  If a pixel contains an invalid (out-of-range) index libpng issues
share/man/man3/libpng.3:   png_set_check_for_invalid_index(png_ptr, 0);
share/man/man3/libpng.3:any invalid pixels are written as-is by the encoder, resulting in an
share/man/man3/libpng.3:responsible for ensuring that the pixel indexes are in range when it writes
share/man/man3/libpng.3:it has also been written out.  The 'row' and 'pass' refer to the next row to be
share/man/man3/libpng.3:in some cases, like if you need to write PNG files extremely fast and
share/man/man3/libpng.3:maximum possible compression at the expense of slower writing.  If you
share/man/man3/libpng.3:the previous row of pixels will be stored in case it's needed later),
share/man/man3/libpng.3:data.  See the Compression Library (zlib.h and algorithm.txt, distributed
share/man/man3/libpng.3:    /* Set zlib parameters for text compression
share/man/man3/libpng.3:    png_set_text_compression_mem_level(png_ptr, 8);
share/man/man3/libpng.3:    png_set_text_compression_strategy(png_ptr,
share/man/man3/libpng.3:    png_set_text_compression_window_bits(png_ptr, 15);
share/man/man3/libpng.3:    png_set_text_compression_method(png_ptr, 8);
share/man/man3/libpng.3:are allowed to write after the image is the text chunks and the time
share/man/man3/libpng.3:their data types, see png.h.  For explanations of what the fields
share/man/man3/libpng.3:                     in pixels (up to 2^31).
share/man/man3/libpng.3:                     in pixels (up to 2^31).
share/man/man3/libpng.3:    png_set_gAMA_fixed(png_ptr, info_ptr, int_file_gamma);
share/man/man3/libpng.3:    png_set_cHRM(png_ptr, info_ptr,  white_x, white_y, red_x, red_y,
share/man/man3/libpng.3:                     green_x, green_y, blue_x, blue_y)
share/man/man3/libpng.3:    png_set_cHRM_fixed(png_ptr, info_ptr, int_white_x, int_white_y,
share/man/man3/libpng.3:                     int_red_x, int_red_y, int_green_x, int_green_y,
share/man/man3/libpng.3:                     int_blue_x, int_blue_y)
share/man/man3/libpng.3:    png_set_cHRM_XYZ_fixed(png_ptr, info_ptr, int_red_X, int_red_Y,
share/man/man3/libpng.3:    {white,red,green,blue}_{x,y}
share/man/man3/libpng.3:                     the sRGB chunk means that the pixel
share/man/man3/libpng.3:                     sRGB chunk means that the pixel
share/man/man3/libpng.3:    png_set_text(png_ptr, info_ptr, text_ptr, num_text);
share/man/man3/libpng.3:    text_ptr       - array of png_text holding image
share/man/man3/libpng.3:    text_ptr[i].compression - type of compression used
share/man/man3/libpng.3:                 on "text" PNG_TEXT_COMPRESSION_NONE
share/man/man3/libpng.3:    text_ptr[i].key   - keyword for comment.  Must contain
share/man/man3/libpng.3:    text_ptr[i].text  - text comments for current
share/man/man3/libpng.3:    text_ptr[i].text_length - length of text string,
share/man/man3/libpng.3:    text_ptr[i].itxt_length - length of itxt string,
share/man/man3/libpng.3:    text_ptr[i].lang  - language of comment (NULL or
share/man/man3/libpng.3:    text_ptr[i].translated_keyword  - keyword in UTF-8 (NULL
share/man/man3/libpng.3:    Note that the itxt_length, lang, and lang_key
share/man/man3/libpng.3:    members of the text_ptr structure only exist when the
share/man/man3/libpng.3:    num_text       - number of comments
share/man/man3/libpng.3:    png_set_oFFs(png_ptr, info_ptr, offset_x, offset_y,
share/man/man3/libpng.3:    offset_x  - positive offset from the left
share/man/man3/libpng.3:    png_set_pHYs(png_ptr, info_ptr, res_x, res_y,
share/man/man3/libpng.3:    res_x       - pixels/unit physical resolution
share/man/man3/libpng.3:                  in x direction
share/man/man3/libpng.3:    res_y       - pixels/unit physical resolution
share/man/man3/libpng.3:    width       - width of a pixel in physical scale units
share/man/man3/libpng.3:    height      - height of a pixel in physical scale units
share/man/man3/libpng.3:    width       - width of a pixel in physical scale units
share/man/man3/libpng.3:                  expressed as a string
share/man/man3/libpng.3:    height      - height of a pixel in physical scale units
share/man/man3/libpng.3:A quick word about text and num_text.  text is an array of png_text
share/man/man3/libpng.3:structures.  num_text is the number of valid structures in the array.
share/man/man3/libpng.3:Each png_text structure holds a language code, a keyword, a text value,
share/man/man3/libpng.3:However, you can store text either compressed or uncompressed, unlike
share/man/man3/libpng.3:text compressed, set the compression type to PNG_TEXT_COMPRESSION_NONE.
share/man/man3/libpng.3:Until text gets around a few hundred bytes, it is not worth compressing it.
share/man/man3/libpng.3:After the text has been written out to the file, the compression type
share/man/man3/libpng.3:The keyword-text pairs work like this.  Keywords should be short
share/man/man3/libpng.3:some text before the image and some after.  For example, you may want
share/man/man3/libpng.3:words, not abbreviations.  Keywords and text are in the ISO 8859-1
share/man/man3/libpng.3:with basic ASCII, and avoid machine specific character set extensions
share/man/man3/libpng.3:you can leave off the text string on non-compressed pairs.
share/man/man3/libpng.3:Compressed pairs must have a text string, as only the text string
share/man/man3/libpng.3:"Creation Time" tEXt chunk is not expected to be automatically changed
share/man/man3/libpng.3:next following png_write_info_before_PLTE, png_write_info, or png_write_end
share/man/man3/libpng.3:Here is an example of writing two private chunks, prVt and miNE:
share/man/man3/libpng.3:      /* Deal with unknown chunk location bug in 1.5.x and earlier */
share/man/man3/libpng.3:                                pixels to LSB first
share/man/man3/libpng.3:    PNG_TRANSFORM_SHIFT         Normalize pixels to the
share/man/man3/libpng.3:data.  For example, don't swap red and blue on grayscale data.
share/man/man3/libpng.3:PNG files store RGB pixels packed into 3 or 6 bytes.  This code tells
share/man/man3/libpng.3:the library to strip input data that has 4 or 8 bytes per pixel down
share/man/man3/libpng.3:bytes per pixel).
share/man/man3/libpng.3:PNG_FILLER_AFTER, depending upon whether the filler byte in the pixel
share/man/man3/libpng.3:PNG files pack pixels of bit depths 1, 2, and 4 into bytes as small as
share/man/man3/libpng.3:they can, resulting in, for example, 8 pixels per byte for 1 bit files.
share/man/man3/libpng.3:If the data is supplied at 1 pixel per byte, use this code, which will
share/man/man3/libpng.3:correctly pack the pixels into a single byte:
share/man/man3/libpng.3:PNG files store 16-bit pixels in network byte order (big-endian,
share/man/man3/libpng.3:If you are using packed-pixel images (1, 2, or 4 bits/pixel), and you
share/man/man3/libpng.3:need to change the order the pixels are packed into bytes, you can use:
share/man/man3/libpng.3:PNG files store 3 color pixels in red, green, blue order.  This code
share/man/man3/libpng.3:one. This code would be used if the pixels are supplied with this reversed
share/man/man3/libpng.3:the existing ones meets your needs.  This is done by setting a callback
share/man/man3/libpng.3:See pngtest.c for a working example.  Your function will be called
share/man/man3/libpng.3:find the output pixel (x,y) given an interlaced sub-image pixel (row,col,pass).
share/man/man3/libpng.3:For example:
share/man/man3/libpng.3:output on the next scanline, and every 25 lines thereafter, unless
share/man/man3/libpng.3:If nrows is too small (less than about 10 lines for a 640 pixel wide
share/man/man3/libpng.3:You can point to void or char or whatever you use for pixels.
share/man/man3/libpng.3:for details of which pixels to write when.
share/man/man3/libpng.3:take advantage of the interlacing and even then the image has to be exactly
share/man/man3/libpng.3:adjacent pixels and these are not available until all the passes have been
share/man/man3/libpng.3:made some pixel-by-pixel transformation to it, as described in the read
share/man/man3/libpng.3:are allowed for the data type identified in the mask, such as text or
share/man/man3/libpng.3:For example, to transfer responsibility for some data from a read structure
share/man/man3/libpng.3:If you allocated text_ptr.text, text_ptr.lang, and text_ptr.translated_keyword
share/man/man3/libpng.3:separately, do not transfer responsibility for freeing text_ptr to libpng,
share/man/man3/libpng.3:because when libpng fills a png_text structure it combines these members with
share/man/man3/libpng.3:the key member, and png_free_data() will free only text_ptr.key.  Similarly,
share/man/man3/libpng.3:if you transfer responsibility for free'ing text_ptr from libpng to your
share/man/man3/libpng.3:For a more compact example of writing a PNG image, see the file example.c.
share/man/man3/libpng.3:   png_uint_32  width   Image width in pixels (columns)
share/man/man3/libpng.3:   png_uint_32  height  Image height in pixels (rows)
share/man/man3/libpng.3:The pixels (samples) of the image have one to four channels whose components
share/man/man3/libpng.3:and matches the 8-bit format expected by typical display devices.
share/man/man3/libpng.3:When an alpha channel is present it is expected to denote pixel coverage
share/man/man3/libpng.3:The image data is encoded as small integers, value 0..255, that index the
share/man/man3/libpng.3:entries in the color-map.  One integer (one byte) is stored for each pixel.
share/man/man3/libpng.3:   PNG_FORMAT_FLAG_ALPHA    0x01 format with an alpha channel
share/man/man3/libpng.3:   PNG_FORMAT_FLAG_COLOR    0x02 color format: otherwise grayscale
share/man/man3/libpng.3:   PNG_FORMAT_FLAG_LINEAR   0x04 png_uint_16 channels else png_byte
share/man/man3/libpng.3:   PNG_FORMAT_FLAG_COLORMAP 0x08 libpng use only
share/man/man3/libpng.3:   PNG_FORMAT_FLAG_BGR      0x10 BGR colors, else order is RGB
share/man/man3/libpng.3:   PNG_FORMAT_FLAG_AFIRST   0x20 alpha channel comes first
share/man/man3/libpng.3:of the components of the pixels of the image.
share/man/man3/libpng.3:indicate a luminance (gray) channel.  The component order within the pixel
share/man/man3/libpng.3:format of the color-map may be extracted using the following macro.
share/man/man3/libpng.3:pixels in the image.  The PNG_IMAGE_PIXEL_ macros return corresponding values
share/man/man3/libpng.3:for the pixels and will always return 1 after a call to
share/man/man3/libpng.3:    Returns the size in bytes of a single component of a pixel or color-map
share/man/man3/libpng.3:    color-mapped it is the size of one color-map entry (and image pixels are
share/man/man3/libpng.3:    one byte in size), otherwise it is the size of one image pixel.
share/man/man3/libpng.3:   a fixed number determined by the format so can easily be allocated on the
share/man/man3/libpng.3:   /* The maximum size of the color-map required by the format expressed in a
share/man/man3/libpng.3:Corresponding information about the pixels
share/man/man3/libpng.3:   The number of separate channels (components) in a pixel; 1 for a
share/man/man3/libpng.3:   The size, in bytes, of each component in a pixel; 1 for a color-mapped
share/man/man3/libpng.3:   The size, in bytes, of a complete pixel; 1 for a color-mapped image.
share/man/man3/libpng.3:   plus any padding bytes that your application might need, for example
share/man/man3/libpng.3:   to start the next row on a 4-byte boundary.
share/man/man3/libpng.3:  PNG_IMAGE_FLAG_COLORSPACE_NOT_sRGB == 0x01
share/man/man3/libpng.3:  PNG_IMAGE_FLAG_COLORMAP == 0x02
share/man/man3/libpng.3:approximation used elsewhere in libpng.
share/man/man3/libpng.3:   width: image width in pixels
share/man/man3/libpng.3:from one row to the next in component sized units (float) and if negative
share/man/man3/libpng.3:Note that the write API does not support interlacing, sub-8-bit pixels,
share/man/man3/libpng.3:and indexed (paletted) images.
share/man/man3/libpng.3:png_get_io_ptr().  For example:
share/man/man3/libpng.3:to using the default C stream functions, which expect the io_ptr to
share/man/man3/libpng.3:but you could change this to do things like exit() if you should wish,
share/man/man3/libpng.3:catch exception handling methods.  This makes the code much easier to write,
share/man/man3/libpng.3:may wish to use the "cexcept" facility (see http://cexcept.sourceforge.net),
share/man/man3/libpng.3:chunk and existing `intrinsic' chunks.
share/man/man3/libpng.3:faster.  For online applications it may be desirable to have maximum speed
share/man/man3/libpng.3:short on memory (running DOS, for example, where you only have 640K).
share/man/man3/libpng.3:    png_set_text_compression_level(png_ptr, level);
share/man/man3/libpng.3:    png_set_text_compression_mem_level(png_ptr, level);
share/man/man3/libpng.3:    png_set_text_compression_strategy(png_ptr,
share/man/man3/libpng.3:    png_set_text_compression_window_bits(png_ptr,
share/man/man3/libpng.3:    png_set_text_compression_method(png_ptr, method);
share/man/man3/libpng.3:for any images with bit depths less than 8 bits/pixel.
share/man/man3/libpng.3:is that many times better than the previous filter.  In the above example,
share/man/man3/libpng.3:"sum of absolute differences" 1.5 x 1.3 times higher than other filters
share/man/man3/libpng.3:The costs do not necessarily reflect the exact computational speeds of
share/man/man3/libpng.3:Note that the numbers above were invented purely for this example and
share/man/man3/libpng.3:are given only to help explain the function usage.  Little testing has
share/man/man3/libpng.3:according to printf-style formatting directives.  For example,
share/man/man3/libpng.3:is expanded to
share/man/man3/libpng.3:certain extensions to PNG for PNG images that are embedded in MNG datastreams.
share/man/man3/libpng.3:Libpng can support some of these extensions.  To enable them, use the
share/man/man3/libpng.3:.SH IX.  Changes to Libpng from version 1.0.x to 1.2.x
share/man/man3/libpng.3:by default.  The functions png_set_user_limits(), png_get_user_width_max(),
share/man/man3/libpng.3:and png_get_user_height_max() were added at libpng-1.2.6.
share/man/man3/libpng.3:The function png_set_expand_gray_1_2_4_to_8() was added at libpng-1.2.9.
share/man/man3/libpng.3:Unlike png_set_gray_1_2_4_to_8(), the new function does not expand the
share/man/man3/libpng.3:    png_get_mmx_flagmask()
share/man/man3/libpng.3:    png_set_mmx_thresholds()
share/man/man3/libpng.3:    png_get_mmx_bitdepth_threshold()
share/man/man3/libpng.3:    png_get_mmx_rowbytes_threshold()
share/man/man3/libpng.3:which also expands tRNS to alpha was replaced with
share/man/man3/libpng.3:    png_set_expand_gray_1_2_4_to_8()
share/man/man3/libpng.3:.SH X.  Changes to Libpng from version 1.0.x/1.2.x to 1.4.x
share/man/man3/libpng.3:Support for setting the maximum amount of memory that the application
share/man/man3/libpng.3:The functions png_set_chunk_cache_max() and png_get_chunk_cache_max()
share/man/man3/libpng.3:We removed the obsolete stub functions png_get_mmx_flagmask(),
share/man/man3/libpng.3:png_set_mmx_thresholds(), png_get_asm_flags(),
share/man/man3/libpng.3:png_get_mmx_bitdepth_threshold(), png_get_mmx_rowbytes_threshold(),
share/man/man3/libpng.3:png_set_asm_flags(), and png_mmx_supported()
share/man/man3/libpng.3:png_set_expand_gray_1_2_4_to_8() because the former function also
share/man/man3/libpng.3:expanded any tRNS chunk to an alpha channel.
share/man/man3/libpng.3:of "png_malloc(); memset();" except in the case in png_read_png()
share/man/man3/libpng.3:The png_zalloc() and png_zfree() functions are no longer exported.
share/man/man3/libpng.3:.SH XI.  Changes to Libpng from version 1.4.x to 1.5.x
share/man/man3/libpng.3:Checking for invalid palette index on write was added at libpng
share/man/man3/libpng.3:1.5.10.  If a pixel contains an invalid (out-of-range) index libpng issues
share/man/man3/libpng.3:   png_set_check_for_invalid_index(png_ptr, allowed);
share/man/man3/libpng.3:any invalid pixels are decoded as opaque black by the decoder and written
share/man/man3/libpng.3:Retrieving the maximum palette index found was added at libpng-1.5.15.
share/man/man3/libpng.3:   int max_palette = png_get_palette_max(png_ptr, info_ptr);
share/man/man3/libpng.3:This will return the maximum palette index found in the image, or "\-1" if
share/man/man3/libpng.3:does not account for any palette index used by ancillary chunks such as the
share/man/man3/libpng.3:bKGD chunk; you must check those separately to determine the maximum
share/man/man3/libpng.3:palette index actually used.
share/man/man3/libpng.3:changed and some of this is visible in the exported header files, in
share/man/man3/libpng.3:application code.  (It is extremely rare for an application to do this.)
share/man/man3/libpng.3:against libpng 1.5, except for the change in the prototype for
share/man/man3/libpng.3:libpng 1.5.0 includes a complete fixed point API.  By default this is
share/man/man3/libpng.3:fixed point API is faster and smaller than the floating point one because
share/man/man3/libpng.3:the PNG file format used fixed point, not floating point.  This applies
share/man/man3/libpng.3:uses floating point arithmetic (the default) or fixed point arithmetic
share/man/man3/libpng.3:composition (png_set_background for example). This applies even if the
share/man/man3/libpng.3:Fixed point support for the sCAL chunk comes with an important caveat;
share/man/man3/libpng.3:and the accuracy of PNG fixed point values is insufficient for
share/man/man3/libpng.3:reset by pngusr.h or by explicit settings on the compiler command line.
share/man/man3/libpng.3:when compressing the IDAT data and textual data such as zTXt and iCCP.
share/man/man3/libpng.3:We added five png_set_text_*() functions for setting the parameters to
share/man/man3/libpng.3:use with textual data.
share/man/man3/libpng.3:application calls to png_set_user_limits(), png_set_user_chunk_cache_max(),
share/man/man3/libpng.3:and/or png_set_user_malloc_max() that increase or decrease the limits.  Also,
share/man/man3/libpng.3:from 1,000,000 to 0x7ffffff (i.e., made unlimited).  Therefore, the
share/man/man3/libpng.3:   png_user_width_max        0x7fffffff    1,000,000
share/man/man3/libpng.3:   png_user_height_max       0x7fffffff    1,000,000
share/man/man3/libpng.3:   png_user_chunk_cache_max  0 (unlimited)   128
share/man/man3/libpng.3:   png_user_chunk_malloc_max 0 (unlimited) 8,000,000
share/man/man3/libpng.3:The library now supports a complete fixed point implementation and can
share/man/man3/libpng.3:independent of the choice of fixed versus floating point APIs and all the
share/man/man3/libpng.3:missing fixed point APIs have been implemented.
share/man/man3/libpng.3:The exact mechanism used to control attributes of API functions has
share/man/man3/libpng.3:3) Three feature macros now control the fixed/floating point decisions:
share/man/man3/libpng.3:PNG_FIXED_POINT_SUPPORTED enables the fixed point APIs; however, in
share/man/man3/libpng.3:file format is fixed point), therefore in most cases PNG_NO_FIXED_POINT
share/man/man3/libpng.3:merely stops the function from being exported.
share/man/man3/libpng.3:point implementation or the fixed point one.  Typically the fixed point
share/man/man3/libpng.3:.SH XII.  Changes to Libpng from version 1.5.x to 1.6.x
share/man/man3/libpng.3:example in contrib/examples/pngtopng.c).  The new publicly visible API
share/man/man3/libpng.3:Starting with libpng-1.6.0, you can configure libpng to prefix all exported
share/man/man3/libpng.3:The signatures of many exported functions were changed, such that
share/man/man3/libpng.3:with color type 0 or 4 and that even if the image only contains gray pixels,
share/man/man3/libpng.3:a pre-existing bug where the per-chunk 'keep' setting is ignored, and makes
share/man/man3/libpng.3:provide a way to revert to the libpng-1.5.x behavior (ignoring the CMF bytes
share/man/man3/libpng.3:and provide a tool (contrib/tools/pngfix) for rewriting a PNG file while
share/man/man3/libpng.3:chunk.  This error was fixed in libpng-1.6.3, and a tool (called
share/man/man3/libpng.3:contrib/tools/png-fix-itxt) has been added to the libpng distribution.
share/man/man3/libpng.3:control.  The git repository was built from old libpng-x.y.z.tar.gz files
share/man/man3/libpng.3:simple verbal discriptions of bug fixes, reported either to the
share/man/man3/libpng.3:We use 3-space indentation, except for continued statements which
share/man/man3/libpng.3:exported functions are marked with PNGAPI:
share/man/man3/libpng.3: png_exported_function(png_ptr, png_info, foo)
share/man/man3/libpng.3:The prototypes for all exported functions appear in png.h,
share/man/man3/libpng.3:We mark all non-exported functions with "/* PRIVATE */"":
share/man/man3/libpng.3: png_non_exported_function(png_ptr, png_info, foo)
share/man/man3/libpng.3:The prototypes for non-exported functions (except for those in
share/man/man3/libpng.3:To avoid polluting the global namespace, the names of all exported
share/man/man3/libpng.3:is an expression, not a type name, and we always enclose the
share/man/man3/libpng.3:"?".  We don't put a space between a typecast and the expression
share/man/man3/libpng.3:       y[i] = a(x) + (int)b;
share/man/man3/libpng.3:We prefer to express integers that are used as bit masks in hex format,
share/man/man3/libpng.3:with an even number of lower-case hex digits (e.g., 0x00, 0xff, 0x0100).
share/man/man3/libpng.3:We prefer to use underscores in variable names rather than camelCase, except
share/man/man3/libpng.3:Lines do not exceed 80 characters.
share/man/man3/libpng.3:holds the date in text format, and will hold years up to 9999.
share/man/man3/libpng.3:in libpng-1.6.x and will be removed from libpng-1.7.0.
share/man/man3/libpng.3: 1.0.1                     10001  code version except as
share/man/man3/libpng.3:for applications, is an unsigned integer of the form xyyzz corresponding
share/man/man3/libpng.3:to the source version x.y.z (leading zeros in y and z).  Beta versions
share/man/man3/libpng.3:ftp://ds.internic.net/rfc/rfc2083.txt
share/man/man3/libpng.3:with testing, bug fixes, and patience.  This wouldn't have been
share/man/man3/libpng.3:   Simon-Pierre Cadieux
share/man/man3/libpng.3:and Group 42, Inc. disclaim all warranties, expressed or implied,
share/man/man3/libpng.3:assume no liability for direct, indirect, incidental, special, exemplary,
share/man/man3/libpng.3:boxes and the like:
share/man/man3/libpng.3:files "pngbar.png" and "pngbar.jpg (88x31) and "pngnow.png" (98x31).
share/man/man5/png.5:PNG (Portable Network Graphics) is an extensible file format for the
share/man/man5/png.5:common uses of TIFF. Indexed-color, grayscale, and truecolor images are
share/man/man5/png.5:ftp://ds.internic.net/rfc/rfc2083.txt
test-driver:# As a special exception to the GNU General Public License, if you
test-driver:# Make unconditional expansion of undefined variables an error.  This
test-driver:  exit 2
test-driver:              [--expect-failure={yes|no}] [--color-tests={yes|no}]
test-driver:expect_failure=no
test-driver:  --help) print_usage; exit $?;;
test-driver:  --version) echo "test-driver $scriptversion"; exit $?;;
test-driver:  --expect-failure) expect_failure=$2; shift;;
test-driver:test x"$test_name" = x && missing_opts="$missing_opts --test-name"
test-driver:test x"$log_file"  = x && missing_opts="$missing_opts --log-file"
test-driver:test x"$trs_file"  = x && missing_opts="$missing_opts --trs-file"
test-driver:if test x"$missing_opts" != x; then
test-driver:do_exit='rm -f $log_file $trs_file; (exit $st); exit $st'
test-driver:trap "st=129; $do_exit" 1
test-driver:trap "st=130; $do_exit" 2
test-driver:trap "st=141; $do_exit" 13
test-driver:trap "st=143; $do_exit" 15
test-driver:case $estatus:$expect_failure in
tests/pngstest-6a16:exec "${srcdir}/tests/pngstest" 6a16
tests/pngvalid-gamma-transform.log:The printed value is the maximum error in the pixel values
tests/pngvalid-gamma-transform.log:is calculated as the difference between the output pixel
tests/pngvalid-gamma-transform.log:Expect this value to be less than .5 for 8 bit formats,
tests/pngvalid-gamma-transform.log:  indexed:     0.00000
tests/pngstest-4a08:exec "${srcdir}/tests/pngstest" 4a08
tests/pngvalid-gamma-expand16-transform:exec ./pngvalid --gamma-transform --expand16
tests/pngstest-3p04:exec "${srcdir}/tests/pngstest" 3p04
tests/pngunknown-save:exec ./pngunknown default=save "${srcdir}/pngtest.png"
tests/pngvalid-gamma-expand16-alpha-mode.log:PASS: pngvalid --gamma-alpha-mode --expand16 (floating point arithmetic)
tests/pngimage-full.log:PASS: pngimage --exhaustive ./contrib/pngsuite/basn0g01.png
tests/pngimage-full.log:PASS: pngimage --exhaustive ./contrib/pngsuite/basn0g02.png
tests/pngimage-full.log:PASS: pngimage --exhaustive ./contrib/pngsuite/basn0g04.png
tests/pngimage-full.log:PASS: pngimage --exhaustive ./contrib/pngsuite/basn0g08.png
tests/pngimage-full.log:PASS: pngimage --exhaustive ./contrib/pngsuite/basn0g16.png
tests/pngimage-full.log:PASS: pngimage --exhaustive ./contrib/pngsuite/basn2c08.png
tests/pngimage-full.log:PASS: pngimage --exhaustive ./contrib/pngsuite/basn2c16.png
tests/pngimage-full.log:PASS: pngimage --exhaustive ./contrib/pngsuite/basn3p01.png
tests/pngimage-full.log:PASS: pngimage --exhaustive ./contrib/pngsuite/basn3p02.png
tests/pngimage-full.log:PASS: pngimage --exhaustive ./contrib/pngsuite/basn3p04.png
tests/pngimage-full.log:PASS: pngimage --exhaustive ./contrib/pngsuite/basn3p08.png
tests/pngimage-full.log:PASS: pngimage --exhaustive ./contrib/pngsuite/basn4a08.png
tests/pngimage-full.log:PASS: pngimage --exhaustive ./contrib/pngsuite/basn4a16.png
tests/pngimage-full.log:PASS: pngimage --exhaustive ./contrib/pngsuite/basn6a08.png
tests/pngimage-full.log:PASS: pngimage --exhaustive ./contrib/pngsuite/basn6a16.png
tests/pngimage-full.log:PASS: pngimage --exhaustive ./contrib/pngsuite/ftbbn0g01.png
tests/pngimage-full.log:PASS: pngimage --exhaustive ./contrib/pngsuite/ftbbn0g02.png
tests/pngimage-full.log:PASS: pngimage --exhaustive ./contrib/pngsuite/ftbbn0g04.png
tests/pngimage-full.log:PASS: pngimage --exhaustive ./contrib/pngsuite/ftbbn2c16.png
tests/pngimage-full.log:PASS: pngimage --exhaustive ./contrib/pngsuite/ftbbn3p08.png
tests/pngimage-full.log:PASS: pngimage --exhaustive ./contrib/pngsuite/ftbgn2c16.png
tests/pngimage-full.log:PASS: pngimage --exhaustive ./contrib/pngsuite/ftbgn3p08.png
tests/pngimage-full.log:PASS: pngimage --exhaustive ./contrib/pngsuite/ftbrn2c08.png
tests/pngimage-full.log:PASS: pngimage --exhaustive ./contrib/pngsuite/ftbwn0g16.png
tests/pngimage-full.log:PASS: pngimage --exhaustive ./contrib/pngsuite/ftbwn3p08.png
tests/pngimage-full.log:PASS: pngimage --exhaustive ./contrib/pngsuite/ftbyn3p08.png
tests/pngimage-full.log:PASS: pngimage --exhaustive ./contrib/pngsuite/ftp0n0g08.png
tests/pngimage-full.log:PASS: pngimage --exhaustive ./contrib/pngsuite/ftp0n2c08.png
tests/pngimage-full.log:PASS: pngimage --exhaustive ./contrib/pngsuite/ftp0n3p08.png
tests/pngimage-full.log:PASS: pngimage --exhaustive ./contrib/pngsuite/ftp1n3p08.png
tests/pngunknown-sTER:exec ./pngunknown sTER=if-safe "${srcdir}/pngtest.png"
tests/pngvalid-standard:exec ./pngvalid --standard --progressive-read
tests/pngvalid-gamma-threshold:exec ./pngvalid --gamma-threshold
tests/pngvalid-gamma-expand16-background:exec ./pngvalid --gamma-background --expand16
tests/pngvalid-gamma-expand16-background.log:PASS: pngvalid --gamma-background --expand16 (floating point arithmetic)
tests/pngunknown-vpAg:exec ./pngunknown vpAg=if-safe "${srcdir}/pngtest.png"
tests/pngimage-full:exec ./pngimage --exhaustive --log "${srcdir}/contrib/pngsuite/"*.png
tests/pngstest-0g16:exec "${srcdir}/tests/pngstest" 0g16
tests/pngvalid-gamma-background:exec ./pngvalid --gamma-background
tests/pngstest-2c16:exec "${srcdir}/tests/pngstest" 2c16
tests/pngvalid-gamma-expand16-transform.log:The printed value is the maximum error in the pixel values
tests/pngvalid-gamma-expand16-transform.log:is calculated as the difference between the output pixel
tests/pngvalid-gamma-expand16-transform.log:Expect this value to be less than .5 for 8 bit formats,
tests/pngvalid-gamma-expand16-transform.log:  indexed:     128.32752
tests/pngvalid-gamma-expand16-transform.log:PASS: pngvalid --gamma-transform --expand16 (floating point arithmetic)
tests/pngstest-4a16:exec "${srcdir}/tests/pngstest" 4a16
tests/pngunknown-if-safe:exec ./pngunknown default=if-safe "${srcdir}/pngtest.png"
tests/pngvalid-gamma-16-to-8:exec ./pngvalid --gamma-16-to-8
tests/pngimage-quick:exec ./pngimage --log "${srcdir}/contrib/pngsuite/"*.png
tests/pngtest:exec ./pngtest --strict ${srcdir}/pngtest.png
tests/pngvalid-progressive-standard:exec ./pngvalid --standard --progressive-read
tests/pngvalid-gamma-sbit:exec ./pngvalid --gamma-sbit
tests/pngstest-0g01:exec "${srcdir}/tests/pngstest" 0g01
tests/pngstest-6a08:exec "${srcdir}/tests/pngstest" 6a08
tests/pngstest-0g08:exec "${srcdir}/tests/pngstest" 0g08
tests/pngvalid-gamma-alpha-mode:exec ./pngvalid --gamma-alpha-mode
tests/pngstest-3p01:exec "${srcdir}/tests/pngstest" 3p01
tests/pngstest-error:for t in "${srcdir}/contrib/pngsuite/"x*".png"
tests/pngstest-error:   if test "$t" != "${srcdir}/contrib/pngsuite/x*.png"
tests/pngstest-error:exit $code
tests/pngvalid-gamma-expand16-alpha-mode:exec ./pngvalid --gamma-alpha-mode --expand16
tests/pngvalid-gamma-transform:exec ./pngvalid --gamma-transform
tests/pngstest:# Runs pngstest on all the contrib/pngsuite/[^x]*${pattern}.png files
tests/pngstest:exec ./pngstest --strict --tmpfile "${pattern}" --log ${1+"$@"}\
tests/pngunknown-discard:exec ./pngunknown default=discard "${srcdir}/pngtest.png"
tests/pngvalid-progressive-interlace-standard:exec ./pngvalid --standard --progressive-read --interlace
tests/pngunknown-IDAT:exec ./pngunknown default=discard IDAT=save "${srcdir}/pngtest.png"
tests/pngstest-2c08:exec "${srcdir}/tests/pngstest" 2c08
tests/pngstest-3p08:exec "${srcdir}/tests/pngstest" 3p08
tests/pngstest-0g04:exec "${srcdir}/tests/pngstest" 0g04
tests/pngstest-0g02:exec "${srcdir}/tests/pngstest" 0g02
tests/pngunknown-sAPI:exec ./pngunknown bKGD=save cHRM=save gAMA=save all=discard iCCP=save sBIT=save sRGB=save "${srcdir}/pngtest.png"
tests/pngvalid-progressive-interlace-size:exec ./pngvalid --size --progressive-read
tests/pngtest.log:   Text compression[0]=-1
tests/pngtest.log: vpAg = 100 x 100, units = 0
tests/pngtest.log:   Text compression[0]=0
tests/pngtest.log:   Text compression[0]=-1
tests/pngtest.log: vpAg = 100 x 100, units = 0
tests/pngtest.log:   Text compression[0]=0
tests/pngtest.log:   Text compression[0]=-1
tests/pngtest.log: vpAg = 100 x 100, units = 0
tests/pngtest.log:   Text compression[0]=0
tests/pngstest-3p02:exec "${srcdir}/tests/pngstest" 3p02
tests/pngvalid-progressive-interlace-transform:exec ./pngvalid --transform
TODO:Final bug fixes.
TODO:Fix problem with C++ and EXTERN "C".
TODO:Text conversion between different code pages (Latin-1 -> Mac and DOS).
TODO:Extend pngvalid.c to validate more of the libpng transformations.
